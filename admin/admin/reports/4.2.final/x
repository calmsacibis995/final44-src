.ds f. 0.t
.\" %M% %I% %E%
.rm CM
.TL
Final Report for
.br
Contract N00039-82-C-0235
.br
ARPA Order 4031
.br
VAX UNIX* System Support
.sp
December 1985
.AB
.FS
* UNIX is a trademark of Bell Laboratories.
.FE
.PP
This report summarizes the results obtained during the
contract period and documents the state of the system
as of the termination date.
The directions for the new work for the next contract period is summarized.
The main part of this report gives a description of the new
file system and networking facilities that were implemented to meet
the needs of the ARPA research community.
.PP
The first section describes the basic kernel functions
provided to a UNIX process: process naming and protection,
memory management, software interrupts,
object references (descriptors), time and statistics functions,
and resource controls.
These facilities, as well as facilities for
bootstrap, shutdown and process accounting,
are provided solely by the kernel.
.PP
The second section describes the standard system
abstractions for
files and file systems,
communication,
terminal handling,
and process control and debugging.
These facilities are implemented by the operating system or by
network server processes.
The first of three appendixes summarizes the system primitives.
.PP
The second appendix describes a reimplementation of the UNIX file system.
The reimplementation provides substantially higher throughput
rates by using more flexible allocation policies,
that allow better locality of reference and that can
be adapted to a wide range of peripheral and processor characteristics.
The new file system clusters data that is sequentially accessed
and provides two block sizes to allow fast access for large files
while not wasting large amounts of space for small files.
File access rates of up to ten times faster than the traditional
UNIX file system are experienced.
Long needed enhancements to the user interface are discussed.
These include a mechanism to lock files, 
extensions of the name space across file systems,
the ability to use arbitrary length file names,
and provisions for efficient administrative control of resource usage.
.PP
The last appendix gives a detailed description of the
internal structure of the networking facilities.
These facilities are based on several central abstractions that
structure the external (user) view of network communication
as well as the internal (system) implementation.
.AE
.LP
.de PT
.lt \\n(LLu
.pc %
.nr PN \\n%
.tl '\\*(LH'\\*(CH'\\*(RH'
.lt \\n(.lu
..
.af PN i
.ds LH Final Report
.ds RH Contents
.bp 1
.if t .ds CF -- December 1985 --
.ft B
.br
.sv 2
.ce
TABLE OF CONTENTS
.ft R
.LP
.sp 1
.nf
.B "0. Notation and types"
.LP
.if t .sp .5v
.nf
.B "1. Kernel primitives"
.LP
.if t .sp .5v
.nf
.nf
\fB1.1.  Processes and protection\fP
\0\0\0.1.  Host and process identifiers
\0\0\0.2.  Process creation and termination
\0\0\0.3.  User and group ids
\0\0\0.4.  Process groups
.LP
.nf
\fB1.2.  Memory management\fP
\0\0\0.1.  Text, data and stack
\0\0\0.2.  Mapping pages
\0\0\0.3.  Page protection control
\0\0\0.4.  Giving and getting advice
.LP
.if t .sp .5v
.nf
\fB1.3.  Signals\fP
\0\0\0.1.  Overview
\0\0\0.2.  Signal types
\0\0\0.3.  Signal handlers
\0\0\0.4.  Sending signals
\0\0\0.5.  Protecting critical sections
\0\0\0.6.  Signal stacks
.LP
.if t .sp .5v
.nf
\fB1.4.  Timing and statistics\fP
\0\0\0.1.  Real time
\0\0\0.2.  Interval time
.LP
.if t .sp .5v
.nf
\fB1.5.  Descriptors\fP
\0\0\0.1.  The reference table
\0\0\0.2.  Descriptor properties
\0\0\0.3.  Managing descriptor references
\0\0\0.4.  Multiplexing requests
\0\0\0.5.  Descriptor wrapping
.LP
.if t .sp .5v
.nf
\fB1.6.  Resource controls\fP
\0\0\0.1.  Process priorities
\0\0\0.2.  Resource utilization
\0\0\0.3.  Resource limits
.LP
.if t .sp .5v
.nf
\fB1.7.  System operation support\fP
\0\0\0.1.   Bootstrap operations
\0\0\0.2.   Shutdown operations
\0\0\0.3.   Accounting
.bp
.LP
.if t .sp .5v
.sp 1
.nf
\fB2.  System facilities\fP
.LP
.if t .sp .5v
.nf
\fB2.1.   Generic operations\fP
\0\0\0.1.   Read and write
\0\0\0.2.   Input/output control
\0\0\0.3.   Non-blocking and asynchronous operations
.LP
.if t .sp .5v
.nf
\fB2.2.  File system\fP
\0\0\0.1   Overview
\0\0\0.2.  Naming
\0\0\0.3.  Creation and removal
\0\0\0.3.1.  Directory creation and removal
\0\0\0.3.2.  File creation
\0\0\0.3.3.  Creating references to devices
\0\0\0.3.4.  Portal creation
\0\0\0.3.6.  File, device, and portal removal
\0\0\0.4.  Reading and modifying file attributes
\0\0\0.5.  Links and renaming
\0\0\0.6.  Extension and truncation
\0\0\0.7.  Checking accessibility
\0\0\0.8.  Locking
\0\0\0.9.  Disc quotas
.LP
.if t .sp .5v
.nf
\fB2.3.  Interprocess communication\fP
\0\0\0.1.   Interprocess communication primitives
\0\0\0.1.1.\0   Communication domains
\0\0\0.1.2.\0   Socket types and protocols
\0\0\0.1.3.\0   Socket creation, naming and service establishment
\0\0\0.1.4.\0   Accepting connections
\0\0\0.1.5.\0   Making connections
\0\0\0.1.6.\0   Sending and receiving data
\0\0\0.1.7.\0   Scatter/gather and exchanging access rights
\0\0\0.1.8.\0   Using read and write with sockets
\0\0\0.1.9.\0   Shutting down halves of full-duplex connections
\0\0\0.1.10.\0  Socket and protocol options
\0\0\0.2.   UNIX domain
\0\0\0.2.1.    Types of sockets
\0\0\0.2.2.    Naming
\0\0\0.2.3.    Access rights transmission
\0\0\0.3.   INTERNET domain
\0\0\0.3.1.    Socket types and protocols
\0\0\0.3.2.    Socket naming
\0\0\0.3.3.    Access rights transmission
\0\0\0.3.4.    Raw access
.LP
.bp
.nf
\fB2.4.  Terminals and devices\fP
\0\0\0.1.   Terminals
\0\0\0.1.1.    Terminal input
\0\0\0.1.1.1     Input modes
\0\0\0.1.1.2     Interrupt characters
\0\0\0.1.1.3     Line editing
\0\0\0.1.2.    Terminal output
\0\0\0.1.3.    Terminal control operations
\0\0\0.1.4.    Terminal hardware support
\0\0\0.2.   Structured devices
\0\0\0.3.   Unstructured devices
.LP
.if t .sp .5v
.nf
\fB2.5.  Process control and debugging\fP
.LP
.sp 2
.nf
\fBAppendix A \- Summary of facilities\fP
.LP
.sp 2
.nf
\fBAppendix B \- File System Implementation\fP
.LP
.sp .5v
.nf
.B "B.1. Introduction"
.LP
.sp .5v
.nf
.B "B.2. Old file system
.LP
.sp .5v
.nf
.B "B.3. New file system organization
\0.1.     Optimizing storage utilization
\0.2.     File system parameterization
\0.3.     Layout policies
.LP
.sp .5v
.nf
.B "B.4. Performance
.LP
.sp .5v
.nf
.B "B.5. File system functional enhancements
\0.1.     Long file names
\0.2.     File locking
\0.3.     Symbolic links
\0.4.     Rename
\0.5.     Quotas
.LP
.bp
.nf
\fBAppendix C \- Networking Implementation\fP
.LP
.sp .5v
.nf
.B "C.1. Introduction"
.LP
.sp .5v
.nf
.B "C.2. Overview"
.LP
.sp .5v
.nf
.B "C.3. Goals
.LP
.sp .5v
.nf
.B "C.4. Internal address representation"
.LP
.sp .5v
.nf
.B "C.5. Memory management"
.LP
.sp .5v
.nf
.B "C.6. Internal layering
\0.1.     Socket layer
\0.1.1.     Socket state
\0.1.2.     Socket data queues
\0.1.3.     Socket connection queueing
\0.2.     Protocol layer(s)
\0.3.     Network-interface layer
\0.3.1.     UNIBUS interfaces
.LP
.sp .5v
.nf
.B "C.7. Socket/protocol interface"
.LP
.sp .5v
.nf
.B "C.8. Protocol/protocol interface"
\0.1.      pr_output
\0.2.      pr_input
\0.3.      pr_ctlinput
\0.4.      pr_ctloutput
.LP
.sp .5v
.nf
.B "C.9. Protocol/network-interface interface"
\0.1.      Packet transmission
\0.2.      Packet reception
.LP
.sp .5v
.nf
.B "C.10. Gateways and routing issues
\0.1.      Routing tables
\0.2.      Routing table interface
\0.3.      User level routing policies
.LP
.sp .5v
.nf
.B "C.11. Raw sockets"
\0.1.      Control blocks
\0.2.      Input processing
\0.3.      Output processing
.LP
.sp .5v
.nf
.B "C.12. Buffering and congestion control"
\0.1.      Memory management
\0.2.      Protocol buffering policies
\0.3.      Queue limiting
\0.4.      Packet forwarding
.LP
.sp .5v
.nf
.B "C.13. Out of band data"
.LP
.sp .5v
.nf
.B "C.14. Trailer protocols"
.LP
.sp 2
.nf
.B "References"
.af PN 1
.de sh
.ds RH \\$1
.sp 2
.ne 1i
.NH \\*(ss
\s+2\\$1\s0
.PP
.PP
..
.ds RH "Notation and types
.bp 1
.nr ss 1
.de _d
.if t .ta .6i 2.1i 2.6i
.\" 2.94 went to 2.6, 3.64 to 3.30
.if n .ta .84i 2.6i 3.30i
..
.de _f
.if t .ta .5i 1.25i 2.5i 3.5i
.\" 3.5i went to 3.8i
.if n .ta .7i 1.75i 3.8i 4.8i
..
.nr H1 -1
.sh "Notation and types
.PP
The notation used to describe system calls is a variant of a
C language call, consisting of a prototype call followed by
declaration of parameters and results.
An additional keyword \fBresult\fP, not part of the normal C language,
is used to indicate which of the declared entities receive results.
As an example, consider the \fIread\fP call, as described in
section 2.1:
.DS
cc = read(fd, buf, nbytes);
result int cc; int fd; result char *buf; int nbytes;
.DE
The first line shows how the \fIread\fP routine is called, with
three parameters.
As shown on the second line \fIcc\fP is an integer and \fIread\fP also
returns information in the parameter \fIbuf\fP.
.PP
Description of all error conditions arising from each system call
is not provided here; they appear in the programmer's manual.
In particular, when accessed from the C language,
many calls return a characteristic \-1 value
when an error occurs, returning the error code in the global variable
\fIerrno\fP.
Other languages may present errors in different ways.
.PP
A number of system standard types are defined in the include file <sys/types.h>
and used in the specifications here and in many C programs.
These include \fBcaddr_t\fP giving a memory address (typically as
a character pointer), 
\fBoff_t\fP giving a file offset (typically as a long integer),
and a set of unsigned types \fBu_char\fP, \fBu_short\fP, \fBu_int\fP
and \fBu_long\fP, shorthand names for \fBunsigned char\fP, \fBunsigned
short\fP, etc.
.ds f. 1.0.t
.\" %M% %I% %E%
.ds ss 1
.sh "Kernel primitives
.PP
The facilities available to a UNIX user process are logically
divided into two parts: kernel facilities directly implemented by
UNIX code running in the operating system, and system facilities
implemented either by the system, or in cooperation with a
\fIserver process\fP.  These kernel facilities are described in
this section 1.
.PP
The facilities implemented in the kernel are those which define the
\fIUNIX virtual machine\fP which each process runs in.
Like many real machines, this virtual machine has memory management hardware,
an interrupt facility, timers and counters.  The UNIX
virtual machine also allows access to files and other objects through a set of
\fIdescriptors\fP.  Each descriptor resembles a device controller,
and supports a set of operations.  Like devices on real machines, some
of which are internal to the machine and some of which are external,
parts of the descriptor machinery are built-in to the operating system, while
other parts are often implemented in server processes on other machines.
The facilities provided through the descriptor machinery are described in
section 2.
.ds ss 2
.ds f. 1.1.t
.\" %M% %I% %E%
.sh "Processes and protection
.NH 3
Host and process identifiers
.PP
Each UNIX host has associated with it a 32-bit host id, and a host
name of up to 255 characters.  These are set (by a privileged user)
and returned by the calls:
.DS
sethostid(hostid)
long hostid;

hostid = gethostid();
result long hostid;

sethostname(name, len)
char *name; int len;

len = gethostname(buf, buflen)
result int len; result char *buf; int buflen;
.DE
On each host runs a set of \fIprocesses\fP.
Each process is largely independent of other processes,
having its own protection domain, address space, timers, and
an independent set of references to system or user implemented objects.
.PP
Each process in a host is named by an integer
called the \fIprocess id\fP.  This number is
in the range 1-30000
and is returned by
the \fIgetpid\fP routine:
.DS
pid = getpid();
result int pid;
.DE
On each UNIX host this identifier is guaranteed to be unique;
in a multi-host environment, the (hostid, process id) pairs are
guaranteed unique.
.NH 3
Process creation and termination
.PP
A new process is created by making a logical duplicate of an
existing process:
.DS
pid = fork();
result int pid;
.DE
The \fIfork\fP call returns twice, once in the parent process, where
\fIpid\fP is the process identifier of the child,
and once in the child process where \fIpid\fP is 0.
The parent-child relationship induces a hierarchical structure on
the set of processes in the system.
.PP
A process may terminate by executing an \fIexit\fP call:
.DS
exit(status)
int status;
.DE
returning 8 bits of exit status to its parent.
.PP
When a child process exits or
terminates abnormally, the parent process receives
information about any
event which caused termination of the child process.  A
second call provides a non-blocking interface and may also be used
to retrieve information about resources consumed by the process during its
lifetime.
.DS
#include <sys/wait.h>

pid = wait(astatus);
result int pid; result union wait *astatus;

pid = wait3(astatus, options, arusage);
result int pid; result union waitstatus *astatus;
int options; result struct rusage *arusage;
.DE
.PP
A process can overlay itself with the memory image of another process,
passing the newly created process a set of parameters, using the call:
.DS
execve(name, argv, envp)
char *name, **argv, **envp;
.DE
The specified \fIname\fP must be a file which is in a format recognized
by the system, either a binary executable file or a file which causes
the execution of a specified interpreter program to process its contents.
.NH 3
User and group ids
.PP
Each process in the system has associated with it two user-id's:
a \fIreal user id\fP and a \fIeffective user id\fP, both non-negative 16 bit
integers.
Each process has an \fIreal accounting group id\fP and an \fIeffective
accounting group id\fP and a set of
\fIaccess group id's\fP.  The group id's are non-negative 16 bit integers.
Each process may be in several different access groups, with the maximum
concurrent number of access groups a system compilation parameter,
the constant NGROUPS in the file <sys/param.h>, guaranteed to be at least 8.
.PP
The real and effective user ids associated with a process are returned by:
.DS
ruid = getuid();
result int ruid;

euid = geteuid();
result int euid;
.DE
the real and effective accounting group ids by:
.DS
rgid = getgid();
result int rgid;

egid = getegid();
result int egid;
.DE
and the access group id set is returned by a \fIgetgroups\fP call:
.DS
ngroups = getgroups(gidsetsize, gidset);
result int ngroups; int gidsetsize; result int gidset[gidsetsize];
.DE
.PP
The user and group id's
are assigned at login time using the \fIsetreuid\fP, \fIsetregid\fP,
and \fIsetgroups\fP calls:
.DS
setreuid(ruid, euid);
int ruid, euid;

setregid(rgid, egid);
int rgid, egid;

setgroups(gidsetsize, gidset)
int gidsetsize; int gidset[gidsetsize];
.DE
The \fIsetreuid\fP call sets both the real and effective user-id's,
while the \fIsetregid\fP call sets both the real
and effective accounting group id's.
Unless the caller is the super-user, \fIruid\fP
must be equal to either the current real or effective user-id,
and \fIrgid\fP equal to either the current real or effective
accounting group id.  The \fIsetgroups\fP call is restricted
to the super-user.
.NH 3
Process groups
.PP
Each process in the system is also normally associated with a \fIprocess
group\fP.  The group of processes in a process group is sometimes
referred to as a \fIjob\fP and manipulated by high-level system
software (such as the shell).
The current process group of a process is returned by the
\fIgetpgrp\fP call:
.DS
pgrp = getpgrp(pid);
result int pgrp; int pid;
.DE
When a process is in a specific process group it may receive
software interrupts affecting the group, causing the group to
suspend or resume execution or to be interrupted or terminated.
In particular, a system terminal has a process group and only processes
which are in the process group of the terminal may read from the
terminal, allowing arbitration of terminals among several different jobs.
.PP
The process group associated with a process may be changed by
the \fIsetpgrp\fP call:
.DS
setpgrp(pid, pgrp);
int pid, pgrp;
.DE
Newly created processes are assigned process id's distinct from all
processes and process groups, and the same process group as their
parent.  A normal (unprivileged) process may set its process group equal
to its process id.  A privileged process may set the process group of any
process to any value.
.ds f. 1.2.t
.\" %M% %I% %E%
.sh "Memory management\(dg
.NH 3
Text, data and stack
.PP
.FS
\(dg This section represents the interface planned for later
releases of the system.  Of the calls described in this section,
only \fIsbrk\fP and \fIgetpagesize\fP are included in 4.2BSD.
.FE
Each process begins execution with three logical areas of memory
called text, data and stack.  
The text area is read-only and shared, while the data and stack
areas are private to the process.  Both the data and stack areas may
be extended and contracted on program request.  The call
.DS
addr = sbrk(incr);
result caddr_t addr; int incr;
.DE
changes the size of the data area by \fIincr\fP bytes and
returns the new end of the data area, while
.DS
addr = sstk(incr);
result caddr_t addr; int incr;
.DE
changes the size of the stack area.
The stack area is also automatically extended as needed.
On the VAX the text and data areas are adjacent in the P0 region,
while the stack section is in the P1 region, and grows downward.
.NH 3
Mapping pages
.PP
The system supports sharing of data between processes
by allowing pages to be mapped into memory.  These mapped
pages may be \fIshared\fP with other processes or \fIprivate\fP
to the process.
Protection and sharing options are defined in <mman.h> as:
.DS
._d
/* protections are chosen from these bits, or-ed together */
#define	PROT_READ	0x4	/* pages can be read */
#define	PROT_WRITE	0x2	/* pages can be written */
#define	PROT_EXEC	0x1	/* pages can be executed */

/* sharing types; choose either SHARED or PRIVATE */
#define	MAP_SHARED	1	/* share changes */
#define	MAP_PRIVATE	2	/* changes are private */
.DE
The cpu-dependent size of a page is returned by the
\fIgetpagesize\fP system call:
.DS
pagesize = getpagesize();
result int pagesize;
.DE
.PP
The call:
.DS
mmap(addr, len, prot, share, fd, pos);
caddr_t addr; int len, prot, share, fd; off_t pos;
.DE
causes the pages starting at \fIaddr\fP and continuing
for \fIlen\fP bytes to be mapped from the object represented by
descriptor \fIfd\fP, at absolute position \fIpos\fP.  The parameter
\fIshare\fP specifies whether modifications made to this mapped copy
of the page, are to be kept \fIprivate\fP, or are to be \fIshared\fP with
other references.
The parameter \fIprot\fP specifies the accessibility
of the mapped pages.
The \fIaddr\fP, \fIlen\fP, and \fIpos\fP parameters
must all be multiples of the pagesize.
.PP
A process can move pages within its own memory by using the
.I mremap
call:
.DS
mremap(addr, len, prot, share, fromaddr);
caddr_t addr; int len, prot, share; caddr_t fromaddr;
.DE
This call maps the pages starting at \fIfromaddr\fP to the address specified
by \fIaddr\fP.
.PP
A mapping can be removed by the call
.DS
munmap(addr, len);
caddr_t addr; int len;
.DE
This causes further references to these pages to refer to private
pages initialized to zero.
.NH 3
Page protection control
.PP
A process can control the protection of pages using the call
.DS
mprotect(addr, len, prot);
caddr_t addr; int len, prot;
.DE
This call changes the specified pages to have protection \fIprot\fP\|.
.NH 3
Giving and getting advice
.PP
A process that has knowledge of its memory behavior may
use the \fImadvise\fP call:
.DS
madvise(addr, len, behav);
caddr_t addr; int len, behav;
.DE
\fIBehav\fP describes expected behavior, as given
in <mman.h>:
.DS
._d
#define	MADV_NORMAL	0	/* no further special treatment */
#define	MADV_RANDOM	1	/* expect random page references */
#define	MADV_SEQUENTIAL	2	/* expect sequential references */
#define	MADV_WILLNEED	3	/* will need these pages */
#define	MADV_DONTNEED	4	/* don't need these pages */
.DE
Finally, a process may obtain information about whether pages are
core resident by using the call
.DS
mincore(addr, len, vec)
caddr_t addr; int len; result char *vec;
.DE
Here the current core residency of the pages is returned
in the character array \fIvec\fP, with a value of 1 meaning
that the page is in-core.
.ds f. 1.3.t
.\" %M% %I% %E%
.sh "Signals
.PP
.NH 3
Overview
.PP
The system defines a set of \fIsignals\fP that may be delivered
to a process.  Signal delivery resembles the occurrence of a hardware
interrupt: the signal is blocked from further occurrence,
the current process context is saved, and a new one
is built.  A process may specify
the \fIhandler\fP to which a signal is delivered, or specify that
the signal is to be \fIblocked\fP or \fIignored\fP.  A process may
also specify that a
\fIdefault\fP action is to be taken when signals occur.
.PP
Some signals
will cause a process to exit when they are not caught.  This
may be accompanied by creation of a \fIcore\fP image file, containing
the current memory image of the process for use in post-mortem debugging.
A process may choose to have signals delivered on a special
stack, so that sophisticated software stack manipulations are possible.
.PP
All signals have the same \fIpriority\fP.  If multiple signals
are pending simultaneously, the order in which they are delivered
to a process is implementation specific.  Signal routines execute
with the signal that caused their invocation \fIblocked\fP, but other
signals may yet occur.  Mechanisms are provided whereby critical sections
of code may protect themselves against the occurrence of specified signals.
.NH 3
Signal types
.PP
The signals defined by the system fall into one of
five classes: hardware conditions,
software conditions, input/output notification, process control, or
resource control.
The set of signals is defined in the file <signal.h>.
.PP
Hardware signals are derived from exceptional conditions which
may occur during
execution.  Such signals include SIGFPE representing floating
point and other arithmetic exceptions, SIGILL for illegal instruction
execution, SIGSEGV for addresses outside the currently assigned
area of memory, and SIGBUS for accesses that violate memory
protection constraints.
Other, more cpu-specific hardware signals exist,
such as those for the various customer-reserved instructions on
the VAX (SIGIOT, SIGEMT, and SIGTRAP). 
.PP
Software signals reflect interrupts generated by user request:
SIGINT for the normal interrupt signal; SIGQUIT for the more
powerful \fIquit\fP signal, that normally causes a core image
to be generated; SIGHUP and SIGTERM that cause graceful
process termination, either because a user has ``hung up'', or
by user or program request; and SIGKILL, a more powerful termination
signal which a process cannot catch or ignore.
Other software signals (SIGALRM, SIGVTALRM, SIGPROF)
indicate the expiration of interval timers.
.PP
A process can request notification via a SIGIO signal
when input or output is possible
on a descriptor, or when a \fInon-blocking\fP operation completes.
A process may request to receive a SIGURG signal when an
urgent condition arises. 
.PP
A process may be \fIstopped\fP by a signal sent to it or the members
of its process group.  The SIGSTOP signal is a powerful stop
signal, because it cannot be caught.  Other stop signals
SIGTSTP, SIGTTIN, and SIGTTOU are used when a user request, input
request, or output request respectively is the reason the process
is being stopped.  A SIGCONT signal is sent to a process when it is
continued from a stopped state.
Processes may receive notification with a SIGCHLD signal when
a child process changes state, either by stopping or by terminating.
.PP
Exceeding resource limits may cause signals to be generated.
SIGXCPU occurs when a process nears its CPU time limit and SIGXFSZ
warns that the limit on file size creation has been reached.
.NH 3
Signal handlers
.PP
A process has a handler associated with each signal that
controls the way the signal is delivered.
The call
.DS
#include <signal.h>

._f
struct sigvec {
	int	(*sv_handler)();
	int	sv_mask;
	int	sv_onstack;
};

sigvec(signo, sv, osv)
int signo; struct sigvec *sv; result struct sigvec *osv;
.DE
assigns interrupt handler address \fIsv_handler\fP to signal \fIsigno\fP.
Each handler address
specifies either an interrupt routine for the signal, that the
signal is to be ignored,
or that a default action (usually process termination) is to occur
if the signal occurs.
The constants
SIG_IGN and SIG_DEF used as values for \fIsv_handler\fP
cause ignoring or defaulting of a condition.
The \fIsv_mask\fP and \fIsv_onstack\fP values specify the
signal mask to be used when the handler is invoked and
whether the handler should operate on the normal run-time
stack or a special signal stack (see below).  If \fIosv\fP
is non-zero, the previous signal vector is returned.
.PP
When a signal condition arises for a process, the signal
is added to a set of signals pending for the process.
If the signal is not currently \fIblocked\fP by the process
then it will be delivered.  The process of signal delivery
adds the signal to be delivered and those signals
specified in the associated signal
handler's \fIsv_mask\fP to a set of those \fImasked\fP
for the process, saves the current process context,
and places the process in the context of the signal
handling routine.  The call is arranged so that if the signal
handling routine exits normally the signal mask will be restored
and the process will resume execution in the original context.
If the process wishes to resume in a different context, then
it must arrange to restore the signal mask itself.
.PP
The mask of \fIblocked\fP signals is independent of handlers for
signals.  It prevents signals from being delivered much as a
raised hardware interrupt priority level prevents hardware interrupts.
Preventing an interrupt from occurring by changing the handler is analogous to
disabling a device from further interrupts.
.PP
The signal handling routine \fIsv_handler\fP is called by a C call
of the form
.DS
(*sv_handler)(signo, code, scp);
int signo; long code; struct sigcontext *scp;
.DE
The \fIsigno\fP gives the number of the signal that occurred, and
the \fIcode\fP, a word of information supplied by the hardware.
The \fIscp\fP parameter is a pointer to a machine-dependent
structure containing the information for restoring the
context before the signal.
.NH 3
Sending signals
.PP
A process can send a signal to another process or group of processes
with the calls:
.DS
kill(pid, signo)
int pid, signo;

killpgrp(pgrp, signo)
int pgrp, signo;
.DE
Unless the process sending the signal is privileged,
it and the process receiving the signal must have the same effective user id.
.PP
Signals are also sent implicitly from a terminal device to the
process group associated with the terminal when certain input characters
are typed.
.NH 3
Protecting critical sections
.PP
To block a section of code against one or more signals, a \fIsigblock\fP
call may be used to add a set of signals to the existing mask, returning
the old mask:
.DS
oldmask = sigblock(mask);
result long oldmask; long mask;
.DE
The old mask can then be restored later with \fIsigsetmask\fP\|,
.DS
oldmask = sigsetmask(mask);
result long oldmask; long mask;
.DE
The \fIsigblock\fP call can be used to read the current mask
by specifying an empty \fImask\fP\|.
.PP
It is possible to check conditions with some signals blocked,
and then to pause waiting for a signal and restoring the mask, by using:
.DS
sigpause(mask);
long mask;
.DE
.NH 3
Signal stacks
.PP
Applications that maintain complex or fixed size stacks can use
the call
.DS
._f
struct sigstack {
	caddr_t	ss_sp;
	int	ss_onstack;
};

sigstack(ss, oss)
struct sigstack *ss; result struct sigstack *oss;
.DE
to provide the system with a stack based at \fIss_sp\fP for delivery
of signals. The value \fIss_onstack\fP indicates whether the
process is currently on the signal stack,
a notion maintained in software by the system.
.PP
When a signal is to be delivered, the system checks whether
the process is on a signal stack.  If not, then the process is switched
to the signal stack for delivery, with the return from the signal
arranged to restore the previous stack.
.PP
If the process wishes to take a non-local exit from the signal routine,
or run code from the signal stack that uses a different stack,
a \fIsigstack\fP call should be used to reset the signal stack.
.ds f. 1.4.t
.\" %M% %I% %E%
.sh "Timers
.NH 3
Real time
.PP
The system's notion of the current Greenwich time and the current time
zone is set and returned by the call by the calls:
.DS
#include <sys/time.h>

settimeofday(tvp, tzp);
struct timeval *tp;
struct timezone *tzp;

gettimeofday(tp, tzp);
result struct timeval *tp;
result struct timezone *tzp;
.DE
where the structures are defined in <sys/time.h> as:
.DS
._f
struct timeval {
	long	tv_sec;	/* seconds since Jan 1, 1970 */
	long	tv_usec;	/* and microseconds */
};

struct timezone {
	int	tz_minuteswest;	/* of Greenwich */
	int	tz_dsttime;	/* type of dst correction to apply */
};
.DE
Earlier versions of UNIX contained only a 1-second resolution version
of this call, which remains as a library routine:
.DS
time(tvsec)
result long *tvsec;
.DE
returning only the tv_sec field from the \fIgettimeofday\fP call.
.NH 3
Interval time
.PP
The system provides each process with three interval timers,
defined in <sys/time.h>:
.DS
._d
#define	ITIMER_REAL	0	/* real time intervals */
#define	ITIMER_VIRTUAL	1	/* virtual time intervals */
#define	ITIMER_PROF	2	/* user and system virtual time */
.DE
The ITIMER_REAL timer decrements
in real time.  It could be used by a library routine to
maintain a wakeup service queue.  A SIGALRM signal is delivered
when this timer expires.
.PP
The ITIMER_VIRTUAL timer decrements in process virtual time.
It runs only when the process is executing.  A SIGVTALRM signal
is delivered when it expires.
.PP
The ITIMER_PROF timer decrements both in process virtual time and when
the system is running on behalf of the process.
It is designed to be used by processes to statistically profile
their execution.
A SIGPROF signal is delivered when it expires.
.PP
A timer value is defined by the \fIitimerval\fP structure:
.DS
._f
struct itimerval {
	struct	timeval it_interval;	/* timer interval */
	struct	timeval it_value;	/* current value */
};
.DE
and a timer is set or read by the call:
.DS
getitimer(which, value);
int which; result struct itimerval *value;

setitimer(which, value, ovalue);
int which; struct itimerval *value; result struct itimerval *ovalue;
.DE
The third argument to \fIsetitimer\fP specifies an optional structure
to receive the previous contents of the interval timer.
A timer can be disabled by specifying a timer value of 0.
.PP
The system rounds argument timer intervals to be not less than the
resolution of its clock.  This clock resolution can be determined
by loading a very small value into a timer and reading the timer back to
see what value resulted.
.PP
The \fIalarm\fP system call of earlier versions of UNIX is provided
as a library routine using the ITIMER_REAL timer.  The process
profiling facilities of earlier versions of UNIX
remain because
it is not always possible to guarantee
the automatic restart of system calls after 
receipt of a signal.
.DS
profil(buf, bufsize, offset, scale);
result char *buf; int bufsize, offset, scale;
.DE
.ds f. 1.5.t
.\" %M% %I% %E%
.sh Descriptors
.PP
.NH 3
The reference table
.PP
Each process has access to resources through
\fIdescriptors\fP.  Each descriptor is a handle allowing
the process to reference objects such as files, devices
and communications links.
.PP
Rather than allowing processes direct access to descriptors, the system
introduces a level of indirection, so that descriptors may be shared
between processes.  Each process has a \fIdescriptor reference table\fP,
containing pointers to the actual descriptors.  The descriptors
themselves thus have multiple references, and are reference counted by the
system.
.PP
Each process has a fixed size descriptor reference table, where
the size is returned by the \fIgetdtablesize\fP call:
.DS
nds = getdtablesize();
result int nds;
.DE
and guaranteed to be at least 20.  The entries in the descriptor reference
table are referred to by small integers; for example if there
are 20 slots they are numbered 0 to 19.
.NH 3
Descriptor properties
.PP
Each descriptor has a logical set of properties maintained
by the system and defined by its \fItype\fP.
Each type supports a set of operations;
some operations, such as reading and writing, are common to several
abstractions, while others are unique.
The generic operations applying to many of these types are described
in section 2.1.  Naming contexts, files and directories are described in
section 2.2.  Section 2.3 describes communications domains and sockets.
Terminals and (structured and unstructured) devices are described
in section 2.4.
.NH 3
Managing descriptor references
.PP
A duplicate of a descriptor reference may be made by doing
.DS
new = dup(old);
result int new; int old;
.DE
returning a copy of descriptor reference \fIold\fP indistinguishable from
the original.  The \fInew\fP chosen by the system will be the
smallest unused descriptor reference slot.
A copy of a descriptor reference may be made in a specific slot
by doing
.DS
dup2(old, new);
int old, new;
.DE
The \fIdup2\fP call causes the system to deallocate the descriptor reference
current occupying slot \fInew\fP, if any, replacing it with a reference
to the same descriptor as old.
This deallocation is also performed by:
.DS
close(old);
int old;
.DE
.NH 3
Multiplexing requests
.PP
The system provides a
standard way to do
synchronous and asynchronous multiplexing of operations.
.PP
Synchronous multiplexing is performed by using the \fIselect\fP call:
.DS
nds = select(nd, in, out, except, tvp);
result int nds; int nd; result *in, *out, *except;
struct timeval *tvp;
.DE
The \fIselect\fP call examines the descriptors
specified by the
sets \fIin\fP, \fIout\fP and \fIexcept\fP, replacing
the specified bit masks by the subsets that select for input,
output, and exceptional conditions respectively (\fInd\fP
indicates the size, in bytes, of the bit masks).
If any descriptors meet the following criteria,
then the number of such descriptors is returned in \fInds\fP and the
bit masks are updated.
.if n .ds bu *
.if t .ds bu \(bu
.IP \*(bu
A descriptor selects for input if an input oriented operation
such as \fIread\fP or \fIreceive\fP is possible, or if a
connection request may be accepted (see section 2.3.1.4).
.IP \*(bu
A descriptor selects for output if an output oriented operation
such as \fIwrite\fP or \fIsend\fP is possible, or if an operation
that was ``in progress'', such as connection establishment,
has completed (see section 2.1.3).
.IP \*(bu
A descriptor selects for an exceptional condition if a condition
that would cause a SIGURG signal to be generated exists (see section 1.3.2).
.LP
If none of the specified conditions is true, the operation blocks for
at most the amount of time specified by \fItvp\fP, or waits for one of the
conditions to arise if \fItvp\fP is given as 0.
.PP
Options affecting i/o on a descriptor
may be read and set by the call:
.DS
._d
dopt = fcntl(d, cmd, arg)
result int dopt; int d, cmd, arg;

/* interesting values for cmd */
#define	F_SETFL	3	/* set descriptor options */
#define	F_GETFL	4	/* get descriptor options */
#define	F_SETOWN	5	/* set descriptor owner (pid/pgrp) */
#define	F_GETOWN	6	/* get descriptor owner (pid/pgrp) */
.DE
The F_SETFL \fIcmd\fP may be used to set a descriptor in 
non-blocking i/o mode and/or enable signalling when i/o is
possible.  F_SETOWN may be used to specify a process or process
group to be signalled when using the latter mode of operation.
.PP
Operations on non-blocking descriptors will
either complete immediately,
note an error EWOULDBLOCK,
partially complete an input or output operation returning a partial count,
or return an error EINPROGRESS noting that the requested operation is
in progress.
A descriptor which has signalling enabled will cause the specified process
and/or process group
be signaled, with a SIGIO for input, output, or in-progress
operation complete, or
a SIGURG for exceptional conditions.
.PP
For example, when writing to a terminal
using non-blocking output,
the system will accept only as much data as there is buffer space for
and return; when making a connection on a \fIsocket\fP, the operation may
return indicating that the connection establishment is ``in progress''.
The \fIselect\fP facility can be used to determine when further
output is possible on the terminal, or when the connection establishment
attempt is complete.
.NH 3
Descriptor wrapping.\(dg
.PP
.FS
\(dg The facilities described in this section are not included
in 4.2BSD.
.FE
A user process may build descriptors of a specified type by
\fIwrapping\fP a communications channel with a system supplied protocol
translator:
.DS
new = wrap(old, proto)
result int new; int old; struct dprop *proto;
.DE
Operations on the descriptor \fIold\fP are then translated by the
system provided protocol translator into requests on the underyling
object \fIold\fP in a way defined by the protocol.
The protocols supported by the kernel may vary from system to system
and are described in the programmers manual.
.PP
Protocols may be based on communications multiplexing or a rights-passing
style of handling multiple requests made on the same object.  For instance,
a protocol for implementing a file abstraction may or may not include
locally generated ``read-ahead'' requests.  A protocol that provides for
read-ahead may provide higher performance but have a more difficult
implementation.
.PP
Another example is the terminal driving facilities.  Normally a terminal
is associated with a communications line and the terminal type
and standard terminal access protocol is wrapped around a synchronous
communications line and given to the user.  If a virtual terminal
is required, the terminal driver can be wrapped around a communications
link, the other end of which is held by a virtual terminal protocol
interpreter.
.ds f. 1.6.t
.\" %M% %I% %E%
.sh "Resource controls
.NH 3
Process priorities
.PP
The system gives CPU scheduling priority to processes that have not used
CPU time recently.  This tends to favor interactive processes and
processes that execute only for short periods.
It is possible to determine the priority currently
assigned to a process, process group, or the processes of a specified user,
or to alter this priority using the calls:
.DS
._d
#define	PRIO_PROCESS	0	/* process */
#define	PRIO_PGRP	1	/* process group */
#define	PRIO_USER	2	/* user id */

prio = getpriority(which, who);
result int prio; int which, who;

setpriority(which, who, prio);
int which, who, prio;
.DE
The value \fIprio\fP is in the range \-20 to 20.
The default priority is 0; lower priorities cause more
favorable execution.
The \fIgetpriority\fP call returns the highest priority (lowest numerical value)
enjoyed by any of the specified processes.
The \fIsetpriority\fP call sets the priorities of all of the
specified processes to the specified value.
Only the super-user may lower priorities.
.NH 3
Resource utilization
.PP
The resources used by a process are returned by a \fIgetrusage\fP call,
returning information in a structure defined in <sys/resource.h>:
.DS
._d
#define	RUSAGE_SELF	0		/* usage by this process */
#define	RUSAGE_CHILDREN	-1		/* usage by all children */

getrusage(who, rusage)
int who; result struct rusage *rusage;

._f
struct rusage {
	struct	timeval ru_utime;	/* user time used */
	struct	timeval ru_stime;	/* system time used */
	int	ru_maxrss;	/* maximum core resident set size: kbytes */
	int	ru_ixrss;	/* integral shared memory size (kbytes*sec) */
	int	ru_idrss;	/* unshared data " */
	int	ru_isrss;	/* unshared stack " */
	int	ru_minflt;	/* page-reclaims */
	int	ru_majflt;	/* page faults */
	int	ru_nswap;	/* swaps */
	int	ru_inblock;	/* block input operations */
	int	ru_oublock;	/* block output " */
	int	ru_msgsnd;	/* messages sent */
	int	ru_msgrcv;	/* messages received */
	int	ru_nsignals;	/* signals received */
	int	ru_nvcsw;	/* voluntary context switches */
	int	ru_nivcsw;	/* involuntary " */
};
.DE
The \fIwho\fP parameter specifies whose resource usage is to be returned.
The resources used by the current process, or by all
the terminated children of the current process may be requested.
.NH 3
Resource limits
.PP
The resources of a process for which limits are controlled by the
kernel are defined in <sys/resource.h>, and controlled by the
\fIgetrlimit\fP and \fIsetrlimit\fP calls:
.DS
._d
#define	RLIMIT_CPU	0	/* cpu time in milliseconds */
#define	RLIMIT_FSIZE	1	/* maximum file size */
#define	RLIMIT_DATA	2	/* maximum data segment size */
#define	RLIMIT_STACK	3	/* maximum stack segment size */
#define	RLIMIT_CORE	4	/* maximum core file size */
#define	RLIMIT_RSS	5	/* maximum resident set size */

#define	RLIM_NLIMITS	6

#define	RLIM_INFINITY	0x7f\&f\&f\&f\&f\&f\&f

._f
struct rlimit {
	int	rlim_cur;	/* current (soft) limit */
	int	rlim_max;	/* hard limit */
};

getrlimit(resource, rlp)
int resource; result struct rlimit *rlp;

setrlimit(resource, rlp)
int resource; struct rlimit *rlp;
.DE
.PP
Only the super-user can raise the maximum limits.
Other users may only
alter \fIrlim_cur\fP within the range from 0 to \fIrlim_max\fP
or (irreversibly) lower \fIrlim_max\fP.
.ds f. 1.7.t
.\" %M% %I% %E%
.sh "System operation support
.PP
Unless noted otherwise,
the calls in this section are permitted only to a privileged user.
.NH 3
Bootstrap operations
.PP
The call
.DS
mount(blkdev, dir, ronly);
char *blkdev, *dir; int ronly;
.DE
extends the UNIX name space.  The \fImount\fP call specifies
a block device \fIblkdev\fP containing a UNIX file system
to be made available starting at \fIdir\fP.  If \fIronly\fP is
set then the file system is read-only; writes to the file system
will not be permitted and access times will not be updated
when files are referenced.
\fIDir\fP is normally a name in the root directory.
.PP
The call
.DS
swapon(blkdev, size);
char *blkdev; int size;
.DE
specifies a device to be made available for paging and swapping.
.PP
.NH 3
Shutdown operations
.PP
The call
.DS
unmount(dir);
char *dir;
.DE
unmounts the file system mounted on \fIdir\fP.
This call will succeed only if the file system is
not currently being used.
.PP
The call
.DS
sync();
.DE
schedules input/output to clean all system buffer caches.
(This call does not require priveleged status.)
.PP
The call
.DS
reboot(how)
int how;
.DE
causes a machine halt or reboot.  The call may request a reboot
by specifying \fIhow\fP as RB_AUTOBOOT, or that the machine be halted
with RB_HALT.  These constants are defined in <sys/reboot.h>.
.NH 3
Accounting
.PP
The system optionally keeps an accounting record in a file
for each process that exits on the system.
The format of this record is beyond the scope of this document.
The accounting may be enabled to a file \fIname\fP by doing
.DS
acct(path);
char *path;
.DE
If \fIpath\fP is null, then accounting is disabled.  Otherwise,
the named file becomes the accounting file.
.ds f. 2.0.t
.\" %M% %I% %E%
.ds ss 1
.sh "System facilities
This section discusses the system facilities that
are not considered part of the kernel.
.PP
The system abstractions described are:
.IP "Directory contexts
.br
A directory context is a position in the UNIX file system name
space.  Operations on files and other named objects in a file system are
always specified relative to such a context.
.IP "Files
.br
Files are used to store uninterpreted sequence of bytes on which
random access \fIreads\fP and \fIwrites\fP may occur.
Pages from files may also be mapped into process address space.
A directory may be read as a file\(dg.
.FS
\(dg Support for mapping files is not included in the 4.2 release.
.FE
.IP "Communications domains
.br
A communications domain represents
an interprocess communications environment, such as the communications
facilities of the UNIX system,
communications in the INTERNET, or the resource sharing protocols
and access rights of a resource sharing system on a local network.
.IP "Sockets
.br
A socket is an endpoint of communication and the focal
point for IPC in a communications domain.  Sockets may be created in pairs,
or given names and used to rendezvous with other sockets
in a communications domain, accepting connections from these
sockets or exchanging messages with them.  These operations model
a labeled or unlabeled communications graph, and can be used in a
wide variety of communications domains.  Sockets can have different
\fItypes\fP\| to provide different semantics of communication,
increasing the flexibility of the model.
.IP "Terminals and other devices
.br
Devices include
terminals, providing input editing and interrupt generation
and output flow control and editing, magnetic tapes,
disks and other peripherals.  They often support the generic
\fIread\fP and \fIwrite\fP operations as well as a number of \fIioctl\fP\|s.
.IP "Processes
.br
Process descriptors provide facilities for control and debugging of
other processes.
.ds ss 2
.ds f. 2.1.t
.\" %M% %I% %E%
.sh "Generic operations
.PP
.PP
Many system abstractions support the
operations \fIread\fP, \fIwrite\fP and \fIioctl\fP.  We describe
the basics of these common primitives here.
Similarly, the mechanisms whereby normally synchronous operations
may occur in a non-blocking or asynchronous fashion are
common to all system-defined abstractions and are described here.
.NH 3
Read and write
.PP
The \fIread\fP and \fIwrite\fP system calls can be applied
to communications channels, files, terminals and devices.
They have the form:
.DS
cc = read(fd, buf, nbytes);
result int cc; int fd; result caddr_t buf; int nbytes;

cc = write(fd, buf, nbytes);
result int cc; int fd; caddr_t buf; int nbytes;
.DE
The \fIread\fP call transfers as much data as possible from the
object defined by \fIfd\fP to the buffer at address \fIbuf\fP of
size \fInbytes\fP.  The number of bytes transferred is
returned in \fIcc\fP, which is \-1 if a return occurred before
any data was transferred because of an error or use of non-blocking
operations.
.PP
The \fIwrite\fP call transfers data from the buffer to the
object defined by \fIfd\fP.  Depending on the type of \fIfd\fP,
it is possible that the \fIwrite\fP call will accept some portion
of the provided bytes; the user should resubmit the other bytes
in a later request in this case.
Error returns because of interrupted or otherwise incomplete operations
are possible.
.PP
Scattering of data on input or gathering of data for output
is also possible using an array of input/output vector descriptors.
The type for the descriptors is defined in <sys/uio.h> as:
.DS
._f
struct iovec {
	caddr_t	iov_msg;	/* base of a component */
	int	iov_len;	/* length of a component */
};
.DE
The calls using an array of descriptors are:
.DS
cc = readv(fd, iov, iovlen);
result int cc; int fd; struct iovec *iov; int iovlen;

cc = writev(fd, iov, iovlen);
result int cc; int fd; struct iovec *iov; int iovlen;
.DE
Here \fIiovlen\fP is the count of elements in the \fIiov\fP array.
.NH 3
Input/output control
.PP
Control operations on an object are performed by the \fIioctl\fP
operation:
.DS
ioctl(fd, request, buffer);
int fd, request; caddr_t buffer;
.DE
This operation causes the specified \fIrequest\fP to be performed
on the object \fIfd\fP.  The \fIrequest\fP parameter specifies
whether the argument buffer is to be read, written, read and written,
or is not needed, and also the size of the buffer, as well as the
request.
Different descriptor types and subtypes within descriptor types
may use distinct \fIioctl\fP requests.  For example,
operations on terminals control flushing of input and output
queues and setting of terminal parameters; operations on
disks cause formatting operations to occur; operations on tapes
control tape positioning.
.PP
The names for basic control operations are defined in <sys/ioctl.h>.
.NH 3
Non-blocking and asynchronous operations
.PP
A process that wishes to do non-blocking operations on one of
its descriptors sets the descriptor in non-blocking mode as
described in section 1.5.4.  Thereafter the \fIread\fP call will
return a specific EWOULDBLOCK error indication if there is no data to be
\fIread\fP.  The process may
\fIdselect\fP the associated descriptor to determine when a read is
possible.
.PP
Output attempted when a descriptor can accept less than is requested
will either accept some of the provided data, returning a shorter than normal
length, or return an error indicating that the operation would block.
More output can be performed as soon as a \fIselect\fP call indicates
the object is writeable.
.PP
Operations other than data input or output
may be performed on a descriptor in a non-blocking fashion.
These operations will return with a characteristic error indicating
that they are in progress
if they cannot return immediately.  The descriptor
may then be \fIselect\fPed for \fIwrite\fP to find out
when the operation can be retried.  When \fIselect\fP indicates
the descriptor is writeable, a respecification of the original
operation will return the result of the operation.
.ds f. 2.2.t
.\" %M% %I% %E%
.sh "File system
.NH 3
Overview
.PP
The file system abstraction provides access to a hierarchical
file system structure.
The file system contains directories (each of which may contain
other sub-directories) as well as files and references to other
objects such as devices and inter-process communications sockets.
.PP
Each file is organized as a linear array of bytes.  No record
boundaries or system related information is present in
a file.
Files may be read and written in a random-access fashion.
The user may read the data in a directory as though
it were an ordinary file to determine the names of the contained files,
but only the system may write into the directories.
The file system stores only a small amount of ownership, protection and usage
information with a file.
.NH 3
Naming
.PP
The file system calls take \fIpath name\fP arguments.
These consist of a zero or more component \fIfile names\fP
separated by ``/'' characters, where each file name
is up to 255 ASCII characters excluding null and ``/''.
.PP
Each process always has two naming contexts: one for the
root directory of the file system and one for the
current working directory.  These are used
by the system in the filename translation process.
If a path name begins with a ``/'', it is called
a full path name and interpreted relative to the root directory context.
If the path name does not begin with a ``/'' it is called
a relative path name and interpreted relative to the current directory
context.
.PP
The system limits
the total length of a path name to 1024 characters.
.PP
The file name ``..'' in each directory refers to
the parent directory of that directory.
The parent directory of a file system is always the systems root directory.
.PP
The calls
.DS
chdir(path);
char *path;

chroot(path)
char *path;
.DE
change the current working directory and root directory context of a process.
Only the super-user can change the root directory context of a process.
.NH 3
Creation and removal
.PP
The file system allows directories, files, special devices,
and ``portals'' to be created and removed from the file system.
.NH 4
Directory creation and removal
.PP
A directory is created with the \fImkdir\fP system call:
.DS
mkdir(path, mode);
char *path; int mode;
.DE
and removed with the \fIrmdir\fP system call:
.DS
rmdir(path);
char *path;
.DE
A directory must be empty if it is to be deleted.
.NH 4
File creation
.PP
Files are created with the \fIopen\fP system call,
.DS
fd = open(path, oflag, mode);
result int fd; char *path; int oflag, mode;
.DE
The \fIpath\fP parameter specifies the name of the
file to be created.  The \fIoflag\fP parameter must
include O_CREAT from below to cause the file to be created.  The protection
for the new file is specified in \fImode\fP.  Bits for \fIoflag\fP are
defined in <sys/file.h>:
.DS
._d
#define	O_RDONLY	000	/* open for reading */
#define	O_WRONLY	001	/* open for writing */
#define	O_RDWR	002	/* open for read & write */
#define	O_NDELAY	004 	/* non-blocking open */
#define	O_APPEND	010	/* append on each write */
#define	O_CREAT	01000	/* open with file create */
#define	O_TRUNC	02000	/* open with truncation */
#define	O_EXCL	04000	/* error on create if file exists */
.DE
.PP
One of O_RDONLY, O_WRONLY and O_RDWR should be specified,
indicating what types of operations are desired to be performed
on the open file.  The operations will be checked against the user's
access rights to the file before allowing the \fIopen\fP to succeed.
Specifying O_APPEND causes writes to automatically append to the
file.
The flag O_CREAT causes the file to be created if it does not
exist, with the specified \fImode\fP, owned by the current user
and the group of the containing directory.
.PP
If the open specifies to create the file with O_EXCL
and the file already exists, then the \fIopen\fP will fail
without affecting the file in any way.  This provides a
simple exclusive access facility.
.NH 4
Creating references to devices
.PP
The file system allows entries which reference peripheral devices.
Peripherals are distinguished as \fIblock\fP or \fIcharacter\fP
devices according by their ability to support block-oriented
operations.
Devices are identified by their ``major'' and ``minor''
device numbers.  The major device number determines the kind
of peripheral it is, while the minor device number indicates
one of possibly many peripherals of that kind.
Structured devices have all operations performed internally
in ``block'' quantities while
unstructured devices often have a number of
special \fIioctl\fP operations, and may have input and output
performed in large units.
The \fImknod\fP call creates special entries:
.DS
mknod(path, mode, dev);
char *path; int mode, dev;
.DE
where \fImode\fP is formed from the object type
and access permissions.  The parameter \fIdev\fP is a configuration
dependent parameter used to identify specific character or
block i/o devices.
.NH 4
Portal creation\(dg
.PP
.FS
\(dg The \fIportal\fP call is not implemented in 4.2BSD.
.FE
The call
.DS
fd = portal(name, server, param, dtype, protocol, domain, socktype)
result int fd; char *name, *server, *param; int dtype, protocol;
int domain, socktype;
.DE
places a \fIname\fP in the file system name space that causes connection to a
server process when the name is used.
The portal call returns an active portal in \fIfd\fP as though an
access had occurred to activate an inactive portal, as now described.
.PP
When an inactive portal is accesseed, the system sets up a socket
of the specified \fIsocktype\fP in the specified communications
\fIdomain\fP (see section 2.3), and creates the \fIserver\fP process,
giving it the specified \fIparam\fP as argument to help it identify
the portal, and also giving it the newly created socket as descriptor
number 0.  The accessor of the portal will create a socket in the same
\fIdomain\fP and \fIconnect\fP to the server.  The user will then
\fIwrap\fP the socket in the specified \fIprotocol\fP to create an object of
the required descriptor type \fIdtype\fP and proceed with the
operation which was in progress before the portal was encountered.
.PP
While the server process holds the socket (which it received as \fIfd\fP
from the \fIportal\fP call on descriptor 0 at activation) further references
will result in connections being made to the same socket.
.NH 4
File, device, and portal removal
.PP
A reference to a file, special device or portal may be removed with the
\fIunlink\fP call,
.DS
unlink(path);
char *path;
.DE
The caller must have write access to the directory in which
the file is located for this call to be successful.
.NH 3
Reading and modifying file attributes
.PP
Detailed information about the attributes of a file
may be obtained with the calls:
.DS
#include <sys/stat.h>

stat(path, stb);
char *path; result struct stat *stb;

fstat(fd, stb);
int fd; result struct stat *stb;
.DE
The \fIstat\fP structure includes the file
type, protection, ownership, access times,
size, and a count of hard links.
If the file is a symbolic link, then the status of the link
itself (rather than the file the link references)
may be found using the \fIlstat\fP call:
.DS
lstat(path, stb);
char *path; result struct stat *stb;
.DE
.PP
Newly created files are assigned the user id of the
process that created it and the group id of the directory
in which it was created.  The ownership of a file may
be changed by either of the calls
.DS
chown(path, owner, group);
char *path; int owner, group;

fchown(fd, owner, group);
int fd, owner, group;
.DE
.PP
In addition to ownership, each file has three levels of access
protection associated with it.  These levels are owner relative,
group relative, and global (all users and groups).  Each level
of access has separate indicators for read permission, write
permission, and execute permission.
The protection bits associated with a file may be set by either
of the calls:
.DS
chmod(path, mode);
char *path; int mode;

fchmod(fd, mode);
int fd, mode;
.DE
where \fImode\fP is a value indicating the new protection
of the file.  The file mode is a three digit octal number.
Each digit encodes read access as 4, write access as 2 and execute
access as 1, or'ed together.  The 0700 bits describe owner
access, the 070 bits describe the access rights for processes in the same
group as the file, and the 07 bits describe the access rights
for other processes. 
.PP
Finally, the access and modify times on a file may be set by the call:
.DS
utimes(path, tvp)
char *path; struct timeval *tvp[2];
.DE
This is particularly useful when moving files between media, to
preserve relationships between the times the file was modified.
.NH 3
Links and renaming
.PP
Links allow multiple names for a file
to exist.  Links exist independently of the file linked to.
.PP
Two types of links exist, \fIhard\fP links and \fIsymbolic\fP
links.  A hard link is a reference counting mechanism that
allows a file to have multiple names within the same file
system.  Symbolic links cause string substitution
during the pathname interpretation process.
.PP
Hard links and symbolic links have different
properties.  A hard link insures the target
file will always be accessible, even after its original
directory entry is removed; no such guarantee exists for a symbolic link.
Symbolic links can span file systems boundaries.
.PP
The following calls create a new link, named \fIpath2\fP,
to \fIpath1\fP:
.DS
link(path1, path2);
char *path1, *path2;

symlink(path1, path2);
char *path1, *path2;
.DE
The \fIunlink\fP primitive may be used to remove
either type of link. 
.PP
If a file is a symbolic link, the ``value'' of the
link may be read with the \fIreadlink\fP call,
.DS
len = readlink(path, buf, bufsize);
result int len; result char *path, *buf; int bufsize;
.DE
This call returns, in \fIbuf\fP, the null-terminated string
substituted into pathnames passing through \fIpath\fP\|.
.PP
Atomic renaming of file system resident objects is possible
with the \fIrename\fP call:
.DS
rename(oldname, newname);
char *oldname, *newname;
.DE
where both \fIoldname\fP and \fInewname\fP must be
in the same file system.
If \fInewname\fP exists and is a directory, then it must be empty.
.NH 3
Extension and truncation
.PP
Files are created with zero length and may be extended
simply by writing or appending to them.  While a file is
open the system maintains a pointer into the file
indicating the current location in the file associated with
the descriptor.  This pointer may be moved about in the
file in a random access fashion.
To set the current offset into a file, the \fIlseek\fP
call may be used,
.DS
oldoffset = lseek(fd, offset, type);
result off_t oldoffset; int fd; off_t offset; int type;
.DE
where \fItype\fP is given in <sys/file.h> as one of,
.DS
._d
#define	L_SET	0	/* set absolute file offset */
#define	L_INCR	1	/* set file offset relative to current position */
#define	L_XTND	2	/* set offset relative to end-of-file */
.DE
The call ``lseek(fd, 0, L_INCR)''
returns the current offset into the file.
.PP
Files may have ``holes'' in them.  Holes are void areas in the
linear extent of the file where data has never been
written.  These may be created by seeking to
a location in a file past the current end-of-file and writing.
Holes are treated by the system as zero valued bytes.
.PP
A file may be truncated with either of the calls:
.DS
truncate(path, length);
char *path; int length;

ftruncate(fd, length);
int fd, length;
.DE
reducing the size of the specified file to \fIlength\fP bytes.
.NH 3
Checking accessibility
.PP
A process running with
different real and effective user ids
may interrogate the accessibility of a file to the
real user by using
the \fIaccess\fP call:
.DS
accessible = access(path, how);
result int accessible; char *path; int how;
.DE
Here \fIhow\fP is constructed by or'ing the following bits, defined
in <sys/file.h>:
.DS
._d
#define	F_OK	0	/* file exists */
#define	X_OK	1	/* file is executable */
#define	W_OK	2	/* file is writable */
#define	R_OK	4	/* file is readable */
.DE
The presence or absence of advisory locks does not affect the
result of \fIaccess\fP\|.
.NH 3
Locking
.PP
The file system provides basic facilities that allow cooperating processes
to synchronize their access to shared files.  A process may
place an advisory \fIread\fP or \fIwrite\fP lock on a file,
so that other cooperating processes may avoid interfering
with the process' access.  This simple mechanism
provides locking with file granularity.  More granular
locking can be built using the IPC facilities to provide a lock
manager.
The system does not force processes to obey the locks;
they are of an advisory nature only.
.PP
Locking is performed after an \fIopen\fP call by applying the
\fIflock\fP primitive,
.DS
flock(fd, how);
int fd, how;
.DE
where the \fIhow\fP parameter is formed from bits defined in <sys/file.h>:
.DS
._d
#define	LOCK_SH	1	/* shared lock */
#define	LOCK_EX	2	/* exclusive lock */
#define	LOCK_NB	4	/* don't block when locking */
#define	LOCK_UN	8	/* unlock */
.DE
Successive lock calls may be used to increase or
decrease the level of locking.  If an object is currently
locked by another process when a \fIflock\fP call is made,
the caller will be blocked until the current lock owner
releases the lock; this may be avoided by including LOCK_NB
in the \fIhow\fP parameter.
Specifying LOCK_UN removes all locks associated with the descriptor.
Advisory locks held by a process are automatically deleted when
the process terminates.
.NH 3
Disk quotas
.PP
As an optional facility, each file system may be requested to
impose limits on a user's disk usage.
Two quantities are limited: the total amount of disk space which
a user may allocate in a file system and the total number of files
a user may create in a file system.  Quotas are expressed as
\fIhard\fP limits and \fIsoft\fP limits.  A hard limit is
always imposed; if a user would exceed a hard limit, the operation
which caused the resource request will fail.  A soft limit results
in the user receiving a warning message, but with allocation succeeding.
Facilities are provided to turn soft limits into hard limits if a
user has exceeded a soft limit for an unreasonable period of time.
.PP
To enable disk quotas on a file system the \fIsetquota\fP call
is used:
.DS
setquota(special, file)
char *special, *file;
.DE
where \fIspecial\fP refers to a structured device file where
a mounted file system exists, and
\fIfile\fP refers to a disk quota file (residing on the file
system associated with \fIspecial\fP) from which user quotas
should be obtained.  The format of the disk quota file is 
implementation dependent.
.PP
To manipulate disk quotas the \fIquota\fP call is provided:
.DS
#include <sys/quota.h>

quota(cmd, uid, arg, addr)
int cmd, uid, arg; caddr_t addr;
.DE
The indicated \fIcmd\fP is applied to the user ID \fIuid\fP.
The parameters \fIarg\fP and \fIaddr\fP are command specific.
The file <sys/quota.h> contains definitions pertinent to the
use of this call.
.ds f. 2.3.t
.\" %M% %I% %E%
.sh "Interprocess communications
.NH 3
Interprocess communication primitives
.NH 4
Communication domains
.PP
The system provides access to an extensible set of 
communication \fIdomains\fP.  A communication domain
is identified by a manifest constant defined in the
file <sys/socket.h>.
Important standard domains supported by the system are the ``unix''
domain, AF_UNIX, for communication within the system, and the ``internet''
domain for communication in the DARPA internet, AF_INET.  Other domains can
be added to the system.
.NH 4
Socket types and protocols
.PP
Within a domain, communication takes place between communication endpoints
known as \fIsockets\fP.  Each socket has the potential to exchange
information with other sockets within the domain.
.PP
Each socket has an associated
abstract type, which describes the semantics of communication using that
socket.  Properties such as reliability, ordering, and prevention
of duplication of messages are determined by the type.
The basic set of socket types is defined in <sys/socket.h>:
.DS
/* Standard socket types */
._d
#define	SOCK_DGRAM	1	/* datagram */
#define	SOCK_STREAM	2	/* virtual circuit */
#define	SOCK_RAW	3	/* raw socket */
#define	SOCK_RDM	4	/* reliably-delivered message */
#define	SOCK_SEQPACKET	5	/* sequenced packets */
.DE
The SOCK_DGRAM type models the semantics of datagrams in network communication:
messages may be lost or duplicated and may arrive out-of-order.
The SOCK_RDM type models the semantics of reliable datagrams: messages
arrive unduplicated and in-order, the sender is notified if
messages are lost.
The \fIsend\fP and \fIreceive\fP operations (described below)
generate reliable/unreliable datagrams.
The SOCK_STREAM type models connection-based virtual circuits: two-way
byte streams with no record boundaries.
The SOCK_SEQPACKET type models a connection-based,
full-duplex, reliable, sequenced packet exchange;
the sender is notified if messages are lost, and messages are never
duplicated or presented out-of-order.
Users of the last two abstractions may use the facilities for
out-of-band transmission to send out-of-band data.
.PP
SOCK_RAW is used for unprocessed access to internal network layers
and interfaces; it has no specific semantics.
.PP
Other socket types can be defined.\(dg
.FS
\(dg 4.2BSD does not support the SOCK_RDM and SOCK_SEQPACKET types.
.FE
.PP
Each socket may have a concrete \fIprotocol\fP associated with it.
This protocol is used within the domain to provide the semantics
required by the socket type.
For example, within the ``internet'' domain, the SOCK_DGRAM type may be
implemented by the UDP user datagram protocol, and the SOCK_STREAM
type may be implemented by the TCP transmission control protocol, while
no standard protocols to provide SOCK_RDM or SOCK_SEQPACKET sockets exist.
.NH 4
Socket creation, naming and service establishment
.PP
Sockets may be \fIconnected\fP or \fIunconnected\fP.  An unconnected
socket descriptor is obtained by the \fIsocket\fP call:
.DS
s = socket(domain, type, protocol);
result int s; int domain, type, protocol;
.DE
.PP
An unconnected socket descriptor may yield a connected socket descriptor
in one of two ways: either by actively connecting to another socket,
or by becoming associated with a name in the communications domain and
\fIaccepting\fP a connection from another socket.
.PP
To accept connections, a socket must first have a binding
to a name within the communications domain.  Such a binding
is established by a \fIbind\fP call:
.DS
bind(s, name, namelen);
int s; char *name; int namelen;
.DE
A socket's bound name may be retrieved with a \fIgetsockname\fP call:
.DS
getsockname(s, name, namelen);
int s; result caddr_t name; result int *namelen;
.DE
while the peer's name can be retrieved with \fIgetpeername\fP:
.DS
getpeername(s, name, namelen);
int s; result caddr_t name; result int *namelen;
.DE
Domains may support sockets with several names.
.NH 4
Accepting connections
.PP
Once a binding is made, it is possible to \fIlisten\fP for
connections:
.DS
listen(s, backlog);
int s, backlog;
.DE
The \fIbacklog\fP specifies the maximum count of connections
that can be simultaneously queued awaiting acceptance.
.PP
An \fIaccept\fP call:
.DS
t = accept(s, name, anamelen);
result int t; int s; result caddr_t name; result int *anamelen;
.DE
returns a descriptor for a new, connected, socket
from the queue of pending connections on \fIs\fP.
.NH 4
Making connections
.PP
An active connection to a named socket is made by the \fIconnect\fP call:
.DS
connect(s, name, namelen);
int s; caddr_t name; int namelen;
.DE
.PP
It is also possible to create connected pairs of sockets without
using the domain's name space to rendezvous; this is done with the
\fIsocketpair\fP call\(dg:
.FS
\(dg 4.2BSD supports \fIsocketpair\fP creation only in the ``unix''
communication domain.
.FE
.DS
socketpair(d, type, protocol, sv);
int d, type, protocol; result int sv[2];
.DE
Here the returned \fIsv\fP descriptors correspond to those obtained with
\fIaccept\fP and \fIconnect\fP.
.PP
The call
.DS
pipe(pv)
result int pv[2];
.DE
creates a pair of SOCK_STREAM sockets in the UNIX domain,
with pv[0] only writeable and pv[1] only readable.
.NH 4
Sending and receiving data
.PP
Messages may be sent from a socket by:
.DS
cc = sendto(s, buf, len, flags, to, tolen);
result int cc; int s; caddr_t buf; int len, flags; caddr_t to; int tolen;
.DE
if the socket is not connected or:
.DS
cc = send(s, buf, len, flags);
result int cc; int s; caddr_t buf; int len, flags;
.DE
if the socket is connected.
The corresponding receive primitives are:
.DS
msglen = recvfrom(s, buf, len, flags, from, fromlenaddr);
result int msglen; int s; result caddr_t buf; int len, flags;
result caddr_t from; result int *fromlenaddr;
.DE
and
.DS
msglen = recv(s, buf, len, flags);
result int msglen; int s; result caddr_t buf; int len, flags;
.DE
.PP
In the unconnected case,
the parameters \fIto\fP and \fItolen\fP
specify the destination or source of the message, while
the \fIfrom\fP parameter stores the source of the message,
and \fI*fromlenaddr\fP initially gives the size of the \fIfrom\fP
buffer and is updated to reflect the true length of the \fIfrom\fP
address.
.PP
All calls cause the message to be received in or sent from
the message buffer of length \fIlen\fP bytes, starting at address \fIbuf\fP.
The \fIflags\fP specify
peeking at a message without reading it or sending or receiving
high-priority out-of-band messages, as follows:
.DS
._d
#define	MSG_PEEK	0x1	/* peek at incoming message */
#define	MSG_OOB	0x2	/* process out-of-band data */
.DE
.NH 4
Scatter/gather and exchanging access rights
.PP
It is possible scatter and gather data and to exchange access rights
with messages.  When either of these operations is involved,
the number of parameters to the call becomes large.
Thus the system defines a message header structure, in <sys/socket.h>,
which can be
used to conveniently contain the parameters to the calls:
.DS
.if t .ta .5i 1.25i 2i 2.7i
.if n ._f
struct msghdr {
	caddr_t	msg_name;		/* optional address */
	int	msg_namelen;	/* size of address */
	struct	iov *msg_iov;	/* scatter/gather array */
	int	msg_iovlen;		/* # elements in msg_iov */
	caddr_t	msg_accrights;	/* access rights sent/received */
	int	msg_accrightslen;	/* size of msg_accrights */
};
.DE
Here \fImsg_name\fP and \fImsg_namelen\fP specify the source or destination
address if the socket is unconnected; \fImsg_name\fP may be given as
a null pointer if no names are desired or required.
The \fImsg_iov\fP and \fImsg_iovlen\fP describe the scatter/gather
locations, as described in section 2.1.3.
Access rights to be sent along with the message are specified
in \fImsg_accrights\fP, which has length \fImsg_accrightslen\fP.
In the ``unix'' domain these are an array of integer descriptors,
taken from the sending process and duplicated in the receiver.
.PP
This structure is used in the operations \fIsendmsg\fP and \fIrecvmsg\fP:
.DS
sendmsg(s, msg, flags);
int s; struct msghdr *msg; int flags;

msglen = recvmsg(s, msg, flags);
result int msglen; int s; result struct msghdr *msg; int flags;
.DE
.NH 4
Using read and write with sockets
.PP
The normal UNIX \fIread\fP and \fIwrite\fP calls may be
applied to connected sockets and translated into \fIsend\fP and \fIreceive\fP
calls from or to a single area of memory and discarding any rights
received.  A process may operate on a virtual circuit socket, a terminal
or a file with blocking or non-blocking input/output
operations without distinguishing the descriptor type.
.NH 4
Shutting down halves of full-duplex connections
.PP
A process that has a full-duplex socket such as a virtual circuit
and no longer wishes to read from or write to this socket can
give the call:
.DS
shutdown(s, direction);
int s, direction;
.DE
where \fIdirection\fP is 0 to not read further, 1 to not
write further, or 2 to completely shut the connection down.
.NH 4
Socket and protocol options
.PP
Sockets, and their underlying communication protocols, may
support \fIoptions\fP.  These options may be used to manipulate
implementation specific or non-standard facilities. 
The \fIgetsockopt\fP
and \fIsetsockopt\fP calls are used to control options:
.DS
getsockopt(s, level, optname, optval, optlen)
int s, level, optname; result caddr_t optval; result int *optlen;

setsockopt(s, level, optname, optval, optlen)
int s, level, optname; caddr_t optval; int optlen;
.DE
The option \fIoptname\fP is interpreted at the indicated
protocol \fIlevel\fP for socket \fIs\fP.  If a value is specified
with \fIoptval\fP and \fIoptlen\fP, it is interpreted by
the software operating at the specified \fIlevel\fP.  The \fIlevel\fP
SOL_SOCKET is reserved to indicate options maintained
by the socket facilities.  Other \fIlevel\fP values indicate
a particular protocol which is to act on the option request;
these values are normally interpreted as a ``protocol number''.
.NH 3
UNIX domain
.PP
This section describes briefly the properties of the UNIX communications
domain.
.NH 4
Types of sockets
.PP
In the UNIX domain,
the SOCK_STREAM abstraction provides pipe-like
facilities, while SOCK_DGRAM provides (usually)
reliable message-style communications.
.NH 4
Naming
.PP
Socket names are strings and may appear in the UNIX file
system name space through portals\(dg.
.FS
\(dg The 4.2BSD implementation of the UNIX domain embeds
bound sockets in the UNIX file system name space; this
is a side effect of the implementation.
.FE
.NH 4
Access rights transmission
.PP
The ability to pass UNIX descriptors with messages in this domain
allows migration of service within the system and allows
user processes to be used in building system facilities.
.NH 3
INTERNET domain
.PP
This section describes briefly how the INTERNET domain is
mapped to the model described in this section.  More
information will be found in the document describing the
network implementation in 4.2BSD.
.NH 4
Socket types and protocols
.PP
SOCK_STREAM is supported by the INTERNET TCP protocol;
SOCK_DGRAM by the UDP protocol.  The SOCK_SEQPACKET
has no direct INTERNET family analogue; a protocol
based on one from the XEROX NS family and layered on
top of IP could be implemented to fill this gap.
.NH 4
Socket naming
.PP
Sockets in the INTERNET domain have names composed of the 32 bit
internet address, and a 16 bit port number.
Options may be used to
provide source routing for the address, security options,
or additional address for subnets of INTERNET for which the basic 32 bit
addresses are insufficient.
.NH 4
Access rights transmission
.PP
No access rights transmission facilities are provided in the INTERNET domain.
.NH 4
Raw access
.PP
The INTERNET domain allows the super-user access to the raw facilities
of the various network interfaces and the various internal layers
of the protocol implementation.  This allows administrative and debugging
functions to occur.  These interfaces are modeled as SOCK_RAW sockets.
.ds f. 2.4.t
.\" %M% %I% %E%
.sh "Terminals and Devices
.NH 3
Terminals
.PP
Terminals support \fIread\fP and \fIwrite\fP i/o operations,
as well as a collection of terminal specific \fIioctl\fP operations,
to control input character editing, and output delays.
.NH 4
Terminal input
.PP
Terminals are handled according to the underlying communication
characteristics such as baud rate and required delays,
and a set of software parameters.
.NH 5
Input modes
.PP
A terminal is in one of three possible modes: \fIraw\fP, \fIcbreak\fP,
or \fIcooked\fP.
In raw mode all input is passed through to the
reading process immediately and without interpretation.
In cbreak mode, the handler interprets input only by looking
for characters that cause interrupts or output flow control;
all other characters are made available as in raw mode.
In cooked mode, input
is processed to provide standard line-oriented local editing functions,
and input is presented on a line-by-line basis.
.NH 5
Interrupt characters
.PP
Interrupt characters are interpreted by the terminal handler only in
cbreak and cooked modes, and
cause a software interrupt to be sent to all processes in the process
group associated with the terminal.  Interrupt characters exist
to send SIGINT
and SIGQUIT signals,
and to stop a process group
with the SIGTSTP signal either immediately, or when
all input up to the stop character has been read.
.NH 5
Line editing
.PP
When the terminal is in cooked mode, editing of an input line
is performed.  Editing facilities allow deletion of the previous
character or word, or deletion of the current input line. 
In addition, a special character may be used to reprint the current
input line after some number of editing operations have been applied.
.PP
Certain other characters are interpreted specially when a process is
in cooked mode.  The \fIend of line\fP character determines
the end of an input record.  The \fIend of file\fP character simulates
an end of file occurrence on terminal input.  Flow control is provided
by \fIstop output\fP and \fIstart output\fP control characters.  Output
may be flushed with the \fIflush output\fP character; and a \fIliteral
character\fP may be used to force literal input of the immediately
following character in the input line.
.NH 4
Terminal output
.PP
On output, the terminal handler provides some simple formatting services.
These include converting the carriage return character to the
two character return-linefeed sequence, displaying non-graphic
ASCII characters as ``^character'', inserting delays after certain
standard control characters, expanding tabs, and providing translations
for upper-case only terminals.
.NH 4
Terminal control operations
.PP
When a terminal is first opened it is initialized to a standard
state and configured with a set of standard control, editing,
and interrupt characters.  A process
may alter this configuration with certain
control operations, specifying parameters in a standard structure:
.DS
._f
struct ttymode {
	short	tt_ispeed;	/* input speed */
	int	tt_iflags;	/* input flags */
	short	tt_ospeed;	/* output speed */
	int	tt_oflags;	/* output flags */
};
.DE
and ``special characters'' are specified with the 
\fIttychars\fP structure,
.DS
._f
struct ttychars {
	char	tc_erasec;	/* erase char */
	char	tc_killc;	/* erase line */
	char	tc_intrc;	/* interrupt */
	char	tc_quitc;	/* quit */
	char	tc_startc;	/* start output */
	char	tc_stopc;	/* stop output */
	char	tc_eofc;	/* end-of-file */
	char	tc_brkc;	/* input delimiter (like nl) */
	char	tc_suspc;	/* stop process signal */
	char	tc_dsuspc;	/* delayed stop process signal */
	char	tc_rprntc;	/* reprint line */
	char	tc_flushc;	/* flush output (toggles) */
	char	tc_werasc;	/* word erase */
	char	tc_lnextc;	/* literal next character */
};
.DE
.NH 4
Terminal hardware support
.PP
The terminal handler allows a user to access basic
hardware related functions; e.g. line speed,
modem control, parity, and stop bits.  A special signal,
SIGHUP, is automatically
sent to processes in a terminal's process
group when a carrier transition is detected.  This is
normally associated with a user hanging up on a modem
controlled terminal line.
.NH 3
Structured devices
.PP
Structures devices are typified by disks and magnetic
tapes, but may represent any random-access device.
The system performs read-modify-write type buffering actions on block
devices to allow them to be read and written in a totally random
access fashion like ordinary files.
File systems are normally created in block devices.
.NH 3
Unstructured devices
.PP
Unstructured devices are those devices which
do not support block structure.  Familiar unstructured devices
are raw communications lines (with
no terminal handler), raster plotters, magnetic tape and disks unfettered
by buffering and permitting large block input/output and positioning
and formatting commands.
.ds f. 2.5.t
.\" %M% %I% %E%
.sh "Process and kernel descriptors
.PP
The status of the facilities in this section is still under discussion.
The \fIptrace\fP facility of 4.1BSD is provided in 4.2BSD.  Planned
enhancements would allow a descriptor based process control facility.
.ds LH "Final Report Appendix A
.ds RH Summary of facilities
.bp
.ds f. a1.t
.\" %M% %I% %E%
.SH
\s+2Appendix A \- Summary of facilities\s0
.PP
.de h
.br
.if n .ne 8
\fB\\$1 \\$2\fP
.br
..
.nr H1 0
.NH
Kernel primitives
.LP
.h 1.1. "Process naming and protection
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \wsethostid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgethostid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsethostname
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgethostname
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetpid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wfork
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wexit
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wexecve
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetuid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgeteuid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetreuid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetgid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetegid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetgroups
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetregid
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetgroups
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetpgrp
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetpgrp
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wset UNIX host id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget UNIX host id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset UNIX host name
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget UNIX host name
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget process id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wcreate new process
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wterminate a process
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wexecute a different process
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget user id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget effective user id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset real and effective user id's
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget accounting group id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget effective accounting group id
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget access group set
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset real and effective group id's
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset access group set
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget process group
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset process group
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 36 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sethostid\h'|\n(4eu'set UNIX host id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'gethostid\h'|\n(4eu'get UNIX host id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sethostname\h'|\n(4eu'set UNIX host name
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'gethostname\h'|\n(4eu'get UNIX host name
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getpid\h'|\n(4eu'get process id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'fork\h'|\n(4eu'create new process
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'exit\h'|\n(4eu'terminate a process
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'execve\h'|\n(4eu'execute a different process
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getuid\h'|\n(4eu'get user id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'geteuid\h'|\n(4eu'get effective user id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setreuid\h'|\n(4eu'set real and effective user id's
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getgid\h'|\n(4eu'get accounting group id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getegid\h'|\n(4eu'get effective accounting group id
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getgroups\h'|\n(4eu'get access group set
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setregid\h'|\n(4eu'set real and effective group id's
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setgroups\h'|\n(4eu'set access group set
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getpgrp\h'|\n(4eu'get process group
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setpgrp\h'|\n(4eu'set process group
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-20
.in -5
.h 1.2 "Memory management
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<mman.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsbrk
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsstk\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \w\(dg Not supported in 4.2BSD.
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetpagesize
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmmap\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmremap\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmunmap\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmprotect\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmadvise\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmincore\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wmemory management definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange data section size
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange stack section size
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget memory page size
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmap pages of memory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wremap pages in memory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wunmap memory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange protection of pages
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wgive memory management advice
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wdetermine core residency of pages
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 55 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<mman.h>\h'|\n(4eu'memory management definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sbrk\h'|\n(4eu'change data section size
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sstk\(dg\h'|\n(4eu'change stack section size
.FS
.ta \n(4gu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'\(dg Not supported in 4.2BSD.\h'|\n(4eu'
.FE
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getpagesize\h'|\n(4eu'get memory page size
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mmap\(dg\h'|\n(4eu'map pages of memory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mremap\(dg\h'|\n(4eu'remap pages in memory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'munmap\(dg\h'|\n(4eu'unmap memory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mprotect\(dg\h'|\n(4eu'change protection of pages
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'madvise\(dg\h'|\n(4eu'give memory management advice
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mincore\(dg\h'|\n(4eu'determine core residency of pages
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-15
.in -5
.h 1.3 "Signals
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<signal.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsigvec
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wkill
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wkillpgrp
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsigblock
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsigsetmask
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsigpause
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsigstack
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wsignal definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset handler for signal
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wsend signal to process
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wsend signal to process group
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wblock set of signals
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wrestore set of blocked signals
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wwait for signals
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset software stack for signals
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 69 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<signal.h>\h'|\n(4eu'signal definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sigvec\h'|\n(4eu'set handler for signal
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'kill\h'|\n(4eu'send signal to process
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'killpgrp\h'|\n(4eu'send signal to process group
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sigblock\h'|\n(4eu'block set of signals
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sigsetmask\h'|\n(4eu'restore set of blocked signals
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sigpause\h'|\n(4eu'wait for signals
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sigstack\h'|\n(4eu'set software stack for signals
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-10
.in -5
.h 1.4 "Timing and statistics
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<sys/time.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgettimeofday
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsettimeofday
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetitimer
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetitimer
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wprofil
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wtime-related definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget current time and timezone
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset current time and timezone
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wread an interval timer
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget and set an interval timer
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wprofile process
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 81 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/time.h>\h'|\n(4eu'time-related definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'gettimeofday\h'|\n(4eu'get current time and timezone
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'settimeofday\h'|\n(4eu'set current time and timezone
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getitimer\h'|\n(4eu'read an interval timer
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setitimer\h'|\n(4eu'get and set an interval timer
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'profil\h'|\n(4eu'profile process
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-8
.in -5
.h 1.5 "Descriptors
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \wgetdtablesize
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wdup
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wdup2
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wclose
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wselect
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wfcntl
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wwrap\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \w\(dg Not supported in 4.2BSD.
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wdescriptor reference table size
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wduplicate descriptor
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wduplicate to specified index
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wclose descriptor
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmultiplex input/output
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wcontrol descriptor options
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wwrap descriptor with protocol
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 97 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getdtablesize\h'|\n(4eu'descriptor reference table size
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'dup\h'|\n(4eu'duplicate descriptor
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'dup2\h'|\n(4eu'duplicate to specified index
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'close\h'|\n(4eu'close descriptor
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'select\h'|\n(4eu'multiplex input/output
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'fcntl\h'|\n(4eu'control descriptor options
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'wrap\(dg\h'|\n(4eu'wrap descriptor with protocol
.FS
.ta \n(4gu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'\(dg Not supported in 4.2BSD.\h'|\n(4eu'
.FE
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-12
.in -5
.h 1.6 "Resource controls
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<sys/resource.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetpriority
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetpriority
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetrusage
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetrlimit
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetrlimit
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wresource-related definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget process priority
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset process priority
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget resource usage
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget resource limitations
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset resource limitations
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 109 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/resource.h>\h'|\n(4eu'resource-related definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getpriority\h'|\n(4eu'get process priority
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setpriority\h'|\n(4eu'set process priority
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getrusage\h'|\n(4eu'get resource usage
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getrlimit\h'|\n(4eu'get resource limitations
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setrlimit\h'|\n(4eu'set resource limitations
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-8
.in -5
.h 1.7 "System operation support
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \wmount
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wswapon
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wumount
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsync
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wreboot
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wacct
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wmount a device file system
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wadd a swap device
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wumount a file system
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wflush system caches
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreboot a machine
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wspecify accounting file
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 121 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mount\h'|\n(4eu'mount a device file system
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'swapon\h'|\n(4eu'add a swap device
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'umount\h'|\n(4eu'umount a file system
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sync\h'|\n(4eu'flush system caches
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'reboot\h'|\n(4eu'reboot a machine
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'acct\h'|\n(4eu'specify accounting file
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-8
.in -5
.NH
System facilities
.LP
.h 2.1 "Generic operations
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \wread
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wwrite
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \w<sys/uio.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wreadv
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wwritev
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \w<sys/ioctl.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wioctl
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wread data
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wwrite data
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wscatter-gather related definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wscattered data input
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wgathered data output
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wstandard control operations
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wdevice control operation
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 137 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'read\h'|\n(4eu'read data
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'write\h'|\n(4eu'write data
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/uio.h>\h'|\n(4eu'scatter-gather related definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'readv\h'|\n(4eu'scattered data input
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'writev\h'|\n(4eu'gathered data output
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/ioctl.h>\h'|\n(4eu'standard control operations
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'ioctl\h'|\n(4eu'device control operation
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-9
.in -5
.h 2.2 "File system
.PP
Operations marked with a * exist in two forms: as shown,
operating on a file name, and operating on a file descriptor,
when the name is preceded with a ``f''.
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<sys/file.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wchdir
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wchroot
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmkdir
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wrmdir
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wopen
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wmknod
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wportal\(dg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wunlink
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wstat*
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wlstat
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wchown*
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wchmod*
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wutimes
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wlink
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsymlink
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wreadlink
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wrename
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wlseek
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wtruncate*
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \waccess
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wflock
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wfile system definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange directory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange root directory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmake a directory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wremove a directory
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wopen a new or existing file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmake a special file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmake a portal entry
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wremove a link
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreturn status for a file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreturned status of link
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange owner
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange mode
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange access/modify times
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmake a hard link
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wmake a symbolic link
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wread contents of symbolic link
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wchange name of file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreposition within file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wtruncate file
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wdetermine accessibility
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wlock a file
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 169 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/file.h>\h'|\n(4eu'file system definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'chdir\h'|\n(4eu'change directory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'chroot\h'|\n(4eu'change root directory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mkdir\h'|\n(4eu'make a directory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'rmdir\h'|\n(4eu'remove a directory
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'open\h'|\n(4eu'open a new or existing file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'mknod\h'|\n(4eu'make a special file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'portal\(dg\h'|\n(4eu'make a portal entry
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'unlink\h'|\n(4eu'remove a link
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'stat*\h'|\n(4eu'return status for a file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'lstat\h'|\n(4eu'returned status of link
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'chown*\h'|\n(4eu'change owner
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'chmod*\h'|\n(4eu'change mode
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'utimes\h'|\n(4eu'change access/modify times
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'link\h'|\n(4eu'make a hard link
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'symlink\h'|\n(4eu'make a symbolic link
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'readlink\h'|\n(4eu'read contents of symbolic link
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'rename\h'|\n(4eu'change name of file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'lseek\h'|\n(4eu'reposition within file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'truncate*\h'|\n(4eu'truncate file
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'access\h'|\n(4eu'determine accessibility
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'flock\h'|\n(4eu'lock a file
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-24
.in -5
.h 2.3 "Communications
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.nr 3i \w<sys/socket.h>
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsocket
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wbind
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetsockname
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wlisten
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \waccept
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wconnect
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsocketpair
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsendto
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsend
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wrecvfrom
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wrecv
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsendmsg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wrecvmsg
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wshutdown
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wgetsockopt
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 3i \wsetsockopt
.if \n(4g<\n(3i .nr 4g \n(3i
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.nr 3b 0
.nr 3c 0
.nr 3i \wstandard definitions
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wcreate socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wbind socket to name
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget socket name
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wallow queueing of connections
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \waccept a connection
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wconnect to peer socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wcreate pair of connected sockets
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wsend data to named socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wsend data to connected socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreceive data on unconnected socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreceive data on connected socket
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wsend gathered data and/or rights
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wreceive scattered data and/or rights
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wpartially close full-duplex connection
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wget socket option
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \wset socket option
.if \n(3c<\n(3i .nr 3c \n(3i
.4h
.rm 4h
.if \n(3c>=\n(4h .nr 4h \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4h .nr 4h \n(3i
.if \n(3i<\n(4h .nr 4e +(\n(4h-\n(3i)/2
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr 4e +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 192 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'<sys/socket.h>\h'|\n(4eu'standard definitions
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'socket\h'|\n(4eu'create socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'bind\h'|\n(4eu'bind socket to name
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getsockname\h'|\n(4eu'get socket name
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'listen\h'|\n(4eu'allow queueing of connections
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'accept\h'|\n(4eu'accept a connection
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'connect\h'|\n(4eu'connect to peer socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'socketpair\h'|\n(4eu'create pair of connected sockets
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sendto\h'|\n(4eu'send data to named socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'send\h'|\n(4eu'send data to connected socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'recvfrom\h'|\n(4eu'receive data on unconnected socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'recv\h'|\n(4eu'receive data on connected socket
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'sendmsg\h'|\n(4eu'send gathered data and/or rights
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'recvmsg\h'|\n(4eu'receive scattered data and/or rights
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'shutdown\h'|\n(4eu'partially close full-duplex connection
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'getsockopt\h'|\n(4eu'get socket option
.ta \n(4gu \n(4hu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'setsockopt\h'|\n(4eu'set socket option
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-19
.in -5
.h 2.4 "Terminals, block and character devices
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.4h
.rm 4h
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 198 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-2
.in -5
.h 2.5 "Processes and kernel hooks
.in +5
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4g 4h
.nr 4g 0
.4g
.rm 4g
.nr 3i 1.6in
.if \n(4g<\n(3i .nr 4g \n(3i
.nr 4h 0
.4h
.rm 4h
.nr 3i 3in
.if \n(4h<\n(3i .nr 4h \n(3i
.nr 3i 1n
.nr 4f 0
.nr 4a \n(4f+((0*\n(3i)/2)
.nr 4g +\n(4a
.nr 4b \n(4g+((6*\n(3i)/2)
.nr 4h +\n(4b
.nr TW \n(4h
.if t .if \n(TW>\n(.lu .tm Table at line 204 file a1.t is too wide - \n(TW units
.fc  
.nr #T 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.ls
..
.ec
.fc
.nr T. 1
.T# 1
.3f
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-2
.in -5
.ds LH "Final Report Appendix B
.ds RH Introduction
.bp
.ds f. a2.1.t
.SH
\s+2Appendix B \- File System Implementation\s0
.PP
.nr H1 0
.NH
Introduction
.PP
This appendix describes the changes from the original 512 byte UNIX file
system to the new one released with the 4.2 Berkeley Software Distribution.
It presents the motivations for the changes,
the methods used to affect these changes,
the rationale behind the design decisions,
and a description of the new implementation.
This discussion is followed by a summary of
the results that have been obtained,
directions for future work,
and the additions and changes
that have been made to the user visible facilities.
The paper concludes with a history of the software engineering
of the project.
.PP
The original UNIX system that runs on the PDP-11\(dg
.FS
\(dg DEC, PDP, VAX, MASSBUS, and UNIBUS are
trademarks of Digital Equipment Corporation.
.FE
has simple and elegant file system facilities.  File system input/output
is buffered by the kernel;
there are no alignment constraints on
data transfers and all operations are made to appear synchronous.
All transfers to the disk are in 512 byte blocks, which can be placed
arbitrarily within the data area of the file system.  No constraints
other than available disk space are placed on file growth
[Ritchie74], [Thompson79].
.PP
When used on the VAX-11 together with other UNIX enhancements,
the original 512 byte UNIX file
system is incapable of providing the data throughput rates
that many applications require.
For example, 
applications that need to do a small amount of processing
on a large quantities of data
such as VLSI design and image processing,
need to have a high throughput from the file system.
High throughput rates are also needed by programs with
large address spaces that are constructed by mapping
files from the file system into virtual memory.
Paging data in and out of the file system is likely
to occur frequently.
This requires a file system providing
higher bandwidth than the original 512 byte UNIX one which provides only about
two percent of the maximum disk bandwidth or about
20 kilobytes per second per arm [White80], [Smith81b].
.PP
Modifications have been made to the UNIX file system to improve
its performance.
Since the UNIX file system interface
is well understood and not inherently slow,
this development retained the abstraction and simply changed
the underlying implementation to increase its throughput.
Consequently users of the system have not been faced with
massive software conversion.
.PP
Problems with file system performance have been dealt with
extensively in the literature; see [Smith81a] for a survey.
The UNIX operating system drew many of its ideas from Multics,
a large, high performance operating system [Feiertag71].
Other work includes Hydra [Almes78],
Spice [Thompson80],
and a file system for a lisp environment [Symbolics81a].
.PP
A major goal of this project has been to build a file system that is
extensible into a networked environment [Holler73].
Other work on network file systems describe
centralized file servers [Accetta80],
distributed file servers [Dion80], [Luniewski77], [Porcar82],
and protocols to reduce the amount of information that must be
transferred across a network [Symbolics81b], [Sturgis80].
.ds RH Old file system
.sp 2
.ds f. a2.2.t
.ds RH Old file system
.NH
Old File System
.PP
In the old file system developed at Bell Laboratories
each disk drive contains one or more file systems.\(dg
.FS
\(dg A file system always resides on a single drive.
.FE
A file system is described by its super-block,
which contains the basic parameters of the file system.
These include the number of data blocks in the file system,
a count of the maximum number of files,
and a pointer to a list of free blocks.
All the free blocks in the system are chained together in
a linked list.
Within the file system are files.
Certain files are distinguished as directories and contain
pointers to files that may themselves be directories.
Every file has a descriptor associated with it called an
.I "inode".
The inode contains information describing ownership of the file,
time stamps marking last modification and access times for the file,
and an array of indices that point to the data blocks for the file.
For the purposes of this section, we assume that the first 8 blocks
of the file are directly referenced by values stored
in the inode structure itself*.
.FS
* The actual number may vary from system to system, but is usually in
the range 5-13.
.FE
The inode structure may also contain references to indirect blocks
containing further data block indices.
In a file system with a 512 byte block size, a singly indirect
block contains 128 further block addresses,
a doubly indirect block contains 128 addresses of further single indirect
blocks,
and a triply indirect block contains 128 addresses of further doubly indirect
blocks.
.PP
A traditional 150 megabyte UNIX file system consists
of 4 megabytes of inodes followed by 146 megabytes of data.
This organization segregates the inode information from the data;
thus accessing a file normally incurs a long seek from its inode to its data.
Files in a single directory are not typically allocated
slots in consecutive locations in the 4 megabytes of inodes,
causing many non-consecutive blocks to be accessed when executing
operations on all the files in a directory.
.PP
The allocation of data blocks to files is also suboptimum.
The traditional
file system never transfers more than 512 bytes per disk transaction
and often finds that the next sequential data block is not on the same
cylinder, forcing seeks between 512 byte transfers.
The combination of the small block size,
limited read-ahead in the system,
and many seeks severely limits file system throughput.
.PP
The first work at Berkeley on the UNIX file system attempted to improve both
reliability and throughput.
The reliability was improved by changing the file system so that
all modifications of critical information were staged so that they could
either be completed or repaired cleanly
by a program after a crash [Kowalski78].
The file system performance was improved by a factor of more than two by
changing the basic block size from 512 to 1024 bytes.
The increase was because of two factors;
each disk transfer accessed twice as much data, 
and most files could be described without need to access through
any indirect blocks since the direct blocks contained twice as much data.
The file system with these changes will henceforth be referred to as the
.I "old file system."
.PP
This performance improvement gave a strong indication that
increasing the block size was a good method for improving
throughput.
Although the throughput had doubled, 
the old file system was still using only about
four percent of the disk bandwidth.
The main problem was that although the free list was initially
ordered for optimal access,
it quickly became scrambled as files were created and removed.
Eventually the free list became entirely random
causing files to have their blocks allocated randomly over the disk.
This forced the disk to seek before every block access.
Although old file systems provided transfer rates of up
to 175 kilobytes per second when they were first created,
this rate deteriorated to 30 kilobytes per second after a
few weeks of moderate use because of randomization of their free block list.
There was no way of restoring the performance an old file system
except to dump, rebuild, and restore the file system.
Another possibility would be to have a process that periodically
reorganized the data on the disk to restore locality as
suggested by [Maruyama76].
.ds RH New file system
.sp 2
.ds f. a2.3.t
.ds RH New file system
.NH
New file system organization
.PP
As in the old file system organization
each disk drive contains one or more file systems.
A file system is described by its super-block,
that is located at the beginning of its disk partition.
Because the super-block contains critical data
it is replicated to protect against catastrophic loss.
This is done at the time that the file system is created;
since the super-block data does not change,
the copies need not be referenced unless a head crash
or other hard disk error causes the default super-block
to be unusable.
.PP
To insure that it is possible to create files as large as
2\(ua32 bytes with only two levels of indirection,
the minimum size of a file system block is 4096 bytes.
The size of file system blocks can be any power of two
greater than or equal to 4096.
The block size of the file system is maintained in the super-block
so it is possible for file systems with different block sizes
to be accessible simultaneously on the same system.
The block size must be decided at the time that
the file system is created;
it cannot be subsequently changed without rebuilding the file system.
.PP
The new file system organization partitions the disk
into one or more areas called
.I "cylinder groups".
A cylinder group is comprised of one or more consecutive
cylinders on a disk.
Associated with each cylinder group is some bookkeeping information
that includes a redundant copy of the super-block,
space for inodes,
a bit map describing available blocks in the cylinder group,
and summary information describing the usage of data blocks
within the cylinder group.
For each cylinder group a static number of inodes
is allocated at file system creation time.
The current policy is to allocate one inode for each 2048
bytes of disk space, expecting this
to be far more than will ever be needed.
.PP
All the cylinder group bookkeeping information could be
placed at the beginning of each cylinder group.
However if this approach were used,
all the redundant information would be on the top platter.
Thus a single hardware failure that destroyed the top platter
could cause the loss of all copies of the redundant super-blocks.
Thus the cylinder group bookkeeping information
begins at a floating offset from the beginning of the cylinder group.
The offset for each successive cylinder group is calculated to be
about one track further from the beginning of the cylinder group.
In this way the redundant
information spirals down into the pack so that any single track, cylinder,
or platter can be lost without losing all copies of the super-blocks.
Except for the first cylinder group,
the space between the beginning of the cylinder group
and the beginning of the cylinder group information
is used for data blocks.\(dg
.FS
\(dg While it appears that the first cylinder group could be laid
out with its super-block at the ``known'' location,
this would not work for file systems
with blocks sizes of 16K or greater,
because of the requirement that the cylinder group information
must begin at a block boundary.
.FE
.NH 2
Optimizing storage utilization
.PP
Data is laid out so that larger blocks can be transferred
in a single disk transfer, greatly increasing file system throughput.
As an example, consider a file in the new file system
composed of 4096 byte data blocks.
In the old file system this file would be composed of 1024 byte blocks.
By increasing the block size, disk accesses in the new file
system may transfer up to four times as much information per
disk transaction.
In large files, several
4096 byte blocks may be allocated from the same cylinder so that
even larger data transfers are possible before initiating a seek.
.PP
The main problem with 
bigger blocks is that most UNIX
file systems are composed of many small files.
A uniformly large block size wastes space.
Table 1 shows the effect of file system
block size on the amount of wasted space in the file system.
The machine measured to obtain these figures is one of our time sharing
systems that has roughly 1.2 Gigabyte of on-line storage.
The measurements are based on the active user file systems containing
about 920 megabytes of formated space.
.KF
.DS B
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4i 4j 4k
.nr 4i 0
.nr 3i \wSpace used
.if \n(4i<\n(3i .nr 4i \n(3i
.nr 3b 0
.nr 3c 0
.nr 3i \w775.2 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w807.8 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w828.7 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w866.5 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w948.5 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w1128.3 Mb
.if \n(3c<\n(3i .nr 3c \n(3i
.4i
.rm 4i
.if \n(3c>=\n(4i .nr 4i \n(3cu+2n
.nr 4e \n(3b
.nr 3i \n(4e+\n(3c
.if \n(3i>\n(4i .nr 4i \n(3i
.if \n(3i<\n(4i .nr 4e +(\n(4i-\n(3i)/2
.nr 4j 0
.nr 3i \w% waste
.if \n(4j<\n(3i .nr 4j \n(3i
.nr 3b 0
.nr 3c 0
.nr 3i \w0
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.0
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w4
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.2
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w6
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.9
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w11
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.8
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w22
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.4
.if \n(3c<\n(3i .nr 3c \n(3i
.nr 3i \w45
.if \n(3b<\n(3i .nr 3b \n(3i
.nr 3i \w.6
.if \n(3c<\n(3i .nr 3c \n(3i
.4j
.rm 4j
.nr 4f \n(3b
.nr 3i \n(4f+\n(3c
.if \n(3i>\n(4j .nr 4j \n(3i
.if \n(3i<\n(4j .nr 4f +(\n(4j-\n(3i)/2
.nr 4k 0
.nr 3i \wOrganization
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \wData only, no separation between files
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \wData only, each file starts on 512 byte boundary
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \w512 byte block UNIX file system
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \w1024 byte block UNIX file system
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \w2048 byte block UNIX file system
.if \n(4k<\n(3i .nr 4k \n(3i
.nr 3i \w4096 byte block UNIX file system
.if \n(4k<\n(3i .nr 4k \n(3i
.4k
.rm 4k
.nr 3i 1n
.nr 4h 0
.nr 4a \n(4h+((2*\n(3i)/2)
.nr 4i +\n(4a
.nr 4e +\n(4a
.nr 4b \n(4i+((6*\n(3i)/2)
.nr 4j +\n(4b
.nr 4f +\n(4b
.nr 4c \n(4j+((6*\n(3i)/2)
.nr 4k +\n(4c
.nr TW \n(4k
.nr TW +((2*\n(3i)/2)
.if t .if \n(TW>\n(.lu .tm Table at line 109 file a2.3.t is too wide - \n(TW units
.ne 7v+2p
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'(|\n(4bu+|\n(4iu)/2u'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'(|\n(4cu+|\n(4ju)/2u'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.mk #a
.ta \n(4iu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Space used\h'|\n(4bu'% waste\h'|\n(4cu'Organization
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'775.2 Mb\h'|\n(4bu'0.0\h'|\n(4cu'Data only, no separation between files
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'807.8 Mb\h'|\n(4bu'4.2\h'|\n(4cu'Data only, each file starts on 512 byte boundary
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'828.7 Mb\h'|\n(4bu'6.9\h'|\n(4cu'512 byte block UNIX file system
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'866.5 Mb\h'|\n(4bu'11.8\h'|\n(4cu'1024 byte block UNIX file system
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'948.5 Mb\h'|\n(4bu'22.4\h'|\n(4cu'2048 byte block UNIX file system
.ta \n(4iu \n(4fu \n(4ju \n(4ku 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4eu'1128.3 Mb\h'|\n(4bu'45.6\h'|\n(4cu'4096 byte block UNIX file system
.fc
.nr T. 1
.T# 1
.3f
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-12
Table 1 \- Amount of wasted space as a function of block size.
.DE
.KE
The space wasted is measured as the percentage of space
on the disk not containing user data.
As the block size on the disk
increases, the waste rises quickly, to an intolerable
45.6% waste with 4096 byte file system blocks.
.PP
To be able to use large blocks without undue waste,
small files must be stored in a more efficient way.
The new file system accomplishes this goal by allowing the division
of a single file system block into one or more
.I "fragments".
The file system fragment size is specified
at the time that the file system is created;
each file system block can be optionally broken into
2, 4, or 8 fragments, each of which is addressable.
The lower bound on the size of these fragments is constrained
by the disk sector size,
typically 512 bytes.
The block map associated with each cylinder group
records the space availability at the fragment level;
to determine block availability, aligned fragments are examined.
Figure 1 shows a piece of a map from a 4096/1024 file system.
.KF
.DS B
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4m 4n 4o 4p 4q
.nr 4m 0
.nr 3i \wBits in map
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wFragment numbers
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wBlock numbers
.if \n(4m<\n(3i .nr 4m \n(3i
.4m
.rm 4m
.nr 4n 0
.nr 3i \wXXXX
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w0-3
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w0
.if \n(4n<\n(3i .nr 4n \n(3i
.4n
.rm 4n
.nr 4o 0
.nr 3i \wXXOO
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w4-7
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w1
.if \n(4o<\n(3i .nr 4o \n(3i
.4o
.rm 4o
.nr 4p 0
.nr 3i \wOOXX
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w8-11
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w2
.if \n(4p<\n(3i .nr 4p \n(3i
.4p
.rm 4p
.nr 4q 0
.nr 3i \wOOOO
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w12-15
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w3
.if \n(4q<\n(3i .nr 4q \n(3i
.4q
.rm 4q
.nr 3i 1n
.nr 4l 0
.nr 4a \n(4l+((2*\n(3i)/2)
.nr 4m +\n(4a
.nr 4b \n(4m+((6*\n(3i)/2)
.nr 4n +\n(4b
.nr 4c \n(4n+((6*\n(3i)/2)
.nr 4o +\n(4c
.nr 4d \n(4o+((6*\n(3i)/2)
.nr 4p +\n(4d
.nr 4e \n(4p+((6*\n(3i)/2)
.nr 4q +\n(4e
.nr TW \n(4q
.nr TW +((2*\n(3i)/2)
.if t .if \n(TW>\n(.lu .tm Table at line 143 file a2.3.t is too wide - \n(TW units
.ne 3v+0p
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'(|\n(4bu+|\n(4mu)/2u'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.mk #a
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Bits in map\h'|\n(4bu'XXXX\h'|\n(4cu'XXOO\h'|\n(4du'OOXX\h'|\n(4eu'OOOO
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Fragment numbers\h'|\n(4bu'0-3\h'|\n(4cu'4-7\h'|\n(4du'8-11\h'|\n(4eu'12-15
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Block numbers\h'|\n(4bu'0\h'|\n(4cu'1\h'|\n(4du'2\h'|\n(4eu'3
.fc
.nr T. 1
.T# 1
.3f
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-6
Figure 1 \- Example layout of blocks and fragments in a 4096/1024 file system.
.DE
.KE
Each bit in the map records the status of a fragment;
an ``X'' shows that the fragment is in use,
while a ``O'' shows that the fragment is available for allocation.
In this example,
fragments 0\-5, 10, and 11 are in use,
while fragments 6\-9, and 12\-15 are free.
Fragments of adjoining blocks cannot be used as a block,
even if they are large enough.
In this example,
fragments 6\-9 cannot be coalesced into a block;
only fragments 12\-15 are available for allocation as a block.
.PP
On a file system with a block size of 4096 bytes
and a fragment size of 1024 bytes,
a file is represented by zero or more 4096 byte blocks of data,
and possibly a single fragmented block.
If a file system block must be fragmented to obtain
space for a small amount of data,
the remainder of the block is made available for allocation
to other files.
As an example consider an 11000 byte file stored on
a 4096/1024 byte file system.
This file would uses two full size blocks and a 3072 byte fragment.
If no 3072 byte fragments are available at the time the
file is created,
a full size block is split yielding the necessary 3072 byte
fragment and an unused 1024 byte fragment.
This remaining fragment can be allocated to another file as needed.
.PP
The granularity of allocation is the \fIwrite\fR system call.
Each time data is written to a file, the system checks to see if
the size of the file has increased*.
.FS
* A program may be overwriting data in the middle of an existing file
in which case space will already be allocated.
.FE
If the file needs to hold the new data,
one of three conditions exists:
.IP 1)
There is enough space left in an already
allocated block to hold the new data.
The new data is written into the available space in the block.
.IP 2)
Nothing has been allocated.
If the new data contains more than 4096 bytes,
a 4096 byte block is allocated and
the first 4096 bytes of new data is written there.
This process is repeated until less than 4096 bytes of new data remain.
If the remaining new data to be written will
fit in three or fewer 1024 byte pieces,
an unallocated fragment is located,
otherwise a 4096 byte block is located.
The new data is written into the located piece.
.IP 3)
A fragment has been allocated.
If the number of bytes in the new data plus the number of bytes
already in the fragment exceeds 4096 bytes,
a 4096 byte block is allocated.
The contents of the fragment is copied to the beginning of the block
and the remainder of the block is filled with the new data.
The process then continues as in (2) above.
If the number of bytes in the new data plus the number of bytes
already in the fragment will fit in three or fewer 1024 byte pieces,
an unallocated fragment is located,
otherwise a 4096 byte block is located.
The contents of the previous fragment appended with the new data
is written into the allocated piece.
.PP
The problem with allowing only a single fragment
on a 4096/1024 byte file system
is that data may be potentially copied up to three times
as its requirements grow from a 1024 byte fragment to
a 2048 byte fragment, then a 3072 byte fragment,
and finally a 4096 byte block.
The fragment reallocation can be avoided
if the user program writes a full block at a time,
except for a partial block at the end of the file.
Because file systems with different block sizes may coexist on
the same system,
the file system interface been extended to provide the ability to
determine the optimal size for a read or write.
For files the optimal size is the block size of the file system
on which the file is being accessed.
For other objects, such as pipes and sockets,
the optimal size is the underlying buffer size.
This feature is used by the Standard
Input/Output Library,
a package used by most user programs.
This feature is also used by
certain system utilities such as archivers and loaders
that do their own input and output management
and need the highest possible file system bandwidth.
.PP
The space overhead in the 4096/1024 byte new file system
organization is empirically observed to be about the same as in the
1024 byte old file system organization.
A file system with 4096 byte blocks and 512 byte fragments
has about the same amount of space overhead as the 512 byte
block UNIX file system.
The new file system is more space efficient
than the 512 byte or 1024 byte file systems in that it uses the same
amount of space for small files
while requiring less indexing information for large files.
This savings is offset by the need to use more space for keeping track
of available free blocks.
The net result is about the same disk utilization
when the new file systems fragment size
equals the old file systems block size.
.PP
In order for the layout policies to be effective, the disk
cannot be kept completely full.
Each file system maintains a parameter that
gives the minimum acceptable percentage of file system
blocks that can be free.
If the the number of free blocks drops below this level
only the system administrator can continue to allocate blocks.
The value of this parameter can be changed at any time,
even when the file system is mounted and active.
The transfer rates to be given in section 4 were measured on file
systems kept less than 90% full.
If the reserve of free blocks is set to zero,
the file system throughput rate tends to be cut in half,
because of the inability of the file system to localize the blocks
in a file.
If the performance is impaired because of overfilling,
it may be restored by removing enough files to
obtain 10% free space.
Access speed for files created during periods of little
free space can be restored by recreating them once enough
space is available.
The amount of free space maintained must be added to the
percentage of waste when comparing the organizations given
in Table 1.
Thus, a site running the old 1024 byte UNIX file system
wastes 11.8% of the space and one
could expect to fit the same amount of data into
a 4096/512 byte new file system with 5% free space,
since a 512 byte old file system wasted 6.9% of the space.
.NH 2 
File system parameterization
.PP
Except for the initial creation of the free list,
the old file system ignores the parameters of the underlying hardware.
It has no information about either the physical characteristics
of the mass storage device,
or the hardware that interacts with it.
A goal of the new file system is to parameterize the 
processor capabilities and
mass storage characteristics
so that blocks can be allocated in an optimum configuration dependent way. 
Parameters used include the speed of the processor,
the hardware support for mass storage transfers,
and the characteristics of the mass storage devices.
Disk technology is constantly improving and
a given installation can have several different disk technologies
running on a single processor.
Each file system is parameterized so that it can adapt
to the characteristics of the disk on which it is placed.
.PP
For mass storage devices such as disks,
the new file system tries to allocate new blocks
on the same cylinder as the previous block in the same file. 
Optimally, these new blocks will also be 
well positioned rotationally.
The distance between ``rotationally optimal'' blocks varies greatly;
it can be a consecutive block
or a rotationally delayed block
depending on system characteristics.
On a processor with a channel that does not require
any processor intervention between mass storage transfer requests,
two consecutive disk blocks often can be accessed
without suffering lost time because of an intervening disk revolution.
For processors without such channels,
the main processor must field an interrupt and
prepare for a new disk transfer.
The expected time to service this interrupt and
schedule a new disk transfer depends on the
speed of the main processor.
.PP
The physical characteristics of each disk include
the number of blocks per track and the rate at which
the disk spins.
The allocation policy routines use this information to calculate
the number of milliseconds required to skip over a block.
The characteristics of the processor include
the expected time to schedule an interrupt.
Given the previous block allocated to a file,
the allocation routines calculate the number of blocks to
skip over so that the next block in a file will be
coming into position under the disk head in the expected
amount of time that it takes to start a new
disk transfer operation.
For programs that sequentially access large amounts of data,
this strategy minimizes the amount of time spent waiting for
the disk to position itself.
.PP
To ease the calculation of finding rotationally optimal blocks,
the cylinder group summary information includes
a count of the availability of blocks at different
rotational positions.
Eight rotational positions are distinguished,
so the resolution of the
summary information is 2 milliseconds for a typical 3600
revolution per minute drive.
.PP
The parameter that defines the
minimum number of milliseconds between the completion of a data
transfer and the initiation of
another data transfer on the same cylinder
can be changed at any time,
even when the file system is mounted and active.
If a file system is parameterized to lay out blocks with
rotational separation of 2 milliseconds,
and the disk pack is then moved to a system that has a
processor requiring 4 milliseconds to schedule a disk operation,
the throughput will drop precipitously because of lost disk revolutions
on nearly every block.
If the eventual target machine is known, 
the file system can be parameterized for it
even though it is initially created on a different processor.
Even if the move is not known in advance,
the rotational layout delay can be reconfigured after the disk is moved
so that all further allocation is done based on the
characteristics of the new host.
.NH 2
Layout policies
.PP
The file system policies are divided into two distinct parts.
At the top level are global policies that use file system
wide summary information to make decisions regarding
the placement of new inodes and data blocks.
These routines are responsible for deciding the
placement of new directories and files.
They also calculate rotationally optimal block layouts,
and decide when to force a long seek to a new cylinder group
because there are insufficient blocks left
in the current cylinder group to do reasonable layouts.
Below the global policy routines are
the local allocation routines that use a locally optimal scheme to
lay out data blocks.
.PP
Two methods for improving file system performance are to increase
the locality of reference to minimize seek latency 
as described by [Trivedi80], and
to improve the layout of data to make larger transfers possible
as described by [Nevalainen77].
The global layout policies try to improve performance
by clustering related information.
They cannot attempt to localize all data references,
but must also try to spread unrelated data
among different cylinder groups.
If too much localization is attempted,
the local cylinder group may run out of space
forcing the data to be scattered to non-local cylinder groups.
Taken to an extreme,
total localization can result in a single huge cluster of data
resembling the old file system.
The global policies try to balance the two conflicting
goals of localizing data that is concurrently accessed
while spreading out unrelated data.
.PP
One allocatable resource is inodes.
Inodes are used to describe both files and directories.
Files in a directory are frequently accessed together.
For example the ``list directory'' command often accesses 
the inode for each file in a directory.
The layout policy tries to place all the files in a directory
in the same cylinder group.
To ensure that files are allocated throughout the disk,
a different policy is used for directory allocation.
A new directory is placed in the cylinder group that has a greater
than average number of free inodes,
and the fewest number of directories in it already.
The intent of this policy is to allow the file clustering policy
to succeed most of the time.
The allocation of inodes within a cylinder group is done using a
next free strategy.
Although this allocates the inodes randomly within a cylinder group,
all the inodes for each cylinder group can be read with
4 to 8 disk transfers.
This puts a small and constant upper bound on the number of
disk transfers required to access all the inodes
for all the files in a directory
as compared to the old file system where typically,
one disk transfer is needed to get the inode for each file in a directory.
.PP
The other major resource is the data blocks.
Since data blocks for a file are typically accessed together,
the policy routines try to place all the data
blocks for a file in the same cylinder group,
preferably rotationally optimally on the same cylinder.
The problem with allocating all the data blocks
in the same cylinder group is that large files will
quickly use up available space in the cylinder group,
forcing a spill over to other areas.
Using up all the space in a cylinder group
has the added drawback that future allocations for
any file in the cylinder group
will also spill to other areas.
Ideally none of the cylinder groups should ever become completely full.
The solution devised is to redirect block allocation
to a newly chosen cylinder group
when a file exceeds 32 kilobytes,
and at every megabyte thereafter.
The newly chosen cylinder group is selected from those cylinder
groups that have a greater than average number of free blocks left.
Although big files tend to be spread out over the disk,
a megabyte of data is typically accessible before
a long seek must be performed,
and the cost of one long seek per megabyte is small.
.PP
The global policy routines call local allocation routines with 
requests for specific blocks.
The local allocation routines will always allocate the requested block 
if it is free.
If the requested block is not available, the allocator
allocates a free block of the requested size that is
rotationally closest to the requested block.
If the global layout policies had complete information,
they could always request unused blocks and
the allocation routines would be reduced to simple bookkeeping.
However, maintaining complete information is costly;
thus the implementation of the global layout policy 
uses heuristic guesses based on partial information.
.PP
If a requested block is not available the local allocator uses
a four level allocation strategy:
.IP 1)
Use the available block rotationally closest
to the requested block on the same cylinder.
.IP 2)
If there are no blocks available on the same cylinder,
use a block within the same cylinder group.
.IP 3)
If the cylinder group is entirely full, 
quadratically rehash among the cylinder groups
looking for a free block.
.IP 4)
Finally if the rehash fails, apply an exhaustive search.
.PP
The use of quadratic rehash is prompted by studies of
symbol table strategies used in programming languages.
File systems that are parameterized to maintain at least
10% free space almost never use this strategy;
file systems that are run without maintaining any free
space typically have so few free blocks that almost any
allocation is random.
Consequently the most important characteristic of
the strategy used when the file system is low on space
is that it be fast.
.ds RH Performance
.sp 2
.ds f. a2.4.t
.ds RH Performance
.NH 
Performance
.PP
Ultimately, the proof of the effectiveness of the
algorithms described in the previous section
is the long term performance of the new file system.
.PP
Our empiric studies have shown that the inode layout policy has
been effective.
When running the ``list directory'' command on a large directory
that itself contains many directories,
the number of disk accesses for inodes is cut by a factor of two.
The improvements are even more dramatic for large directories
containing only files,
disk accesses for inodes being cut by a factor of eight.
This is most encouraging for programs such as spooling daemons that
access many small files,
since these programs tend to flood the
disk request queue on the old file system.
.PP
Table 2 summarizes the measured throughput of the new file system.
Several comments need to be made about the conditions under which these
tests were run.
The test programs measure the rate that user programs can transfer
data to or from a file without performing any processing on it.
These programs must write enough data to insure that buffering in the
operating system does not affect the results.
They should also be run at least three times in succession;
the first to get the system into a known state
and the second two to insure that the 
experiment has stabilized and is repeatable.
The methodology and test results are
discussed in detail in [Kridle83]\(dg.
.FS
\(dg A UNIX command that is similar to the reading test that we used is,
``cp file /dev/null'', where ``file'' is eight Megabytes long.
.FE
The systems were running multi-user but were otherwise quiescent.
There was no contention for either the cpu or the disk arm.
The only difference between the UNIBUS and MASSBUS tests
was the controller.
All tests used an Ampex Capricorn 330 Megabyte Winchester disk.
As Table 2 shows, all file system test runs were on a VAX 11/750.
All file systems had been in production use for at least
a month before being measured.
.KF
.DS B
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4m 4n 4o 4p 4q
.nr 4m 0
.nr 3i \wType of
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wFile System
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wold 1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 4096/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 8192/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 4096/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 8192/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.4m
.rm 4m
.nr 4n 0
.nr 3i \wProcessor and
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \wBus Measured
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/MASSBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/MASSBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.4n
.rm 4n
.nr 4o 0
.nr 3i \wSpeed
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w29 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w221 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w233 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w466 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w466 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.4o
.rm 4o
.nr 4p 0
.nr 3i \wBandwidth
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w29/1100 3%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w221/1100 20%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w233/1100 21%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w466/1200 39%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w466/1200 39%
.if \n(4p<\n(3i .nr 4p \n(3i
.4p
.rm 4p
.nr 4q 0
.nr 3i \w% CPU
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w11%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w43%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w29%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w73%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w54%
.if \n(4q<\n(3i .nr 4q \n(3i
.4q
.rm 4q
.nr 3i \wRead-\n(4o-3n-\n(4p-3n-\n(4q
.if \n(3i>0 .nr 3i \n(3i/2
.if \n(3i<0 .nr 3i 0
.nr 4p +\n(3i
.nr 4q +\n(3i
.nr 3i 1n
.nr 4l 0
.nr 4a \n(4l+((2*\n(3i)/2)
.nr 4m +\n(4a
.nr 4b \n(4m+((6*\n(3i)/2)
.nr 4n +\n(4b
.nr 4c \n(4n+((6*\n(3i)/2)
.nr 4o +\n(4c
.nr 4d \n(4o+((6*\n(3i)/2)
.nr 4p +\n(4d
.nr 4e \n(4p+((6*\n(3i)/2)
.nr 4q +\n(4e
.nr TW \n(4q
.nr TW +((2*\n(3i)/2)
.if t .if \n(TW>\n(.lu .tm Table at line 60 file a2.4.t is too wide - \n(TW units
.ne 7v+2p
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'(|\n(4cu+|\n(4nu)/2u'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.mk #a
.ta \n(4mu \n(4nu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Type of\h'|\n(4bu'Processor and\h'|\n(4cu'Read
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'File System\h'|\n(4bu'Bus Measured\h'|\n(4cu'Speed\h'|\n(4du'Bandwidth\h'|\n(4eu'% CPU
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'old 1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'29 Kbytes/sec\h'|\n(4du'29/1100 3%\h'|\n(4eu'11%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 4096/1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'221 Kbytes/sec\h'|\n(4du'221/1100 20%\h'|\n(4eu'43%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 8192/1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'233 Kbytes/sec\h'|\n(4du'233/1100 21%\h'|\n(4eu'29%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 4096/1024\h'|\n(4bu'750/MASSBUS\h'|\n(4cu'466 Kbytes/sec\h'|\n(4du'466/1200 39%\h'|\n(4eu'73%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 8192/1024\h'|\n(4bu'750/MASSBUS\h'|\n(4cu'466 Kbytes/sec\h'|\n(4du'466/1200 39%\h'|\n(4eu'54%
.fc
.nr T. 1
.T# 1
.3f
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-12
.ce 1
Table 2a \- Reading rates of the old and new UNIX file systems.
.TS
.if \n+(b.=1 .nr d. \n(.c-\n(c.-1
.de 3f
.ps \n(.s
.vs \n(.vu
.in \n(.iu
.if \n(.u .fi
.if \n(.j .ad
.if \n(.j=0 .na
..
.nf
.nr #~ 0
.if \n(.T .if n .nr #~ 0.6n
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.fc
.nr 3d \n(.s
.rm 4m 4n 4o 4p 4q
.nr 4m 0
.nr 3i \wType of
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wFile System
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wold 1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 4096/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 8192/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 4096/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.nr 3i \wnew 8192/1024
.if \n(4m<\n(3i .nr 4m \n(3i
.4m
.rm 4m
.nr 4n 0
.nr 3i \wProcessor and
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \wBus Measured
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/UNIBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/MASSBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.nr 3i \w750/MASSBUS
.if \n(4n<\n(3i .nr 4n \n(3i
.4n
.rm 4n
.nr 4o 0
.nr 3i \wSpeed
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w48 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w142 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w215 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w323 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.nr 3i \w466 Kbytes/sec
.if \n(4o<\n(3i .nr 4o \n(3i
.4o
.rm 4o
.nr 4p 0
.nr 3i \wBandwidth
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w48/1100 4%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w142/1100 13%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w215/1100 19%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w323/1200 27%
.if \n(4p<\n(3i .nr 4p \n(3i
.nr 3i \w466/1200 39%
.if \n(4p<\n(3i .nr 4p \n(3i
.4p
.rm 4p
.nr 4q 0
.nr 3i \w% CPU
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w29%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w43%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w46%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w94%
.if \n(4q<\n(3i .nr 4q \n(3i
.nr 3i \w95%
.if \n(4q<\n(3i .nr 4q \n(3i
.4q
.rm 4q
.nr 3i \wWrite-\n(4o-3n-\n(4p-3n-\n(4q
.if \n(3i>0 .nr 3i \n(3i/2
.if \n(3i<0 .nr 3i 0
.nr 4p +\n(3i
.nr 4q +\n(3i
.nr 3i 1n
.nr 4l 0
.nr 4a \n(4l+((2*\n(3i)/2)
.nr 4m +\n(4a
.nr 4b \n(4m+((6*\n(3i)/2)
.nr 4n +\n(4b
.nr 4c \n(4n+((6*\n(3i)/2)
.nr 4o +\n(4c
.nr 4d \n(4o+((6*\n(3i)/2)
.nr 4p +\n(4d
.nr 4e \n(4p+((6*\n(3i)/2)
.nr 4q +\n(4e
.nr TW \n(4q
.nr TW +((2*\n(3i)/2)
.if t .if \n(TW>\n(.lu .tm Table at line 75 file a2.4.t is too wide - \n(TW units
.ne 7v+2p
.fc  
.nr #T 0-1
.nr #a 0-1
.nr #a 0-1
.eo
.de T#
.nr 3f 1m
.ds #d .d
.if \(ts\n(.z\(ts\(ts .ds #d nl
.mk ##
.nr ## -1v
.ls 1
.if \n(#T>=0 .nr #a \n(#T
.if \n(T. .vs \n(.vu-\n(.sp
.if \n(T. \h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.if \n(T. .vs
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|0'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'(|\n(4cu+|\n(4nu)/2u'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'\h'|\n(TWu'
.if \n(#a>=0 .sp -1
.if \n(#a>=0 \h'|\n(TWu'\s\n(3d\h'-\n(#~u'\L'|\n(#au-1v'\s0\v'\n(\*(#du-\n(#au+1v'
.ls
..
.ec
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.mk #a
.ta \n(4mu \n(4nu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'Type of\h'|\n(4bu'Processor and\h'|\n(4cu'Write
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'File System\h'|\n(4bu'Bus Measured\h'|\n(4cu'Speed\h'|\n(4du'Bandwidth\h'|\n(4eu'% CPU
.nr 3g \n(.v
.vs \n(.vu-\n(.sp
\h'|0'\s\n(3d\l'|\n(TWu\(ul'\s0
.vs \n(3gu
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'old 1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'48 Kbytes/sec\h'|\n(4du'48/1100 4%\h'|\n(4eu'29%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 4096/1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'142 Kbytes/sec\h'|\n(4du'142/1100 13%\h'|\n(4eu'43%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 8192/1024\h'|\n(4bu'750/UNIBUS\h'|\n(4cu'215 Kbytes/sec\h'|\n(4du'215/1100 19%\h'|\n(4eu'46%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 4096/1024\h'|\n(4bu'750/MASSBUS\h'|\n(4cu'323 Kbytes/sec\h'|\n(4du'323/1200 27%\h'|\n(4eu'94%
.ta \n(4mu \n(4nu \n(4ou \n(4pu \n(4qu 
.nr 3f 1m
.nr 3b \n(.f
\&\h'|\n(4au'new 8192/1024\h'|\n(4bu'750/MASSBUS\h'|\n(4cu'466 Kbytes/sec\h'|\n(4du'466/1200 39%\h'|\n(4eu'95%
.fc
.nr T. 1
.T# 1
.3f
.nr #a 0
.TE
.if \n-(b.=0 .nr c. \n(.c-\n(d.-12
.ce 1
Table 2b \- Writing rates of the old and new UNIX file systems.
.DE
.KE
.PP
Unlike the old file system,
the transfer rates for the new file system do not
appear to change over time.
The throughput rate is tied much more strongly to the
amount of free space that is maintained.
The measurements in Table 2 were based on a file system run
with 10% free space.
Synthetic work loads suggest the performance deteriorates
to about half the throughput rates given in Table 2 when no
free space is maintained.
.PP
The percentage of bandwidth given in Table 2 is a measure
of the effective utilization of the disk by the file system.
An upper bound on the transfer rate from the disk is measured
by doing 65536* byte reads from contiguous tracks on the disk.
.FS
* This number, 65536, is the maximal I/O size supported by the
VAX hardware; it is a remnant of the system's PDP-11 ancestry.
.FE
The bandwidth is calculated by comparing the data rates
the file system is able to achieve as a percentage of this rate.
Using this metric, the old file system is only
able to use about 3-4% of the disk bandwidth,
while the new file system uses up to 39%
of the bandwidth.
.PP
In the new file system, the reading rate is always at least
as fast as the writing rate.
This is to be expected since the kernel must do more work when
allocating blocks than when simply reading them.
Note that the write rates are about the same 
as the read rates in the 8192 byte block file system;
the write rates are slower than the read rates in the 4096 byte block
file system.
The slower write rates occur because
the kernel has to do twice as many disk allocations per second,
and the processor is unable to keep up with the disk transfer rate.
.PP
In contrast the old file system is about 50%
faster at writing files than reading them.
This is because the \fIwrite\fR system call is asynchronous and
the kernel can generate disk transfer
requests much faster than they can be serviced,
hence disk transfers build up in the disk buffer cache.
Because the disk buffer cache is sorted by minimum seek order,
the average seek between the scheduled disk writes is much
less than they would be if the data blocks are written out
in the order in which they are generated.
However when the file is read,
the \fIread\fR system call is processed synchronously so
the disk blocks must be retrieved from the disk in the
order in which they are allocated.
This forces the disk scheduler to do long
seeks resulting in a lower throughput rate.
.PP
The performance of the new file system is currently
limited by a memory to memory copy operation
because it transfers data from the disk into buffers
in the kernel address space and then spends 40% of the processor
cycles copying these buffers to user address space.
If the buffers in both address spaces are properly aligned, 
this transfer can be affected without copying by
using the VAX virtual memory management hardware.
This is especially desirable when large amounts of data
are to be transferred.
We did not implement this because it would change the semantics
of the file system in two major ways;
user programs would be required to allocate buffers on page boundaries, 
and data would disappear from buffers after being written.
.PP
Greater disk throughput could be achieved by rewriting the disk drivers
to chain together kernel buffers.
This would allow files to be allocated to
contiguous disk blocks that could be read
in a single disk transaction.
Most disks contain either 32 or 48 512 byte sectors per track.
The inability to use contiguous disk blocks effectively limits the performance
on these disks to less than fifty percent of the available bandwidth.
Since each track has a multiple of sixteen sectors
it holds exactly two or three 8192 byte file system blocks,
or four or six 4096 byte file system blocks.
If the the next block for a file cannot be laid out contiguously,
then the minimum spacing to the next allocatable
block on any platter is between a sixth and a half a revolution.
The implication of this is that the best possible layout without
contiguous blocks uses only half of the bandwidth of any given track.
If each track contains an odd number of sectors, 
then it is possible to resolve the rotational delay to any number of sectors
by finding a block that begins at the desired 
rotational position on another track.
The reason that block chaining has not been implemented is because it
would require rewriting all the disk drivers in the system,
and the current throughput rates are already limited by the
speed of the available processors.
.PP
Currently only one block is allocated to a file at a time.
A technique used by the DEMOS file system
when it finds that a file is growing rapidly,
is to preallocate several blocks at once,
releasing them when the file is closed if they remain unused.
By batching up the allocation the system can reduce the
overhead of allocating at each write,
and it can cut down on the number of disk writes needed to
keep the block pointers on the disk
synchronized with the block allocation [Powell79].
.ds RH Functional enhancements
.sp 2
.ds f. a2.5.t
.ds RH Functional enhancements
.NH 
File system functional enhancements
.PP
The speed enhancements to the UNIX file system did not require
any changes to the semantics or data structures viewed by the
users.
However several changes have been generally desired for some 
time but have not been introduced because they would require users to 
dump and restore all their file systems.
Since the new file system already
requires that all existing file systems
be dumped and restored, 
these functional enhancements have been introduced at this time.
.NH 2
Long file names
.PP
File names can now be of nearly arbitrary length.
The only user programs affected by this change are
those that access directories.
To maintain portability among UNIX systems that
are not running the new file system, a set of directory
access routines have been introduced that provide a uniform
interface to directories on both old and new systems.
.PP
Directories are allocated in units of 512 bytes.
This size is chosen so that each allocation can be transferred
to disk in a single atomic operation.
Each allocation unit contains variable-length directory entries.
Each entry is wholly contained in a single allocation unit.
The first three fields of a directory entry are fixed and contain
an inode number, the length of the entry, and the length
of the name contained in the entry.
Following this fixed size information is the null terminated name,
padded to a 4 byte boundary.
The maximum length of a name in a directory is currently 255 characters.
.PP
Free space in a directory is held by
entries that have a record length that exceeds the space
required by the directory entry itself.
All the bytes in a directory unit are claimed by the directory entries.
This normally results in the last entry in a directory being large.
When entries are deleted from a directory,
the space is returned to the previous entry in the same directory
unit by increasing its length.
If the first entry of a directory unit is free, then its 
inode number is set to zero to show that it is unallocated.
.NH 2
File locking
.PP
The old file system had no provision for locking files.
Processes that needed to synchronize the updates of a
file had to create a separate ``lock'' file to synchronize
their updates.
A process would try to create a ``lock'' file. 
If the creation succeeded, then it could proceed with its update;
if the creation failed, then it would wait, and try again.
This mechanism had three drawbacks.
Processes consumed CPU time, by looping over attempts to create locks.
Locks were left lying around following system crashes and had
to be cleaned up by hand.
Finally, processes running as system administrator
are always permitted to create files,
so they had to use a different mechanism.
While it is possible to get around all these problems,
the solutions are not straight-forward,
so a mechanism for locking files has been added.
.PP
The most general schemes allow processes to concurrently update a file.
Several of these techniques are discussed in [Peterson83].
A simpler technique is to simply serialize access with locks.
To attain reasonable efficiency,
certain applications require the ability to lock pieces of a file.
Locking down to the byte level has been implemented in the
Onyx file system by [Bass81].
However, for the applications that currently run on the system,
a mechanism that locks at the granularity of a file is sufficient.
.PP
Locking schemes fall into two classes,
those using hard locks and those using advisory locks.
The primary difference between advisory locks and hard locks is the
decision of when to override them. 
A hard lock is always enforced whenever a program tries to
access a file;
an advisory lock is only applied when it is requested by a program.
Thus advisory locks are only effective when all programs accessing
a file use the locking scheme.
With hard locks there must be some override policy implemented in the kernel,
with advisory locks the policy is implemented by the user programs.
In the UNIX system, programs with system administrator
privilege can override any protection scheme.
Because many of the programs that need to use locks run as
system administrators,
we chose to implement advisory locks rather than 
create a protection scheme that was contrary to the UNIX 
philosophy or could not be used by system administration
programs.
.PP
The file locking facilities allow cooperating programs to apply
advisory
.I shared
or
.I exclusive
locks on files.
Only one process has an exclusive
lock on a file while multiple shared locks may be present.
Both shared and exclusive locks cannot be present on
a file at the same time.
If any lock is requested when
another process holds an exclusive lock,
or an exclusive lock is requested when another process holds any lock,
the open will block until the lock can be gained.
Because shared and exclusive locks are advisory only,
even if a process has obtained a lock on a file,
another process can override the lock by
opening the same file without a lock.
.PP
Locks can be applied or removed on open files,
so that locks can be manipulated without
needing to close and reopen the file.
This is useful, for example, when a process wishes
to open a file with a shared lock to read some information,
to determine whether an update is required.
It can then get an exclusive lock so that it can do a read,
modify, and write to update the file in a consistent manner.
.PP
A request for a lock will cause the process to block if the lock
can not be immediately obtained.
In certain instances this is unsatisfactory.
For example, a process that
wants only to check if a lock is present would require a separate
mechanism to find out this information.
Consequently, a process may specify that its locking
request should return with an error if a lock can not be immediately
obtained.
Being able to poll for a lock is useful to ``daemon'' processes
that wish to service a spooling area.
If the first instance of the
daemon locks the directory where spooling takes place,
later daemon processes can
easily check to see if an active daemon exists.
Since the lock is removed when the process exits or the system crashes,
there is no problem with unintentional locks files
that must be cleared by hand.
.PP
Almost no deadlock detection is attempted.
The only deadlock detection made by the system is that the file
descriptor to which a lock is applied does not currently have a
lock of the same type (i.e. the second of two successive calls
to apply a lock of the same type will fail).
Thus a  process can deadlock itself by
requesting locks on two separate file descriptors for the same
object.
.NH 2
Symbolic links
.PP
The 512 byte UNIX file system allows multiple
directory entries in the same file system
to reference a single file.
The link concept is fundamental;
files do not live in directories, but exist separately and
are referenced by links.
When all the links are removed,
the file is deallocated.
This style of links does not allow references across physical file
systems, nor does it support inter-machine linkage. 
To avoid these limitations
.I "symbolic links"
have been added similar to the scheme used by Multics [Feiertag71].
.PP
A symbolic link is implemented as a file that contains a pathname.
When the system encounters a symbolic link while
interpreting a component of a pathname,
the contents of the symbolic link is prepended to the rest
of the pathname, and this name is interpreted to yield the
resulting pathname.
If the symbolic link contains an absolute pathname,
the absolute pathname is used,
otherwise the contents of the symbolic link is evaluated
relative to the location of the link in the file hierarchy.
.PP
Normally programs do not want to be aware that there is a
symbolic link in a pathname that they are using.
However certain system utilities
must be able to detect and manipulate symbolic links.
Three new system calls provide the ability to detect, read, and write
symbolic links, and seven system utilities were modified to use these calls.
.PP
In future Berkeley software distributions 
it will be possible to mount file systems from other
machines within a local file system.
When this occurs,
it will be possible to create symbolic links that span machines.
.NH 2
Rename
.PP
Programs that create new versions of data files typically create the
new version as a temporary file and then rename the temporary file
with the original name of the data file.
In the old UNIX file systems the renaming required three calls to the system.
If the program were interrupted or the system crashed between
these calls,
the data file could be left with only its temporary name.
To eliminate this possibility a single system call
has been added that performs the rename in an
atomic fashion to guarantee the existence of the original name.
.PP
In addition, the rename facility allows directories to be moved around
in the directory tree hierarchy.
The rename system call performs special validation checks to insure
that the directory tree structure is not corrupted by the creation
of loops or inaccessible directories.
Such corruption would occur if a parent directory were moved
into one of its descendants.
The validation check requires tracing the ancestry of the target
directory to insure that it does not include the directory being moved.
.NH 2
Quotas
.PP
The UNIX system has traditionally attempted to share all available
resources to the greatest extent possible.
Thus any single user can allocate all the available space
in the file system.
In certain environments this is unacceptable.
Consequently, a quota mechanism has been added for restricting the
amount of file system resources that a user can obtain.
The quota mechanism sets limits on both the number of files
and the number of disk blocks that a user may allocate.
A separate quota can be set for each user on each file system.
Each resource is given both a hard and a soft limit.
When a program exceeds a soft limit,
a warning is printed on the users terminal;
the offending program is not terminated
unless it exceeds its hard limit.
The idea is that users should stay below their soft limit between
login sessions,
but they may use more space while they are actively working.
To encourage this behavior,
users are warned when logging in if they are over
any of their soft limits.
If they fail to correct the problem for too many login sessions,
they are eventually reprimanded by having their soft limit
enforced as their hard limit.
.ds LH "Final Report Appendix C
.ds RH Introduction
.bp
.ds f. a3.1.t
.SH
\s+2Appendix C \- Networking Implementation\s0
.PP
.nr H1 0
.NH
\s+2Introduction\s0
.PP
This report describes the internal structure of
facilities added to the
4.2BSD version of the UNIX operating system for
the VAX.  The system facilities provide
a uniform user interface to networking
within UNIX.  In addition, the implementation 
introduces a structure for network communications which may be
used by system implementors in adding new networking
facilities.  The internal structure is not visible
to the user, rather it is intended to aid implementors
of communication protocols and network services by
providing a framework which
promotes code sharing and minimizes implementation effort.
.PP
The reader is expected to be familiar with the C programming
language and system interface, as described in the body of this report.
Basic understanding of network communication concepts is assumed;
where required any additional ideas are introduced.
.PP
The remainder of this document
provides a description of the system internals,
avoiding, when possible, those portions which are utilized only
by the interprocess communication facilities.
.ds RH Overview
.sp 2
.ds f. a3.2.t
.nr H2 1
.ds RH Overview
.NH
\s+2Overview\s0
.PP
If we consider
the International Standards Organization's (ISO)
Open System Interconnection (OSI) model of
network communication [ISO81] [Zimmermann80],
the networking facilities
described here correspond to a portion of the
session layer (layer 3) and all of the transport and
network layers (layers 2 and 1, respectively).
.PP
The network layer provides possibly imperfect
data transport services with minimal addressing
structure.
Addressing at this level is normally host to host,
with implicit or explicit routing optionally supported
by the communicating agents. 
.PP
At the transport
layer the notions of reliable transfer, data sequencing,
flow control, and service addressing are normally
included.  Reliability is usually managed by 
explicit acknowledgement of data delivered.  Failure
to acknowledge a transfer results in retransmission of
the data.  Sequencing may be handled by tagging
each message handed to the network layer by a
\fIsequence number\fP and maintaining
state at the endpoints of communication to utilize
received sequence numbers in reordering data which
arrives out of order.
.PP
The session layer facilities may provide forms of
addressing which are mapped into formats required
by the transport layer, service authentication
and client authentication, etc.  Various systems
also provide services such as data encryption and
address and protocol translation.
.PP
The following sections begin by describing some of the common
data structures and utility routines, then examine
the internal layering.  The contents of each layer
and its interface are considered.  Certain of the
interfaces are protocol implementation specific.  For
these cases examples have been drawn from the Internet [Cerf78]
protocol family.  Later sections cover routing issues,
the design of the raw socket interface and other
miscellaneous topics.
.ds RH Goals
.sp 2
.ds f. a3.3.t
.nr H2 1
.ds RH Goals
.NH
\s+2Goals\s0
.PP
The networking system was designed with the goal of supporting
multiple \fIprotocol families\fP and addressing styles.  This required
information to be ``hidden'' in common data structures which
could be manipulated by all the pieces of the system, but which
required interpretation only by the protocols which ``controlled''
it.  The system described here attempts to minimize
the use of shared data structures to those kept by a suite of
protocols (a \fIprotocol family\fP), and those used for rendezvous
between ``synchronous'' and ``asynchronous'' portions of the
system (e.g. queues of data packets are filled at interrupt
time and emptied based on user requests).
.PP
A major goal of the system was to provide a framework within
which new protocols and hardware could be easily be supported.
To this end, a great deal of effort has been extended to
create utility routines which hide many of the more
complex and/or hardware dependent chores of networking.
Later sections describe the utility routines and the underlying
data structures they manipulate.
.ds RH "Address representation
.sp 2
.ds f. a3.4.t
.nr H2 1
.ds RH "Address representation
.NH
\s+2Internal address representation\s0
.PP
Common to all portions of the system are two data structures.
These structures are used to represent
addresses and various data objects.
Addresses, internally are described by the \fIsockaddr\fP structure,
.DS
._f
struct sockaddr {
	short	sa_family;	/* data format identifier */
	char	sa_data[14];	/* address */
};
.DE
All addresses belong to one or more \fIaddress families\fP
which define their format and interpretation.
The \fIsa_family\fP field indicates which address family the address
belongs to, the \fIsa_data\fP field contains the actual data value.
The size of the data field, 14 bytes, was selected based on a study
of current address formats*.
.FS
* Later versions of the system support variable length addresses.
.FE
.ds RH "Memory management
.sp 2
.ds f. a3.5.t
.nr H2 1
.ds RH "Memory management
.NH
\s+2Memory management\s0
.PP
A single mechanism is used for data storage: memory buffers, or
\fImbuf\fP's.  An mbuf is a structure of the form:
.DS
._f
struct mbuf {
	struct	mbuf *m_next;		/* next buffer in chain */
	u_long	m_off;			/* offset of data */
	short	m_len;			/* amount of data in this mbuf */
	short	m_type;			/* mbuf type (accounting) */
	u_char	m_dat[MLEN];		/* data storage */
	struct	mbuf *m_act;		/* link in higher-level mbuf list */
};
.DE
The \fIm_next\fP field is used to chain mbufs together on linked
lists, while the \fIm_act\fP field allows lists of mbufs to be
accumulated.  By convention, the mbufs common to a single object
(for example, a packet) are chained together with the \fIm_next\fP
field, while groups of objects are linked via the \fIm_act\fP
field (possibly when in a queue).
.PP
Each mbuf has a small data area for storing information, \fIm_dat\fP.
The \fIm_len\fP field indicates the amount of data, while the \fIm_off\fP
field is an offset to the beginning of the data from the base of the
mbuf.  Thus, for example, the macro \fImtod\fP, which converts a pointer
to an mbuf to a pointer to the data stored in the mbuf, has the form
.DS
._d
#define	mtod(x,t)	((t)((int)(x) + (x)->m_off))
.DE
(note the \fIt\fP parameter, a C type cast, is used to cast
the resultant pointer for proper assignment).
.PP
In addition to storing data directly in the mbuf's data area, data
of page size may be also be stored in a separate area of memory.
The mbuf utility routines maintain
a pool of pages for this purpose and manipulate a private page map
for such pages.  The virtual addresses of
these data pages precede those of mbufs, so when pages of data are
separated from an mbuf, the mbuf data offset is a negative value.
An array of reference counts on pages is also maintained
so that copies of pages may be made without core to core
copying  (copies are created simply by duplicating the relevant
page table entries in the data page map and incrementing the associated
reference counts for the pages).  Separate data pages are currently
used only
when copying data from a user process into the kernel,
and when bringing data in at the hardware level.  Routines which
manipulate mbufs are not normally aware if data is stored directly in 
the mbuf data array, or if it is kept in separate pages.
.PP
The following utility routines are available for manipulating mbuf
chains:
.IP "m = m_copy(m0, off, len);"
.br
The \fIm_copy\fP routine create a copy of all, or part, of a
list of the mbufs in \fIm0\fP.  \fILen\fP bytes of data, starting 
\fIoff\fP bytes from the front of the chain, are copied. 
Where possible, reference counts on pages are used instead
of core to core copies.  The original mbuf chain must have at
least \fIoff\fP + \fIlen\fP bytes of data.  If \fIlen\fP is
specified as M_COPYALL, all the data present, offset
as before, is copied.  
.IP "m_cat(m, n);"
.br
The mbuf chain, \fIn\fP, is appended to the end of \fIm\fP.
Where possible, compaction is performed.
.IP "m_adj(m, diff);"
.br
The mbuf chain, \fIm\fP is adjusted in size by \fIdiff\fP
bytes.  If \fIdiff\fP is non-negative, \fIdiff\fP bytes
are shaved off the front of the mbuf chain.  If \fIdiff\fP
is negative, the alteration is performed from back to front.
No space is reclaimed in this operation, alterations are
accomplished by changing the \fIm_len\fP and \fIm_off\fP
fields of mbufs.
.IP "m = m_pullup(m0, size);"
.br
After a successful call to \fIm_pullup\fP, the mbuf at
the head of the returned list, \fIm\fP, is guaranteed
to have at least \fIsize\fP
bytes of data in contiguous memory (allowing access via
a pointer, obtained using the \fImtod\fP macro).
If the original data was less than \fIsize\fP bytes long,
\fIlen\fP was greater than the size of an mbuf data
area (112 bytes), or required resources were unavailable,
\fIm\fP is 0 and the original mbuf chain is deallocated.
.IP
This routine is particularly useful when verifying packet
header lengths on reception.  For example, if a packet is
received and only 8 of the necessary 16 bytes required
for a valid packet header are present at the head of the list
of mbufs representing the packet, the remaining 8 bytes
may be ``pulled up'' with a single \fIm_pullup\fP call.
If the call fails the invalid packet will have been discarded.
.PP
By insuring mbufs always reside on 128 byte boundaries
it is possible to always locate the mbuf associated with a data
area by masking off the low bits of the virtual address.
This allows modules to store data structures in mbufs and
pass them around without concern for locating the original
mbuf when it comes time to free the structure.
The \fIdtom\fP macro is used to convert a pointer into an mbuf's
data area to a pointer to the mbuf,
.DS
#define	dtom(x)	((struct mbuf *)((int)x & ~(MSIZE-1)))
.DE
.PP
Mbufs are used for dynamically allocated data structures such as
sockets, as well as memory allocated for packets.  Statistics are
maintained on mbuf usage and can be viewed by users using the
\fInetstat\fP(1) program.
.ds RH "Internal layering
.sp 2
.ds f. a3.6.t
.nr H2 1
.ds RH "Internal layering
.NH
\s+2Internal layering\s0
.PP
The internal structure of the network system is divided into
three layers.  These
layers correspond to the services provided by the socket
abstraction, those provided by the communication protocols,
and those provided by the hardware interfaces.  The communication
protocols are normally layered into two or more individual
cooperating layers, though they are collectively viewed
in the system as one layer providing services supportive
of the appropriate socket abstraction.
.PP
The following sections describe the properties of each layer
in the system and the interfaces each must conform to.
.NH 2
Socket layer
.PP
The socket layer deals with the interprocess communications
facilities provided by the system.  A socket is a bidirectional
endpoint of communication which is ``typed'' by the semantics
of communication it supports.  The system calls described in
the \fI4.2BSD System Manual\fP are used to manipulate sockets.
.PP
A socket consists of the following data structure:
.DS
._f
struct socket {
	short	so_type;		/* generic type */
	short	so_options;		/* from socket call */
	short	so_linger;		/* time to linger while closing */
	short	so_state;		/* internal state flags */
	caddr_t	so_pcb;			/* protocol control block */
	struct	protosw *so_proto;	/* protocol handle */
	struct	socket *so_head;	/* back pointer to accept socket */
	struct	socket *so_q0;		/* queue of partial connections */
	short	so_q0len;		/* partials on so_q0 */
	struct	socket *so_q;		/* queue of incoming connections */
	short	so_qlen;		/* number of connections on so_q */
	short	so_qlimit;		/* max number queued connections */
	struct	sockbuf so_snd;		/* send queue */
	struct	sockbuf so_rcv;		/* receive queue */
	short	so_timeo;		/* connection timeout */
	u_short	so_error;		/* error affecting connection */
	short	so_oobmark;		/* chars to oob mark */
	short	so_pgrp;		/* pgrp for signals */
};
.DE
.PP
Each socket contains two data queues, \fIso_rcv\fP and \fIso_snd\fP,
and a pointer to routines which provide supporting services. 
The type of the socket,
\fIso_type\fP is defined at socket creation time and used in selecting
those services which are appropriate to support it.  The supporting
protocol is selected at socket creation time and recorded in
the socket data structure for later use.  Protocols are defined
by a table of procedures, the \fIprotosw\fP structure, which will
be described in detail later.  A pointer to a protocol specific
data structure,
the ``protocol control block'' is also present in the socket structure.
Protocols control this data structure and it normally includes a
back pointer to the parent socket structure(s) to allow easy
lookup when returning information to a user 
(for example, placing an error number in the \fIso_error\fP
field).  The other entries in the socket structure are used in
queueing connection requests, validating user requests, storing
socket characteristics (e.g.
options supplied at the time a socket is created), and maintaining
a socket's state.
.PP
Processes ``rendezvous at a socket'' in many instances.  For instance,
when a process wishes to extract data from a socket's receive queue
and it is empty, or lacks sufficient data to satisfy the request,
the process blocks, supplying the address of the receive queue as
an ``wait channel' to be used in notification.  When data arrives
for the process and is placed in the socket's queue, the blocked
process is identified by the fact it is waiting ``on the queue''.
.NH 3
Socket state
.PP
A socket's state is defined from the following:
.DS
.if t .ta .6i 2.3i 3.0i
.if n .ta .84i 2.5i 3.20i
#define	SS_NOFDREF	0x001	/* no file table ref any more */
#define	SS_ISCONNECTED	0x002	/* socket connected to a peer */
#define	SS_ISCONNECTING	0x004	/* in process of connecting to peer */
#define	SS_ISDISCONNECTING	0x008	/* in process of disconnecting */
#define	SS_CANTSENDMORE	0x010	/* can't send more data to peer */
#define	SS_CANTRCVMORE	0x020	/* can't receive more data from peer */
#define	SS_CONNAWAITING	0x040	/* connections awaiting acceptance */
#define	SS_RCVATMARK	0x080	/* at mark on input */

#define	SS_PRIV	0x100	/* privileged */
#define	SS_NBIO	0x200	/* non-blocking ops */
#define	SS_ASYNC	0x400	/* async i/o notify */
.DE
.PP
The state of a socket is manipulated both by the protocols
and the user (through system calls).
When a socket is created the state is defined based on the type of
input/output the user wishes to perform.  ``Non-blocking'' I/O  implies
a process should never be blocked to await resources.  Instead, any
call which would block returns prematurely
with the error EWOULDBLOCK (the service request may be partially
fulfilled, e.g. a request for more data than is present).
.PP
If a process requested ``asynchronous'' notification of events
related to the socket the SIGIO signal is posted to the process.
An event is a change in the socket's state,
examples of such occurances are: space
becoming available in the send queue, new data available in the
receive queue, connection establishment or disestablishment, etc. 
.PP
A socket may be marked ``priviledged'' if it was created by the
super-user.  Only priviledged sockets may
send broadcast packets, or bind
addresses in priviledged portions of an address space.
.NH 3
Socket data queues
.PP
A socket's data queue contains a pointer to the data stored in
the queue and other entries related to the management of
the data.  The following structure defines a data queue:
.DS
._f
struct sockbuf {
	short	sb_cc;		/* actual chars in buffer */
	short	sb_hiwat;	/* max actual char count */
	short	sb_mbcnt;	/* chars of mbufs used */
	short	sb_mbmax;	/* max chars of mbufs to use */
	short	sb_lowat;	/* low water mark */
	short	sb_timeo;	/* timeout */
	struct	mbuf *sb_mb;	/* the mbuf chain */
	struct	proc *sb_sel;	/* process selecting read/write */
	short	sb_flags;	/* flags, see below */
};
.DE
.PP
Data is stored in a queue as a chain of mbufs.  The actual
count of characters as well as high and low water marks are
used by the protocols in controlling the flow of data.
The socket routines cooperate in implementing the flow control
policy by blocking a process when it requests to send data and
the high water mark has been reached, or when it requests to
receive data and less than the low water mark is present
(assuming non-blocking I/O has not been specified).
.PP
When a socket is created, the supporting protocol ``reserves'' space
for the send and receive queues of the socket.
The actual storage associated with a
socket queue may fluctuate during a socket's lifetime, but is assumed
this reservation will always allow a protocol to acquire enough memory
to satisfy the high water marks.
.PP
The timeout and select values are manipulated by the socket routines
in implementing various portions of the interprocess communications
facilities and will not be described here.
.PP
A socket queue has a number of flags used in synchronizing access
to the data and in acquiring resources;
.DS
._d
#define	SB_LOCK	0x01	/* lock on data queue (so_rcv only) */
#define	SB_WANT	0x02	/* someone is waiting to lock */
#define	SB_WAIT	0x04	/* someone is waiting for data/space */
#define	SB_SEL	0x08	/* buffer is selected */
#define	SB_COLL	0x10	/* collision selecting */
.DE
The last two flags are manipulated by the system in implementing
the select mechanism.
.NH 3
Socket connection queueing
.PP
In dealing with connection oriented sockets (e.g. SOCK_STREAM)
the two sides are considered distinct.  One side is termed
\fIactive\fP, and generates connection requests.  The other
side is called \fIpassive\fP and accepts connection requests.
.PP
From the passive side, a socket is created with the option
SO_ACCEPTCONN specified, 
creating two queues of sockets: \fIso_q0\fP for connections
in progress and \fIso_q\fP for connections already made and
awaiting user acceptance.
As a protocol is preparing incoming connections, it creates
a socket structure queued on \fIso_q0\fP by calling the routine
\fIsonewconn\fP().  When the connection
is established, the socket structure is then transfered
to \fIso_q\fP, making it available for an accept.
.PP
If an SO_ACCEPTCONN socket is closed with sockets on either
\fIso_q0\fP or \fIso_q\fP, these sockets are dropped.
.NH 2
Protocol layer(s)
.PP
Protocols are described by a set of entry points and certain
socket visible characteristics, some of which are used in
deciding which socket type(s) they may support.  
.PP
An entry in the ``protocol switch'' table exists for each
protocol module configured into the system.  It has the following form:
.DS
._f
struct protosw {
	short	pr_type;		/* socket type used for */
	short	pr_family;		/* protocol family */
	short	pr_protocol;		/* protocol number */
	short	pr_flags;		/* socket visible attributes */
/* protocol-protocol hooks */
	int	(*pr_input)();		/* input to protocol (from below) */
	int	(*pr_output)();		/* output to protocol (from above) */
	int	(*pr_ctlinput)();	/* control input (from below) */
	int	(*pr_ctloutput)();	/* control output (from above) */
/* user-protocol hook */
	int	(*pr_usrreq)();		/* user request */
/* utility hooks */
	int	(*pr_init)();		/* initialization routine */
	int	(*pr_fasttimo)();	/* fast timeout (200ms) */
	int	(*pr_slowtimo)();	/* slow timeout (500ms) */
	int	(*pr_drain)();		/* flush any excess space possible */
};
.DE
.PP
A protocol is called through the \fIpr_init\fP entry before any other.
Thereafter it is called every 200 milliseconds through the
\fIpr_fasttimo\fP entry and
every 500 milliseconds through the \fIpr_slowtimo\fP for timer based actions.
The system will call the \fIpr_drain\fP entry if it is low on space and
this should throw away any non-critical data.
.PP
Protocols pass data between themselves as chains of mbufs using
the \fIpr_input\fP and \fIpr_output\fP routines.  \fIPr_input\fP
passes data up (towards
the user) and \fIpr_output\fP passes it down (towards the network); control
information passes up and down on \fIpr_ctlinput\fP and \fIpr_ctloutput\fP.
The protocol is responsible for the space occupied by any the
arguments to these entries and must dispose of it.
.PP
The \fIpr_userreq\fP routine interfaces protocols to the socket
code and is described below.
.PP
The \fIpr_flags\fP field is constructed from the following values:
.DS
._d
#define	PR_ATOMIC	0x01		/* exchange atomic messages only */
#define	PR_ADDR	0x02		/* addresses given with messages */
#define	PR_CONNREQUIRED	0x04		/* connection required by protocol */
#define	PR_WANTRCVD	0x08		/* want PRU_RCVD calls */
#define	PR_RIGHTS	0x10		/* passes capabilities */
.DE
Protocols which are connection-based specify the PR_CONNREQUIRED
flag so that the socket routines will never attempt to send data
before a connection has been established.  If the PR_WANTRCVD flag
is set, the socket routines will notfiy the protocol when the user
has removed data from the socket's receive queue.  This allows
the protocol to implement acknowledgement on user receipt, and
also update windowing information based on the amount of space
available in the receive queue.  The PR_ADDR field indicates any
data placed in the socket's receive queue will be preceded by the
address of the sender.  The PR_ATOMIC flag specifies each \fIuser\fP
request to send data must be performed in a single \fIprotocol\fP send
request; it is the protocol's responsibility to maintain record
boundaries on data to be sent.  The PR_RIGHTS flag indicates the
protocol supports the passing of capabilities;  this is currently
used only the protocols in the UNIX protocol family.
.PP
When a socket is created, the socket routines scan the protocol
table looking for an appropriate protocol to support the type of
socket being created.  The \fIpr_type\fP field contains one of the
possible socket types (e.g. SOCK_STREAM), while the \fIpr_family\fP
field indicates which protocol family the protocol belongs to.
The \fIpr_protocol\fP field contains the protocol number of the
protocol, normally a well known value.
.NH 2
Network-interface layer
.PP
Each network-interface configured into a system defines a
path through which packets may be sent and received.
Normally a hardware device is associated with this interface,
though there is no requirement for this (for example, all
systems have a software ``loopback'' interface used for 
debugging and performance analysis).
In addition to manipulating the hardware device, an interface
module is responsible
for encapsulation and deencapsulation of any low level header
information required to deliver a message to it's destination.
The selection of which interface to use in delivering packets
is a routing decision carried out at a
higher level than the network-interface layer.  Each interface
normally identifies itself at boot time to the routing module
so that it may be selected for packet delivery.
.PP
An interface is defined by the following structure,
.DS
._f
struct ifnet {
	char	*if_name;		/* name, e.g. ``en'' or ``lo'' */
	short	if_unit;		/* sub-unit for lower level driver */
	short	if_mtu;			/* maximum transmission unit */
	int	if_net;			/* network number of interface */
	short	if_flags;		/* up/down, broadcast, etc. */
	short	if_timer;		/* time 'til if_watchdog called */
	int	if_host[2];		/* local net host number */
	struct	sockaddr if_addr;	/* address of interface */
	union {
		struct	sockaddr ifu_broadaddr;
		struct	sockaddr ifu_dstaddr;
	} if_ifu;
	struct	ifqueue if_snd;		/* output queue */
	int	(*if_init)();		/* init routine */
	int	(*if_output)();		/* output routine */
	int	(*if_ioctl)();		/* ioctl routine */
	int	(*if_reset)();		/* bus reset routine */
	int	(*if_watchdog)();	/* timer routine */
	int	if_ipackets;		/* packets received on interface */
	int	if_ierrors;		/* input errors on interface */
	int	if_opackets;		/* packets sent on interface */
	int	if_oerrors;		/* output errors on interface */
	int	if_collisions;		/* collisions on csma interfaces */
	struct	ifnet *if_next;
};
.DE
.PP
Each interface has a send queue and routines used for 
initialization, \fIif_init\fP, and output, \fIif_output\fP.
If the interface resides on a system bus, the routine \fIif_reset\fP
will be called after a bus reset has been performed. 
An interface may also
specify a timer routine, \fIif_watchdog\fP, which should be called
every \fIif_timer\fP seconds (if non-zero).
.PP
The state of an interface and certain characteristics are stored in
the \fIif_flags\fP field.  The following values are possible:
.DS
._d
#define	IFF_UP	0x1	/* interface is up */
#define	IFF_BROADCAST	0x2	/* broadcast address valid */
#define	IFF_DEBUG	0x4	/* turn on debugging */
#define	IFF_ROUTE	0x8	/* routing entry installed */
#define	IFF_POINTOPOINT	0x10	/* interface is point-to-point link */
#define	IFF_NOTRAILERS	0x20	/* avoid use of trailers */
#define	IFF_RUNNING	0x40	/* resources allocated */
#define	IFF_NOARP	0x80	/* no address resolution protocol */
.DE
If the interface is connected to a network which supports transmission
of \fIbroadcast\fP packets, the IFF_BROADCAST flag will be set and
the \fIif_broadaddr\fP field will contain the address to be used in
sending or accepting a broadcast packet.  If the interface is associated
with a point to point hardware link (for example, a DEC DMR-11), the
IFF_POINTOPOINT flag will be set and \fIif_dstaddr\fP will contain the
address of the host on the other side of the connection.  These addresses
and the local address of the interface, \fIif_addr\fP, are used in
filtering incoming packets.  The interface sets IFF_RUNNING after
it has allocated system resources and posted an initial read on the
device it manages.  This state bit is used to avoid multiple allocation
requests when an interface's address is changed.  The IFF_NOTRAILERS
flag indicates the interface should refrain from using a \fItrailer\fP
encapsulation on outgoing packets; \fItrailer\fP protocols are described
in section 14.  The IFF_NOARP flag indicates the interface should not
use an ``address resolution protocol'' in mapping internetwork addresses
to local network addresses.
.PP
The information stored in an \fIifnet\fP structure for point to point
communication devices is not currently used by the system internally.
Rather, it is used by the user level routing process in determining
host network connections and in initially devising routes (refer to
chapter 10 for more information).
.PP
Various statistics are also stored in the interface structure.  These
may be viewed by users using the \fInetstat\fP(1) program.
.PP
The interface address and flags may be set with the SIOCSIFADDR and
SIOCSIFFLAGS ioctls.  SIOCSIFADDR is used to initially define each
interface's address; SIOGSIFFLAGS can be used to mark
an interface down and perform site-specific configuration.
.NH 3
UNIBUS interfaces
.PP
All hardware related interfaces currently reside on the UNIBUS.
Consequently a common set of utility routines for dealing
with the UNIBUS has been developed.  Each UNIBUS interface
utilizes a structure of the following form:
.DS
.if t .ta .5i 1.25i 2.8i
.if n .ta .7i 1.75i 3.8i
struct	ifuba {
	short	ifu_uban;			/* uba number */
	short	ifu_hlen;			/* local net header length */
	struct	uba_regs *ifu_uba;		/* uba regs, in vm */
	struct ifrw {
.if t .ta .5i 1.25i 2.0i 2.8i
.if n .ta .7i 1.75i 2.75i 3.8i
		caddr_t	ifrw_addr;		/* virt addr of header */
		int	ifrw_bdp;		/* unibus bdp */
		int	ifrw_info;		/* value from ubaalloc */
		int	ifrw_proto;		/* map register prototype */
		struct	pte *ifrw_mr;		/* base of map registers */
	} ifu_r, ifu_w;
.if t .ta .5i 1.25i 2.8i
.if n .ta .7i 1.75i 3.8i
	struct	pte ifu_wmap[IF_MAXNUBAMR];	/* base pages for output */
	short	ifu_xswapd;			/* mask of clusters swapped */
	short	ifu_flags;			/* used during uballoc's */
	struct	mbuf *ifu_xtofree;		/* pages being dma'd out */
};
.DE
.PP
The \fIif_uba\fP structure describes UNIBUS resources held by
an interface.
IF_NUBAMR map registers are held for datagram data, starting
at \fIifr_mr\fP.  UNIBUS map register \fIifr_mr\fP[\-1]
maps the local network header
ending on a page boundary.  UNIBUS data paths are
reserved for read and for
write, given by \fIifr_bdp\fP.  The prototype of the map
registers for read and for write is saved in \fIifr_proto\fP.
.PP
When write transfers are not full pages on page boundaries
the data is just copied into the pages mapped on the UNIBUS
and the transfer is started.
If a write transfer is of a (1024 byte) page size and on a page
boundary, UNIBUS page table entries are swapped to reference
the pages, and then the initial pages are
remapped from \fIifu_wmap\fP when the transfer completes.
.PP
When read transfers give whole pages of data to be input, page
frames are allocated from a network page list and traded
with the pages already containing the data, mapping the allocated
pages to replace the input pages for the next UNIBUS data input.
.PP
The following utility routines are available for use in
writing network interface drivers, all use the \fIifuba\fP
structure described above.
.IP "if_ubainit(ifu, uban, hlen, nmr);"
.br
\fIif_ubainit\fP allocates resources on UNIBUS adaptor \fIuban\fP
and stores the resultant information
in the \fIifuba\fP structure pointed to by \fIifu\fP. 
It is called only at boot time or after a UNIBUS reset. 
Two data paths (buffered or unbuffered,
depending on the \fIifu_flags\fP field) are allocated, one for
reading and one for writing.  The \fInmr\fP parameter indicates
the number of UNIBUS mapping registers required to map a maximal
sized packet onto the UNIBUS, while \fIhlen\fP specifies the size
of a local network header, if any, which should be mapped separately
from the data (see the description of trailer protocols in chapter 14).
Sufficient UNIBUS mapping registers and pages of memory are allocated
to initialize the input data path for an initial read.  For the output
data path, mapping registers and pages of memory are also allocated
and mapped onto the UNIBUS.  The pages associated with the output
data path are held in reserve in the event a write requires copying
non-page-aligned data (see \fIif_wubaput\fP below).
If \fIif_ubainit\fP is called with resources already allocated,
they will be used instead of allocating new ones (this normally
occurs after a UNIBUS reset).
A 1 is returned when allocation and initialization is successful,
0 otherwise.
.IP "m = if_rubaget(ifu, totlen, off0);"
.br
\fIif_rubaget\fP pulls read data off an interface.  \fItotlen\fP
specifies the length of data to be obtained, not counting the
local network header.  If \fIoff0\fP is non-zero, it indicates
a byte offset to a trailing local network header which should be
copied into a
separate mbuf and prepended to the front of the resultant mbuf
chain.  When page sized units of data are present and are
page-aligned, the previously mapped data pages are remapped
into the mbufs and swapped with fresh pages; thus avoiding
any copying.  A 0 return value indicates a failure to allocate
resources.
.IP "if_wubaput(ifu, m);"
.br
\fIif_wubaput\fP maps a chain of mbufs onto a network interface
in preparation for output.  The chain includes any local network
header, which is copied so that it resides in the mapped and
aligned I/O space.  Any other mbufs which contained non page
sized data portions are also copied to the I/O space.
Pages mapped from a previous output operation (no longer needed)
are unmapped and returned to the network page pool.
.ds RH "Socket/protocol interface
.sp 2
.ds f. a3.7.t
.nr H2 1
.ds RH "Socket/protocol interface
.NH
\s+2Socket/protocol interface\s0
.PP
The interface between the socket routines and the communication
protocols is through the \fIpr_usrreq\fP routine defined in the
protocol switch table.  The following requests to a protocol
module are possible:
.DS
._d
#define	PRU_ATTACH	0	/* attach protocol */
#define	PRU_DETACH	1	/* detach protocol */
#define	PRU_BIND	2	/* bind socket to address */
#define	PRU_LISTEN	3	/* listen for connection */
#define	PRU_CONNECT	4	/* establish connection to peer */
#define	PRU_ACCEPT	5	/* accept connection from peer */
#define	PRU_DISCONNECT	6	/* disconnect from peer */
#define	PRU_SHUTDOWN	7	/* won't send any more data */
#define	PRU_RCVD	8	/* have taken data; more room now */
#define	PRU_SEND	9	/* send this data */
#define	PRU_ABORT	10	/* abort (fast DISCONNECT, DETATCH) */
#define	PRU_CONTROL	11	/* control operations on protocol */
#define	PRU_SENSE	12	/* return status into m */
#define	PRU_RCVOOB	13	/* retrieve out of band data */
#define	PRU_SENDOOB	14	/* send out of band data */
#define	PRU_SOCKADDR	15	/* fetch socket's address */
#define	PRU_PEERADDR	16	/* fetch peer's address */
#define	PRU_CONNECT2	17	/* connect two sockets */
/* begin for protocols internal use */
#define	PRU_FASTTIMO	18	/* 200ms timeout */
#define	PRU_SLOWTIMO	19	/* 500ms timeout */
#define	PRU_PROTORCV	20	/* receive from below */
#define	PRU_PROTOSEND	21	/* send to below */
.DE
A call on the user request routine is of the form,
.DS
._f
error = (*protosw[].pr_usrreq)(up, req, m, addr, rights);
int error; struct socket *up; int req; struct mbuf *m, *rights; caddr_t addr;
.DE
The mbuf chain, \fIm\fP, and the address are optional parameters.
The \fIrights\fP parameter is an optional pointer to an mbuf
chain containing user specified capabilities (see the \fIsendmsg\fP
and \fIrecvmsg\fP system calls).  The protocol is responsible for
disposal of both mbuf chains.  A non-zero return value gives a
UNIX error number which should be passed to higher level software.
The following paragraphs describe each
of the requests possible.
.IP PRU_ATTACH
.br
When a protocol is bound to a socket (with the \fIsocket\fP
system call) the protocol module is called with this
request.  It is the responsibility of the protocol module to
allocate any resources necessary.
The ``attach'' request
will always precede any of the other requests, and should not
occur more than once.
.IP PRU_DETACH
.br
This is the antithesis of the attach request, and is used
at the time a socket is deleted.  The protocol module may
deallocate any resources assigned to the socket.
.IP PRU_BIND
.br
When a socket is initially created it has no address bound
to it.  This request indicates an address should be bound to
an existing socket.  The protocol module must verify the
requested address is valid and available for use.
.IP PRU_LISTEN
.br
The ``listen'' request indicates the user wishes to listen
for incoming connection requests on the associated socket.
The protocol module should perform any state changes needed
to carry out this request (if possible).  A ``listen'' request
always precedes a request to accept a connection.
.IP PRU_CONNECT
.br
The ``connect'' request indicates the user wants to a establish
an association.  The \fIaddr\fP parameter supplied describes
the peer to be connected to.  The effect of a connect request
may vary depending on the protocol.  Virtual circuit protocols,
such as TCP [Postel80b], use this request to initiate establishment of a
TCP connection.  Datagram protocols, such as UDP [Postel79], simply
record the peer's address in a private data structure and use
it to tag all outgoing packets.  There are no restrictions
on how many times a connect request may be used after an attach.
If a protocol supports the notion of \fImulti-casting\fP, it
is possible to use multiple connects to establish a multi-cast
group.  Alternatively, an association may be broken by a
PRU_DISCONNECT request, and a new association created with a
subsequent connect request; all without destroying and creating
a new socket.
.IP PRU_ACCEPT
.br
Following a successful PRU_LISTEN request and the arrival
of one or more connections, this request is made to
indicate the user
has accepted the first connection on the queue of
pending connections.  The protocol module should fill
in the supplied address buffer with the address of the
connected party.
.IP PRU_DISCONNECT
.br
Eliminate an association created with a PRU_CONNECT request.
.IP PRU_SHUTDOWN
.br
This call is used to indicate no more data will be sent and/or
received (the \fIaddr\fP parameter indicates the direction of
the shutdown, as encoded in the \fIsoshutdown\fP system call).
The protocol may, at its discretion, deallocate any data
structures related to the shutdown.
.IP PRU_RCVD
.br
This request is made only if the protocol entry in the protocol
switch table includes the PR_WANTRCVD flag.
When a user removes data from the receive queue this request
will be sent to the protocol module.  It may be used to trigger
acknowledgements, refresh windowing information, initiate
data transfer, etc.
.IP PRU_SEND
.br
Each user request to send data is translated into one or more
PRU_SEND requests (a protocol may indicate a single user
send request must be translated into a single PRU_SEND request by
specifying the PR_ATOMIC flag in its protocol description).
The data to be sent is presented to the protocol as a list of
mbufs and an address is, optionally, supplied in the \fIaddr\fP
parameter.  The protocol is responsible for preserving the data
in the socket's send queue if it is not able to send it immediately,
or if it may need it at some later time (e.g. for retransmission).
.IP PRU_ABORT
.br
This request indicates an abnormal termination of service.  The
protocol should delete any existing association(s).
.IP PRU_CONTROL
.br
The ``control'' request is generated when a user performs a
UNIX \fIioctl\fP system call on a socket (and the ioctl is not
intercepted by the socket routines).  It allows protocol-specific
operations to be provided outside the scope of the common socket
interface.  The \fIaddr\fP parameter contains a pointer to a static
kernel data area where relevant information may be obtained or returned.
The \fIm\fP parameter contains the actual \fIioctl\fP request code
(note the non-standard calling convention).
.IP PRU_SENSE
.br
The ``sense'' request is generated when the user makes an \fIfstat\fP
system call on a socket; it requests status of the associated socket. 
There currently is no common format for the status returned. 
Information which might be returned includes per-connection statistics,
protocol state, resources currently in use by the connection, the
optimal transfer size for the connection (based on windowing information
and maximum packet size).  The \fIaddr\fP parameter contains a pointer
to a static kernel data area where the status buffer should be placed.
.IP PRU_RCVOOB
.br
Any ``out-of-band'' data presently available is to be returned.  An
mbuf is passed in to the protocol module and the protocol
should either place
data in the mbuf or attach new mbufs to the one supplied if there is
insufficient space in the single mbuf.
.IP PRU_SENDOOB
.br
Like PRU_SEND, but for out-of-band data.
.IP PRU_SOCKADDR
.br
The local address of the socket is returned, if any is currently
bound to the it.  The address format (protocol specific) is returned
in the \fIaddr\fP parameter.
.IP PRU_PEERADDR
.br
The address of the peer to which the socket is connected is returned.
The socket must be in a SS_ISCONNECTED state for this request to
be made to the protocol.  The address format (protocol specific) is
returned in the \fIaddr\fP parameter.
.IP PRU_CONNECT2
.br
The protocol module is supplied two sockets and requested to
establish a connection between the two without binding any
addresses, if possible.  This call is used in implementing
the
.IR socketpair (2)
system call.
.PP
The following requests are used internally by the protocol modules
and are never generated by the socket routines.  In certain instances,
they are handed to the \fIpr_usrreq\fP routine solely for convenience
in tracing a protocol's operation (e.g. PRU_SLOWTIMO).
.IP PRU_FASTTIMO
.br
A ``fast timeout'' has occured.  This request is made when a timeout
occurs in the protocol's \fIpr_fastimo\fP routine.  The \fIaddr\fP
parameter indicates which timer expired.
.IP PRU_SLOWTIMO
.br
A ``slow timeout'' has occured.  This request is made when a timeout
occurs in the protocol's \fIpr_slowtimo\fP routine.  The \fIaddr\fP
parameter indicates which timer expired.
.IP PRU_PROTORCV
.br
This request is used in the protocol-protocol interface, not by the
routines.  It requests reception of data destined for the protocol and
not the user.  No protocols currently use this facility.
.IP PRU_PROTOSEND
.br
This request allows a protocol to send data destined for another
protocol module, not a user.  The details of how data is marked
``addressed to protocol'' instead of ``addressed to user'' are
left to the protocol modules.  No protocols currently use this facility.
.ds RH "Protocol/protocol interface
.sp 2
.ds f. a3.8.t
.nr H2 1
.ds RH "Protocol/protocol interface
.NH
\s+2Protocol/protocol interface\s0
.PP
The interface between protocol modules is through the \fIpr_usrreq\fP,
\fIpr_input\fP, \fIpr_output\fP, \fIpr_ctlinput\fP, and
\fIpr_ctloutput\fP routines.  The calling conventions for all
but the \fIpr_usrreq\fP routine are expected to be specific to
the protocol
modules and are not guaranteed to be consistent across protocol
families.  We
will examine the conventions used for some of the Internet
protocols in this section as an example.
.NH 2
pr_output
.PP
The Internet protocol UDP uses the convention,
.DS
error = udp_output(inp, m);
int error; struct inpcb *inp; struct mbuf *m;
.DE
where the \fIinp\fP, ``\fIin\fPternet
\fIp\fProtocol \fIc\fPontrol \fIb\fPlock'',
passed between modules conveys per connection state information, and
the mbuf chain contains the data to be sent.  UDP
performs consistency checks, appends its header, calculates a
checksum, etc. before passing the packet on to the IP module:
.DS
error = ip_output(m, opt, ro, allowbroadcast);
int error; struct mbuf *m, *opt; struct route *ro; int allowbroadcast;
.DE
.PP
The call to IP's output routine is more complicated than that for
UDP, as befits the additional work the IP module must do.
The \fIm\fP parameter is the data to be sent, and the \fIopt\fP
parameter is an optional list of IP options which should
be placed in the IP packet header.  The \fIro\fP parameter is
is used in making routing decisions (and passing them back to the
caller).  The
final parameter, \fIallowbroadcast\fP is a flag indicating if the
user is allowed to transmit a broadcast packet.  This may
be inconsequential if the underlying hardware does not support the
notion of broadcasting.
.PP
All output routines return 0 on success and a UNIX error number
if a failure occured which could be immediately detected
(no buffer space available, no route to destination, etc.).
.NH 2
pr_input
.PP
Both UDP and TCP use the following calling convention,
.DS
(void) (*protosw[].pr_input)(m);
struct mbuf *m;
.DE
Each mbuf list passed is a single packet to be processed by
the protocol module.
.PP
The IP input routine is a VAX software interrupt level routine,
and so is not called with any parameters.  It instead communicates
with network interfaces through a queue, \fIipintrq\fP, which is
identical in structure to the queues used by the network interfaces
for storing packets awaiting transmission.
.NH 2
pr_ctlinput
.PP
This routine is used to convey ``control'' information to a
protocol module (i.e. information which might be passed to the
user, but is not data).  This routine, and the \fIpr_ctloutput\fP
routine, have not been extensively developed, and thus suffer
from a ``clumsiness'' that can only be improved as more demands
are placed on it.
.PP
The common calling convention for this routine is,
.DS
(void) (*protosw[].pr_ctlinput)(req, info);
int req; caddr_t info;
.DE
The \fIreq\fP parameter is one of the following,
.DS
.if t .ta .6i 2.6i 3.1i
.if n .ta .84i 3.1i 3.80i
#define	PRC_IFDOWN	0	/* interface transition */
#define	PRC_ROUTEDEAD	1	/* select new route if possible */
#define	PRC_QUENCH	4	/* some said to slow down */
#define	PRC_HOSTDEAD	6	/* normally from IMP */
#define	PRC_HOSTUNREACH	7	/* ditto */
#define	PRC_UNREACH_NET	8	/* no route to network */
#define	PRC_UNREACH_HOST	9	/* no route to host */
#define	PRC_UNREACH_PROTOCOL	10	/* dst says bad protocol */
#define	PRC_UNREACH_PORT	11	/* bad port # */
#define	PRC_MSGSIZE	12	/* message size forced drop */
#define	PRC_REDIRECT_NET	13	/* net routing redirect */
#define	PRC_REDIRECT_HOST	14	/* host routing redirect */
#define	PRC_TIMXCEED_INTRANS	17	/* packet lifetime expired in transit */
#define	PRC_TIMXCEED_REASS	18	/* lifetime expired on reass q */
#define	PRC_PARAMPROB	19	/* header incorrect */
.DE
while the \fIinfo\fP parameter is a ``catchall'' value which
is request dependent.  Many of the requests have obviously been
derived from ICMP (the Internet Control Message Protocol),
and from error messages defined in the 1822 host/IMP convention
[BBN78].  Mapping tables exist to convert
control requests to UNIX error codes which are delivered
to a user.
.NH 2
pr_ctloutput
.PP
This routine is not currently used by any protocol modules.
.ds RH "Protocol/network-interface
.sp 2
.ds f. a3.9.t
.nr H2 1
.ds RH "Protocol/network-interface
.NH
\s+2Protocol/network-interface interface\s0
.PP
The lowest layer in the set of protocols which comprise a
protocol family must interface itself to one or more network
interfaces in order to transmit and receive
packets.  It is assumed that
any routing decisions have been made before handing a packet
to a network interface, in fact this is absolutely necessary
in order to locate any interface at all (unless, of course,
one uses a single ``hardwired'' interface).  There are two
cases to be concerned with, transmission of a packet,
and receipt of a packet; each will be considered separately.
.NH 2
Packet transmission
.PP
Assuming a protocol has a handle on an interface, \fIifp\fP,
a (struct ifnet *),
it transmits a fully formatted packet with the following call,
.DS
error = (*ifp->if_output)(ifp, m, dst)
int error; struct ifnet *ifp; struct mbuf *m; struct sockaddr *dst;
.DE
The output routine for the network interface transmits the packet
\fIm\fP to the \fIdst\fP address, or returns an error indication
(a UNIX error number).  In reality transmission may
not be immediate, or successful; normally the output
routine simply queues the packet on its send queue and primes
an interrupt driven routine to actually transmit the packet.
For unreliable mediums, such as the Ethernet, ``successful''
transmission simply means the packet has been placed on the cable
without a collision.  On the other hand, an 1822 interface guarantees
proper delivery or an error indication for each message transmitted.
The model employed in the networking system attaches no promises
of delivery to the packets handed to a network interface, and thus
corresponds more closely to the Ethernet.  Errors returned by the
output routine are normally trivial in nature (no buffer space, 
address format not handled, etc.).
.NH 2
Packet reception
.PP
Each protocol family must have one or more ``lowest level'' protocols.
These protocols deal with internetwork addressing and are responsible
for the delivery of incoming packets to the proper protocol processing
modules.  In the PUP model [Boggs78] these protocols are termed Level
1 protocols,
in the ISO model, network layer protocols.  In our system each such
protocol module has an input packet queue assigned to it.  Incoming
packets received by a network interface are queued up for the protocol
module and a VAX software interrupt is posted to initiate processing.  
.PP
Three macros are available for queueing and dequeueing packets,
.IP "IF_ENQUEUE(ifq, m)"
.br
This places the packet \fIm\fP at the tail of the queue \fIifq\fP.
.IP "IF_DEQUEUE(ifq, m)"
.br
This places a pointer to the packet at the head of queue \fIifq\fP 
in \fIm\fP.  A zero value will be returned in \fIm\fP if the queue
is empty.
.IP "IF_PREPEND(ifq, m)"
.br
This places the packet \fIm\fP at the head of the queue \fIifq\fP.
.PP
Each queue has a maximum length associated with it as a simple form
of congestion control.  The macro IF_QFULL(ifq) returns 1 if the queue
is filled, in which case the macro IF_DROP(ifq) should be used to
bump a count of the number of packets dropped and the offending
packet dropped.  For example, the following code fragment is commonly
found in a network interface's input routine,
.DS 
._f
if (IF_QFULL(inq)) {
	IF_DROP(inq);
	m_freem(m);
} else
	IF_ENQUEUE(inq, m);
.DE
.ds RH "Gateways and routing
.sp 2
.ds f. a3.a.t
.nr H2 1
.ds RH "Gateways and routing
.NH
\s+2Gateways and routing issues\s0
.PP
The system has been designed with the expectation that it will
be used in an internetwork environment.  The ``canonical''
environment was envisioned to be a collection of local area
networks connected at one or more points through hosts with
multiple network interfaces (one on each local area network),
and possibly a connection to a long haul network (for example,
the ARPANET).  In such an environment, issues of
gatewaying and packet routing become very important.  Certain
of these issues, such as congestion
control, have been handled in a simplistic manner or specifically
not addressed.
Instead, where possible, the network system
attempts to provide simple mechanisms upon which more involved
policies may be implemented.  As some of these problems become
better understood, the solutions developed will be incorporated
into the system.
.PP
This section will describe the facilities provided for packet
routing.  The simplistic mechanisms provided for congestion
control are described in chapter 12.
.NH 2
Routing tables
.PP
The network system maintains a set of routing tables for
selecting a network interface to use in delivering a 
packet to its destination.  These tables are of the form:
.DS
._f
struct rtentry {
	u_long	rt_hash;		/* hash key for lookups */
	struct	sockaddr rt_dst;	/* destination net or host */
	struct	sockaddr rt_gateway;	/* forwarding agent */
	short	rt_flags;		/* see below */
	short	rt_refcnt;		/* no. of references to structure */
	u_long	rt_use;			/* packets sent using route */
	struct	ifnet *rt_ifp;		/* interface to give packet to */
};
.DE
.PP
The routing information is organized in two separate tables, one
for routes to a host and one for routes to a network.  The
distinction between hosts and networks is necessary so
that a single mechanism may be used
for both broadcast and multi-drop type networks, and
also for networks built from point-to-point links (e.g
DECnet [DEC80]).
.PP
Each table is organized as a hashed set of linked lists.
Two 32-bit hash values are calculated by routines defined for
each address family; one based on the destination being
a host, and one assuming the target is the network portion
of the address.  Each hash value is used to
locate a hash chain to search (by taking the value modulo the
hash table size) and the entire 32-bit value is then
used as a key in scanning the list of routes.  Lookups are
applied first to the routing
table for hosts, then to the routing table for networks.
If both lookups fail, a final lookup is made for a ``wildcard''
route (by convention, network 0).
By doing this, routes to a specific host on a network may be
present as well as routes to the network.  This also allows a
``fall back'' network route to be defined to an ``smart'' gateway
which may then perform more intelligent routing.
.PP
Each routing table entry contains a destination (who's at
the other end of the route), a gateway to send the packet
to, and various
flags which indicate the route's status and type (host or
network).  A count
of the number of packets sent using the route is kept for
use in deciding between multiple routes to the same destination
(see below), and a count of ``held references'' to the dynamically
allocated structure is maintained to insure memory reclamation
occurs only when the route is not in use.  Finally a pointer to the
a network interface is kept; packets sent using
the route should be handed to this interface.
.PP
Routes are typed in two ways: either as host or network, and as
``direct'' or ``indirect''.  The host/network
distinction determines how to compare the \fIrt_dst\fP field
during lookup.  If the route is to a network, only a packet's
destination network is compared to the \fIrt_dst\fP entry stored
in the table.  If the route is to a host, the addresses must
match bit for bit.
.PP
The distinction between ``direct'' and ``indirect'' routes indicates
whether the destination is directly connected to the source.
This is needed when performing local network encapsulation.  If
a packet is destined for a peer at a host or network which is
not directly connected to the source, the internetwork packet
header will
indicate the address of the eventual destination, while
the local network header will indicate the address of the intervening
gateway.  Should the destination be directly connected, these addresses
are likely to be identical, or a mapping between the two exists.
The RTF_GATEWAY flag indicates the route is to an ``indirect''
gateway agent and the local network header should be filled in
from the \fIrt_gateway\fP field instead of \fIrt_dst\fP, or 
from the internetwork destination address.
.PP
It is assumed multiple routes to the same destination will not
be present unless they are deemed \fIequal\fP in cost (the
current routing policy process never installs multiple routes
to the same destination).
However, should multiple routes to the same destination exist,
a request for a route will return the ``least used'' route
based on the total number of packets sent along this route.
This can result in a ``ping-pong'' effect (alternate packets
taking alternate routes), unless protocols ``hold onto''
routes until they no longer find them useful;  either because
the destination has changed, or because the route is lossy.
.PP
Routing redirect control messages are used to dynamically
modify existing routing table entries as well as dynamically
create new routing table entries.  On hosts where exhaustive
routing information is too expensive to maintain (e.g. work
stations), the
combination of wildcard routing entries and routing redirect
messages can be used to provide a simple routing management
scheme without the use of a higher level policy process. 
Statistics are kept by the routing table routines
on the use of routing redirect messages and their
affect on the routing tables.  These statistics may be viewed using
.IR netstat (1).
.PP
Status information other than routing redirect control messages
may be used in the future, but at present they are ignored.
Likewise, more intelligent ``metrics'' may be used to describe
routes in the future, possibly based on bandwidth and monetary
costs.
.NH 2
Routing table interface
.PP
A protocol accesses the routing tables through
three routines,
one to allocate a route, one to free a route, and one
to process a routing redirect control message.
The routine \fIrtalloc\fP performs route allocation; it is
called with a pointer to the following structure,
.DS
._f
struct route {
	struct	rtentry *ro_rt;
	struct	sockaddr ro_dst;
};
.DE
The route returned is assumed ``held'' by the caller until
disposed of with an \fIrtfree\fP call.  Protocols which implement
virtual circuits, such as TCP, hold onto routes for the duration
of the circuit's lifetime, while connection-less protocols,
such as UDP, currently allocate and free routes on each transmission.
.PP
The routine \fIrtredirect\fP is called to process a routing redirect
control message.  It is called with a destination address and 
the new gateway to that destination.  If a non-wildcard route
exists to the destination, the gateway entry in the route is modified 
to point at the new gateway supplied.  Otherwise, a new routing
table entry is inserted reflecting the information supplied.  Routes
to interfaces and routes to gateways which are not directly accesible
from the host are ignored.
.NH 2
User level routing policies
.PP
Routing policies implemented in user processes manipulate the
kernel routing tables through two \fIioctl\fP calls.  The
commands SIOCADDRT and SIOCDELRT add and delete routing entries,
respectively; the tables are read through the /dev/kmem device.
The decision to place policy decisions in a user process implies
routing table updates may lag a bit behind the identification of
new routes, or the failure of existing routes, but this period
of instability is normally very small with proper implementation
of the routing process.  Advisory information, such as ICMP
error messages and IMP diagnostic messages, may be read from
raw sockets (described in the next section).
.PP
One routing policy process has already been implemented.  The
system standard
``routing daemon'' uses a variant of the Xerox NS Routing Information
Protocol [Xerox82] to maintain up to date routing tables in our local
environment.  Interaction with other existing routing protocols,
such as the Internet GGP (Gateway-Gateway Protocol), may be
accomplished using a similar process.
.ds RH "Raw sockets
.sp 2
.ds f. a3.b.t
.nr H2 1
.ds RH "Raw sockets
.NH
\s+2Raw sockets\s0
.PP
A raw socket is a mechanism which allows users direct access
to a lower level protocol.  Raw sockets are intended for knowledgeable
processes which wish to take advantage of some protocol
feature not directly accessible through the normal interface, or 
for the development of new protocols built atop existing lower level
protocols.  For example, a new version of TCP might be developed at the
user level by utilizing a raw IP socket for delivery of packets.
The raw IP socket interface attempts to provide an identical interface
to the one a protocol would have if it were resident in the kernel.
.PP
The raw socket support is built around a generic raw socket interface,
and (possibly) augmented by protocol-specific processing routines.
This section will describe the core of the raw socket interface.
.NH 2
Control blocks
.PP
Every raw socket has a protocol control block of the following form,
.DS
.if t .ta .5i 1.25i 2.9i
.if n .ta .7i 1.75i 4.0i
struct rawcb {
	struct	rawcb *rcb_next;	/* doubly linked list */
	struct	rawcb *rcb_prev;
	struct	socket *rcb_socket;	/* back pointer to socket */
	struct	sockaddr rcb_faddr;	/* destination address */
	struct	sockaddr rcb_laddr;	/* socket's address */
	caddr_t	rcb_pcb;		/* protocol specific stuff */
	short	rcb_flags;
};
.DE
All the control blocks are kept on a doubly linked list for
performing lookups during packet dispatch.  Associations may
be recorded in the control block and used by the output routine
in preparing packets for transmission.  The addresses are also
used to filter packets on input; this will be described in more
detail shortly.  If any protocol specific information is required,
it may be attached to the control block using the \fIrcb_pcb\fP
field. 
.PP
A raw socket interface is datagram oriented.  That is, each send
or receive on the socket requires a destination address.  This
address may be supplied by the user or stored in the control block
and automatically installed in the outgoing packet by the output
routine.  Since it is not possible to determine whether an address
is present or not in the control block, two flags, RAW_LADDR and
RAW_FADDR, indicate if a local and foreign address are present.
Another flag, RAW_DONTROUTE, indicates if routing should be performed
on outgoing packets.  If it is, a route is expected to be 
allocated for each
``new'' destination address.  That is, the first time a packet is
transmitted a route is determined, and thereafter each time the
destination address stored in \fIrcb_route\fP differs from
\fIrcb_faddr\fP, or \fIrcb_route.ro_rt\fP is zero, the old
route is discarded and a new one allocated. 
.NH 2
Input processing
.PP
Input packets are ``assigned'' to raw sockets based on a simple
pattern matching scheme.  Each network interface or protocol
gives packets
to the raw input routine with the call:
.DS
raw_input(m, proto, src, dst)
struct mbuf *m; struct sockproto *proto, struct sockaddr *src, *dst;
.DE
The data packet then has a generic header prepended to it of the
form
.DS
._f
struct raw_header {
	struct	sockproto raw_proto;
	struct	sockaddr raw_dst;
	struct	sockaddr raw_src;
};
.DE
and it is placed in a packet queue for the ``raw input protocol'' module.
Packets taken from this queue are copied into any raw sockets that
match the header according to the following rules,
.IP 1)
The protocol family of the socket and header agree.
.IP 2)
If the protocol number in the socket is non-zero, then it agrees
with that found in the packet header.
.IP 3)
If a local address is defined for the socket, the address format
of the local address is the same as the destination address's and
the two addresses agree bit for bit.
.IP 4)
The rules of 3) are applied to the socket's foreign address and the packet's
source address.
.LP
A basic assumption is that addresses present in the
control block and packet header (as constructed by the network
interface and any raw input protocol module) are in a canonical
form which may be ``block compared''.
.NH 2
Output processing
.PP
On output the raw \fIpr_usrreq\fP routine 
passes the packet and raw control block to the
raw protocol output routine for any processing required before
it is delivered to the appropriate network interface.  The
output routine is normally the only code required to implement
a raw socket interface.
.ds RH "Buffering and congestion control
.sp 2
.ds f. a3.c.t
.nr H2 1
.ds RH "Buffering and congestion control
.NH
\s+2Buffering and congestion control\s0
.PP
One of the major factors in the performance of a protocol is
the buffering policy used.  Lack of a proper buffering policy
can force packets to be dropped, cause falsified windowing
information to be emitted by protocols, fragment host memory,
degrade the overall host performance, etc.  Due to problems
such as these, most systems allocate a fixed pool of memory
to the networking system and impose
a policy optimized for ``normal'' network operation.  
.PP
The networking system developed for UNIX is little different in this
respect.  At boot time a fixed amount of memory is allocated by
the networking system.  At later times more system memory
may be requested as the need arises, but at no time is
memory ever returned to the system.  It is possible to
garbage collect memory from the network, but difficult.  In
order to perform this garbage collection properly, some
portion of the network will have to be ``turned off'' as
data structures are updated.  The interval over which this
occurs must kept small compared to the average inter-packet
arrival time, or too much traffic may
be lost, impacting other hosts on the network, as well as
increasing load on the interconnecting mediums.  In our
environment we have not experienced a need for such compaction,
and thus have left the problem unresolved.
.PP
The mbuf structure was introduced in chapter 5.  In this
section a brief description will be given of the allocation
mechanisms, and policies used by the protocols in performing
connection level buffering.
.NH 2
Memory management
.PP
The basic memory allocation routines place no restrictions on
the amount of space which may be allocated.  Any request made
is filled until the system memory allocator starts refusing
to allocate additional memory.  When the current quota of memory
is insufficient to satisfy an mbuf allocation request, the
allocator requests enough new pages from the system to satisfy
the current request only.  All memory owned by the network is
described by a private page table used in remapping pages to
be logically contiguous as the need arises.  In addition, an
array of reference counts parallels the page table and is used
when multiple copies of a page are present.
.PP
Mbufs are 128 byte structures, 8 fitting in a 1Kbyte
page of memory.  When data is placed in mbufs, if possible,
it is copied or remapped into logically contiguous pages of
memory from the network page pool.  Data smaller than the size
of a page is copied into one or more 112 byte mbuf data areas. 
.NH 2
Protocol buffering policies
.PP
Protocols reserve fixed amounts of
buffering for send and receive queues at socket creation time.  These
amounts define the high and low water marks used by the socket routines
in deciding when to block and unblock a process.  The reservation
of space does not currently
result in any action by the memory management
routines, though it is clear if one imposed an upper
bound on the total amount of physical memory allocated to the network,
reserving memory would become important.
.PP
Protocols which provide connection level flow control do this
based on the amount of space in the associated socket queues.  That
is, send windows are calculated based on the amount of free space
in the socket's receive queue, while receive windows are adjusted
based on the amount of data awaiting transmission in the send queue.
Care has been taken to avoid the ``silly window syndrome'' described
in [Clark82] at both the sending and receiving ends.
.NH 2
Queue limiting
.PP
Incoming packets from the network are always received unless
memory allocation fails.  However, each Level 1 protocol
input queue
has an upper bound on the queue's length, and any packets
exceeding that bound are discarded.  It is possible for a host to be
overwhelmed by excessive network traffic (for instance a host
acting as a gateway from a high bandwidth network to a low bandwidth
network).  As a ``defensive'' mechanism the queue limits may be
adjusted to throttle network traffic load on a host.
Consider a host willing to devote some percentage of
its machine to handling network traffic. 
If the cost of handling an
incoming packet can be calculated so that an acceptable
``packet handling rate''
can be determined, then input queue lengths may be dynamically
adjusted based on a host's network load and the number of packets
awaiting processing.  Obviously, discarding packets is
not a satisfactory solution to a problem such as this
(simply dropping packets is likely to increase the load on a network);
the queue lengths were incorporated mainly as a safeguard mechanism.
.NH 2
Packet forwarding
.PP
When packets can not be forwarded because of memory limitations,
the system generates a ``source quench'' message.  In addition,
any other problems encountered during packet forwarding are also
reflected back to the sender in the form of ICMP packets.  This
helps hosts avoid unneeded retransmissions.
.PP
Broadcast packets are never forwarded due to possible dire
consequences.  In an early stage of network development, broadcast
packets were forwarded and a ``routing loop'' resulted in network
saturation and every host on the network crashing.
.ds RH "Out of band data
.sp 2
.ds f. a3.d.t
.nr H2 1
.ds RH "Out of band data
.NH
\s+2Out of band data\s0
.PP
Out of band data is a facility peculiar to the stream socket
abstraction defined.  Little agreement appears to exist as
to what its semantics should be.  TCP defines the notion of
``urgent data'' as in-line, while the NBS protocols [Burruss81]
and numerous others provide a fully independent logical
transmission channel along which out of band data is to be
sent.
In addition, the amount of the data which may be sent as an out
of band message varies from protocol to protocol; everything
from 1 bit to 16 bytes or more.
.PP
A stream socket's notion of out of band data has been defined
as the lowest reasonable common denominator (at least reasonable
in our minds);
clearly this is subject to debate.  Out of band data is expected
to be transmitted out of the normal sequencing and flow control
constraints of the data stream.  A minimum of 1 byte of out of
band data and one outstanding out of band message are expected to
be supported by the protocol supporting a stream socket.
It is a protocols perogative to support larger sized messages, or
more than one outstanding out of band message at a time.
.PP
Out of band data is maintained by the protocol and usually not
stored in the socket's send queue.  The PRU_SENDOOB and PRU_RCVOOB
requests to the \fIpr_usrreq\fP routine are used in sending and
receiving data.
.ds RH "Trailer protocols
.sp 2
.ds f. a3.e.t
.nr H2 1
.ds RH "Trailer protocols
.NH
\s+2Trailer protocols\s0
.PP
Core to core copies can be expensive.
Consequently, a great deal of effort was spent
in minimizing such operations.  The VAX architecture
provides virtual memory hardware organized in
page units.  To cut down on copy operations, data
is kept in page sized units on page-aligned
boundaries whenever possible.  This allows data
to be moved in memory simply by remapping the page
instead of copying.  The mbuf and network
interface routines perform page table manipulations
where needed, hiding the complexities of the VAX
virtual memory hardware from higher level code. 
.PP
Data enters the system in two ways: from the user,
or from the network (hardware interface).  When data
is copied from the user's address space
into the system it is deposited in pages (if sufficient
data is present to fill an entire page).
This encourages the user to transmit information in
messages which are a multiple of the system page size.
.PP
Unfortunately, performing a similar operation when taking
data from the network is very difficult.
Consider the format of an incoming packet.  A packet
usually contains a local network header followed by
one or more headers used by the high level protocols. 
Finally, the data, if any, follows these headers.  Since
the header information may be variable length, DMA'ing the eventual
data for the user into a page aligned area of
memory is impossible without
a priori knowledge of the format (e.g. supporting
only a single protocol header format).
.PP
To allow variable length header information to
be present and still ensure page alignment of data,
a special local network encapsulation may be used.
This encapsulation, termed a \fItrailer protocol\fP,
places the variable length header information after
the data.  A fixed size local network
header is then prepended to the resultant packet. 
The local network header contains the size of the
data portion, and a new \fItrailer protocol
header\fP, inserted before the variable length
information, contains the size of the variable length
header information.  The following trailer
protocol header is used to store information
regarding the variable length protocol header:
.DS
._f
struct {
	short	protocol;	/* original protocol no. */
	short	length;	/* length of trailer */
};
.DE
.PP
The processing of the trailer protocol is very
simple.  On output, the local network header indicates
a trailer encapsulation is being used.
The protocol identifier also includes an indication
of the number of data pages present (before the trailer
protocol header).  The trailer protocol header is
initialized to contain the actual protocol and
variable length header size, and appended to the data
along with the variable length header information.
.PP
On input, the interface routines identify the
trailer encapsulation
by the protocol type stored in the local network header,
then calculate the number of
pages of data to find the beginning of the trailer. 
The trailing information is copied into a separate
mbuf and linked to the front of the resultant packet.
.PP
Clearly, trailer protocols require cooperation between
source and destination.  In addition, they are normally
cost effective only when sizable packets are used.  The
current scheme works because the local network encapsulation
header is a fixed size, allowing DMA operations
to be performed at a known offset from the first data page
being received.  Should the local network header be
variable length this scheme fails. 
.PP
Statistics collected indicate as much as 200Kb/s
can be gained by using a trailer protocol with
1Kbyte packets.  The average size of the variable
length header was 40 bytes (the size of a
minimal TCP/IP packet header).  If hardware
supports larger sized packets, even greater gains
may be realized.
.ds LH "Final Report
.ds RH References
.bp
.ds f. refs.t
.ds RH References
.nr H2 1
.sp 2
.SH
\s+2References\s0
.LP
.IP [Accetta80] 20
Accetta, M., Robertson, G., Satyanarayanan, M., and Thompson, M.
"The Design of a Network-Based Central File System",
Carnegie-Mellon University, Dept of Computer Science Tech Report,
#CMU-CS-80-134
.IP [Almes78] 20
Almes, G., and Robertson, G.
"An Extensible File System for Hydra"
Proceedings of the Third International Conference on Software Engineering,
IEEE, May 1978.
.IP [Bass81] 20
Bass, J.
"Implementation Description for File Locking",
Onyx Systems Inc, 73 E. Trimble Rd, San Jose, CA 95131
Jan 1981.
.IP [Boggs79] 20
Boggs, D. R., J. F. Shoch, E. A. Taft, and R. M. Metcalfe;
\fIPUP: An Internetwork Architecture\fP.  Report CSL-79-10.
XEROX Palo Alto Research Center, July 1979.
.IP [BBN78] 20
Bolt Beranek and Newman;
\fISpecification for the Interconnection of Host and IMP\fP.
BBN Technical Report 1822.  May 1978.
.IP [Cerf78] 20
Cerf, V. G.;  The Catenet Model for Internetworking.
Internet Working Group, IEN 48.  July 1978.
.IP [Clark82] 20
Clark, D. D.;  Window and Acknowledgement Strategy in TCP. 
Internet Working Group, IEN Draft Clark-2.  March 1982.
.IP [DEC80] 20
Digital Equipment Corporation;  \fIDECnet DIGITAL Network
Architecture \- General Description\fP.  Order No.
AA-K179A-TK.  October 1980.
.IP [Dion80] 20
Dion, J.
"The Cambridge File Server",
Operating Systems Review, 14, 4. Oct 1980. pp 26-35
.IP [Eswaran74] 20
Eswaran, K.
"Placement of records in a file and file allocation in a computer network",
Proceedings IFIPS, 1974. pp 304-307
.IP [Feiertag71] 20
Feiertag, R. J. and Organick, E. I., 
"The Multics Input-Output System",
Proceedings of the Third Symposium on Operating Systems Principles,
ACM, Oct 1971. pp 35-41
.IP [Gurwitz81] 20
Gurwitz, R. F.;  VAX-UNIX Networking Support Project \- Implementation
Description.  Internetwork Working Group, IEN 168.
January 1981.
.IP [Holler73] 20
Holler, J.
"Files in Computer Networks",
First European Workshop on Computer Networks,
April 1973. pp 381-396
.IP [ISO81] 20
International Organization for Standardization.
\fIISO Open Systems Interconnection \- Basic Reference Model\fP.
ISO/TC 97/SC 16 N 719.  August 1981.
.IP [Kowalski78] 20
Kowalski, T.
"FSCK - The UNIX System Check Program",
Bell Laboratory, Murray Hill, NJ 07974. March 1978
.IP [Kridle83] 20
Kridle, R., and McKusick, M.,
"Performance Effects of Disk Subsystem Choices for
VAX Systems Running 4.2BSD UNIX",
Computer Systems Research Group, Dept of EECS, Berkeley, CA 94720,
Technical Report #8.
.IP [Luniewski77] 20
Luniewski, A.
"File Allocation in a Distributed System",
MIT Laboratory for Computer Science, Dec 1977.
.IP [Maruyama76]
Maruyama, K., and Smith, S.
"Optimal reorganization of Distributed Space Disk Files",
Communications of the ACM, 19, 11. Nov 1976. pp 634-642
.IP [Nevalainen77] 20
Nevalainen, O., Vesterinen, M.
"Determining Blocking Factors for Sequential Files by Heuristic Methods",
The Computer Journal, 20, 3. Aug 1977. pp 245-247
.IP [Peterson83] 20
Peterson, G.
"Concurrent Reading While Writing",
ACM Transactions on Programming Languages and Systems,
ACM, 5, 1. Jan 1983. pp 46-55
.IP [Porcar82] 20
Porcar, J.
"File Migration in Distributed Computer Systems",
Ph.D. Thesis, Lawrence Berkeley Laboratory Tech Report #LBL-14763.
.IP [Postel79] 20
Postel, J., ed.  \fIDOD Standard User Datagram Protocol\fP.
Internet Working Group, IEN 88.  May 1979.
.IP [Postel80a] 20
Postel, J., ed.  \fIDOD Standard Internet Protocol\fP.
Internet Working Group, IEN 128.  January 1980.
.IP [Postel80b] 20
Postel, J., ed.  \fIDOD Standard Transmission Control Protocol\fP.
Internet Working Group, IEN 129.  January 1980.
.IP [Powell79] 20
Powell, M.
"The DEMOS File System",
Proceedings of the Sixth Symposium on Operating Systems Principles,
ACM, Nov 1977. pp 33-42
.IP [Ritchie74] 20
Ritchie, D. M. and Thompson, K.,
"The UNIX Time-Sharing System",
CACM 17, 7. July 1974. pp 365-375
.IP [Smith81a] 20
Smith, A.
"Input/Output Optimization and Disk Architectures: A Survey",
Performance and Evaluation 1. Jan 1981. pp 104-117
.IP [Smith81b] 20
Smith, A.
"Bibliography on File and I/O System Optimization and Related Topics",
Operating Systems Review, 15, 4. Oct 1981. pp 39-54
.IP [Sturgis80] 20
Sturgis, H., Mitchell, J., and Israel, J.
"Issues in the Design and Use of a Distributed File System",
Operating Systems Review, 14, 3. pp 55-79
.IP [Symbolics81a] 20
"Symbolics File System",
Symbolics Inc, 9600 DeSoto Ave, Chatsworth, CA 91311
Aug 1981.
.IP [Symbolics81b] 20
"Chaosnet FILE Protocol".
Symbolics Inc, 9600 DeSoto Ave, Chatsworth, CA 91311
Sept 1981.
.IP [Thompson79] 20
Thompson, K.
"UNIX Implementation",
Section 31, Volume 2B, UNIX Programmers Manual,
Bell Laboratory, Murray Hill, NJ 07974. Jan 1979
.IP [Thompson80] 20
Thompson, M.
"Spice File System",
Carnegie-Mellon University, Dept of Computer Science Tech Report,
#CMU-CS-80-???
.IP [Trivedi80] 20
Trivedi, K.
"Optimal Selection of CPU Speed, Device Capabilities, and File Assignments",
Journal of the ACM, 27, 3. July 1980. pp 457-473
.IP [White80] 20
White, R. M.
"Disk Storage Technology",
Scientific American, 243(2), August 1980.
.IP [Xerox81] 20
Xerox Corporation.  \fIInternet Transport Protocols\fP. 
Xerox System Integration Standard 028112.  December 1981.
.IP [Zimmermann80] 20
Zimmermann, H.  OSI Reference Model \- The ISO Model of
Architecture for Open Systems Interconnection.
IEEE Transactions on Communications.  Com-28(4); 425-432.
April 1980.
