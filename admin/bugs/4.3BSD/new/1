Return-Path: <sun!gorodish!guy@ucbvax.Berkeley.EDU>
Received: by ucbarpa.Berkeley.EDU (5.53/1.14)
	id AA22211; Tue, 29 Jul 86 16:11:46 PDT
Received: by ucbvax.Berkeley.EDU (5.53/1.14)
	id AA22468; Tue, 29 Jul 86 15:56:12 PDT
Received: from snail.sun.com (snail-ptp) by sun.com (3.2/SMI-3.0)
	id AA14083; Tue, 29 Jul 86 15:52:08 PDT
Received: from gorodish.gorodish. com by snail.sun.com (3.2/SMI-3.2)
	id AA05766; Tue, 29 Jul 86 15:51:38 PDT
Received: by gorodish.gorodish.gorodish. com. com (3.2/SMI-3.2)
	id AA09704; Tue, 29 Jul 86 15:48:42 PDT
Date: Tue, 29 Jul 86 15:48:42 PDT
From: sun!gorodish!guy@ucbvax.Berkeley.EDU (Guy Harris)
Message-Id: <8607292248.AA09704@gorodish.gorodish.gorodish. com. com>
Subject: RCS dereferences null pointers, assumes sizeof pointer == sizeof int
Index: 	new/rcs/src 4.3BSD
To: 4bsd-bugs@ucbvax.Berkeley.EDU

Description:
	RCS dereferences a null pointer at one point.  It also assumes that
	sizeof(pointer) == sizeof(int), and can't be built if you have
	neither "sendmail" nor "delivermail" or if you have an S3/S5 system.
Repeat-By:
	Try porting it to a machine:

	1) where dereferencing a null pointer causes a fault;

	2) where "int"s and pointers aren't the same size;

	3) that run S3 or S5;

	4) that doesn't have "sendmail" or "delivermail", or is not a BSD
	system but does have "sendmail";

	or, for even more fun, a machine that meets all four of these
	criteria.
Fix:
	Here's a set of "diffs" for the 4.3 RCS, incorporating changes made
	(a long time ago, with the 4.2BSD version) for a machine that *did*
	meet all four of those criteria:

diff -c /arch/4.3/usr/src/new/rcs/src/Makefile /usr/poppy/guy/src/cmd/rcs/src/Makefile
*** /arch/4.3/usr/src/new/rcs/src/Makefile	Thu May 15 02:25:54 1986
--- /usr/poppy/guy/src/cmd/rcs/src/Makefile	Mon Jul 28 23:37:40 1986
***************
*** 1,5 ****
  
! #$Header: Makefile,v 3.5 86/05/15 02:25:37 lepreau Exp $
  
  # Copyright (C) 1982 by Walter F. Tichy
  #                       Purdue University
--- 1,5 ----
  
! #$Header: Makefile,v 3.7 86/07/28 23:34:14 guy Locked $
  
  # Copyright (C) 1982 by Walter F. Tichy
  #                       Purdue University
***************
*** 28,34 ****
  #     (That's a shell file.)
  
  # 3.  Figure out where to put the RCS commands; define TARGETDIR
! #     and merge accordingly.
  DESTDIR=
  TARGETDIR = /usr/new
  MERGE     = /usr/new/merge
--- 28,34 ----
  #     (That's a shell file.)
  
  # 3.  Figure out where to put the RCS commands; define TARGETDIR
! #     and MERGE accordingly.
  DESTDIR=
  TARGETDIR = /usr/new
  MERGE     = /usr/new/merge
***************
*** 49,75 ****
  #     a) define SNOOP (that's where the process that writes the log goes),
  #     b) define SNOOPFILE (that's the file where SNOOP writes the log; it must
  #        be owned by the same user that owns SNOOP),
! #     c) include SNOOP and SNOOPFILE in the CFLAGS macro.
  #     If you don't want the logging of command usage, omit the SNOOP and
! #     SNOOPFILE definitions from CFLAGS.
! #     The two variants of the CFLAG macros are given below.
  SNOOPFILE = /usr/wft/RCSLOG/log
  SNOOP     = /usr/wft/BIN/snoop
! #CFLAGS    = -O -DCOMPAT2 -DDIFF='"$(DIFF)"' -DMERGE='"$(MERGE)"' -DTARGETDIR='"$(TARGETDIR)"' -DSNOOPFILE='"$(SNOOPFILE)"' -DSNOOP='"$(SNOOP)"'
! CFLAGS   = -O -DDIFF='"$(DIFF)"' -DMERGE='"$(MERGE)"' -DTARGETDIR='"$(TARGETDIR)"' -DV4_2BSD
  
! # 7.  If you don't have release 2 RCS files around (e.g., if you don't have
! #     an old release of RCS), remove the word -DCOMPAT2 from whatever
! #     variant of CFLAGS you selected. -DCOMPAT2 assures that release 2
! #     RCS files can still be read. (After all release 2 RCS files have
! #     been updated with release 3 ci or rcs, you can remake RCS without
! #     -DCOMPAT2.) Also, make sure that the co commands at the end of this
! #     file are commented out; otherwise, Make will complain.
  #
! # 8.  Now you are ready. Try to make all. If all went well, make
! #     INSTALLW if you want the logging of command usage, INSTALLNO otherwise.
! #
! # 9.  IMPORTANT! When you have RCS installed, rename old RCS files as
  #     follows (if you have any):
  #     If the working file was "f.c" and the RCS file "f.c.v", rename the
  #     RCS file to "f.c,v". If the working file was "f.c" and the RCS file
--- 49,97 ----
  #     a) define SNOOP (that's where the process that writes the log goes),
  #     b) define SNOOPFILE (that's the file where SNOOP writes the log; it must
  #        be owned by the same user that owns SNOOP),
! #     c) include SNOOP and SNOOPFILE in the SNOOPDEFS macro.
  #     If you don't want the logging of command usage, omit the SNOOP and
! #     SNOOPFILE definitions from SNOOPDEFS.
  SNOOPFILE = /usr/wft/RCSLOG/log
  SNOOP     = /usr/wft/BIN/snoop
! #SNOOPDEFS = -DSNOOPFILE='"$(SNOOPFILE)"' -DSNOOP='"$(SNOOP)"'
! SNOOPDEFS =
  
! # 7.  If you are running under USG UNIX, you must define USG.
! #     If you are running under 4.2BSD or 4.3BSD, you must define V4_2BSD.
! #     If you are running under any BSD, you must also define BSD.
! #     Select the appropriate version of OSDEFS.
! #OSDEFS = -DUSG
! OSDEFS = -DV4_2BSD -DBSD
! #OSDEFS = -DBSD
! #OSDEFS = -DUSG -DV4_2BSD -DBSD
! 
! # 8.  If you have "delivermail", define DELIVERMAIL.
! #     If you have "sendmail", define SENDMAIL
! #     Select the appropriate version of DMDEFS.
! #DMDEFS = -DDELIVERMAIL
! DMDEFS = -DSENDMAIL
! #DMDEFS =
! 
! # 9.  If you don't have release 2 RCS files around (e.g., if you don't have
! #     an old release of RCS), don't define COMPAT2.
! #     If you have release 2 RCS files around, define COMPAT2.
! #     -DCOMPAT2 assures that release 2 RCS files can still be read. (After all
! #     release 2 RCS files have been updated with release 3 ci or rcs, you can
! #     remake RCS without -DCOMPAT2.)
! #     Select the appropriate version of COMPATDEFS.
! #COMPATDEFS = -DCOMPAT2
! COMPATDEFS =
! 
! # 10. Now you are ready.  Make sure that the co commands at the end of this 
! #     file are commented out; otherwise, Make will complain.  Try to make all.
! #     If all went well, make INSTALLW if you want the logging of command
! #     usage, INSTALLNO otherwise.
  #
! DEFINES = -DDIFF='"$(DIFF)"' -DMERGE='"$(MERGE)"' -DTARGETDIR='"$(TARGETDIR)"' $(OSDEFS) $(SNOOPDEFS) $(DMDEFS) $(COMPATDEFS)
! CFLAGS = -O $(DEFINES)
! 
! # 11. IMPORTANT! When you have RCS installed, rename old RCS files as
  #     follows (if you have any):
  #     If the working file was "f.c" and the RCS file "f.c.v", rename the
  #     RCS file to "f.c,v". If the working file was "f.c" and the RCS file
***************
*** 76,82 ****
  #     "f.v", rename the RCS file "f.c,v". Thus, suffixes are no longer
  #     dropped and RCS files end in ",v" rather than ".v".
  #
! # 10. If you want to maintain RCS with itself, be sure you preserve the
  #     original revision numbers, dates, etc. This is done by checking the
  #     files in with the -k option. When done, remove the comments from the
  #     co-rules at the end of this file.
--- 98,104 ----
  #     "f.v", rename the RCS file "f.c,v". Thus, suffixes are no longer
  #     dropped and RCS files end in ",v" rather than ".v".
  #
! # 12. If you want to maintain RCS with itself, be sure you preserve the
  #     original revision numbers, dates, etc. This is done by checking the
  #     files in with the -k option. When done, remove the comments from the
  #     co-rules at the end of this file.
***************
*** 85,93 ****
--- 107,121 ----
  	rcsedit.o rcsutil.o rcsfnms.o co.o ci.o ident.o rlog.o rcs.o\
  	rcsdiff.o rcsmerge.o rcskeep.o rcsfcmp.o snoop.o
  RCSCOMMANDS = ci ident rcs rcsdiff rcsmerge rlog co sccstorcs
+ RCSLINT = cilint identlint rcslint rcsdifflint rcsmergelint rloglint colint sccstorcslint
  
+ LINT = lint
+ LINTFLAGS = -hbax
+ 
  all:		merge $(RCSCOMMANDS)
  
+ lintall:	$(RCSLINT)
+ 
  INSTALLW:	INSTALLSNOOP INSTALLNO
  
  install:	INSTALLNO
***************
*** 97,109 ****
  #		This takes out the comment lines and fixes the DIFF3 definition
  		chmod 755 $(DESTDIR)$(MERGE) $(RCSCOMMANDS)
  #		Save the old commands if you have any.
! #		mv $(TARGETDIR)/co $(OLDDIR)/co
! #		mv $(TARGETDIR)/ci $(OLDDIR)/ci
! #		mv $(TARGETDIR)/rlog $(OLDDIR)/rlog
! #		mv $(TARGETDIR)/rcs $(OLDDIR)/rcs
! #		mv $(TARGETDIR)/ident $(OLDDIR)/ident
  		for i in ${RCSCOMMANDS}; do \
! 			(install -o root -s $$i ${DESTDIR}$(TARGETDIR)/$$i); done
  
  INSTALLSNOOP:	snoop
  		strip snoop
--- 125,137 ----
  #		This takes out the comment lines and fixes the DIFF3 definition
  		chmod 755 $(DESTDIR)$(MERGE) $(RCSCOMMANDS)
  #		Save the old commands if you have any.
! #		mv $(DESTDIR)$(TARGETDIR)/co $(DESTDIR)$(OLDDIR)/co
! #		mv $(DESTDIR)$(TARGETDIR)/ci $(DESTDIR)$(OLDDIR)/ci
! #		mv $(DESTDIR)$(TARGETDIR)/rlog $(DESTDIR)$(OLDDIR)/rlog
! #		mv $(DESTDIR)$(TARGETDIR)/rcs $(DESTDIR)$(OLDDIR)/rcs
! #		mv $(DESTDIR)$(TARGETDIR)/ident $(DESTDIR)$(OLDDIR)/ident
  		for i in ${RCSCOMMANDS}; do \
! 			(install -s $$i ${DESTDIR}$(TARGETDIR)/$$i); done
  
  INSTALLSNOOP:	snoop
  		strip snoop
***************
*** 120,161 ****
  
  partime.o maketime.o co.o ci.o rlog.o rcsutil.o:	time.h
  
!  CI = ci.o rcslex.o rcssyn.o rcsgen.o rcsedit.o rcsrev.o rcsutil.o rcsfnms.o rcskeep.o rcsfcmp.o
! ci:		$(CI); cc $(LDFLAGS) -o ci $(CI)
  
! CO = co.o rcslex.o rcssyn.o rcsgen.o rcsedit.o rcsrev.o rcsutil.o rcsfnms.o partime.o maketime.o
! co:		$(CO); cc $(LDFLAGS) -o co $(CO)
  
  ident:		ident.o
! 		cc -o ident ident.o
  
! RLOG = rlog.o rcslex.o rcssyn.o rcsrev.o rcsutil.o partime.o maketime.o rcsfnms.o
! rlog:		$(RLOG); cc $(LDFLAGS) -o rlog $(RLOG)
  
! RCS = rcs.o rcslex.o rcssyn.o rcsrev.o rcsutil.o rcsgen.o rcsedit.o rcsfnms.o
! rcs:		$(RCS); cc $(LDFLAGS) -o rcs $(RCS)
  
! RCSDIFF = rcsdiff.o rcsutil.o rcsfnms.o rcsrev.o rcssyn.o rcslex.o
! rcsdiff:	$(RCSDIFF); cc -o rcsdiff $(RCSDIFF)
  
! RCSMERGE = rcsmerge.o rcsutil.o rcsfnms.o rcsrev.o rcssyn.o rcslex.o
! rcsmerge:	$(RCSMERGE); cc -o rcsmerge $(RCSMERGE)
  
! SCCSTORCS = sccstorcs.o
! sccstorcs:	$(SCCSTORCS); cc -o sccstorcs $(SCCSTORCS)
  
  snoop:		snoop.o
! 		cc -o snoop snoop.o
  
  PAIRTEST = rcsfnmsTST.o rcssyn.o rcslex.o
! pairtest:	$(PAIRTEST); cc -o pairtest $(PAIRTEST)
  
  rcsfnmsTST.o:   rcsfnms.c
! 		cc -c -DPAIRTEST rcsfnms.c
  		mv rcsfnms.o rcsfnmsTST.o
  
  REVTEST = rcsrevTST.o rcssyn.o rcslex.o
! revtest:	$(REVTEST); cc $(REVTEST)
  		echo "a.out ../TEST/rev.test.v <../TEST/rev.test.in >&! tmp" |csh
  		diff tmp ../TEST/rev.test.out
  		rm tmp
--- 148,207 ----
  
  partime.o maketime.o co.o ci.o rlog.o rcsutil.o:	time.h
  
! CIOBJ = ci.o rcslex.o rcssyn.o rcsgen.o rcsedit.o rcsrev.o rcsutil.o rcsfnms.o rcskeep.o rcsfcmp.o
! CISRC = ci.c rcslex.c rcssyn.c rcsgen.c rcsedit.c rcsrev.c rcsutil.c rcsfnms.c rcskeep.c rcsfcmp.c
! ci:		$(CIOBJ); $(CC) $(LDFLAGS) -o ci $(CIOBJ)
! cilint:		$(CISRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(CISRC) 
  
! COOBJ = co.o rcslex.o rcssyn.o rcsgen.o rcsedit.o rcsrev.o rcsutil.o rcsfnms.o partime.o maketime.o
! COSRC = co.c rcslex.c rcssyn.c rcsgen.c rcsedit.c rcsrev.c rcsutil.c rcsfnms.c partime.c maketime.c
! co:		$(COOBJ); $(CC) $(LDFLAGS) -o co $(COOBJ)
! colint:		$(COSRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(COSRC) 
  
  ident:		ident.o
! 		$(CC) -o ident ident.o
! identlint:	ident.c
! 		$(LINT) $(LINTFLAGS) $(DEFINES) ident.c 
  
! RLOGOBJ = rlog.o rcslex.o rcssyn.o rcsrev.o rcsutil.o partime.o maketime.o rcsfnms.o
! RLOGSRC = rlog.c rcslex.c rcssyn.c rcsrev.c rcsutil.c partime.c maketime.c rcsfnms.c
! rlog:		$(RLOGOBJ); $(CC) $(LDFLAGS) -o rlog $(RLOGOBJ)
! rloglint:	$(RLOGSRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(RLOGSRC) 
  
! RCSOBJ = rcs.o rcslex.o rcssyn.o rcsrev.o rcsutil.o rcsgen.o rcsedit.o rcsfnms.o
! RCSSRC = rcs.c rcslex.c rcssyn.c rcsrev.c rcsutil.c rcsgen.c rcsedit.c rcsfnms.c
! rcs:		$(RCSOBJ); $(CC) $(LDFLAGS) -o rcs $(RCSOBJ)
! rcslint:	$(RCSSRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(RCSSRC) 
  
! RCSDIFFOBJ = rcsdiff.o rcsutil.o rcsfnms.o rcsrev.o rcssyn.o rcslex.o
! RCSDIFFSRC = rcsdiff.c rcsutil.c rcsfnms.c rcsrev.c rcssyn.c rcslex.c
! rcsdiff:	$(RCSDIFFOBJ); $(CC) -o rcsdiff $(RCSDIFFOBJ)
! rcsdifflint:	$(RCSDIFFSRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(RCSDIFFSRC) 
  
! RCSMERGEOBJ = rcsmerge.o rcsutil.o rcsfnms.o rcsrev.o rcssyn.o rcslex.o
! RCSMERGESRC = rcsmerge.c rcsutil.c rcsfnms.c rcsrev.c rcssyn.c rcslex.c
! rcsmerge:	$(RCSMERGEOBJ); $(CC) -o rcsmerge $(RCSMERGEOBJ)
! rcsmergelint:	$(RCSMERGESRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(RCSMERGESRC) 
  
! SCCSTORCSOBJ = sccstorcs.o
! SCCSTORCSSRC = sccstorcs.c
! sccstorcs:	$(SCCSTORCSOBJ); $(CC) -o sccstorcs $(SCCSTORCSOBJ)
! sccstorcslint:	$(SCCSTORCSSRC); $(LINT) $(LINTFLAGS) $(DEFINES) $(SCCSTORCSSRC) 
  
  snoop:		snoop.o
! 		$(CC) -o snoop snoop.o
! snooplint:	snoop.c
! 		$(LINT) $(LINTFLAGS) $(DEFINES) snoop.c 
  
  PAIRTEST = rcsfnmsTST.o rcssyn.o rcslex.o
! pairtest:	$(PAIRTEST); $(CC) -o pairtest $(PAIRTEST)
  
  rcsfnmsTST.o:   rcsfnms.c
! 		$(CC) -c -DPAIRTEST rcsfnms.c
  		mv rcsfnms.o rcsfnmsTST.o
  
  REVTEST = rcsrevTST.o rcssyn.o rcslex.o
! revtest:	$(REVTEST); $(CC) $(REVTEST)
  		echo "a.out ../TEST/rev.test.v <../TEST/rev.test.in >&! tmp" |csh
  		diff tmp ../TEST/rev.test.out
  		rm tmp
***************
*** 162,172 ****
  		mv a.out revtest
  
  rcsrevTST.o:	rcsrev.c
! 		cc -c -DREVTEST rcsrev.c
  		mv rcsrev.o rcsrevTST.o
  
  SYNTEST = rcslex.o rcssynTST.o rcsrev.o
! syntest:	$(SYNTEST); cc $(SYNTEST)
  		echo "a.out ../TEST/syn.test >&! tmp" | csh
  		diff tmp ../TEST/syn.result
  		rm tmp
--- 208,218 ----
  		mv a.out revtest
  
  rcsrevTST.o:	rcsrev.c
! 		$(CC) -c -DREVTEST rcsrev.c
  		mv rcsrev.o rcsrevTST.o
  
  SYNTEST = rcslex.o rcssynTST.o rcsrev.o
! syntest:	$(SYNTEST); $(CC) $(SYNTEST)
  		echo "a.out ../TEST/syn.test >&! tmp" | csh
  		diff tmp ../TEST/syn.result
  		rm tmp
***************
*** 173,183 ****
  		mv a.out syntest
  
  rcssynTST.o:	rcssyn.c
! 		cc -c -DSYNDB -DCOMPAT2 -DSYNTEST rcssyn.c
  		mv rcssyn.o rcssynTST.o
  
  lextest:	rcslex.c
! 		cc -DLEXDB rcslex.c
  		echo "a.out ../TEST/lex.test >&! tmp" | csh
  		diff tmp ../TEST/lex.result
  		rm tmp
--- 219,229 ----
  		mv a.out syntest
  
  rcssynTST.o:	rcssyn.c
! 		$(CC) -c -DSYNDB -DCOMPAT2 -DSYNTEST rcssyn.c
  		mv rcssyn.o rcssynTST.o
  
  lextest:	rcslex.c
! 		$(CC) -DLEXDB rcslex.c
  		echo "a.out ../TEST/lex.test >&! tmp" | csh
  		diff tmp ../TEST/lex.result
  		rm tmp
diff -c /arch/4.3/usr/src/new/rcs/src/ci.c /usr/poppy/guy/src/cmd/rcs/src/ci.c
*** /arch/4.3/usr/src/new/rcs/src/ci.c	Thu Oct 24 08:31:02 1985
--- /usr/poppy/guy/src/cmd/rcs/src/ci.c	Tue Jul 29 13:01:04 1986
***************
*** 1,8 ****
  /*
   *                     RCS checkin operation
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/ci.c,v 3.9 83/02/15 15:25:44 wft Exp $ Purdue CS";
  /*******************************************************************
   *                       check revisions into RCS files
   *******************************************************************
--- 1,10 ----
  /*
   *                     RCS checkin operation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: ci.c,v 3.11 86/07/28 23:21:50 guy Exp $ Purdue CS";
! #endif
  /*******************************************************************
   *                       check revisions into RCS files
   *******************************************************************
***************
*** 21,26 ****
--- 23,36 ----
  
  
  /* $Log:	ci.c,v $
+  * Revision 3.11  86/07/28  23:21:50  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.10  86/07/19  02:11:02  guy
+  * Bug fix from Ray Chen to completely check symbolic names added to the
+  * RCS file.
+  * Fixed to cast null pointers properly.
+  * 
   * Revision 3.9  83/02/15  15:25:44  wft
   * Added call to fastcopy() to copy remainder of RCS file.
   * 
***************
*** 65,71 ****
--- 75,83 ----
   */
  
  #include "rcsbase.h"
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <pwd.h>
***************
*** 123,128 ****
--- 135,141 ----
  {
          register int i;
          register char * sp, *tp;
+ 	char * nametest;
          char * cmdusage;         /* holds command format                    */
          char command[NCPPN+50];  /* holds diff commands                     */
          char curdate[datelength];/* date for new delta                      */
***************
*** 182,188 ****
                                  }
                                  if (msg[msglen-1]!='\n') {
                                     /*append linefeed*/
!                                    strcpy(logmsg,msg);msg=logmsg;
                                     msg[msglen]  = '\n';
                                     msg[++msglen]= '\0';
                                  }
--- 195,201 ----
                                  }
                                  if (msg[msglen-1]!='\n') {
                                     /*append linefeed*/
!                                    VOID strcpy(logmsg,msg);msg=logmsg;
                                     msg[msglen]  = '\n';
                                     msg[++msglen]= '\0';
                                  }
***************
*** 194,200 ****
                          if ((*argv)[2]!='\0'){
                                  if (symbol!=nil)warn("Redefinition of symbolic name");
                                  symbol = (*argv)+2;
!                                 checkid(symbol,' ');
                          } else warn("Missing name for -n option");
                          break;
  
--- 207,214 ----
                          if ((*argv)[2]!='\0'){
                                  if (symbol!=nil)warn("Redefinition of symbolic name");
                                  symbol = (*argv)+2;
! 				if (!(nametest=checkid(symbol,' '))||*nametest)
! 					faterror("Name %s must be one word",symbol);
                          } else warn("Missing name for -n option");
                          break;
  
***************
*** 203,209 ****
                          if ((*argv)[2]!='\0'){
                                  if (symbol!=nil)warn("Redefinition of symbolic name");
                                  symbol = (*argv)+2;
!                                 checkid(symbol,' ');
                          } else warn("Missing name for -N option");
                          break;
  
--- 217,224 ----
                          if ((*argv)[2]!='\0'){
                                  if (symbol!=nil)warn("Redefinition of symbolic name");
                                  symbol = (*argv)+2;
! 				if (!(nametest=checkid(symbol,' '))||*nametest)
! 					faterror("Name %s must be one word",symbol);
                          } else warn("Missing name for -N option");
                          break;
  
***************
*** 272,278 ****
          if (initflag || rcsinitflag) /* get mode for RCSfile from workfile*/
              stat(workfilename, &filestatus);
          else /* otherwise keep the one from the RCS file.*/
!             fstat(fileno(finptr), &filestatus);
  
          if (!trydiraccess(RCSfilename)) continue; /* give up */
          if (!initflag && !checkaccesslist(caller))   continue; /* give up */
--- 287,293 ----
          if (initflag || rcsinitflag) /* get mode for RCSfile from workfile*/
              stat(workfilename, &filestatus);
          else /* otherwise keep the one from the RCS file.*/
!             VOID fstat(fileno(finptr), &filestatus);
  
          if (!trydiraccess(RCSfilename)) continue; /* give up */
          if (!initflag && !checkaccesslist(caller))   continue; /* give up */
***************
*** 303,310 ****
  
          if (initflag || rcsinitflag ) {
                  /* this covers non-existing RCS file and a file initialized with rcs -i */
!                 if (newdnumlength==0) strcpy(newdelnum,"1.1");
!                 elsif (newdnumlength==1) strcat(newdelnum,".1");
                  elsif (newdnumlength>2) {
                          error("Branch point does not exist for %s",
                          newdelnum);
--- 318,325 ----
  
          if (initflag || rcsinitflag ) {
                  /* this covers non-existing RCS file and a file initialized with rcs -i */
!                 if (newdnumlength==0) VOID strcpy(newdelnum,"1.1");
!                 elsif (newdnumlength==1) VOID strcat(newdelnum,".1");
                  elsif (newdnumlength>2) {
                          error("Branch point does not exist for %s",
                          newdelnum);
***************
*** 315,323 ****
                  newdelta.next=nil;
          } elsif (newdnumlength==0) {
                  /* derive new revision number from locks */
!                 if(!(targetdelta=removelock(caller,nil))) continue;
                  olddeltanum=targetdelta->num;
!                 if (!genrevs(olddeltanum,nil,nil,nil,gendeltas)) continue;
  
                  if (targetdelta==Head) {
                          /* make new head */
--- 330,338 ----
                  newdelta.next=nil;
          } elsif (newdnumlength==0) {
                  /* derive new revision number from locks */
!                 if(!(targetdelta=removelock(caller,(struct hshentry *)nil))) continue;
                  olddeltanum=targetdelta->num;
!                 if (!genrevs(olddeltanum,(char *)nil,(char *)nil,(char *)nil,gendeltas)) continue;
  
                  if (targetdelta==Head) {
                          /* make new head */
***************
*** 343,349 ****
                          /* make a two-field number out of it*/
                          if (cmpnumfld(newdelnum,olddeltanum,1)==0)
                                  incnum(olddeltanum,newdelnum);
!                         else    strcat(newdelnum, ".1");
                  }
                  if (cmpnum(newdelnum,olddeltanum) <= 0) {
                          error("deltanumber %s too low; must be higher than %s",
--- 358,364 ----
                          /* make a two-field number out of it*/
                          if (cmpnumfld(newdelnum,olddeltanum,1)==0)
                                  incnum(olddeltanum,newdelnum);
!                         else    VOID strcat(newdelnum, ".1");
                  }
                  if (cmpnum(newdelnum,olddeltanum) <= 0) {
                          error("deltanumber %s too low; must be higher than %s",
***************
*** 351,357 ****
                          continue;
                  }
                  if (!(targetdelta=removelock(caller,Head))) continue;
!                 if (!(genrevs(olddeltanum,nil,nil,nil,gendeltas))) continue;
                  newdelta.next=Head;
                  Head= &newdelta;
  
--- 366,372 ----
                          continue;
                  }
                  if (!(targetdelta=removelock(caller,Head))) continue;
!                 if (!(genrevs(olddeltanum,(char *)nil,(char *)nil,(char *)nil,gendeltas))) continue;
                  newdelta.next=Head;
                  Head= &newdelta;
  
***************
*** 365,371 ****
                  }
                  *(tp-1) = '\0'; /* kill final dot */
                  olddeltanum=branchpointnum; /*temporary old delta*/
!                 if (!(targetdelta=genrevs(branchpointnum,nil,nil,nil,gendeltas))) continue;
                  if (cmpnum(targetdelta->num,branchpointnum)!=0) {
                          error("Cannot find branchpoint %s",branchpointnum);
                          continue;
--- 380,386 ----
                  }
                  *(tp-1) = '\0'; /* kill final dot */
                  olddeltanum=branchpointnum; /*temporary old delta*/
!                 if (!(targetdelta=genrevs(branchpointnum,(char *)nil,(char *)nil,(char *)nil,gendeltas))) continue;
                  if (cmpnum(targetdelta->num,branchpointnum)!=0) {
                          error("Cannot find branchpoint %s",branchpointnum);
                          continue;
***************
*** 426,432 ****
                          if (!mustcheckin(expfilename,targetdelta)) continue;
                                  /* don't check in files that aren't different, unless forced*/
                          newdelta.log=getlogmsg();
!                         sprintf(command,"%s -n %s %s > %s\n", DIFF,
                                  workfilename,expfilename,diffilename);
                          exit_stats = system (command);
                          if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
--- 441,447 ----
                          if (!mustcheckin(expfilename,targetdelta)) continue;
                                  /* don't check in files that aren't different, unless forced*/
                          newdelta.log=getlogmsg();
!                         VOID sprintf(command,"%s -n %s %s > %s\n", DIFF,
                                  workfilename,expfilename,diffilename);
                          exit_stats = system (command);
                          if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
***************
*** 442,448 ****
                          if (!mustcheckin(expfilename,targetdelta)) continue;
                                  /* don't check in files that aren't different, unless forced*/
                          newdelta.log=getlogmsg();
!                         sprintf(command,"%s -n %s %s > %s\n", DIFF,
                                  expfilename,workfilename,diffilename);
                          exit_stats = system (command);
                          if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
--- 457,463 ----
                          if (!mustcheckin(expfilename,targetdelta)) continue;
                                  /* don't check in files that aren't different, unless forced*/
                          newdelta.log=getlogmsg();
!                         VOID sprintf(command,"%s -n %s %s > %s\n", DIFF,
                                  expfilename,workfilename,diffilename);
                          exit_stats = system (command);
                          if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
***************
*** 473,479 ****
  #       endif
  
          if (!keepworkingfile) {
!                 unlink(workfilename); /* get rid of old file */
          } else {
                  /* expand keywords in file */
                  newworkfilename=
--- 488,494 ----
  #       endif
  
          if (!keepworkingfile) {
!                 VOID unlink(workfilename); /* get rid of old file */
          } else {
                  /* expand keywords in file */
                  newworkfilename=
***************
*** 480,486 ****
                  xpandfile(workfilename,workfilename /*for directory*/,&newdelta);
                  if (!newworkfilename) continue; /* expand failed */
  		ignoreints();
!                 unlink(workfilename);
                  if (link(newworkfilename,workfilename)<0) {
                      error("Can't expand keywords in %s",workfilename);
  		    catchints();
--- 495,501 ----
                  xpandfile(workfilename,workfilename /*for directory*/,&newdelta);
                  if (!newworkfilename) continue; /* expand failed */
  		ignoreints();
!                 VOID unlink(workfilename);
                  if (link(newworkfilename,workfilename)<0) {
                      error("Can't expand keywords in %s",workfilename);
  		    catchints();
***************
*** 496,501 ****
--- 511,517 ----
                   ++argv, --argc >=1);
  
          exit(nerror!=0);
+ 	/*NOTREACHED*/
  }       /* end of main (ci) */
  /*****************************************************************/
  /* the rest are auxiliary routines                               */
***************
*** 522,531 ****
                  /* start first branch */
                  branchpoint->branches = &newbranch;
                  if (numlength==0) {
!                         strcpy(num, branchpoint->num);
!                         strcat(num,".1.1");
                  } elsif(countnumflds(num)%2 == 1)
!                         strcat(num, ".1");
                  newbranch.nextbranch=nil;
  
          } elsif (numlength==0) {
--- 538,547 ----
                  /* start first branch */
                  branchpoint->branches = &newbranch;
                  if (numlength==0) {
!                         VOID strcpy(num, branchpoint->num);
!                         VOID strcat(num,".1.1");
                  } elsif(countnumflds(num)%2 == 1)
!                         VOID strcat(num, ".1");
                  newbranch.nextbranch=nil;
  
          } elsif (numlength==0) {
***************
*** 535,541 ****
                  bhead->nextbranch = &newbranch;
                  getbranchno(bhead->hsh->num,branchnum);
                  incnum(branchnum,num);
!                 strcat(num,".1");
                  newbranch.nextbranch=nil;
          } else {
                  /* place the branch properly */
--- 551,557 ----
                  bhead->nextbranch = &newbranch;
                  getbranchno(bhead->hsh->num,branchnum);
                  incnum(branchnum,num);
!                 VOID strcat(num,".1");
                  newbranch.nextbranch=nil;
          } else {
                  /* place the branch properly */
***************
*** 553,563 ****
                                  branchpoint->branches= &newbranch;
                          else    btrail->nextbranch= &newbranch;
                          newbranch.nextbranch=bhead;
!                         if (numlength%2 ==1) strcat(num,".1");
                  } else {
                          /* branch exists; append to end */
                          getbranchno(num,branchnum);
!                         if (!(targetdelta=genrevs(branchnum,nil,nil,nil,gendeltas))) return false;
                          olddeltanum=targetdelta->num;
                          if (cmpnum(num,olddeltanum) <= 0) {
                                  error("deltanumber %s too low; must be higher than %s",
--- 569,580 ----
                                  branchpoint->branches= &newbranch;
                          else    btrail->nextbranch= &newbranch;
                          newbranch.nextbranch=bhead;
!                         if (numlength%2 ==1) VOID strcat(num,".1");
                  } else {
                          /* branch exists; append to end */
                          getbranchno(num,branchnum);
!                         if (!(targetdelta=genrevs(branchnum,(char *)nil,(char *)nil,(char *)nil,
!                                 gendeltas))) return false;
                          olddeltanum=targetdelta->num;
                          if (cmpnum(num,olddeltanum) <= 0) {
                                  error("deltanumber %s too low; must be higher than %s",
***************
*** 621,627 ****
                  next->delta->lockedby=nil; /* reset locked-by */
                  return next->delta;
          } else {
!                 fstat(fileno(finptr), &statbuf);
                  owner= (StrictLocks==false) && (getuid() == statbuf.st_uid);
                  if (!owner) {
                          if (num==nil) error("no lock set by %s",who);
--- 638,644 ----
                  next->delta->lockedby=nil; /* reset locked-by */
                  return next->delta;
          } else {
!                 VOID fstat(fileno(finptr), &statbuf);
                  owner= (StrictLocks==false) && (getuid() == statbuf.st_uid);
                  if (!owner) {
                          if (num==nil) error("no lock set by %s",who);
***************
*** 658,666 ****
          extern long time();
          long clock;
          struct tm * tm;
!         clock=time(0);
          tm=localtime(&clock);
!         sprintf(buffer, DATEFORM,
                  tm->tm_year, tm->tm_mon+1, tm->tm_mday,
                  tm->tm_hour, tm->tm_min, tm->tm_sec);
          return buffer;
--- 675,683 ----
          extern long time();
          long clock;
          struct tm * tm;
!         clock=time((long *)0);
          tm=localtime(&clock);
!         VOID sprintf(buffer, DATEFORM,
                  tm->tm_year, tm->tm_mon+1, tm->tm_mday,
                  tm->tm_hour, tm->tm_min, tm->tm_sec);
          return buffer;
***************
*** 714,720 ****
                  result=false;
          } else {
                  /* ask user whether to check in */
!                 fputs("checkin anyway? [ny](n): ",stdout);
                  response=c=getchar();
                  while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
  		if (c == EOF)
--- 731,737 ----
                  result=false;
          } else {
                  /* ask user whether to check in */
!                 VOID fputs("checkin anyway? [ny](n): ",stdout);
                  response=c=getchar();
                  while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
  		if (c == EOF)
***************
*** 729,735 ****
                      diagnose("checkin aborted; %s %sdeleted.",
                               workfilename,keepworkingfile?"not ":"");
                  }
!                 if (!keepworkingfile) unlink(workfilename);
          }
          return result;
  }
--- 746,752 ----
                      diagnose("checkin aborted; %s %sdeleted.",
                               workfilename,keepworkingfile?"not ":"");
                  }
!                 if (!keepworkingfile) VOID unlink(workfilename);
          }
          return result;
  }
***************
*** 769,775 ****
                  /*previous log available*/
                  if (!isatty(fileno(stdin))) return logmsg; /* reuse if stdin is not a terminal*/
                  /* otherwise ask */
!                 fputs("reuse log message of previous file? [yn](y): ",stdout);
                  cin=getchar();
  		response=cin;
                  while (!(cin==EOF || cin=='\n')) cin=getchar();/*skip to end of line*/
--- 786,792 ----
                  /*previous log available*/
                  if (!isatty(fileno(stdin))) return logmsg; /* reuse if stdin is not a terminal*/
                  /* otherwise ask */
!                 VOID fputs("reuse log message of previous file? [yn](y): ",stdout);
                  cin=getchar();
  		response=cin;
                  while (!(cin==EOF || cin=='\n')) cin=getchar();/*skip to end of line*/
***************
*** 783,795 ****
  
          /* now read string from terminal */
          if (isatty(fileno(stdin)))
!                fputs("enter log message:\n(terminate with ^D or single '.')\n>> ",stdout);
          tp=logmsg; old1='\n'; old2=' ';
          for (;;) {
                  cin=getchar();
                  if (cin==EOF) {
                          if(isatty(fileno(stdin))) {
! 				putc('\n',stdout);
  				clearerr(stdin);
  			}
                          if (*(tp-1) != '\n') *tp++ = '\n'; /* append newline */
--- 800,812 ----
  
          /* now read string from terminal */
          if (isatty(fileno(stdin)))
!                VOID fputs("enter log message:\n(terminate with ^D or single '.')\n>> ",stdout);
          tp=logmsg; old1='\n'; old2=' ';
          for (;;) {
                  cin=getchar();
                  if (cin==EOF) {
                          if(isatty(fileno(stdin))) {
! 				VOID putc('\n',stdout);
  				clearerr(stdin);
  			}
                          if (*(tp-1) != '\n') *tp++ = '\n'; /* append newline */
***************
*** 806,818 ****
                                  logmsg[logsize-2]='\n';logmsg[logsize-1]='\0';
                                  return logmsg;
                          }
!                         fprintf(stdout,"log message too long. Maximum: %d\n",logsize);
!                         fputs("reenter log message:\n>> ",stdout);
                          tp=logmsg; old1='\n'; old2=' ';
                          while (cin!='\n' && cin!=EOF) cin=getchar(); /*skip line */
                          continue;
                  }
!                 if (cin=='\n' && isatty(fileno(stdin))) fputs(">> ",stdout);
                  *tp++ = cin; old2=old1; old1=cin; /* this is the actual work!*/
                  /*SDELIM will be changed to double SDELIM by putdtext*/
          } /* end for */
--- 823,835 ----
                                  logmsg[logsize-2]='\n';logmsg[logsize-1]='\0';
                                  return logmsg;
                          }
!                         VOID fprintf(stdout,"log message too long. Maximum: %d\n",logsize);
!                         VOID fputs("reenter log message:\n>> ",stdout);
                          tp=logmsg; old1='\n'; old2=' ';
                          while (cin!='\n' && cin!=EOF) cin=getchar(); /*skip line */
                          continue;
                  }
!                 if (cin=='\n' && isatty(fileno(stdin))) VOID fputs(">> ",stdout);
                  *tp++ = cin; old2=old1; old1=cin; /* this is the actual work!*/
                  /*SDELIM will be changed to double SDELIM by putdtext*/
          } /* end for */
diff -c /arch/4.3/usr/src/new/rcs/src/co.c /usr/poppy/guy/src/cmd/rcs/src/co.c
*** /arch/4.3/usr/src/new/rcs/src/co.c	Thu Oct 24 08:31:02 1985
--- /usr/poppy/guy/src/cmd/rcs/src/co.c	Mon Jul 28 23:24:59 1986
***************
*** 1,8 ****
  /*
   *                     RCS checkout operation
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/co.c,v 3.7 83/02/15 15:27:07 wft Exp $ Purdue CS";
  /*****************************************************************************
   *                       check out revisions from RCS files
   *****************************************************************************
--- 1,10 ----
  /*
   *                     RCS checkout operation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: co.c,v 3.9 86/07/28 23:22:29 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       check out revisions from RCS files
   *****************************************************************************
***************
*** 20,25 ****
--- 22,33 ----
  
  
  /* $Log:	co.c,v $
+  * Revision 3.9  86/07/28  23:22:29  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.8  86/07/19  02:15:26  guy
+  * Fixed to properly cast/declare null pointers and routines returning pointers.
+  * 
   * Revision 3.7  83/02/15  15:27:07  wft
   * Added call to fastcopy() to copy remainder of RCS file.
   * 
***************
*** 66,72 ****
--- 74,82 ----
  #include <sys/types.h>
  #include <sys/stat.h>
  
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  extern FILE * fopen();
  extern int    rename();
***************
*** 73,78 ****
--- 83,89 ----
  extern struct passwd *getpwuid();
  extern char * malloc();
  extern struct hshentry * genrevs(); /*generate delta numbers                */
+ extern char * getancestor();
  extern int  nextc;                  /*next input character                  */
  extern int  nerror;                 /*counter for errors                    */
  extern char * Kdesc;                /*keyword for description               */
***************
*** 109,115 ****
  int argc;
  char * argv[];
  {
-         register c;
          char * cmdusage;
          struct stat RCSstat;
          struct tm parseddate, *ftm;
--- 120,125 ----
***************
*** 154,160 ****
                          if ((unixtime=maketime(&parseddate))== 0L)
                                  faterror("Inconsistent date/time: %s",rawdate);
                          ftm=localtime(&unixtime);
!                         sprintf(finaldate,DATEFORM,
                          ftm->tm_year,ftm->tm_mon+1,ftm->tm_mday,ftm->tm_hour,ftm->tm_min,ftm->tm_sec);
                          date=finaldate;
                          break;
--- 164,170 ----
                          if ((unixtime=maketime(&parseddate))== 0L)
                                  faterror("Inconsistent date/time: %s",rawdate);
                          ftm=localtime(&unixtime);
!                         VOID sprintf(finaldate,DATEFORM,
                          ftm->tm_year,ftm->tm_mon+1,ftm->tm_mday,ftm->tm_hour,ftm->tm_min,ftm->tm_sec);
                          date=finaldate;
                          break;
***************
*** 202,208 ****
           */
          diagnose("%s  -->  %s", RCSfilename,tostdout?"stdout":workfilename);
  
!         fstat(fileno(finptr),&RCSstat); /* get file status, esp. the mode  */
  
          if (!tostdout && !trydiraccess(workfilename)) continue; /* give up */
          if (lockflag && !checkaccesslist(caller)) continue;     /* give up */
--- 212,218 ----
           */
          diagnose("%s  -->  %s", RCSfilename,tostdout?"stdout":workfilename);
  
!         VOID fstat(fileno(finptr),&RCSstat); /* get file status, esp. the mode  */
  
          if (!tostdout && !trydiraccess(workfilename)) continue; /* give up */
          if (lockflag && !checkaccesslist(caller)) continue;     /* give up */
***************
*** 216,222 ****
                  diagnose("no revisions present; generating empty revision 0.0");
                  if (!tostdout)
                          if (!creatempty(workfilename)) continue;
!                 else    putchar('\0'); /* end of file */
                  /* Can't reserve a delta, so don't call addlock */
          } else {
                  /* expand symbolic revision number */
--- 226,232 ----
                  diagnose("no revisions present; generating empty revision 0.0");
                  if (!tostdout)
                          if (!creatempty(workfilename)) continue;
!                 else    VOID putchar('\0'); /* end of file */
                  /* Can't reserve a delta, so don't call addlock */
          } else {
                  /* expand symbolic revision number */
***************
*** 247,253 ****
                          }
                          putadmin(frewrite);
                          puttree(Head,frewrite);
!                         fprintf(frewrite, "\n\n%s%c",Kdesc,nextc);
                          rewriteflag=true;
                  }
  
--- 257,263 ----
                          }
                          putadmin(frewrite);
                          puttree(Head,frewrite);
!                         VOID fprintf(frewrite, "\n\n%s%c",Kdesc,nextc);
                          rewriteflag=true;
                  }
  
***************
*** 255,261 ****
                  getdesc(false); /* don't echo*/
  
                  if (!(neworkfilename=buildrevision(gendeltas,targetdelta,
!                       tostdout?(join!=nil?"/tmp/":nil):workfilename,true)))
                                  continue;
  
                  if (lockflag&&nerror==0) {
--- 265,271 ----
                  getdesc(false); /* don't echo*/
  
                  if (!(neworkfilename=buildrevision(gendeltas,targetdelta,
!                       tostdout?(join!=nil?"/tmp/":(char *)nil):workfilename,true)))
                                  continue;
  
                  if (lockflag&&nerror==0) {
***************
*** 327,333 ****
  
          if (buf.st_mode & 0222) {            /* File is writable */
              if (!quietflag) {
!                 fprintf(stderr,"writable %s exists; overwrite? [ny](n): ",ofile);
                  /* must be stderr in case of IO redirect */
                  c=response=getchar();
                  while (!(c==EOF || c=='\n')) c=getchar(); /*skip rest*/
--- 337,343 ----
  
          if (buf.st_mode & 0222) {            /* File is writable */
              if (!quietflag) {
!                 VOID fprintf(stderr,"writable %s exists; overwrite? [ny](n): ",ofile);
                  /* must be stderr in case of IO redirect */
                  c=response=getchar();
                  while (!(c==EOF || c=='\n')) c=getchar(); /*skip rest*/
***************
*** 365,371 ****
                  faterror("Cannot create %s",file);
                  return false;
          } else {
!                 close(fdesc); /* empty file */
                  return true;
          }
  }
--- 375,381 ----
                  faterror("Cannot create %s",file);
                  return false;
          } else {
!                 VOID close(fdesc); /* empty file */
                  return true;
          }
  }
***************
*** 425,431 ****
                  }
                  if(!(j=getrev(j,symbolrev,revlength))) return false;
                  if (!expandsym(symbolrev,numrev)) return false;
!                 tmpdelta=genrevs(numrev,nil,nil,nil,joindeltas);
                  if (tmpdelta==nil)
                          return false;
                  else    joinlist[++lastjoin]=tmpdelta->num;
--- 435,441 ----
                  }
                  if(!(j=getrev(j,symbolrev,revlength))) return false;
                  if (!expandsym(symbolrev,numrev)) return false;
!                 tmpdelta=genrevs(numrev,(char *)nil,(char *)nil,(char *)nil,joindeltas);
                  if (tmpdelta==nil)
                          return false;
                  else    joinlist[++lastjoin]=tmpdelta->num;
***************
*** 436,442 ****
                          if (*j!='\0') {
                                  if(!(j=getrev(j,symbolrev,revlength))) return false;
                                  if (!expandsym(symbolrev,numrev)) return false;
!                                 tmpdelta=genrevs(numrev,nil,nil,nil,joindeltas);
                                  if (tmpdelta==nil)
                                          return false;
                                  else    joinlist[++lastjoin]=tmpdelta->num;
--- 446,452 ----
                          if (*j!='\0') {
                                  if(!(j=getrev(j,symbolrev,revlength))) return false;
                                  if (!expandsym(symbolrev,numrev)) return false;
!                                 tmpdelta=genrevs(numrev,(char *)nil,(char *)nil,(char *)nil,joindeltas);
                                  if (tmpdelta==nil)
                                          return false;
                                  else    joinlist[++lastjoin]=tmpdelta->num;
***************
*** 485,504 ****
          while (i<lastjoin) {
                  /*prepare marker for merge*/
                  if (i==0)
!                         strcpy(subs,targetdelta->num);
!                 else    sprintf(subs, "merge%d",i/2);
                  diagnose("revision %s",joinlist[i]);
!                 sprintf(command,"%s/co -p%s -q  %s > %s\n",TARGETDIR,joinlist[i],RCSfilename,rev2);
                  if (system(command)) {
                          nerror++;return false;
                  }
                  diagnose("revision %s",joinlist[i+1]);
!                 sprintf(command,"%s/co -p%s -q  %s > %s\n",TARGETDIR,joinlist[i+1],RCSfilename,rev3);
                  if (system(command)) {
                          nerror++; return false;
                  }
                  diagnose("merging...");
!                 sprintf(command,"%s %s%s %s %s %s %s\n", MERGE,
                          ((i+2)>=lastjoin && tostdout)?"-p ":"",
                          initialfile,rev2,rev3,subs,joinlist[i+1]);
                  if (system(command)) {
--- 495,514 ----
          while (i<lastjoin) {
                  /*prepare marker for merge*/
                  if (i==0)
!                         VOID strcpy(subs,targetdelta->num);
!                 else    VOID sprintf(subs, "merge%d",i/2);
                  diagnose("revision %s",joinlist[i]);
!                 VOID sprintf(command,"%s/co -p%s -q  %s > %s\n",TARGETDIR,joinlist[i],RCSfilename,rev2);
                  if (system(command)) {
                          nerror++;return false;
                  }
                  diagnose("revision %s",joinlist[i+1]);
!                 VOID sprintf(command,"%s/co -p%s -q  %s > %s\n",TARGETDIR,joinlist[i+1],RCSfilename,rev3);
                  if (system(command)) {
                          nerror++; return false;
                  }
                  diagnose("merging...");
!                 VOID sprintf(command,"%s %s%s %s %s %s %s\n", MERGE,
                          ((i+2)>=lastjoin && tostdout)?"-p ":"",
                          initialfile,rev2,rev3,subs,joinlist[i+1]);
                  if (system(command)) {
diff -c /arch/4.3/usr/src/new/rcs/src/ident.c /usr/poppy/guy/src/cmd/rcs/src/ident.c
*** /arch/4.3/usr/src/new/rcs/src/ident.c	Wed May 11 15:02:35 1983
--- /usr/poppy/guy/src/cmd/rcs/src/ident.c	Mon Jul 28 23:25:25 1986
***************
*** 1,8 ****
  /*
   *                     RCS identification operation
   */
   static char rcsid[] =
!  "$Header: /usr/wft/RCS/SRC/RCS/ident.c,v 3.4 83/02/18 17:37:49 wft Exp $Purdue CS";
  /*****************************************************************************
   *****************************************************************************
   *
--- 1,10 ----
  /*
   *                     RCS identification operation
   */
+ #ifndef lint
   static char rcsid[] =
!  "$Header: ident.c,v 3.5 86/07/28 23:22:58 guy Exp $Purdue CS";
! #endif
  /*****************************************************************************
   *****************************************************************************
   *
***************
*** 18,23 ****
--- 20,28 ----
   */
  
  /* $Log:	ident.c,v $
+  * Revision 3.5  86/07/28  23:22:58  guy
+  * More "lint" cleanups.
+  * 
   * Revision 3.4  83/02/18  17:37:49  wft
   * removed printing of new line after last file.
   * 
***************
*** 34,40 ****
--- 39,47 ----
  #include  "rcsbase.h"
  #define fflsbuf _flsbuf
  /* redefinition of _flsbuf in putc not needed */
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  main(argc, argv)
  int  argc; char  *argv[];
***************
*** 49,73 ****
     register int matchcount;
  
     if (argc<2) {
!         fprintf(stderr,  "ident error: no input file\n");
          exit(1);
     }
     while ( --argc > 0 ) {
        if ( (fp = fopen(*++argv, "r") ) == NULL ) {
!          fprintf(stderr,  "ident error: can't open %s\n", *argv);
           continue;
        } else {
           matchcount = 0;
!          printf( "%s:\n", *argv);   /*  print file name  */
           while( (c=getc(fp)) != EOF) {
              if ( (char)c==KDELIM)
                 matchcount += match(fp);
           }
           if (matchcount == 0)
!             fprintf(stderr, "ident warning: no id keywords in %s\n", *argv);
!          if (argc>1) putchar('\n');
        }
!       fclose(fp);
     }
  }
  
--- 56,80 ----
     register int matchcount;
  
     if (argc<2) {
!         VOID fprintf(stderr,  "ident error: no input file\n");
          exit(1);
     }
     while ( --argc > 0 ) {
        if ( (fp = fopen(*++argv, "r") ) == NULL ) {
!          VOID fprintf(stderr,  "ident error: can't open %s\n", *argv);
           continue;
        } else {
           matchcount = 0;
!          VOID printf( "%s:\n", *argv);   /*  print file name  */
           while( (c=getc(fp)) != EOF) {
              if ( (char)c==KDELIM)
                 matchcount += match(fp);
           }
           if (matchcount == 0)
!             VOID fprintf(stderr, "ident warning: no id keywords in %s\n", *argv);
!          if (argc>1) VOID putchar('\n');
        }
!       VOID fclose(fp);
     }
  }
  
***************
*** 105,114 ****
         ;
     else {
        /* no match; put trailing KDELIM back into input */
!       ungetc(c,fp );
        return(0);
     }
!    fprintf(stdout,"     $%s\n",line);
     return(1);
  }
  
--- 112,121 ----
         ;
     else {
        /* no match; put trailing KDELIM back into input */
!       VOID ungetc(c,fp );
        return(0);
     }
!    VOID fprintf(stdout,"     $%s\n",line);
     return(1);
  }
  
diff -c /arch/4.3/usr/src/new/rcs/src/maketime.c /usr/poppy/guy/src/cmd/rcs/src/maketime.c
*** /arch/4.3/usr/src/new/rcs/src/maketime.c	Mon Mar 28 07:04:34 1983
--- /usr/poppy/guy/src/cmd/rcs/src/maketime.c	Tue Jul 29 12:19:58 1986
***************
*** 20,28 ****
--- 20,38 ----
   *	(ARPANET: KLH @ SRI)
   */
  
+ #ifndef lint
  static char rcsid[]= "$Id: maketime.c,v 1.1 82/05/06 11:38:00 wft Exp $";
+ #endif
  
  /* $Log:	maketime.c,v $
+  * Revision 1.3  86/07/29  12:17:25  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 1.2  86/07/19  02:21:35  guy
+  * Fixed to properly declare "time()" as a long, and to use the USG UNIX
+  * routines for getting time zone information if built for USG UNIX.
+  * (Also properly declared the V7/USG "timezone" variable as a long.)
+  * 
   * Revision 1.1  82/05/06  11:38:00  wft
   * Initial revision
   * 
***************
*** 29,34 ****
--- 39,50 ----
   */
  
  
+ #if defined(USG) || defined(BSD)
+ #define VOID	(void)
+ #else
+ #define VOID
+ #endif
+ 
  #include "time.h"
  
  int daytb[] = {   /* # days in year thus far, indexed by month (0-12!!) */
***************
*** 36,41 ****
--- 52,58 ----
  };
  
  struct tm *localtime();
+ long	time();
  
  long maketime(atm)
  struct tm *atm;
***************
*** 44,50 ****
  	int year, yday, mon, day, hour, min, sec, zone, dst, leap;
  	long tres, curtim;
  
! 	time(&curtim);
  	tp = localtime(&curtim);        /* Get breakdowns of current time */
  	year = tp->tm_year;		/* Use to set up defaults */
  	mon = tp->tm_mon;
--- 61,67 ----
  	int year, yday, mon, day, hour, min, sec, zone, dst, leap;
  	long tres, curtim;
  
! 	VOID time(&curtim);
  	tp = localtime(&curtim);        /* Get breakdowns of current time */
  	year = tp->tm_year;		/* Use to set up defaults */
  	mon = tp->tm_mon;
***************
*** 177,184 ****
   *
   */
  
! #ifdef V6
! extern timezone;
  #else /* V7 */
  #include <sys/types.h>
  #include <sys/timeb.h>
--- 194,201 ----
   *
   */
  
! #if defined(V6) || defined(USG)
! extern long timezone;
  #else /* V7 */
  #include <sys/types.h>
  #include <sys/timeb.h>
***************
*** 187,193 ****
  int _lclzon = -1;
  localzone()
  {
! #ifdef V6
  	return(_lclzon >= 0 ? _lclzon : (_lclzon = timezone/60));
  #else /* V7 */
  	struct timeb tb;
--- 204,213 ----
  int _lclzon = -1;
  localzone()
  {
! #if defined(V6) || defined(USG)
! #ifdef USG
! 	tzset();
! #endif
  	return(_lclzon >= 0 ? _lclzon : (_lclzon = timezone/60));
  #else /* V7 */
  	struct timeb tb;
diff -c /arch/4.3/usr/src/new/rcs/src/partime.c /usr/poppy/guy/src/cmd/rcs/src/partime.c
*** /arch/4.3/usr/src/new/rcs/src/partime.c	Mon Mar 28 07:13:20 1983
--- /usr/poppy/guy/src/cmd/rcs/src/partime.c	Mon Jul 28 23:25:45 1986
***************
*** 26,35 ****
   *		like midnight/noon?
   */
  
  static char rcsid[]=
! "$Header: /usr/wft/RCS/SRC/RCS/partime.c,v 1.1 82/05/06 11:38:26 wft Exp $";
  
  /* $Log:	partime.c,v $
   * Revision 1.1  82/05/06  11:38:26  wft
   * Initial revision
   * 
--- 26,44 ----
   *		like midnight/noon?
   */
  
+ #ifndef lint
  static char rcsid[]=
! "$Header: partime.c,v 1.3 86/07/28 23:23:16 guy Exp $";
! #endif
  
  /* $Log:	partime.c,v $
+  * Revision 1.3  86/07/28  23:23:16  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 1.2  86/07/19  02:25:44  guy
+  * Changed some "int"s to "long"s to make them big enough to hold a pointer,
+  * and fixed some type declarations.
+  * 
   * Revision 1.1  82/05/06  11:38:26  wft
   * Initial revision
   * 
***************
*** 39,49 ****
  #include <ctype.h>
  #include "time.h"
  
  static char timeid[] = TIMEID;
  
  struct tmwent {
  	char *went;
! 	int wval;
  	char wflgs;
  	char wtype;
  };
--- 48,60 ----
  #include <ctype.h>
  #include "time.h"
  
+ #ifndef lint
  static char timeid[] = TIMEID;
+ #endif
  
  struct tmwent {
  	char *went;
! 	long wval;	/* must be big enough to hold pointer or integer */
  	char wflgs;
  	char wtype;
  };
***************
*** 56,65 ****
  int pt12hack();
  int ptnoise();
  struct tmwent tmwords [] = {
! 	{"january",
!       0,
! 0,
! TM_MON},
  	{"february",     1, 0, TM_MON},
  	{"march",        2, 0, TM_MON},
  	{"april",        3, 0, TM_MON},
--- 67,73 ----
  int pt12hack();
  int ptnoise();
  struct tmwent tmwords [] = {
! 	{"january",      0, 0, TM_MON},
  	{"february",     1, 0, TM_MON},
  	{"march",        2, 0, TM_MON},
  	{"april",        3, 0, TM_MON},
***************
*** 110,116 ****
  	{"pm",           2, TWTIME, TM_AMPM},
  	{"noon",         12,TWTIME+TW1200, 0},    /* Special frobs */
  	{"midnight",     0, TWTIME+TW1200, 0},
! 	{"at",           (int)ptnoise, TWSPEC, 0},    /* Noise word */
  
  	{0, 0, 0, 0},             /* Zero entry to terminate searches */
  };
--- 118,124 ----
  	{"pm",           2, TWTIME, TM_AMPM},
  	{"noon",         12,TWTIME+TW1200, 0},    /* Special frobs */
  	{"midnight",     0, TWTIME+TW1200, 0},
! 	{"at",           (long)ptnoise, TWSPEC, 0},    /* Noise word */
  
  	{0, 0, 0, 0},             /* Zero entry to terminate searches */
  };
***************
*** 163,172 ****
  			goto domore;
  		  }
  		if(twp->wflgs&TW1200)
! 			if(ptstash(&midnoon,twp->wval))
  				return(0);	/* ERR: noon/midnite clash */
  			else goto domore;
! 		if(ptstash(&tp[twp->wtype],twp->wval))
  			return(0);		/* ERR: val already set */
  		if(twp->wtype == TM_ZON)	/* If was zone, hack DST */
  			if(ptstash(&tp[TM_ISDST],(twp->wflgs&TWDST)))
--- 171,180 ----
  			goto domore;
  		  }
  		if(twp->wflgs&TW1200)
! 			if(ptstash(&midnoon,(int)twp->wval))
  				return(0);	/* ERR: noon/midnite clash */
  			else goto domore;
! 		if(ptstash(&tp[twp->wtype],(int)twp->wval))
  			return(0);		/* ERR: val already set */
  		if(twp->wtype == TM_ZON)	/* If was zone, hack DST */
  			if(ptstash(&tp[TM_ISDST],(twp->wflgs&TWDST)))
***************
*** 354,360 ****
  
  ptitoken(astr, tkp)
  register struct token *tkp;
! struct token *astr;
  {
  	register char *cp;
  	register int i;
--- 362,368 ----
  
  ptitoken(astr, tkp)
  register struct token *tkp;
! char *astr;
  {
  	register char *cp;
  	register int i;
***************
*** 362,368 ****
  	tkp->tval.tnum = 0;
  	if(pttoken(astr,tkp) == 0)
  #ifdef DEBUG
! 	printf("EOF\n");
  #endif DEBUG
  		return(0);
  	cp = tkp->tcp;
--- 370,376 ----
  	tkp->tval.tnum = 0;
  	if(pttoken(astr,tkp) == 0)
  #ifdef DEBUG
! 	VOID printf("EOF\n");
  #endif DEBUG
  		return(0);
  	cp = tkp->tcp;
***************
*** 370,376 ****
  #ifdef DEBUG
  	i = cp[tkp->tcnt];
  	cp[tkp->tcnt] = 0;
! 	printf("Token: \"%s\" ",cp);
  	cp[tkp->tcnt] = i;
  #endif DEBUG
  
--- 378,384 ----
  #ifdef DEBUG
  	i = cp[tkp->tcnt];
  	cp[tkp->tcnt] = 0;
! 	VOID printf("Token: \"%s\" ",cp);
  	cp[tkp->tcnt] = i;
  #endif DEBUG
  
***************
*** 378,388 ****
  		for(i = tkp->tcnt; i > 0; i--)
  			tkp->tval.tnum = (int)tkp->tval.tnum*10 + ((*cp++)-'0');
  	else
! 	  {     i = ptmatchstr(cp, tkp->tcnt, tmwords, sizeof (struct tmwent));
  		tkp->tval.tnum = i ? i : -1;         /* Set -1 for error */
  
  #ifdef DEBUG
! 		if(!i) printf("Not found!\n");
  #endif DEBUG
  
  		if(!i) return(0);
--- 386,396 ----
  		for(i = tkp->tcnt; i > 0; i--)
  			tkp->tval.tnum = (int)tkp->tval.tnum*10 + ((*cp++)-'0');
  	else
! 	  {     i = ptmatchstr(cp, tkp->tcnt, tmwords);
  		tkp->tval.tnum = i ? i : -1;         /* Set -1 for error */
  
  #ifdef DEBUG
! 		if(!i) VOID printf("Not found!\n");
  #endif DEBUG
  
  		if(!i) return(0);
***************
*** 390,397 ****
  
  #ifdef DEBUG
  	if(tkp->tflg)
! 		printf("Val: %d.\n",tkp->tval.tnum);
! 	else printf("Found: \"%s\", val: %d., type %d\n",
  		tkp->tval.ttmw->went,tkp->tval.ttmw->wval,tkp->tval.ttmw->wtype);
  #endif DEBUG
  
--- 398,405 ----
  
  #ifdef DEBUG
  	if(tkp->tflg)
! 		VOID printf("Val: %d.\n",tkp->tval.tnum);
! 	else VOID printf("Found: \"%s\", val: %d., type %d\n",
  		tkp->tval.ttmw->went,tkp->tval.ttmw->wval,tkp->tval.ttmw->wtype);
  #endif DEBUG
  
***************
*** 441,449 ****
  }
  
  
! ptmatchstr(astr,cnt,astruc,size)
  char *astr;
! int cnt,size;
  struct tmwent *astruc;
  {	register char *cp, *mp;
  	register int c;
--- 449,457 ----
  }
  
  
! ptmatchstr(astr,cnt,astruc)
  char *astr;
! int cnt;
  struct tmwent *astruc;
  {	register char *cp, *mp;
  	register int c;
***************
*** 472,482 ****
  
  
  
! zaptime(atm)
! struct tm *atm;
! /* clears atm */
! {	register int *tp, i;
! 	tp = (int *)atm;
  	i = (sizeof (struct tm))/(sizeof (int));
  	do *tp++ = TMNULL;		/* Set entry to "unspecified" */
  	while(--i);			/* Faster than FOR */
--- 480,489 ----
  
  
  
! zaptime(tp)
! register int *tp;
! /* clears tm structure pointed to by tp */
! {	register int i;
  	i = (sizeof (struct tm))/(sizeof (int));
  	do *tp++ = TMNULL;		/* Set entry to "unspecified" */
  	while(--i);			/* Faster than FOR */
diff -c /arch/4.3/usr/src/new/rcs/src/rcs.c /usr/poppy/guy/src/cmd/rcs/src/rcs.c
*** /arch/4.3/usr/src/new/rcs/src/rcs.c	Thu Oct 24 08:31:03 1985
--- /usr/poppy/guy/src/cmd/rcs/src/rcs.c	Mon Jul 28 23:26:31 1986
***************
*** 1,8 ****
  /*
   *                      RCS create/change operation
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcs.c,v 3.9 83/02/15 15:38:39 wft Exp $ Purdue CS";
  /***************************************************************************
   *                       create RCS files or change RCS file attributes
   *                       Compatibility with release 2: define COMPAT2
--- 1,10 ----
  /*
   *                      RCS create/change operation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcs.c,v 3.11 86/07/28 23:23:57 guy Exp $ Purdue CS";
! #endif
  /***************************************************************************
   *                       create RCS files or change RCS file attributes
   *                       Compatibility with release 2: define COMPAT2
***************
*** 21,26 ****
--- 23,38 ----
  
  
  /* $Log:	rcs.c,v $
+  * Revision 3.11  86/07/28  23:23:57  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.10  86/07/19  02:32:49  guy
+  * Fixed to properly cast null and other pointer arguments.
+  * Some routines which return no value declared as void to silence lint.
+  * "#ifdef" added for "delivermail", and "SENDMAIL" made the define to use
+  * "sendmail".
+  * Checks against dereferencing null pointers added.
+  * 
   * Revision 3.9  83/02/15  15:38:39  wft
   * Added call to fastcopy() to copy remainder of RCS file.
   * 
***************
*** 66,74 ****
--- 78,92 ----
  #include <pwd.h>
  #include <sys/types.h>
  #include <sys/stat.h>
+ #ifdef BSD
  #include <sysexits.h>
+ #else
+ #define EX_OK 0
+ #endif
  #include "rcsbase.h"
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  
  extern FILE * fopen();
***************
*** 79,85 ****
  extern struct  lock      * addlock();   /* add a lock                       */
  extern char              * getid();
  extern char              * getkeyval();
! extern char              * Klog, *Khead, *Kaccess, *Ksuffix, *Ktext;
  extern struct passwd *getpwuid();
  extern char * malloc();
  extern struct hshentry   * genrevs();
--- 97,106 ----
  extern struct  lock      * addlock();   /* add a lock                       */
  extern char              * getid();
  extern char              * getkeyval();
! extern char              * Klog, *Khead, *Kaccess, *Ktext;
! #ifdef COMPAT2
! extern char              * Ksuffix;
! #endif
  extern struct passwd *getpwuid();
  extern char * malloc();
  extern struct hshentry   * genrevs();
***************
*** 88,93 ****
--- 109,116 ----
  extern char * getfullRCSname();         /* get full path name of RCS file   */
  extern char * mktempfile();             /* temporary file name generator    */
  extern free();
+ extern void catchints();
+ extern void ignoreints();
  extern int nextc;                       /* next input character             */
  extern int  nerror;                     /* counter for errors               */
  extern int  quietflag;                  /* diagnoses suppressed if true     */
***************
*** 373,379 ****
                  case -1: break;
                  case  0: continue;     /*  can't open  */
                  case  1: error("file %s exists already", RCSfilename);
!                          fclose(finptr);
                           continue;
              }
  	}
--- 396,402 ----
                  case -1: break;
                  case  0: continue;     /*  can't open  */
                  case  1: error("file %s exists already", RCSfilename);
!                          VOID fclose(finptr);
                           continue;
              }
  	}
***************
*** 382,388 ****
                  case -1: continue;    /*  not exist    */
                  case  0: continue;    /*  can't open   */
                  case  1:              /*  file exists  */
!                          fstat(fileno(finptr), &filestatus);/*grab mode*/
                           break;
              }
  	}
--- 405,411 ----
                  case -1: continue;    /*  not exist    */
                  case  0: continue;    /*  can't open   */
                  case  1:              /*  file exists  */
!                          VOID fstat(fileno(finptr), &filestatus);/*grab mode*/
                           break;
              }
  	}
***************
*** 442,448 ****
          }
          if(unlockcaller == true) { /*  find lock for caller  */
              if ( Head ) {
!                 breaklock(caller, nil);
                  /* breaklock does it's own diagnose */
              } else {
                  warn("Can't unlock an empty tree");
--- 465,471 ----
          }
          if(unlockcaller == true) { /*  find lock for caller  */
              if ( Head ) {
!                 breaklock(caller, (struct hshentry *)nil);
                  /* breaklock does it's own diagnose */
              } else {
                  warn("Can't unlock an empty tree");
***************
*** 455,461 ****
          curstate = statelst;
          while( curstate ) {
              if ( expandsym(curstate->revno, &numrev[0]) ) {
!                 target = genrevs(&numrev[0], nil, nil, nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num, &numrev[0]) )
                          error("Can't set state %s of a nonexistent revision %s",
--- 478,484 ----
          curstate = statelst;
          while( curstate ) {
              if ( expandsym(curstate->revno, &numrev[0]) ) {
!                 target = genrevs(&numrev[0], (char *)nil, (char *)nil, (char *)nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num, &numrev[0]) )
                          error("Can't set state %s of a nonexistent revision %s",
***************
*** 469,475 ****
          cuthead = cuttail = nil;
          if ( delrev && removerevs()) {
              /*  rebuild delta tree if some deltas are deleted   */
!             if ( cuttail ) genrevs(cuttail->num, nil,nil, nil, gendeltas);
              buildtree();
          }
  
--- 492,498 ----
          cuthead = cuttail = nil;
          if ( delrev && removerevs()) {
              /*  rebuild delta tree if some deltas are deleted   */
!             if ( cuttail ) genrevs(cuttail->num, (char *)nil,(char *)nil, (char *)nil, gendeltas);
              buildtree();
          }
  
***************
*** 478,488 ****
          newRCSfilename=mktempfile(RCSfilename,NEWRCSFILE);
          oldumask = umask(0222); /* turn off write bits */
          if ((frewrite=fopen(newRCSfilename, "w"))==NULL) {
!                 fclose(finptr);
                  error("Can't open file %s",newRCSfilename);
                  continue;
          }
!         umask(oldumask);
          putadmin(frewrite);
          if ( Head )
             puttree(Head, frewrite);
--- 501,511 ----
          newRCSfilename=mktempfile(RCSfilename,NEWRCSFILE);
          oldumask = umask(0222); /* turn off write bits */
          if ((frewrite=fopen(newRCSfilename, "w"))==NULL) {
!                 VOID fclose(finptr);
                  error("Can't open file %s",newRCSfilename);
                  continue;
          }
!         VOID umask(oldumask);
          putadmin(frewrite);
          if ( Head )
             puttree(Head, frewrite);
***************
*** 497,503 ****
                  if ( cuttail )
                      buildeltatext(gendeltas);
                  else
!                     scanlogtext(nil,empty);
                      /* copy rest of delta text nodes that are not deleted      */
              }
          }
--- 520,526 ----
                  if ( cuttail )
                      buildeltatext(gendeltas);
                  else
!                     scanlogtext((struct hshentry *)nil,empty);
                      /* copy rest of delta text nodes that are not deleted      */
              }
          }
***************
*** 707,713 ****
          int    c;
          struct  delrevpair      *pt;
  
!         if (delrev) free(delrev);
  
          pt = (struct delrevpair *)malloc(sizeof(struct delrevpair));
          while((c = (*++sp)) == ' ' || c == '\n' || c == '\t') ;
--- 730,736 ----
          int    c;
          struct  delrevpair      *pt;
  
!         if (delrev) free((char *)delrev);
  
          pt = (struct delrevpair *)malloc(sizeof(struct delrevpair));
          while((c = (*++sp)) == ' ' || c == '\n' || c == '\t') ;
***************
*** 733,739 ****
              }
              if ( c != '-' && c != '<') {
                  faterror("Invalid range %s %s after -o", pt->strt, sp);
!                 free(pt);
                  return;
              }
              while( (c = *++sp) == ' ' || c == '\n' || c == '\t')  ;
--- 756,762 ----
              }
              if ( c != '-' && c != '<') {
                  faterror("Invalid range %s %s after -o", pt->strt, sp);
!                 free((char *)pt);
                  return;
              }
              while( (c = *++sp) == ' ' || c == '\n' || c == '\t')  ;
***************
*** 773,779 ****
                  }
                  if ( nextdelta->selector != DELETE) {
                          rewriteflag = true;
!                         fprintf(frewrite,DELNUMFORM,nextdelta->num,Klog);
                  }
                  if (!getkey(Klog) || nexttok!=STRING)
                          serror("Missing log entry");
--- 796,802 ----
                  }
                  if ( nextdelta->selector != DELETE) {
                          rewriteflag = true;
!                         VOID fprintf(frewrite,DELNUMFORM,nextdelta->num,Klog);
                  }
                  if (!getkey(Klog) || nexttok!=STRING)
                          serror("Missing log entry");
***************
*** 792,798 ****
                          switch (func) {
                          case copy:      copystring();
                                          break;
!                         case edit:      editstring(nil);
                                          break;
                          default:        faterror("Wrong scanlogtext");
                          }
--- 815,821 ----
                          switch (func) {
                          case copy:      copystring();
                                          break;
!                         case edit:      editstring((struct hshentry *)nil);
                                          break;
                          default:        faterror("Wrong scanlogtext");
                          }
***************
*** 812,818 ****
  
          pt = sourcelst;
          while(pt) {
!             free(pt);
              pt = pt->nextaccess;
          }
  }
--- 835,841 ----
  
          pt = sourcelst;
          while(pt) {
!             free((char *)pt);
              pt = pt->nextaccess;
          }
  }
***************
*** 827,833 ****
          struct  Lockrev   * pt, *pre;
  
          while( newlocklst && (! strcmp(newlocklst->revno, which->revno))){
!             free(newlocklst);
              newlocklst = newlocklst->nextrev;
          }
  
--- 850,856 ----
          struct  Lockrev   * pt, *pre;
  
          while( newlocklst && (! strcmp(newlocklst->revno, which->revno))){
!             free((char *)newlocklst);
              newlocklst = newlocklst->nextrev;
          }
  
***************
*** 834,840 ****
          pt = pre = newlocklst;
          while( pt ) {
              if ( ! strcmp(pt->revno, which->revno) ) {
!                 free(pt);
                  pt = pt->nextrev;
                  pre->nextrev = pt;
              }
--- 857,863 ----
          pt = pre = newlocklst;
          while( pt ) {
              if ( ! strcmp(pt->revno, which->revno) ) {
!                 free((char *)pt);
                  pt = pt->nextrev;
                  pre->nextrev = pt;
              }
***************
*** 858,864 ****
  
          pt = sourcelst;
          while( pt && (! strcmp(who->login, pt->login) )) {
!             free(pt);
              flag = false;
              pt = pt->nextaccess;
  	}
--- 881,887 ----
  
          pt = sourcelst;
          while( pt && (! strcmp(who->login, pt->login) )) {
!             free((char *)pt);
              flag = false;
              pt = pt->nextaccess;
  	}
***************
*** 865,871 ****
          pre = sourcelst = pt;
          while( pt ) {
              if ( ! strcmp(who->login, pt->login) ) {
! 		free(pt);
                  flag = false;
                  pt = pt->nextaccess;
                  pre->nextaccess = pt;
--- 888,894 ----
          pre = sourcelst = pt;
          while( pt ) {
              if ( ! strcmp(who->login, pt->login) ) {
! 		free((char *)pt);
                  flag = false;
                  pt = pt->nextaccess;
                  pre->nextaccess = pt;
***************
*** 918,925 ****
          FILE    * mailmess;
  
  
!         fprintf(stdout, "Revision %s is already locked by %s.\n", Delta, who);
!         fprintf(stdout, "Do you want to break the lock? [ny](n): ");
          response=c=getchar();
          while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
  	if (c == EOF) {
--- 941,948 ----
          FILE    * mailmess;
  
  
!         VOID fprintf(stdout, "Revision %s is already locked by %s.\n", Delta, who);
!         VOID fprintf(stdout, "Do you want to break the lock? [ny](n): ");
          response=c=getchar();
          while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
  	if (c == EOF) {
***************
*** 934,944 ****
              faterror("Can't open file %s", messagefile);
          }
  
!         fprintf(mailmess, "Subject: Broken lock on %s\n\n",RCSfilename);
!         fprintf(mailmess, "Your lock on revision %s of file %s\n",Delta, getfullRCSname());
!         fprintf(mailmess,"has been broken by %s for the following reason:\n",caller);
!         fputs("State the reason for breaking the lock:\n", stdout);
!         fputs("(terminate with ^D or single '.')\n>> ", stdout);
  
          old1 = '\n';    old2 = ' ';
          for (; ;) {
--- 957,967 ----
              faterror("Can't open file %s", messagefile);
          }
  
!         VOID fprintf(mailmess, "Subject: Broken lock on %s\n\n",RCSfilename);
!         VOID fprintf(mailmess, "Your lock on revision %s of file %s\n",Delta, getfullRCSname());
!         VOID fprintf(mailmess,"has been broken by %s for the following reason:\n",caller);
!         VOID fputs("State the reason for breaking the lock:\n", stdout);
!         VOID fputs("(terminate with ^D or single '.')\n>> ", stdout);
  
          old1 = '\n';    old2 = ' ';
          for (; ;) {
***************
*** 945,970 ****
              c = getchar();
              if ( c == EOF ) {
  		clearerr(stdin);
!                 putc('\n',stdout);
!                 fprintf(mailmess, "%c\n", old1);
                  break;
              }
              else if ( c == '\n' && old1 == '.' && old2 == '\n')
                  break;
              else {
!                 fputc( old1, mailmess);
                  old2 = old1;   old1 = c;
!                 if (c== '\n') fputs(">> ", stdout);
              }
          }
          ffclose(mailmess);
! #ifdef V4_2BSD
!         sprintf(command, "/usr/lib/sendmail %s < %s",who,messagefile);
  #else
!         sprintf(command, "/etc/delivermail -w %s < %s",who,messagefile);
  #endif
          exitstatus = system(command);
!         unlink(messagefile);
          return(exitstatus==EX_OK);
  }
  
--- 968,997 ----
              c = getchar();
              if ( c == EOF ) {
  		clearerr(stdin);
!                 VOID putc('\n',stdout);
!                 VOID fprintf(mailmess, "%c\n", old1);
                  break;
              }
              else if ( c == '\n' && old1 == '.' && old2 == '\n')
                  break;
              else {
!                 VOID fputc( old1, mailmess);
                  old2 = old1;   old1 = c;
!                 if (c== '\n') VOID fputs(">> ", stdout);
              }
          }
          ffclose(mailmess);
! #ifdef SENDMAIL
!         VOID sprintf(command, "/usr/lib/sendmail %s < %s",who,messagefile);
  #else
! #  ifdef DELIVERMAIL
!         VOID sprintf(command, "/etc/delivermail -w %s < %s",who,messagefile);
! #  else
!         VOID sprintf(command, "/bin/mail %s < %s",who,messagefile);
! #  endif
  #endif
          exitstatus = system(command);
!         VOID unlink(messagefile);
          return(exitstatus==EX_OK);
  }
  
***************
*** 987,993 ****
          dummy.nextlock=next=Locks;
          trail = &dummy;
          while (next!=nil) {
!                numr = strcmp(num, next->delta->num);
                 if ((whor=strcmp(who,next->login))==0 &&
                    (num==nil || numr==0))
                          break; /* found a lock */
--- 1014,1021 ----
          dummy.nextlock=next=Locks;
          trail = &dummy;
          while (next!=nil) {
!                if (num!=nil)
!                         numr = strcmp(num, next->delta->num);
                 if ((whor=strcmp(who,next->login))==0 &&
                    (num==nil || numr==0))
                          break; /* found a lock */
***************
*** 1095,1101 ****
  
          flag = false;
          if ( ! expandsym(delrev->strt, &numrev[0]) ) return 0;
!         target = genrevs(&numrev[0], nil, nil, nil, gendeltas);
          if ( ! target ) return 0;
          if ( cmpnum(target->num, &numrev[0]) ) flag = true;
          length = countnumflds( &numrev[0] );
--- 1123,1129 ----
  
          flag = false;
          if ( ! expandsym(delrev->strt, &numrev[0]) ) return 0;
!         target = genrevs(&numrev[0], (char *)nil, (char *)nil, (char *)nil, gendeltas);
          if ( ! target ) return 0;
          if ( cmpnum(target->num, &numrev[0]) ) flag = true;
          length = countnumflds( &numrev[0] );
***************
*** 1158,1164 ****
                  else
                      temp = searchcutpt(target->num, length, gendeltas);
                  getbranchno(temp->num, &numrev[0]);  /*  get branch number  */
!                 target = genrevs(&numrev[0], nil, nil, nil, gendeltas);
              }
              if ( branchpoint( temp, cuttail ) ) {
                  cuttail = nil;
--- 1186,1192 ----
                  else
                      temp = searchcutpt(target->num, length, gendeltas);
                  getbranchno(temp->num, &numrev[0]);  /*  get branch number  */
!                 target = genrevs(&numrev[0], (char *)nil, (char *)nil, (char *)nil, gendeltas);
              }
              if ( branchpoint( temp, cuttail ) ) {
                  cuttail = nil;
***************
*** 1179,1185 ****
              return 0;
          }
  
!         target2 = genrevs( &numrev[0], nil, nil, nil,gendeltas);
          if ( ! target2 ) return 0;
  
          if ( length > 2) {  /* delete revisions on branches  */
--- 1207,1213 ----
              return 0;
          }
  
!         target2 = genrevs( &numrev[0], (char *)nil, (char *)nil, (char *)nil,gendeltas);
          if ( ! target2 ) return 0;
  
          if ( length > 2) {  /* delete revisions on branches  */
***************
*** 1266,1272 ****
  	    /*   add symbol  */
                 target = (struct hshentry *) malloc(sizeof(struct hshentry));
                 target->num = &numrev[0];
!                addsymbol(target, curassoc->ssymbol, curassoc->override);
              }
              curassoc = curassoc->nextsym;
          }
--- 1294,1300 ----
  	    /*   add symbol  */
                 target = (struct hshentry *) malloc(sizeof(struct hshentry));
                 target->num = &numrev[0];
!                VOID addsymbol(target, curassoc->ssymbol, curassoc->override);
              }
              curassoc = curassoc->nextsym;
          }
***************
*** 1288,1294 ****
          lockpt = rmvlocklst;
          while( lockpt ) {
              if (expandsym(lockpt->revno, &numrev[0]) ) {
!                 target = genrevs(&numrev[0], nil, nil, nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num,&numrev[0]) )
                          error("Can't unlock a nonexisting revision %s",lockpt->revno);
--- 1316,1322 ----
          lockpt = rmvlocklst;
          while( lockpt ) {
              if (expandsym(lockpt->revno, &numrev[0]) ) {
!                 target = genrevs(&numrev[0], (char *)nil, (char *)nil, (char *)nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num,&numrev[0]) )
                          error("Can't unlock a nonexisting revision %s",lockpt->revno);
***************
*** 1303,1309 ****
          lockpt = newlocklst;
          while( lockpt ) {
              if (expandsym(lockpt->revno, &numrev[0]) ){
!                 target = genrevs(&numrev[0], nil, nil, nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num,&numrev[0]))
                          error("Can't lock a nonexisting revision %s",lockpt->revno);
--- 1331,1337 ----
          lockpt = newlocklst;
          while( lockpt ) {
              if (expandsym(lockpt->revno, &numrev[0]) ){
!                 target = genrevs(&numrev[0], (char *)nil, (char *)nil, (char *)nil, gendeltas);
                  if ( target )
                     if ( !(countnumflds(&numrev[0])%2) && cmpnum(target->num,&numrev[0]))
                          error("Can't lock a nonexisting revision %s",lockpt->revno);
***************
*** 1339,1346 ****
                  scanlogtext(deltas[i++], edit);
              }
  
!             finishedit(nil);    rewind(fcopy);
!             while( (c = getc(fcopy)) != EOF) putc(c, fcut);
              swapeditfiles(false);
              ffclose(fcut);
          }
--- 1367,1374 ----
                  scanlogtext(deltas[i++], edit);
              }
  
!             finishedit((struct hshentry *)nil);    rewind(fcopy);
!             while( (c = getc(fcopy)) != EOF) VOID putc(c, fcut);
              swapeditfiles(false);
              ffclose(fcut);
          }
***************
*** 1347,1357 ****
  
          while( deltas[i-1] != cuttail)
              scanlogtext(deltas[i++], edit);
!         finishedit(nil);    ffclose(fcopy);
  
          if ( cuthead ) {
              diffilename=mktempfile("/tmp/", "RCSdifXXXXXX");
!             sprintf(command, "%s -n %s %s > %s", DIFF,cutfilename, resultfile, diffilename);
              exit_stats = system (command);
              if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
                  faterror ("diff failed");
--- 1375,1385 ----
  
          while( deltas[i-1] != cuttail)
              scanlogtext(deltas[i++], edit);
!         finishedit((struct hshentry *)nil);    ffclose(fcopy);
  
          if ( cuthead ) {
              diffilename=mktempfile("/tmp/", "RCSdifXXXXXX");
!             VOID sprintf(command, "%s -n %s %s > %s", DIFF,cutfilename, resultfile, diffilename);
              exit_stats = system (command);
              if (exit_stats != 0 && exit_stats != (1 << BYTESIZ))
                  faterror ("diff failed");
***************
*** 1360,1366 ****
          else
              if (!putdtext(cuttail->num,curlogmsg,resultfile,frewrite)) return;
  
!         scanlogtext(nil,empty); /* read the rest of the deltas */
  }
  
  
--- 1388,1394 ----
          else
              if (!putdtext(cuttail->num,curlogmsg,resultfile,frewrite)) return;
  
!         scanlogtext((struct hshentry *)nil,empty); /* read the rest of the deltas */
  }
  
  
***************
*** 1393,1399 ****
              }
  	else {
              if ( cuttail == nil && !quietflag) {
!                 fprintf(stderr,"Do you really want to delete all revisions ?[ny](n): ");
  		c = response = getchar();
  		while( c != EOF && c != '\n') c = getchar();
  		if (c == EOF)
--- 1421,1427 ----
              }
  	else {
              if ( cuttail == nil && !quietflag) {
!                 VOID fprintf(stderr,"Do you really want to delete all revisions ?[ny](n): ");
  		c = response = getchar();
  		while( c != EOF && c != '\n') c = getchar();
  		if (c == EOF)
diff -c /arch/4.3/usr/src/new/rcs/src/rcsbase.h /usr/poppy/guy/src/cmd/rcs/src/rcsbase.h
*** /arch/4.3/usr/src/new/rcs/src/rcsbase.h	Fri Nov 15 08:52:43 1985
--- /usr/poppy/guy/src/cmd/rcs/src/rcsbase.h	Mon Jul 28 23:26:50 1986
***************
*** 2,8 ****
  /*
   *                     RCS common definitions and data structures
   */
! #define RCSBASE "$Header: /usr/src/new/rcs/src/RCS/rcsbase.h,v 3.7 83/10/19 04:22:11 lepreau Exp $"
  /*****************************************************************************
   * INSTRUCTIONS:
   * =============
--- 2,8 ----
  /*
   *                     RCS common definitions and data structures
   */
! #define RCSBASE "$Header: rcsbase.h,v 3.8 86/07/28 23:24:22 guy Exp $"
  /*****************************************************************************
   * INSTRUCTIONS:
   * =============
***************
*** 28,33 ****
--- 28,36 ----
  
  
  /* $Log:	rcsbase.h,v $
+  * Revision 3.8  86/07/28  23:24:22  guy
+  * More "lint" cleanups.
+  * 
   * Revision 3.7  83/10/19  04:22:11  lepreau
   * Make teeny logsize big
   * 
***************
*** 254,260 ****
--- 257,265 ----
  extern struct hshentry * Head;
  extern int               StrictLocks;
  extern int               TotalDeltas;
+ #ifndef lint
  static char copyright[]="Copyright (C) 1982 by Walter F. Tichy";
+ #endif
  
  /* common variables (lexical analyzer)*/
  extern enum tokens map[];
***************
*** 270,276 ****
--- 275,292 ----
  extern int serror();
  extern int faterror();
  extern int fatserror();
+ extern void ignoreints();
+ extern void catchints();
  
+ extern char *strcpy();
+ extern char *strcat();
+ extern char *strncpy();
+ #ifdef USG
+ extern int sprintf();
+ #else
+ extern char *sprintf();
+ #endif
+ 
  /*
   * Markers for keyword expansion (used in co and ident)
   */
***************
*** 291,294 ****
--- 307,315 ----
  #define DELETE          'D'
  /* set by rcs -o and used by puttree() in rcssyn */
  
+ #if defined(USG) || defined(BSD)
+ #define VOID	(void)
+ #else
  typedef int void;
+ #define VOID
+ #endif
diff -c /arch/4.3/usr/src/new/rcs/src/rcsdiff.c /usr/poppy/guy/src/cmd/rcs/src/rcsdiff.c
*** /arch/4.3/usr/src/new/rcs/src/rcsdiff.c	Mon May 19 02:37:01 1986
--- /usr/poppy/guy/src/cmd/rcs/src/rcsdiff.c	Mon Jul 28 23:27:05 1986
***************
*** 1,8 ****
  /*
   *                     RCS rcsdiff operation
   */
   static char rcsid[]=
!  "$Header: rcsdiff.c,v 3.7 86/05/19 02:36:16 lepreau Exp $ Purdue CS";
  /*****************************************************************************
   *                       generate difference between RCS revisions
   *****************************************************************************
--- 1,10 ----
  /*
   *                     RCS rcsdiff operation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsdiff.c,v 3.9 86/07/28 23:24:38 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       generate difference between RCS revisions
   *****************************************************************************
***************
*** 20,25 ****
--- 22,33 ----
  
  
  /* $Log:	rcsdiff.c,v $
+  * Revision 3.9  86/07/28  23:24:38  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.8  86/07/19  02:37:09  guy
+  * Changed to properly cast null pointer arguments.
+  * 
   * Revision 3.7  86/05/19  02:36:16  lepreau
   * Pass on new diff options, and allow them to be clustered.
   * 
***************
*** 43,49 ****
--- 51,59 ----
   *
   */
  #include "rcsbase.h"
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  extern int    cleanup();            /* cleanup after signals                */
  extern char * mktempfile();         /*temporary file name generator         */
***************
*** 146,157 ****
                  if (revnums==0) rev1=Head->num; /* default rev1 */
  
                  if (!expandsym(rev1,numericrev)) continue;
!                 if (!(target=genrevs(numericrev,nil,nil,nil,gendeltas))) continue;
                  xrev1=target->num;
  
                  if (revnums==2) {
                          if (!expandsym(rev2,numericrev)) continue;
!                         if (!(target=genrevs(numericrev,nil,nil,nil,gendeltas))) continue;
                          xrev2=target->num;
                  }
  
--- 156,167 ----
                  if (revnums==0) rev1=Head->num; /* default rev1 */
  
                  if (!expandsym(rev1,numericrev)) continue;
!                 if (!(target=genrevs(numericrev,(char *)nil,(char *)nil,(char *)nil,gendeltas))) continue;
                  xrev1=target->num;
  
                  if (revnums==2) {
                          if (!expandsym(rev2,numericrev)) continue;
!                         if (!(target=genrevs(numericrev,(char *)nil,(char *)nil,(char *)nil,gendeltas))) continue;
                          xrev2=target->num;
                  }
  
***************
*** 158,164 ****
  
                  temp1file=mktempfile("/tmp/",TMPFILE1);
                  diagnose("retrieving revision %s",xrev1);
!                 sprintf(command,"%s/co -q -p%s %s > %s\n",
                          TARGETDIR,xrev1,RCSfilename,temp1file);
                  if (system(command)){
                          error("co failed");
--- 168,174 ----
  
                  temp1file=mktempfile("/tmp/",TMPFILE1);
                  diagnose("retrieving revision %s",xrev1);
!                 VOID sprintf(command,"%s/co -q -p%s %s > %s\n",
                          TARGETDIR,xrev1,RCSfilename,temp1file);
                  if (system(command)){
                          error("co failed");
***************
*** 170,176 ****
                  } else {
                          temp2file=mktempfile("/tmp/",TMPFILE2);
                          diagnose("retrieving revision %s",xrev2);
!                         sprintf(command,"%s/co -q -p%s %s > %s\n",
                                  TARGETDIR,xrev2,RCSfilename,temp2file);
                          if (system(command)){
                                  error("co failed");
--- 180,186 ----
                  } else {
                          temp2file=mktempfile("/tmp/",TMPFILE2);
                          diagnose("retrieving revision %s",xrev2);
!                         VOID sprintf(command,"%s/co -q -p%s %s > %s\n",
                                  TARGETDIR,xrev2,RCSfilename,temp2file);
                          if (system(command)){
                                  error("co failed");
***************
*** 178,184 ****
                          }
                          diagnose("diff %s%s -r%s -r%s",boption,otheroption,xrev1,xrev2);
                  }
!                 sprintf(command,"%s %s %s %s %s\n",DIFF,boption,
                          otheroption, temp1file, temp2file);
                  exit_stats = system (command);
                  if (exit_stats != 0 && exit_stats != (1 << BYTESIZ)) {
--- 188,194 ----
                          }
                          diagnose("diff %s%s -r%s -r%s",boption,otheroption,xrev1,xrev2);
                  }
!                 VOID sprintf(command,"%s %s %s %s %s\n",DIFF,boption,
                          otheroption, temp1file, temp2file);
                  exit_stats = system (command);
                  if (exit_stats != 0 && exit_stats != (1 << BYTESIZ)) {
diff -c /arch/4.3/usr/src/new/rcs/src/rcsedit.c /usr/poppy/guy/src/cmd/rcs/src/rcsedit.c
*** /arch/4.3/usr/src/new/rcs/src/rcsedit.c	Thu May 15 02:17:07 1986
--- /usr/poppy/guy/src/cmd/rcs/src/rcsedit.c	Mon Jul 28 23:27:55 1986
***************
*** 1,8 ****
  /*
   *                     RCS stream editor
   */
   static char rcsid[]=
!  "$Header: rcsedit.c,v 3.8 86/05/15 02:15:43 lepreau Exp $ Purdue CS";
  /**********************************************************************************
   *                       edits the input file according to a
   *                       script from stdin, generated by diff -n
--- 1,10 ----
  /*
   *                     RCS stream editor
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsedit.c,v 3.10 86/07/28 23:25:27 guy Exp $ Purdue CS";
! #endif
  /**********************************************************************************
   *                       edits the input file according to a
   *                       script from stdin, generated by diff -n
***************
*** 22,27 ****
--- 24,36 ----
  
  
  /* $Log:	rcsedit.c,v $
+  * Revision 3.10  86/07/28  23:25:27  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.9  86/07/19  02:40:11  guy
+  * Changed to properly declare routine that returns a pointer.
+  * Changed to properly cast null pointer arguments.
+  * 
   * Revision 3.8  86/05/15  02:15:43  lepreau
   * Use "Locked" instead of state in $Head expansion if locked.
   * 
***************
*** 69,74 ****
--- 78,84 ----
  extern int nextc;
  extern char * getfullRCSname();
  extern char * RCSfilename;
+ extern char * bindex();
  
  
  FILE  * fcopy,  * fedit; /* result and edit file descriptors                */
***************
*** 127,133 ****
                          while (expandline(fedit,fcopy,delta,false,false)) editline++;
                  } else {
                          while((c=getc(fedit))!=EOF) {
!                                 putc(c,fcopy);
                                  if (c=='\n') editline++;
                          }
                  }
--- 137,143 ----
                          while (expandline(fedit,fcopy,delta,false,false)) editline++;
                  } else {
                          while((c=getc(fedit))!=EOF) {
!                                 VOID putc(c,fcopy);
                                  if (c=='\n') editline++;
                          }
                  }
***************
*** 146,158 ****
  
          if (editline>line) {
                  /* swap files */
!                 finishedit(nil); swapeditfiles(false);
                  /* assumes edit only during last pass, from the beginning*/
          }
          while (editline<line) {
                  /*copy another line*/
                  if (delta)
!                         expandline(fedit,fcopy,delta,false,false);
                  else
                          while (putc(getc(fedit),fcopy)!='\n');
                  editline++;
--- 156,168 ----
  
          if (editline>line) {
                  /* swap files */
!                 finishedit((struct hshentry *)nil); swapeditfiles(false);
                  /* assumes edit only during last pass, from the beginning*/
          }
          while (editline<line) {
                  /*copy another line*/
                  if (delta)
!                         VOID expandline(fedit,fcopy,delta,false,false);
                  else
                          while (putc(getc(fedit),fcopy)!='\n');
                  editline++;
***************
*** 192,198 ****
                          nextc = c;
                          return;
                  }
!                 putc(c,fcopy);
                  if (c=='\n') editline++;
          }
          nextc = c;
--- 202,208 ----
                          nextc = c;
                          return;
                  }
!                 VOID putc(c,fcopy);
                  if (c=='\n') editline++;
          }
          nextc = c;
***************
*** 270,282 ****
                          for (i=length;i>0;i--) {
                                  /*copy next line from script*/
                                  if (delta!=nil)
!                                        expandline(finptr,fcopy,delta,true,write);
                                  else {
                                         c = GETC(finptr,frewrite,write);
                                         while (putc(c,fcopy)!='\n'){
                                                 if ((c==SDELIM)&&((c=GETC(finptr,frewrite,write))!=SDELIM)){
                                                         serror("Missing string delimiter in edit script");
!                                                        putc(c,fcopy);
                                                 }
                                                 c = GETC(finptr,frewrite,write);
                                         }
--- 280,292 ----
                          for (i=length;i>0;i--) {
                                  /*copy next line from script*/
                                  if (delta!=nil)
!                                        VOID expandline(finptr,fcopy,delta,true,write);
                                  else {
                                         c = GETC(finptr,frewrite,write);
                                         while (putc(c,fcopy)!='\n'){
                                                 if ((c==SDELIM)&&((c=GETC(finptr,frewrite,write))!=SDELIM)){
                                                         serror("Missing string delimiter in edit script");
!                                                        VOID putc(c,fcopy);
                                                 }
                                                 c = GETC(finptr,frewrite,write);
                                         }
***************
*** 355,361 ****
                                  return false;
                          }
                  }
!                 putc(c,out);
  
                  if (c=='\n') return true; /* end of line */
  
--- 365,371 ----
                                  return false;
                          }
                  }
!                 VOID putc(c,out);
  
                  if (c=='\n') return true; /* end of line */
  
***************
*** 365,371 ****
                          j=0;
                          while (((c=GETC(in,frewrite,write))!=EOF) && (j<keylength-1) && (c!='\n')
                                 && (c!=KDELIM) && (c!=VDELIM)) {
!                               putc(c,out);
                                keystring[j++] = c;
                                if (c==SDELIM && delimstuffed) { /*skip next SDELIM */
                                          c=GETC(in,frewrite,write);
--- 375,381 ----
                          j=0;
                          while (((c=GETC(in,frewrite,write))!=EOF) && (j<keylength-1) && (c!='\n')
                                 && (c!=KDELIM) && (c!=VDELIM)) {
!                               VOID putc(c,out);
                                keystring[j++] = c;
                                if (c==SDELIM && delimstuffed) { /*skip next SDELIM */
                                          c=GETC(in,frewrite,write);
***************
*** 379,385 ****
  				if (c==SDELIM && delimstuffed) {
  					c=GETC(in,frewrite,write);
  				}
!                                 putc(c,out);
                                  if (c=='\n') return true; /* end of line */
                          } else {
                                  /* no we have something that looks like a  */
--- 389,395 ----
  				if (c==SDELIM && delimstuffed) {
  					c=GETC(in,frewrite,write);
  				}
!                                 VOID putc(c,out);
                                  if (c=='\n') return true; /* end of line */
                          } else {
                                  /* no we have something that looks like a  */
***************
*** 387,393 ****
                                  keystring[j]= '\0';
                                  if ((matchresult=trymatch(keystring))==Nomatch) {
                                        /* no match */
!                                       putc(c,out);
  				      if (c==KDELIM) goto retry;
                                  } elsif (c==VDELIM) {
                                        /* try to find closing KDELIM, and replace value */
--- 397,403 ----
                                  keystring[j]= '\0';
                                  if ((matchresult=trymatch(keystring))==Nomatch) {
                                        /* no match */
!                                       VOID putc(c,out);
  				      if (c==KDELIM) goto retry;
                                  } elsif (c==VDELIM) {
                                        /* try to find closing KDELIM, and replace value */
***************
*** 404,410 ****
   				      keyval[j++] =c;
                                        if (c!=KDELIM) {
                                              /* couldn't find closing KDELIM -- give up */
!                                             putc(VDELIM,out); keyval[j]='\0';fputs(keyval,out);
                                              if (c=='\n') return true; /* end of line */
                                        } else {
                                              /* found complete pattern -- replace */
--- 414,420 ----
   				      keyval[j++] =c;
                                        if (c!=KDELIM) {
                                              /* couldn't find closing KDELIM -- give up */
!                                             VOID putc(VDELIM,out); keyval[j]='\0'; VOID fputs(keyval,out);
                                              if (c=='\n') return true; /* end of line */
                                        } else {
                                              /* found complete pattern -- replace */
***************
*** 434,481 ****
  
          switch (marker) {
          case Author:
!                 fprintf(out,"%c %s %c",VDELIM,delta->author,KDELIM);
                  break;
          case Date:
!                 putc(VDELIM,out);putc(' ',out);
!                 PRINTDATE(out,date);putc(' ',out);
!                 PRINTTIME(out,date);putc(' ',out);putc(KDELIM,out);
                  break;
          case Header:
!                 fprintf(out,"%c %s %s ",VDELIM,bindex(RCSfilename,'/'),
  					delta->num);
!                 PRINTDATE(out,date);putc(' ',out);PRINTTIME(out,date);
  		if (delta->lockedby == nil)
! 			fprintf(out, " %s %s ", delta->author, delta->state);
  		else
! 			fprintf(out," %s Locked ", delta->lockedby);
! 		putc(KDELIM, out);
                  break;
          case Locker:
!                 fprintf(out,"%c %s %c", VDELIM,
                          delta->lockedby==nil?"":delta->lockedby,KDELIM);
                  break;
          case Log:
!                 fprintf(out, "%c\t%s %c\n%sRevision %s  ",
  			VDELIM, bindex(RCSfilename,'/'), KDELIM, Comment, delta->num);
!                 PRINTDATE(out,date);fputs("  ",out);PRINTTIME(out,date);
!                 fprintf(out, "  %s\n%s",delta->author,Comment);
                  /* do not include state here because it may change and is not updated*/
                  sp = delta->log;
!                 while (*sp) if (putc(*sp++,out)=='\n') fputs(Comment,out);
                  /* Comment is the comment leader */
                  break;
          case Revision:
!                 fprintf(out,"%c %s %c",VDELIM,delta->num,KDELIM);
                  break;
          case Source:
!                 fprintf(out,"%c %s %c",VDELIM,getfullRCSname(),KDELIM);
                  break;
          case State:
!                 fprintf(out,"%c %s %c",VDELIM,delta->state,KDELIM);
                  break;
          case Nomatch:
!                 putc(KDELIM,out);
                  break;
          }
  }
--- 444,491 ----
  
          switch (marker) {
          case Author:
!                 VOID fprintf(out,"%c %s %c",VDELIM,delta->author,KDELIM);
                  break;
          case Date:
!                 VOID putc(VDELIM,out); VOID putc(' ',out);
!                 VOID PRINTDATE(out,date); VOID putc(' ',out);
!                 VOID PRINTTIME(out,date); VOID putc(' ',out); VOID putc(KDELIM,out);
                  break;
          case Header:
!                 VOID fprintf(out,"%c %s %s ",VDELIM,bindex(RCSfilename,'/'),
  					delta->num);
!                 VOID PRINTDATE(out,date); VOID putc(' ',out); VOID PRINTTIME(out,date);
  		if (delta->lockedby == nil)
! 			VOID fprintf(out, " %s %s ", delta->author, delta->state);
  		else
! 			VOID fprintf(out," %s Locked ", delta->lockedby);
! 		VOID putc(KDELIM, out);
                  break;
          case Locker:
!                 VOID fprintf(out,"%c %s %c", VDELIM,
                          delta->lockedby==nil?"":delta->lockedby,KDELIM);
                  break;
          case Log:
!                 VOID fprintf(out, "%c\t%s %c\n%sRevision %s  ",
  			VDELIM, bindex(RCSfilename,'/'), KDELIM, Comment, delta->num);
!                 VOID PRINTDATE(out,date); VOID fputs("  ",out); VOID PRINTTIME(out,date);
!                 VOID fprintf(out, "  %s\n%s",delta->author,Comment);
                  /* do not include state here because it may change and is not updated*/
                  sp = delta->log;
!                 while (*sp) if (putc(*sp++,out)=='\n') VOID fputs(Comment,out);
                  /* Comment is the comment leader */
                  break;
          case Revision:
!                 VOID fprintf(out,"%c %s %c",VDELIM,delta->num,KDELIM);
                  break;
          case Source:
!                 VOID fprintf(out,"%c %s %c",VDELIM,getfullRCSname(),KDELIM);
                  break;
          case State:
!                 VOID fprintf(out,"%c %s %c",VDELIM,delta->state,KDELIM);
                  break;
          case Nomatch:
!                 VOID putc(KDELIM,out);
                  break;
          }
  }
diff -c /arch/4.3/usr/src/new/rcs/src/rcsfcmp.c /usr/poppy/guy/src/cmd/rcs/src/rcsfcmp.c
*** /arch/4.3/usr/src/new/rcs/src/rcsfcmp.c	Wed May 11 14:03:53 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcsfcmp.c	Mon Jul 28 23:28:13 1986
***************
*** 1,8 ****
  /*
   *                     RCS file comparison
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcsfcmp.c,v 3.1 82/12/04 13:21:40 wft Exp $ Purdue CS";
  /*****************************************************************************
   *                       rcsfcmp()
   *                       Testprogram: define FCMPTEST
--- 1,10 ----
  /*
   *                     RCS file comparison
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsfcmp.c,v 3.2 86/07/28 23:25:47 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       rcsfcmp()
   *                       Testprogram: define FCMPTEST
***************
*** 22,27 ****
--- 24,32 ----
  
  
  /* $Log:	rcsfcmp.c,v $
+  * Revision 3.2  86/07/28  23:25:47  guy
+  * More "lint" cleanups.
+  * 
   * Revision 3.1  82/12/04  13:21:40  wft
   * Initial revision.
   * 
***************
*** 109,115 ****
              }
          }
      }
!     fclose(xfp);fclose(uxfp);
      return result;
  }
  
--- 114,120 ----
              }
          }
      }
!     VOID fclose(xfp); VOID fclose(uxfp);
      return result;
  }
  
***************
*** 131,137 ****
          Comment=argv[1];
          delta.log=argv[2];
          if (rcsfcmp(argv[3],argv[4],&delta))
!                 printf("files are the same\n");
!         else    printf("files are different\n");
  }
  #endif
--- 136,142 ----
          Comment=argv[1];
          delta.log=argv[2];
          if (rcsfcmp(argv[3],argv[4],&delta))
!                 VOID printf("files are the same\n");
!         else    VOID printf("files are different\n");
  }
  #endif
diff -c /arch/4.3/usr/src/new/rcs/src/rcsfnms.c /usr/poppy/guy/src/cmd/rcs/src/rcsfnms.c
*** /arch/4.3/usr/src/new/rcs/src/rcsfnms.c	Thu May 15 02:25:15 1986
--- /usr/poppy/guy/src/cmd/rcs/src/rcsfnms.c	Mon Jul 28 23:29:41 1986
***************
*** 1,8 ****
  /*
   *                     RCS file name handling
   */
   static char rcsid[]=
!  "$Header: rcsfnms.c,v 3.9 86/05/15 02:24:55 lepreau Exp $ Purdue CS";
  /****************************************************************************
   *                     creation and deletion of semaphorefile,
   *                     creation of temporary filenames and cleanup()
--- 1,10 ----
  /*
   *                     RCS file name handling
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsfnms.c,v 3.11 86/07/28 23:27:12 guy Exp $ Purdue CS";
! #endif
  /****************************************************************************
   *                     creation and deletion of semaphorefile,
   *                     creation of temporary filenames and cleanup()
***************
*** 23,28 ****
--- 25,37 ----
  
  
  /* $Log:	rcsfnms.c,v $
+  * Revision 3.11  86/07/28  23:27:12  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.10  86/07/19  02:47:27  guy
+  * Added "mm" macros, and Motorola 68000 and PDP-11 assembler, to list of
+  * file types.
+  * 
   * Revision 3.9  86/05/15  02:24:55  lepreau
   * add suffix .el for gnulisp
   * 
***************
*** 103,109 ****
--- 112,126 ----
          "p",   " * ",   /* pascal      */
          "sh",  "# ",    /* shell       */
          "csh", "# ",    /* shell       */
+ #ifdef sun
+         "s",   "| ",    /* assembler   */
+ #endif
+ #ifdef pdp11
+         "s",   "/ ",    /* assembler   */
+ #endif
+ #ifdef vax
          "s",   "# ",    /* assembler   */
+ #endif
          "sl",  "% ",    /* psl         */
          "red", "% ",    /* psl/rlisp   */
          "cl", ";;; ",    /* common lisp   */
***************
*** 119,124 ****
--- 136,142 ----
          "f",   "c ",    /* fortran     */
          "ms",  "\\\" ", /* ms-macros   t/nroff*/
          "me",  "\\\" ", /* me-macros   t/nroff*/
+         "mm",  "\\\" ", /* mm-macros   t/nroff*/
          "",    "# ",    /* default for empty suffix */
          nil,   ""       /* default for unknown suffix; must always be last */
  };
***************
*** 173,179 ****
                       error("Can't create semaphore file for RCS file %s",RCSfilename);
                       return false;
                  } else
!                      close(fdesc);
                       madesema=true;
          }
          return true;
--- 191,197 ----
                       error("Can't create semaphore file for RCS file %s",RCSfilename);
                       return false;
                  } else
!                      VOID close(fdesc);
                       madesema=true;
          }
          return true;
***************
*** 209,218 ****
  {
          register int i;
  
!         if (finptr!=NULL)   fclose(finptr);
!         if (frewrite!=NULL) fclose(frewrite);
          for (i=0; i<=lastfilename; i++) {
!             if (tfnames[i][0]!='\0')  unlink(tfnames[i]);
          }
          InitCleanup();
          return (rmsema());
--- 227,236 ----
  {
          register int i;
  
!         if (finptr!=NULL)   VOID fclose(finptr);
!         if (frewrite!=NULL) VOID fclose(frewrite);
          for (i=0; i<=lastfilename; i++) {
!             if (tfnames[i][0]!='\0')  VOID unlink(tfnames[i]);
          }
          InitCleanup();
          return (rmsema());
***************
*** 398,404 ****
          } else {
                  /* build second RCS file name by prefixing it with RCSDIR*/
                  /* then try to open one of them */
!                 strcpy(subfilename,RCSDIR); strcat(subfilename,RCS1);
                  opened=(
                  ((finptr=fopen(RCSfilename=subfilename, "r"))!=NULL) ||
                  ((finptr=fopen(RCSfilename=RCS1,"r"))!=NULL) );
--- 416,422 ----
          } else {
                  /* build second RCS file name by prefixing it with RCSDIR*/
                  /* then try to open one of them */
!                 VOID strcpy(subfilename,RCSDIR); VOID strcat(subfilename,RCS1);
                  opened=(
                  ((finptr=fopen(RCSfilename=subfilename, "r"))!=NULL) ||
                  ((finptr=fopen(RCSfilename=RCS1,"r"))!=NULL) );
***************
*** 490,497 ****
                  } else {
                      /* build full path name */
                      realpathlength=lastpathchar-pathbuf+1;
!                     strncpy(namebuf,pathbuf,realpathlength);
!                     strcpy(&namebuf[realpathlength],realname);
                      return(namebuf);
                  }
          }
--- 508,515 ----
                  } else {
                      /* build full path name */
                      realpathlength=lastpathchar-pathbuf+1;
!                     VOID strncpy(namebuf,pathbuf,realpathlength);
!                     VOID strcpy(&namebuf[realpathlength],realname);
                      return(namebuf);
                  }
          }
***************
*** 541,547 ****
  /* Function: renames a file with the name given by from to the name given by to.
   * unlinks the to-file if it already exists. returns -1 on error, 0 otherwise.
   */
! {       unlink(to);      /* no need to check return code; will be caught by link*/
                           /* no harm done if file "to" does not exist            */
          if (link(from,to)<0) return -1;
          return(unlink(from));
--- 559,565 ----
  /* Function: renames a file with the name given by from to the name given by to.
   * unlinks the to-file if it already exists. returns -1 on error, 0 otherwise.
   */
! {       VOID unlink(to);      /* no need to check return code; will be caught by link*/
                           /* no harm done if file "to" does not exist            */
          if (link(from,to)<0) return -1;
          return(unlink(from));
***************
*** 594,600 ****
                          if(d.st_ino == dd.st_ino) {
                              if (name[off] == '/') name[off] = '\0';
                              chdir(name); /*change back to current directory*/
!                             fclose(file);
                              return name;
                          }
                          do {
--- 612,618 ----
                          if(d.st_ino == dd.st_ino) {
                              if (name[off] == '/') name[off] = '\0';
                              chdir(name); /*change back to current directory*/
!                             VOID fclose(file);
                              return name;
                          }
                          do {
***************
*** 608,614 ****
                          }
                          stat(dir.d_name, &dd);
                  } while(dd.st_ino != d.st_ino || dd.st_dev != d.st_dev);
!                 fclose(file);
  
                  /* concatenate file name */
                  i = -1;
--- 626,632 ----
                          }
                          stat(dir.d_name, &dd);
                  } while(dd.st_ino != d.st_ino || dd.st_dev != d.st_dev);
!                 VOID fclose(file);
  
                  /* concatenate file name */
                  i = -1;
***************
*** 621,627 ****
                          name[i+1] = dir.d_name[i];
          } /* end for */
  
! fail:   fclose(file);
          return NULL;
  }
  
--- 639,645 ----
                          name[i+1] = dir.d_name[i];
          } /* end for */
  
! fail:   VOID fclose(file);
          return NULL;
  }
  
diff -c /arch/4.3/usr/src/new/rcs/src/rcsgen.c /usr/poppy/guy/src/cmd/rcs/src/rcsgen.c
*** /arch/4.3/usr/src/new/rcs/src/rcsgen.c	Thu May 15 02:19:59 1986
--- /usr/poppy/guy/src/cmd/rcs/src/rcsgen.c	Mon Jul 28 23:30:07 1986
***************
*** 1,8 ****
  /*
   *                     RCS revision generation
   */
   static char rcsid[]=
!  "$Header: rcsgen.c,v 3.4 86/05/15 02:18:42 lepreau Exp $ Purdue CS";
  /*********************************************************************************
   *********************************************************************************
   *
--- 1,10 ----
  /*
   *                     RCS revision generation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsgen.c,v 3.6 86/07/28 23:27:42 guy Exp $ Purdue CS";
! #endif
  /*********************************************************************************
   *********************************************************************************
   *
***************
*** 19,24 ****
--- 21,32 ----
  
  
  /* $Log:	rcsgen.c,v $
+  * Revision 3.6  86/07/28  23:27:42  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.5  86/07/19  02:51:22  guy
+  * Changed to properly cast null pointer arguments.
+  * 
   * Revision 3.4  86/05/15  02:18:42  lepreau
   * Fix immediate EOF from non-tty files: avoid 0377's in description.
   * 
***************
*** 120,131 ****
                  if (!expandflag) {
                          /* no keyword expansion; only invoked from ci */
                          scandeltatext(deltas[i],edit);
!                         finishedit(nil);
                          ffclose(fcopy);
                  } else {
                          /* perform keyword expansion*/
                          /* first, get to beginning of file*/
!                         finishedit(nil); swapeditfiles(dir==nil);
                          scandeltatext(deltas[i],edit_expand);
                          finishedit(deltas[i]);
                          if (dir!=nil) ffclose(fcopy);
--- 128,139 ----
                  if (!expandflag) {
                          /* no keyword expansion; only invoked from ci */
                          scandeltatext(deltas[i],edit);
!                         finishedit((struct hshentry *)nil);
                          ffclose(fcopy);
                  } else {
                          /* perform keyword expansion*/
                          /* first, get to beginning of file*/
!                         finishedit((struct hshentry *)nil); swapeditfiles(dir==nil);
                          scandeltatext(deltas[i],edit_expand);
                          finishedit(deltas[i]);
                          if (dir!=nil) ffclose(fcopy);
***************
*** 170,176 ****
                                          break;
                          case expand:    xpandstring(delta);
                                          break;
!                         case edit:      editstring(nil);
                                          break;
                          case edit_expand: editstring(delta);
                                          break;
--- 178,184 ----
                                          break;
                          case expand:    xpandstring(delta);
                                          break;
!                         case edit:      editstring((struct hshentry *)nil);
                                          break;
                          case edit_expand: editstring(delta);
                                          break;
***************
*** 195,201 ****
  
          if (!initflag && !textflag) {
                  /* copy old description */
!                 fprintf(frewrite,"\n\n%s%c",Kdesc,nextc);
                  rewriteflag=true; getdesc(false);
                  return true;
          } else {
--- 203,209 ----
  
          if (!initflag && !textflag) {
                  /* copy old description */
!                 VOID fprintf(frewrite,"\n\n%s%c",Kdesc,nextc);
                  rewriteflag=true; getdesc(false);
                  return true;
          } else {
***************
*** 204,222 ****
                          /*skip old description*/
                          rewriteflag=false; getdesc(false);
                  }
!                 fprintf(frewrite,"\n\n%s\n%c",Kdesc,SDELIM);
                  if (textfile) {
                          old1='\n';
                          /* copy textfile */
                          if ((txt=fopen(textfile,"r"))!=NULL) {
                                  while ((c=getc(txt))!=EOF) {
!                                         if (c==SDELIM) putc(c,frewrite); /*double up*/
!                                         putc(c,frewrite);
                                          old1=c;
                                  }
!                                 if (old1!='\n') putc('\n',frewrite);
!                                 fclose(txt);
!                                 putc(SDELIM,frewrite);fputs("\n\n", frewrite);
                                  return true;
                          } else {
                                  error("Can't open file with description%s",textfile);
--- 212,230 ----
                          /*skip old description*/
                          rewriteflag=false; getdesc(false);
                  }
!                 VOID fprintf(frewrite,"\n\n%s\n%c",Kdesc,SDELIM);
                  if (textfile) {
                          old1='\n';
                          /* copy textfile */
                          if ((txt=fopen(textfile,"r"))!=NULL) {
                                  while ((c=getc(txt))!=EOF) {
!                                         if (c==SDELIM) VOID putc(c,frewrite); /*double up*/
!                                         VOID putc(c,frewrite);
                                          old1=c;
                                  }
!                                 if (old1!='\n') VOID putc('\n',frewrite);
!                                 VOID fclose(txt);
!                                 VOID putc(SDELIM,frewrite); VOID fputs("\n\n", frewrite);
                                  return true;
                          } else {
                                  error("Can't open file with description%s",textfile);
***************
*** 224,241 ****
                  }
                  if (initflag&&quietflag) {
                          warn("empty descriptive text");
!                         putc(SDELIM,frewrite);fputs("\n\n", frewrite);
                          return true;
                  }
                  /* read text from stdin */
                  if (isatty(fileno(stdin))) {
!                     fputs("enter description, terminated with ^D or '.':\n",stdout);
!                     fputs("NOTE: This is NOT the log message!\n>> ",stdout);
                  }
                  c = '\0'; old2= '\n';
                  if ((old1=getchar())==EOF) {
  		    if (isatty(fileno(stdin))) {
! 			putc('\n',stdout);
  			clearerr(stdin);
  		    }
  		}
--- 232,249 ----
                  }
                  if (initflag&&quietflag) {
                          warn("empty descriptive text");
!                         VOID putc(SDELIM,frewrite); VOID fputs("\n\n", frewrite);
                          return true;
                  }
                  /* read text from stdin */
                  if (isatty(fileno(stdin))) {
!                     VOID fputs("enter description, terminated with ^D or '.':\n",stdout);
!                     VOID fputs("NOTE: This is NOT the log message!\n>> ",stdout);
                  }
                  c = '\0'; old2= '\n';
                  if ((old1=getchar())==EOF) {
  		    if (isatty(fileno(stdin))) {
! 			VOID putc('\n',stdout);
  			clearerr(stdin);
  		    }
  		}
***************
*** 243,265 ****
                              c=getchar();
                              if (c==EOF) {
                                      if (isatty(fileno(stdin))) {
! 					putc('\n',stdout);
  					clearerr(stdin);
  				    }
!                                     putc(old1,frewrite);
!                                     if (old1!='\n') putc('\n',frewrite);
                                      break;
                              }
                              if (c=='\n' && old1=='.' && old2=='\n') {
                                      break;
                              }
!                             if (c=='\n' && isatty(fileno(stdin))) fputs(">> ",stdout);
!                             if(old1==SDELIM) putc(old1,frewrite); /* double up*/
!                             putc(old1,frewrite);
                              old2=old1;
                              old1=c;
                      } /* end for */
!                 putc(SDELIM,frewrite);fputs("\n\n",frewrite);
                  return true;
          }
  }
--- 251,273 ----
                              c=getchar();
                              if (c==EOF) {
                                      if (isatty(fileno(stdin))) {
! 					VOID putc('\n',stdout);
  					clearerr(stdin);
  				    }
!                                     VOID putc(old1,frewrite);
!                                     if (old1!='\n') VOID putc('\n',frewrite);
                                      break;
                              }
                              if (c=='\n' && old1=='.' && old2=='\n') {
                                      break;
                              }
!                             if (c=='\n' && isatty(fileno(stdin))) VOID fputs(">> ",stdout);
!                             if(old1==SDELIM) VOID putc(old1,frewrite); /* double up*/
!                             VOID putc(old1,frewrite);
                              old2=old1;
                              old1=c;
                      } /* end for */
!                 VOID putc(SDELIM,frewrite); VOID fputs("\n\n",frewrite);
                  return true;
          }
  }
diff -c /arch/4.3/usr/src/new/rcs/src/rcskeep.c /usr/poppy/guy/src/cmd/rcs/src/rcskeep.c
*** /arch/4.3/usr/src/new/rcs/src/rcskeep.c	Wed May 11 14:02:29 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcskeep.c	Mon Jul 28 23:30:30 1986
***************
*** 1,8 ****
  /*
   *                     RCS keyword extraction
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcskeep.c,v 3.2 82/12/24 12:08:26 wft Exp $ Purdue CS";
  /*****************************************************************************
   *                       main routine: getoldkeys()
   *                       Testprogram: define GETOLDTEST
--- 1,10 ----
  /*
   *                     RCS keyword extraction
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcskeep.c,v 3.4 86/07/28 23:28:05 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       main routine: getoldkeys()
   *                       Testprogram: define GETOLDTEST
***************
*** 22,27 ****
--- 24,36 ----
  
  
  /* $Log:	rcskeep.c,v $
+  * Revision 3.4  86/07/28  23:28:05  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.3  86/07/19  02:54:07  guy
+  * Changed to properly declare argument "fname" and to pass the second argument
+  * to "checkid" in all cases.
+  * 
   * Revision 3.2  82/12/24  12:08:26  wft
   * added missing #endif.
   * 
***************
*** 37,42 ****
--- 46,52 ----
  #include  "rcsbase.h"
  extern char * checkid();
  extern FILE * fopen();
+ static int getval();
  
  FILE * fp;
  #define IDLENGTH 30
***************
*** 48,53 ****
--- 58,64 ----
  char prevlocker[IDLENGTH];
  
  getoldkeys(fname)
+ char * fname;
  /* Function: Tries to read keyword values for author, date,
   * revision number, RCS file, and state out of the file fname.
   * The results are placed into
***************
*** 75,88 ****
              tp = keyword;
              while( ctab[(c=getc(fp))]==LETTER && tp< keyword+keylength)
                  *tp++ = c;
!             if (c==KDELIM) {ungetc(c,fp);continue;}
              if (c!=VDELIM) continue;
              *tp='\0';
              while ((c=getc(fp))==' '||c=='\t'); /* skip blanks */
!             ungetc(c,fp); /* needed for getval */
              if (strcmp(keyword, AUTHOR)==0 ) {
                  if (getval(prevauthor,IDLENGTH,true))
!                     if (!checkid(prevauthor)) goto errexit;
              } elsif ( strcmp(keyword,DATE)==0 ) {
                  if (!getprevdate(true)) goto errexit;
              } elsif ( strcmp(keyword, HEADER)==0 ) {
--- 86,99 ----
              tp = keyword;
              while( ctab[(c=getc(fp))]==LETTER && tp< keyword+keylength)
                  *tp++ = c;
!             if (c==KDELIM) {VOID ungetc(c,fp);continue;}
              if (c!=VDELIM) continue;
              *tp='\0';
              while ((c=getc(fp))==' '||c=='\t'); /* skip blanks */
!             VOID ungetc(c,fp); /* needed for getval */
              if (strcmp(keyword, AUTHOR)==0 ) {
                  if (getval(prevauthor,IDLENGTH,true))
!                     if (!checkid(prevauthor,'\0')) goto errexit;
              } elsif ( strcmp(keyword,DATE)==0 ) {
                  if (!getprevdate(true)) goto errexit;
              } elsif ( strcmp(keyword, HEADER)==0 ) {
***************
*** 94,102 ****
                      }
                      if (!getprevdate(false)) goto errexit;
                      if (!getval(prevauthor,IDLENGTH,false)) goto errexit;
!                     if (!checkid(prevauthor)) goto errexit;
                      if (!getval(prevstate,IDLENGTH,false)) goto errexit;
!                     if (!checkid(prevstate)) goto errexit;
                  }
              } elsif ( strcmp(keyword, LOCKER)==0 ) {
                  getval(prevlocker,IDLENGTH,true);
--- 105,113 ----
                      }
                      if (!getprevdate(false)) goto errexit;
                      if (!getval(prevauthor,IDLENGTH,false)) goto errexit;
!                     if (!checkid(prevauthor,'\0')) goto errexit;
                      if (!getval(prevstate,IDLENGTH,false)) goto errexit;
!                     if (!checkid(prevstate,'\0')) goto errexit;
                  }
              } elsif ( strcmp(keyword, LOCKER)==0 ) {
                  getval(prevlocker,IDLENGTH,true);
***************
*** 112,118 ****
                  getval(prevsource,NCPPN,true);
              } elsif ( strcmp(keyword, STATE)==0 ) {
                  if (getval(prevstate,IDLENGTH,true))
!                     if (!checkid(prevstate)) goto errexit;
              } else {
                 continue;
              }
--- 123,129 ----
                  getval(prevsource,NCPPN,true);
              } elsif ( strcmp(keyword, STATE)==0 ) {
                  if (getval(prevstate,IDLENGTH,true))
!                     if (!checkid(prevstate,'\0')) goto errexit;
              } else {
                 continue;
              }
***************
*** 125,140 ****
             }
          }
      }
!     fclose(fp);
      return true;
  
  errexit:
      prevauthor[0]=prevsource[0]=prevstate[0]=prevdate[0]=prevrev[0]= '\0';
!     fclose(fp); return false;
  }
  
  
! getval(target,maxchars,optional)
  char * target; int maxchars, optional;
  /* Function: Places a keyword value into target, but not more
   * than maxchars characters. Prints an error if optiona==false
--- 136,151 ----
             }
          }
      }
!     VOID fclose(fp);
      return true;
  
  errexit:
      prevauthor[0]=prevsource[0]=prevstate[0]=prevdate[0]=prevrev[0]= '\0';
!     VOID fclose(fp); return false;
  }
  
  
! static int getval(target,maxchars,optional)
  char * target; int maxchars, optional;
  /* Function: Places a keyword value into target, but not more
   * than maxchars characters. Prints an error if optiona==false
***************
*** 148,154 ****
      if (c==KDELIM) {
          if (!optional)
              error("Missing keyword value");
!         ungetc(c,fp);
          return false;
      } else {
          while (!(c==' '||c=='\n'||c=='\t'||c==KDELIM||c==EOF)) {
--- 159,165 ----
      if (c==KDELIM) {
          if (!optional)
              error("Missing keyword value");
!         VOID ungetc(c,fp);
          return false;
      } else {
          while (!(c==' '||c=='\n'||c=='\t'||c==KDELIM||c==EOF)) {
***************
*** 162,172 ****
          }
          *tp= '\0';
  #       ifdef GETOLDTEST
!         printf("getval: %s\n",target);
  #       endif
          while(c==' '||c=='\t') c=getc(fp); /* skip trailing blanks */
      }
!     ungetc(c,fp);
      return true;
  }
  
--- 173,183 ----
          }
          *tp= '\0';
  #       ifdef GETOLDTEST
!         VOID printf("getval: %s\n",target);
  #       endif
          while(c==' '||c=='\t') c=getc(fp); /* skip trailing blanks */
      }
!     VOID ungetc(c,fp);
      return true;
  }
  
***************
*** 186,193 ****
      /*process date */
      prevday[2]=prevday[5]=prevday[8]=prevtime[2]=prevtime[5]='.';
      prevday[9]='\0';
!     strcpy(prevdate,prevday);
!     strcat(prevdate,prevtime);
      if (!checknum(prevdate,5)) {
              error("Bad date: %s",prevdate);
              prevdate[0]='\0';
--- 197,204 ----
      /*process date */
      prevday[2]=prevday[5]=prevday[8]=prevtime[2]=prevtime[5]='.';
      prevday[9]='\0';
!     VOID strcpy(prevdate,prevday);
!     VOID strcat(prevdate,prevtime);
      if (!checknum(prevdate,5)) {
              error("Bad date: %s",prevdate);
              prevdate[0]='\0';
***************
*** 221,227 ****
          cmdid="getoldkeys";
          while (*(++argv)) {
                  if (getoldkeys(*argv))
!                 printf("%s:  revision: %s, date: %s, author: %s, state: %s\n",
                          *argv, prevrev, prevdate, prevauthor,prevstate);
          }
  }
--- 232,238 ----
          cmdid="getoldkeys";
          while (*(++argv)) {
                  if (getoldkeys(*argv))
!                 VOID printf("%s:  revision: %s, date: %s, author: %s, state: %s\n",
                          *argv, prevrev, prevdate, prevauthor,prevstate);
          }
  }
diff -c /arch/4.3/usr/src/new/rcs/src/rcslex.c /usr/poppy/guy/src/cmd/rcs/src/rcslex.c
*** /arch/4.3/usr/src/new/rcs/src/rcslex.c	Wed May 11 10:03:39 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcslex.c	Tue Jul 29 12:49:33 1986
***************
*** 1,8 ****
  /*
   *                     RCS file input
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcslex.c,v 3.3 82/12/10 16:22:37 wft Exp $ Purdue CS";
  /*********************************************************************************
   *                     Lexical Analysis.
   *                     Character mapping table,
--- 1,10 ----
  /*
   *                     RCS file input
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcslex.c,v 3.5 86/07/28 23:28:31 guy Exp $ Purdue CS";
! #endif
  /*********************************************************************************
   *                     Lexical Analysis.
   *                     Character mapping table,
***************
*** 25,30 ****
--- 27,40 ----
   */
  
  /* $Log:	rcslex.c,v $
+  * Revision 3.5  86/07/28  23:28:31  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.4  86/07/19  03:00:55  guy
+  * "lint" cleanups, made to work on systems with "vfprintf" but not "_doprnt",
+  * and gave some error routines more arguments so they're more likely to work
+  * on machines where sizeof(int) != sizeof(char *).
+  * 
   * Revision 3.3  82/12/10  16:22:37  wft
   * Improved error messages, changed exit status on error to 1.
   * 
***************
*** 149,155 ****
                          hshtab[ihash].num = NextString;
                          nexthsh= &hshtab[ihash];/*save hashtable address*/
  #                       ifdef LEXDB
!                         printf("\nEntered: %s at %d ",nexthsh->num, ihash);
  #                       endif
                          return;
                  }
--- 159,165 ----
                          hshtab[ihash].num = NextString;
                          nexthsh= &hshtab[ihash];/*save hashtable address*/
  #                       ifdef LEXDB
!                         VOID printf("\nEntered: %s at %d ",nexthsh->num, ihash);
  #                       endif
                          return;
                  }
***************
*** 243,249 ****
          case NEWLN:
                  line++;
  #               ifdef LEXDB
!                 putchar('\n');
  #               endif
                  /* Note: falls into next case */
  
--- 253,259 ----
          case NEWLN:
                  line++;
  #               ifdef LEXDB
!                 VOID putchar('\n');
  #               endif
                  /* Note: falls into next case */
  
***************
*** 423,429 ****
                                  return;
                          }
                  }
!                 putchar(c);
          }
          nextc = c;
          error("Unterminated string");
--- 433,439 ----
                                  return;
                          }
                  }
!                 VOID putchar(c);
          }
          nextc = c;
          error("Unterminated string");
***************
*** 514,576 ****
  }
  
  
  serror(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* non-fatal syntax error */
  {       nerror++;
!         fprintf(stderr,"%s error, line %d: ", cmdid, line);
!         fprintf(stderr,e, e1, e2, e3, e4, e5);
!         putc('\n',stderr);
  }
  
  error(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* non-fatal error */
  {       nerror++;
!         fprintf(stderr,"%s error: ",cmdid);
!         fprintf(stderr,e, e1, e2, e3, e4, e5);
!         putc('\n',stderr);
  }
  
  fatserror(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* fatal syntax error */
  {       nerror++;
!         fprintf(stderr,"%s error, line %d: ", cmdid,line);
!         fprintf(stderr,e, e1, e2, e3, e4, e5);
!         fprintf(stderr,"\n%s aborted\n",cmdid);
          cleanup();
          exit(1);
  }
  
  faterror(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* fatal error, terminates program after cleanup */
  {       nerror++;
!         fprintf(stderr,"%s error: ",cmdid);
!         fprintf(stderr,e, e1, e2, e3, e4, e5);
!         fprintf(stderr,"\n%s aborted\n",cmdid);
          cleanup();
          exit(1);
  }
  
  warn(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* prints a warning message */
  {       nwarn++;
!         fprintf(stderr,"%s warning: ",cmdid);
!         fprintf(stderr,e, e1, e2, e3, e4, e5);
!         putc('\n',stderr);
  }
  
  
  diagnose(e,e1,e2,e3,e4,e5)
! char * e, * e1;
  /* prints a diagnostic message */
  {
          if (!quietflag) {
!                 fprintf(stderr,e, e1, e2, e3, e4, e5);
!                 putc('\n',stderr);
          }
  }
  
--- 524,592 ----
  }
  
  
+ /*VARARGS1*/
  serror(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* non-fatal syntax error */
  {       nerror++;
!         VOID fprintf(stderr,"%s error, line %d: ", cmdid, line);
!         VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!         VOID putc('\n',stderr);
  }
  
+ /*VARARGS1*/
  error(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* non-fatal error */
  {       nerror++;
!         VOID fprintf(stderr,"%s error: ",cmdid);
!         VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!         VOID putc('\n',stderr);
  }
  
+ /*VARARGS1*/
  fatserror(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* fatal syntax error */
  {       nerror++;
!         VOID fprintf(stderr,"%s error, line %d: ", cmdid,line);
!         VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!         VOID fprintf(stderr,"\n%s aborted\n",cmdid);
          cleanup();
          exit(1);
  }
  
+ /*VARARGS1*/
  faterror(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* fatal error, terminates program after cleanup */
  {       nerror++;
!         VOID fprintf(stderr,"%s error: ",cmdid);
!         VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!         VOID fprintf(stderr,"\n%s aborted\n",cmdid);
          cleanup();
          exit(1);
  }
  
+ /*VARARGS1*/
  warn(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* prints a warning message */
  {       nwarn++;
!         VOID fprintf(stderr,"%s warning: ",cmdid);
!         VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!         VOID putc('\n',stderr);
  }
  
  
+ /*VARARGS1*/
  diagnose(e,e1,e2,e3,e4,e5)
! char * e, * e1, * e2, * e3, * e4, * e5;
  /* prints a diagnostic message */
  {
          if (!quietflag) {
!                 VOID fprintf(stderr,e, e1, e2, e3, e4, e5);
!                 VOID putc('\n',stderr);
          }
  }
  
***************
*** 577,583 ****
  
  
  fflsbuf(c, iop)
! int c; register FILE * iop;
  /* Function: Flush iop.
   * Same routine as _flsbuf in stdio, but aborts program on error.
   */
--- 593,599 ----
  
  
  fflsbuf(c, iop)
! unsigned c; register FILE * iop;
  /* Function: Flush iop.
   * Same routine as _flsbuf in stdio, but aborts program on error.
   */
***************
*** 612,618 ****
--- 628,638 ----
   * but aborts program on error
   */
  {
+ #ifdef VFPRINTF
+ 	VOID vfprintf(iop, fmt, &args);
+ #else
  	_doprnt(fmt, &args, iop);
+ #endif VFPRINTF
          if (ferror(iop)) {
                  faterror("write error");
                  return EOF;
***************
*** 632,638 ****
  {
          cmdid="lextest";
          if (argc<2) {
!                 fputs("No input file\n",stderr);
                  exit(1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
--- 652,658 ----
  {
          cmdid="lextest";
          if (argc<2) {
!                 VOID fputs("No input file\n",stderr);
                  exit(1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
***************
*** 644,680 ****
          switch (nexttok) {
  
          case ID:
!                 printf("ID: %s",NextString);
                  break;
  
          case NUM:
                  if (hshenter==true)
!                    printf("NUM: %s, index: %d",nexthsh->num, nexthsh-hshtab);
                  else
!                    printf("NUM, unentered: %s",NextString);
                  hshenter = !hshenter; /*alternate between dates and numbers*/
                  break;
  
          case COLON:
!                 printf("COLON"); break;
  
          case SEMI:
!                 printf("SEMI"); break;
  
          case STRING:
                  readstring();
!                 printf("STRING"); break;
  
          case UNKN:
!                 printf("UNKN"); break;
  
          default:
!                 printf("DEFAULT"); break;
          }
!         printf(" | ");
          nextlex();
          }
!         printf("\nEnd of lexical analyzer test\n");
  }
  
  cleanup()
--- 664,700 ----
          switch (nexttok) {
  
          case ID:
!                 VOID printf("ID: %s",NextString);
                  break;
  
          case NUM:
                  if (hshenter==true)
!                    VOID printf("NUM: %s, index: %d",nexthsh->num, nexthsh-hshtab);
                  else
!                    VOID printf("NUM, unentered: %s",NextString);
                  hshenter = !hshenter; /*alternate between dates and numbers*/
                  break;
  
          case COLON:
!                 VOID printf("COLON"); break;
  
          case SEMI:
!                 VOID printf("SEMI"); break;
  
          case STRING:
                  readstring();
!                 VOID printf("STRING"); break;
  
          case UNKN:
!                 VOID printf("UNKN"); break;
  
          default:
!                 VOID printf("DEFAULT"); break;
          }
!         VOID printf(" | ");
          nextlex();
          }
!         VOID printf("\nEnd of lexical analyzer test\n");
  }
  
  cleanup()
diff -c /arch/4.3/usr/src/new/rcs/src/rcsmerge.c /usr/poppy/guy/src/cmd/rcs/src/rcsmerge.c
*** /arch/4.3/usr/src/new/rcs/src/rcsmerge.c	Wed May 11 15:10:23 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcsmerge.c	Mon Jul 28 23:31:18 1986
***************
*** 1,8 ****
  /*
   *                       rcsmerge operation
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcsmerge.c,v 3.3 82/12/24 15:29:00 wft Exp $ Purdue CS";
  /*****************************************************************************
   *                       join 2 revisions with respect to a third
   *****************************************************************************
--- 1,10 ----
  /*
   *                       rcsmerge operation
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsmerge.c,v 3.5 86/07/28 23:28:53 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       join 2 revisions with respect to a third
   *****************************************************************************
***************
*** 20,25 ****
--- 22,33 ----
  
  
  /* $Log:	rcsmerge.c,v $
+  * Revision 3.5  86/07/28  23:28:53  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.4  86/07/19  03:03:49  guy
+  * Changed to properly cast null pointer arguments.
+  * 
   * Revision 3.3  82/12/24  15:29:00  wft
   * Added call to catchsig().
   * 
***************
*** 31,37 ****
--- 39,47 ----
   *
   */
  #include "rcsbase.h"
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  extern int  cleanup();              /* cleanup after signals                */
  extern char * mktempfile();         /*temporary file name generator         */
***************
*** 102,112 ****
  
  
                  if (!expandsym(rev1,numericrev)) goto end;
!                 if (!(target=genrevs(numericrev,nil,nil,nil,gendeltas))) goto end;
                  rev1=target->num;
                  if (revnums==1) rev2=Head->num; /* default for rev2 */
                  if (!expandsym(rev2,numericrev)) goto end;
!                 if (!(target=genrevs(numericrev,nil,nil,nil,gendeltas))) goto end;
                  rev2=target->num;
  
                  temp1file=mktempfile("/tmp/",TMPFILE1);
--- 112,122 ----
  
  
                  if (!expandsym(rev1,numericrev)) goto end;
!                 if (!(target=genrevs(numericrev,(char *)nil,(char *)nil,(char *)nil,gendeltas))) goto end;
                  rev1=target->num;
                  if (revnums==1) rev2=Head->num; /* default for rev2 */
                  if (!expandsym(rev2,numericrev)) goto end;
!                 if (!(target=genrevs(numericrev,(char *)nil,(char *)nil,(char *)nil,gendeltas))) goto end;
                  rev2=target->num;
  
                  temp1file=mktempfile("/tmp/",TMPFILE1);
***************
*** 113,125 ****
                  temp2file=mktempfile("/tmp/",TMPFILE2);
  
                  diagnose("retrieving revision %s",rev1);
!                 sprintf(command,"%s/co -q -p%s %s > %s\n",
                          TARGETDIR,rev1,RCSfilename,temp1file);
                  if (system(command)){
                          faterror("co failed");
                  }
                  diagnose("retrieving revision %s",rev2);
!                 sprintf(command,"%s/co -q -p%s %s > %s\n",
                           TARGETDIR,rev2,RCSfilename,temp2file);
                  if (system(command)){
                          faterror("co failed");
--- 123,135 ----
                  temp2file=mktempfile("/tmp/",TMPFILE2);
  
                  diagnose("retrieving revision %s",rev1);
!                 VOID sprintf(command,"%s/co -q -p%s %s > %s\n",
                          TARGETDIR,rev1,RCSfilename,temp1file);
                  if (system(command)){
                          faterror("co failed");
                  }
                  diagnose("retrieving revision %s",rev2);
!                 VOID sprintf(command,"%s/co -q -p%s %s > %s\n",
                           TARGETDIR,rev2,RCSfilename,temp2file);
                  if (system(command)){
                          faterror("co failed");
***************
*** 128,134 ****
                           rev1, rev2, workfilename,
                           tostdout?"; result to stdout":"");
  
!                 sprintf(command,"%s %s%s %s %s %s %s\n",MERGE,tostdout?"-p ":"",
                          workfilename,temp1file,temp2file,workfilename,rev2);
                  if (system(command)) {
                          faterror("merge failed");
--- 138,144 ----
                           rev1, rev2, workfilename,
                           tostdout?"; result to stdout":"");
  
!                 VOID sprintf(command,"%s %s%s %s %s %s %s\n",MERGE,tostdout?"-p ":"",
                          workfilename,temp1file,temp2file,workfilename,rev2);
                  if (system(command)) {
                          faterror("merge failed");
diff -c /arch/4.3/usr/src/new/rcs/src/rcsrev.c /usr/poppy/guy/src/cmd/rcs/src/rcsrev.c
*** /arch/4.3/usr/src/new/rcs/src/rcsrev.c	Thu Oct 24 08:31:03 1985
--- /usr/poppy/guy/src/cmd/rcs/src/rcsrev.c	Mon Jul 28 23:31:45 1986
***************
*** 2,9 ****
  /*
   *                     RCS revision number handling
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcsrev.c,v 3.4 82/12/04 13:24:08 wft Exp $ Purdue CS";
  /*********************************************************************************
   *********************************************************************************
   *
--- 2,11 ----
  /*
   *                     RCS revision number handling
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsrev.c,v 3.6 86/07/28 23:29:18 guy Exp $ Purdue CS";
! #endif
  /*********************************************************************************
   *********************************************************************************
   *
***************
*** 20,25 ****
--- 22,34 ----
  
  
  /* $Log:	rcsrev.c,v $
+  * Revision 3.6  86/07/28  23:29:18  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.5  86/07/19  03:06:32  guy
+  * Changed to properly cast null pointer arguments.
+  * "NOTREACHED" added to silence "lint".
+  * 
   * Revision 3.4  82/12/04  13:24:08  wft
   * Replaced getdelta() with gettree().
   * 
***************
*** 87,93 ****
  
          numflds=countnumflds(revno);
          if (numflds%2 == 1)
!                 strcpy(branchno,revno);
          else {
                  sp=revno; tp=branchno;
                  for (i=1;i<numflds;i++) {
--- 96,102 ----
  
          numflds=countnumflds(revno);
          if (numflds%2 == 1)
!                 VOID strcpy(branchno,revno);
          else {
                  sp=revno; tp=branchno;
                  for (i=1;i<numflds;i++) {
***************
*** 221,226 ****
--- 230,236 ----
  
          if ( *s1 == '\0' ) return 1;
          if ( *s2 == '\0' ) return -1;
+ /*NOTREACHED*/
  }
  
  
***************
*** 239,249 ****
                  while (*sp != '.') *tp++ = *sp++;
                  *tp++ = *sp++;  /* copy dot also */
          }
!         sprintf(tp,"%d",atoi(sp)+1);
  }
  
  
! char * partialno(rev1,rev2,length)
  char * rev1, * rev2; register int length;
  /* Function: Copies length fields of revision number rev2 into rev1.
   * returns rev1.
--- 249,259 ----
                  while (*sp != '.') *tp++ = *sp++;
                  *tp++ = *sp++;  /* copy dot also */
          }
!         VOID sprintf(tp,"%d",atoi(sp)+1);
  }
  
  
! static char * partialno(rev1,rev2,length)
  char * rev1, * rev2; register int length;
  /* Function: Copies length fields of revision number rev2 into rev1.
   * returns rev1.
***************
*** 287,296 ****
          /* This will terminate since r1 and r2 are not the same; see above*/
          if (l3==0) {
                  /* no common prefix. Common ancestor on main trunk. */
!                 partialno(t1,r1,l1>2?2:l1);partialno(t2,r2,l2>2?2:l2);
                  if (cmpnum(t1,t2)<0)
!                         strcpy(r3,t1);
!                 else    strcpy(r3,t2);
                  if ((cmpnum(r3,r1)==0)||(cmpnum(r3,r2)==0)) {
                          error("Ancestor for %s and %s undefined.",r1,r2);
                          return false;
--- 297,306 ----
          /* This will terminate since r1 and r2 are not the same; see above*/
          if (l3==0) {
                  /* no common prefix. Common ancestor on main trunk. */
!                 VOID partialno(t1,r1,l1>2?2:l1); VOID partialno(t2,r2,l2>2?2:l2);
                  if (cmpnum(t1,t2)<0)
!                         VOID strcpy(r3,t1);
!                 else    VOID strcpy(r3,t2);
                  if ((cmpnum(r3,r1)==0)||(cmpnum(r3,r2)==0)) {
                          error("Ancestor for %s and %s undefined.",r1,r2);
                          return false;
***************
*** 630,636 ****
  
          cmdid = "revtest";
          if (argc<2) {
!                 fputs("No input file\n",stderr);
                  exit(-1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
--- 640,646 ----
  
          cmdid = "revtest";
          if (argc<2) {
!                 VOID fputs("No input file\n",stderr);
                  exit(-1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
***************
*** 646,674 ****
          do {
                  /* all output goes to stderr, to have diagnostics and       */
                  /* errors in sequence.                                      */
!                 fprintf(stderr,"\nEnter revision number or <return> or '.': ");
                  if(gets(symrevno)==NULL) break;
                  if (*symrevno == '.') break;
!                 fprintf(stderr,"%s;\n",symrevno);
                  expandsym(symrevno,numricrevno);
!                 fprintf(stderr,"expanded number: %s; ",numricrevno);
!                 fprintf(stderr,"Date: ");
!                 gets(date); fprintf(stderr,"%s; ",date);
!                 fprintf(stderr,"Author: ");
!                 gets(author);fprintf(stderr,"%s; ",author);
!                 fprintf(stderr,"State: ");
!                 gets(state); fprintf(stderr, "%s;\n", state);
!                 target=genrevs(numricrevno,*date=='\0'?nil:date, *author=='\0'?nil:author,
!                               *state=='\0'?nil:state,gendeltas);
                  if (target!=nil) {
                          i=0;
                          while (gendeltas[i]!=nil) {
!                                 fprintf(stderr,"%s\n",gendeltas[i++]->num);
                          }
                  }
          } while (true);
  	clearerr(stdin);
!         fprintf(stderr,"done\n");
  
  }
  
--- 656,684 ----
          do {
                  /* all output goes to stderr, to have diagnostics and       */
                  /* errors in sequence.                                      */
!                 VOID fprintf(stderr,"\nEnter revision number or <return> or '.': ");
                  if(gets(symrevno)==NULL) break;
                  if (*symrevno == '.') break;
!                 VOID fprintf(stderr,"%s;\n",symrevno);
                  expandsym(symrevno,numricrevno);
!                 VOID fprintf(stderr,"expanded number: %s; ",numricrevno);
!                 VOID fprintf(stderr,"Date: ");
!                 gets(date); VOID fprintf(stderr,"%s; ",date);
!                 VOID fprintf(stderr,"Author: ");
!                 gets(author); VOID fprintf(stderr,"%s; ",author);
!                 VOID fprintf(stderr,"State: ");
!                 gets(state); VOID fprintf(stderr, "%s;\n", state);
!                 target=genrevs(numricrevno,*date=='\0'?(char *)nil:date, *author=='\0'?(char *)nil:author,
!                               *state=='\0'?(char *)nil:state,gendeltas);
                  if (target!=nil) {
                          i=0;
                          while (gendeltas[i]!=nil) {
!                                 VOID fprintf(stderr,"%s\n",gendeltas[i++]->num);
                          }
                  }
          } while (true);
  	clearerr(stdin);
!         VOID fprintf(stderr,"done\n");
  
  }
  
diff -c /arch/4.3/usr/src/new/rcs/src/rcssyn.c /usr/poppy/guy/src/cmd/rcs/src/rcssyn.c
*** /arch/4.3/usr/src/new/rcs/src/rcssyn.c	Wed May 11 10:05:57 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcssyn.c	Mon Jul 28 23:32:11 1986
***************
*** 2,9 ****
  /*
   *                     RCS file input
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcssyn.c,v 3.6 83/01/15 17:46:50 wft Exp $ Purdue CS";
  /*********************************************************************************
   *                       Syntax Analysis.
   *                       Keyword table
--- 2,11 ----
  /*
   *                     RCS file input
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcssyn.c,v 3.7 86/07/28 23:29:45 guy Exp $ Purdue CS";
! #endif
  /*********************************************************************************
   *                       Syntax Analysis.
   *                       Keyword table
***************
*** 24,29 ****
--- 26,34 ----
  
  
  /* $Log:	rcssyn.c,v $
+  * Revision 3.7  86/07/28  23:29:45  guy
+  * More "lint" cleanups.
+  * 
   * Revision 3.6  83/01/15  17:46:50  wft
   * Changed readdelta() to initialize selector and log-pointer.
   * Changed puttree to check for selector==DELETE; putdtext() uses DELNUMFORM.
***************
*** 93,99 ****
--- 98,106 ----
  char * Knext       = "next";
  char * Kstate      = "state";
  char * Kstrict     = "strict";
+ #ifdef COMPAT2
  char * Ksuffix     = "suffix";
+ #endif
  char * Ksymbols    = "symbols";
  char * Ktext       = "text";
  
***************
*** 278,284 ****
  
  gettree()
  /* Function: Reads in the delta tree with getdelta(), then
!  * updates the lockedby fields. Returns the total number of deltas read.
   */
  {       struct lock * currlock;
          while (getdelta());
--- 285,291 ----
  
  gettree()
  /* Function: Reads in the delta tree with getdelta(), then
!  * updates the lockedby fields.
   */
  {       struct lock * currlock;
          while (getdelta());
***************
*** 287,293 ****
                  currlock->delta->lockedby = currlock->login;
                  currlock = currlock->nextlock;
          }
-         return TotalDeltas;
  }
  
  
--- 294,299 ----
***************
*** 351,387 ****
          struct access * curaccess;
          register char * sp;
  
!         fputs(Khead,fout); fputs("     ",fout);
!         if (Head) fputs(Head->num,fout);
  
!         fprintf(fout,";\n%s  ",Kaccess);
          curaccess = AccessList;
!         if (curaccess==nil) putc(' ',fout);
          while (curaccess) {
!                putc(' ',fout);
!                fputs(curaccess->login,fout);
                 curaccess = curaccess->nextaccess;
          }
!         fprintf(fout,";\n%s ",Ksymbols);
          curassoc = Symbols;
!         if (curassoc==nil) putc(' ',fout);
          while (curassoc) {
!                fprintf(fout," %s:%s",curassoc->symbol, curassoc->delta->num);
                 curassoc = curassoc->nextassoc;
          }
!         fprintf(fout,";\n%s   ",Klocks);
          curlock = Locks;
!         if (curlock==nil) putc(' ',fout);
          while (curlock) {
!                fprintf(fout," %s:%s",curlock->login, curlock->delta->num);
                 curlock = curlock->nextlock;
          }
!         if (StrictLocks) fprintf(fout,"; %s",Kstrict);
!         fprintf(fout,";\n%s  %c",Kcomment,SDELIM);
          if((sp=Comment)!=nil) {
!                while (*sp) if (putc(*sp++,fout)==SDELIM) putc(SDELIM,fout);
          }
!         fprintf(fout,"%c;\n\n",SDELIM);
  }
  
  
--- 357,393 ----
          struct access * curaccess;
          register char * sp;
  
!         VOID fputs(Khead,fout); VOID fputs("     ",fout);
!         if (Head) VOID fputs(Head->num,fout);
  
!         VOID fprintf(fout,";\n%s  ",Kaccess);
          curaccess = AccessList;
!         if (curaccess==nil) VOID putc(' ',fout);
          while (curaccess) {
!                VOID putc(' ',fout);
!                VOID fputs(curaccess->login,fout);
                 curaccess = curaccess->nextaccess;
          }
!         VOID fprintf(fout,";\n%s ",Ksymbols);
          curassoc = Symbols;
!         if (curassoc==nil) VOID putc(' ',fout);
          while (curassoc) {
!                VOID fprintf(fout," %s:%s",curassoc->symbol, curassoc->delta->num);
                 curassoc = curassoc->nextassoc;
          }
!         VOID fprintf(fout,";\n%s   ",Klocks);
          curlock = Locks;
!         if (curlock==nil) VOID putc(' ',fout);
          while (curlock) {
!                VOID fprintf(fout," %s:%s",curlock->login, curlock->delta->num);
                 curlock = curlock->nextlock;
          }
!         if (StrictLocks) VOID fprintf(fout,"; %s",Kstrict);
!         VOID fprintf(fout,";\n%s  %c",Kcomment,SDELIM);
          if((sp=Comment)!=nil) {
!                while (*sp) if (putc(*sp++,fout)==SDELIM) VOID putc(SDELIM,fout);
          }
!         VOID fprintf(fout,"%c;\n\n",SDELIM);
  }
  
  
***************
*** 396,417 ****
  
          if (node == nil) return;
  
!         fprintf(fout,"\n%s\n",node->num);
!         fprintf(fout,"%s     %s;  %s %s;  %s ",
                  Kdate,node->date,Kauthor,node->author,Kstate);
!         if (node->state!=nil) fputs(node->state,fout);
!         fputs(";\nbranches",fout);
          nextbranch = node->branches;
!         if (nextbranch==nil) putc(' ',fout);
          while (nextbranch) {
!                putc(' ',fout);
!                fputs(nextbranch->hsh->num,fout);
                 nextbranch = nextbranch->nextbranch;
          }
  
!         fprintf(fout,";\n%s     ",Knext);
!         if (node->next!=nil) fputs(node->next->num,fout);
!         fputs(";\n",fout);
  
  }
  
--- 402,423 ----
  
          if (node == nil) return;
  
!         VOID fprintf(fout,"\n%s\n",node->num);
!         VOID fprintf(fout,"%s     %s;  %s %s;  %s ",
                  Kdate,node->date,Kauthor,node->author,Kstate);
!         if (node->state!=nil) VOID fputs(node->state,fout);
!         VOID fputs(";\nbranches",fout);
          nextbranch = node->branches;
!         if (nextbranch==nil) VOID putc(' ',fout);
          while (nextbranch) {
!                VOID putc(' ',fout);
!                VOID fputs(nextbranch->hsh->num,fout);
                 nextbranch = nextbranch->nextbranch;
          }
  
!         VOID fprintf(fout,";\n%s     ",Knext);
!         if (node->next!=nil) VOID fputs(node->next->num,fout);
!         VOID fputs(";\n",fout);
  
  }
  
***************
*** 454,477 ****
  	register int c;
          register FILE * fin;
  
!         fprintf(fout,DELNUMFORM,num,Klog);
          /* put log */
!         putc(SDELIM,fout);
          sp=log;
!         while (*sp) if (putc(*sp++,fout)==SDELIM) putc(SDELIM,fout);
!         if (*(sp-1)!='\n') putc('\n', fout); /*append \n if necessary*/
          /* put text */
!         fprintf(fout, "%c\n%s\n%c",SDELIM,Ktext,SDELIM);
          if ((fin=fopen(srcfilename,"r"))==NULL) {
                  error("Can't open source file %s",srcfilename);
                  return false;
          }
          while ((c=fgetc(fin))!=EOF) {
!                 if (c==SDELIM) putc(SDELIM,fout);   /*double up SDELIM*/
!                 putc(c,fout);
          }
!         putc(SDELIM,fout);putc('\n',fout);
!         fclose(fin);
          return true;
  }
  
--- 460,483 ----
  	register int c;
          register FILE * fin;
  
!         VOID fprintf(fout,DELNUMFORM,num,Klog);
          /* put log */
!         VOID putc(SDELIM,fout);
          sp=log;
!         while (*sp) if (putc(*sp++,fout)==SDELIM) VOID putc(SDELIM,fout);
!         if (*(sp-1)!='\n') VOID putc('\n', fout); /*append \n if necessary*/
          /* put text */
!         VOID fprintf(fout, "%c\n%s\n%c",SDELIM,Ktext,SDELIM);
          if ((fin=fopen(srcfilename,"r"))==NULL) {
                  error("Can't open source file %s",srcfilename);
                  return false;
          }
          while ((c=fgetc(fin))!=EOF) {
!                 if (c==SDELIM) VOID putc(SDELIM,fout);   /*double up SDELIM*/
!                 VOID putc(c,fout);
          }
!         VOID putc(SDELIM,fout); VOID putc('\n',fout);
!         VOID fclose(fin);
          return true;
  }
  
***************
*** 485,491 ****
  
          cmdid = "syntest";
          if (argc<2) {
!                 fputs("No input file\n",stderr);
                  exit(-1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
--- 491,497 ----
  
          cmdid = "syntest";
          if (argc<2) {
!                 VOID fputs("No input file\n",stderr);
                  exit(-1);
          }
          if ((finptr=fopen(argv[1], "r")) == NULL) {
diff -c /arch/4.3/usr/src/new/rcs/src/rcsutil.c /usr/poppy/guy/src/cmd/rcs/src/rcsutil.c
*** /arch/4.3/usr/src/new/rcs/src/rcsutil.c	Wed May 11 10:07:33 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rcsutil.c	Mon Jul 28 23:32:32 1986
***************
*** 1,8 ****
  /*
   *                     RCS utilities
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/rcsutil.c,v 3.8 83/02/15 15:41:49 wft Exp $ Purdue CS";
  /*****************************************************************************
   *****************************************************************************
   *
--- 1,10 ----
  /*
   *                     RCS utilities
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: rcsutil.c,v 3.10 86/07/28 23:30:06 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *****************************************************************************
   *
***************
*** 20,25 ****
--- 22,35 ----
  
  
  /* $Log:	rcsutil.c,v $
+  * Revision 3.10  86/07/28  23:30:06  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.9  86/07/19  03:10:27  guy
+  * Cleaned up the signal catching stuff (mainly to shut lint up).
+  * Fixed not to catch signals if they're being ignored.
+  * Changed to properly cast null pointer arguments.
+  * 
   * Revision 3.8  83/02/15  15:41:49  wft
   * Added routine fastcopy() to copy remainder of a file in blocks.
   * 
***************
*** 62,70 ****
  extern FILE * finptr;
  extern char * getfullRCSname();
  
- struct hshentry dummy;         /* dummy delta for reservations  */
  
- 
  struct lock * addlock(delta,who)
  struct hshentry * delta; char * who;
  /* Given a delta, addlock checks whether
--- 72,78 ----
***************
*** 161,167 ****
                  next=next->nextaccess;
          } while (next!=nil);
  
!         fstat(fileno(finptr),&statbuf);  /* get owner of file */
          if (getuid() == statbuf.st_uid) return true;
  
          error("User %s not on the access list",who);
--- 169,175 ----
                  next=next->nextaccess;
          } while (next!=nil);
  
!         VOID fstat(fileno(finptr),&statbuf);  /* get owner of file */
          if (getuid() == statbuf.st_uid) return true;
  
          error("User %s not on the access list",who);
***************
*** 170,176 ****
  
  void catchsig(sig)
  {
! 	signal(sig, SIG_IGN);
          diagnose("\nRCS: cleaning up\n");
          cleanup();
          exit(1);
--- 178,184 ----
  
  void catchsig(sig)
  {
! 	VOID signal(sig, SIG_IGN);
          diagnose("\nRCS: cleaning up\n");
          cleanup();
          exit(1);
***************
*** 178,193 ****
  
  void catchints()
  {
!         signal(SIGINT,catchsig); signal(SIGHUP,catchsig);
!         signal(SIGQUIT,catchsig); signal(SIGPIPE,catchsig);
! 	signal(SIGTERM,catchsig);
  }
  
  void ignoreints()
  {
!         signal(SIGINT,SIG_IGN); signal(SIGHUP,SIG_IGN);
!         signal(SIGQUIT,SIG_IGN); signal(SIGPIPE,SIG_IGN);
! 	signal(SIGTERM,SIG_IGN);
  }
  
  
--- 186,209 ----
  
  void catchints()
  {
!         cksignal(SIGINT); cksignal(SIGHUP);
!         cksignal(SIGQUIT); cksignal(SIGPIPE);
! 	cksignal(SIGTERM);
  }
  
+ 
+ cksignal(sig)
+ int	sig;
+ {
+ 	if (signal(sig,SIG_IGN) != SIG_IGN)
+ 		VOID signal(sig,catchsig);
+ }
+ 
  void ignoreints()
  {
!         VOID signal(SIGINT,SIG_IGN); VOID signal(SIGHUP,SIG_IGN);
!         VOID signal(SIGQUIT,SIG_IGN); VOID signal(SIGPIPE,SIG_IGN);
! 	VOID signal(SIGTERM,SIG_IGN);
  }
  
  
***************
*** 202,210 ****
  
          /* write the rest of the buffer to outf */
          while ((--inf->_cnt)>=0) {
!                 putc(*inf->_ptr++&0377,outf);
          }
!         fflush(outf);
  
          /*now read the rest of the file in blocks*/
          while ((rcount=read(fileno(inf),buf,BUFSIZ))>0) {
--- 218,228 ----
  
          /* write the rest of the buffer to outf */
          while ((--inf->_cnt)>=0) {
!                 VOID putc(*inf->_ptr++&0377,outf);
          }
!         if (fflush(outf) == EOF) {
! 		faterror("write error");
! 	}
  
          /*now read the rest of the file in blocks*/
          while ((rcount=read(fileno(inf),buf,BUFSIZ))>0) {
***************
*** 242,251 ****
          long clock;
          struct tm * tm;
  
!         clock=time(0);
          tm=localtime(&clock);
  
!         sprintf(curdate,DATEFORM,
                  tm->tm_year, tm->tm_mon+1, tm->tm_mday,
                  tm->tm_hour, tm->tm_min, tm->tm_sec);
  
--- 260,269 ----
          long clock;
          struct tm * tm;
  
!         clock=time((long *)0);
          tm=localtime(&clock);
  
!         VOID sprintf(curdate,DATEFORM,
                  tm->tm_year, tm->tm_mon+1, tm->tm_mday,
                  tm->tm_hour, tm->tm_min, tm->tm_sec);
  
***************
*** 256,264 ****
          else    forward++;   /* branch delta  */
          i++;
          }
!         sprintf(command,"%s \"%s %10sr %3db %3df %3dt %sc %so %s %s\" &\n",
                  SNOOP, commandname,delta->num,backward,forward,TotalDeltas,delta->date,
                  curdate,login,getfullRCSname());
!         system(command);
  }
  #endif
--- 274,282 ----
          else    forward++;   /* branch delta  */
          i++;
          }
!         VOID sprintf(command,"%s \"%s %10sr %3db %3df %3dt %sc %so %s %s\" &\n",
                  SNOOP, commandname,delta->num,backward,forward,TotalDeltas,delta->date,
                  curdate,login,getfullRCSname());
!         VOID system(command);
  }
  #endif
diff -c /arch/4.3/usr/src/new/rcs/src/rlog.c /usr/poppy/guy/src/cmd/rcs/src/rlog.c
*** /arch/4.3/usr/src/new/rcs/src/rlog.c	Wed May 11 15:13:27 1983
--- /usr/poppy/guy/src/cmd/rcs/src/rlog.c	Mon Jul 28 23:32:59 1986
***************
*** 1,8 ****
  /*
   *                       RLOG    operation
   */
  static char rcsid[]=
! "$Header: /usr/wft/RCS/SRC/RCS/rlog.c,v 3.7 83/05/11 14:24:13 wft Exp $ Purdue CS";
  /*****************************************************************************
   *                       print contents of RCS files
   *****************************************************************************
--- 1,10 ----
  /*
   *                       RLOG    operation
   */
+ #ifndef lint
  static char rcsid[]=
! "$Header: rlog.c,v 3.9 86/07/28 23:30:29 guy Exp $ Purdue CS";
! #endif
  /*****************************************************************************
   *                       print contents of RCS files
   *****************************************************************************
***************
*** 20,25 ****
--- 22,33 ----
  
  
  /* $Log:	rlog.c,v $
+  * Revision 3.9  86/07/28  23:30:29  guy
+  * More "lint" cleanups.
+  * 
+  * Revision 3.8  86/07/19  03:12:41  guy
+  * Changed to properly cast pointer arguments.
+  * 
   * Revision 3.7  83/05/11  14:24:13  wft
   * Added options -L and -R;
   * Fixed selection bug with -l on multiple files.
***************
*** 54,60 ****
--- 62,70 ----
  #include <pwd.h>
  #include "time.h"
  #include "rcsbase.h"
+ #ifndef lint
  static char rcsbaseid[] = RCSBASE;
+ #endif
  
  
  extern FILE * fopen();
***************
*** 64,70 ****
  extern struct hshentry * genrevs(); /*generate delta numbers                */
  extern int    countnumflds();
  extern int    compartial();
- extern char * partialno();
  extern int    expandsym();          /*get numeric name of a revision        */
  extern char * getfullRCSname();     /*get full path name of RCS file        */
  extern int nextc;                   /*next input character                  */
--- 74,79 ----
***************
*** 232,282 ****
  	    if ( onlylockflag && Locks == nil ) goto loopend;
  
  	    if ( onlyRCSflag ) {
! 		fprintf(stdout, "%s\n", RCSfilename);
  		goto loopend;
  	    }
              /*   print RCS filename , working filename and optional
                   administrative information                         */
!             fprintf(stdout, "\nRCS file:        %s;   ",RCSfilename);
              /* could use getfullRCSname() here, but that is very slow */
!             fprintf(stdout, "Working file:    %s\n", workfilename);
!             fprintf(stdout, "head:            %s\n", Head==nil?"":Head->num);
  
!             fputs("locks:         ", stdout);  /*  print locker list   */
              currlock = Locks;
              while( currlock ) {
!                 fprintf(stdout,"  %s: %s;", currlock->login,
                                  currlock->delta->num);
                  currlock = currlock->nextlock;
              }
              if ( StrictLocks )
!                 fputs(Locks==nil?"  ;  strict":"  strict",stdout);
  
!             fputs("\naccess list:   ", stdout);      /*  print access list  */
              curaccess = AccessList;
              while(curaccess) {
!                 fputs("  ",stdout);
!                 fputs(curaccess->login, stdout);
                  curaccess = curaccess->nextaccess;
              }
  
!             fputs("\nsymbolic names:", stdout);   /*  print symbolic names   */
              curassoc = Symbols;
              while( curassoc ) {
!                 fprintf(stdout, "  %s: %s;",curassoc->symbol,
                             curassoc->delta->num);
                  curassoc = curassoc->nextassoc;
              }
  
!             fprintf(stdout,"\ncomment leader:  \"%s\"\n",Comment);
  
              gettree();
!             fprintf(stdout, "total revisions: %d;    ", TotalDeltas);
              if ( Head == nil || !selectflag || !descflag) {
!                 putc('\n',stdout);
!                 if (descflag) fputs("description:\n", stdout);
                  getdesc(descflag);
!                 fputs("=============================================================================\n",stdout);
                  goto loopend;
              }
  
--- 241,291 ----
  	    if ( onlylockflag && Locks == nil ) goto loopend;
  
  	    if ( onlyRCSflag ) {
! 		VOID fprintf(stdout, "%s\n", RCSfilename);
  		goto loopend;
  	    }
              /*   print RCS filename , working filename and optional
                   administrative information                         */
!             VOID fprintf(stdout, "\nRCS file:        %s;   ",RCSfilename);
              /* could use getfullRCSname() here, but that is very slow */
!             VOID fprintf(stdout, "Working file:    %s\n", workfilename);
!             VOID fprintf(stdout, "head:            %s\n", Head==nil?"":Head->num);
  
!             VOID fputs("locks:         ", stdout);  /*  print locker list   */
              currlock = Locks;
              while( currlock ) {
!                 VOID fprintf(stdout,"  %s: %s;", currlock->login,
                                  currlock->delta->num);
                  currlock = currlock->nextlock;
              }
              if ( StrictLocks )
!                 VOID fputs(Locks==nil?"  ;  strict":"  strict",stdout);
  
!             VOID fputs("\naccess list:   ", stdout);      /*  print access list  */
              curaccess = AccessList;
              while(curaccess) {
!                 VOID fputs("  ",stdout);
!                 VOID fputs(curaccess->login, stdout);
                  curaccess = curaccess->nextaccess;
              }
  
!             VOID fputs("\nsymbolic names:", stdout);   /*  print symbolic names   */
              curassoc = Symbols;
              while( curassoc ) {
!                 VOID fprintf(stdout, "  %s: %s;",curassoc->symbol,
                             curassoc->delta->num);
                  curassoc = curassoc->nextassoc;
              }
  
!             VOID fprintf(stdout,"\ncomment leader:  \"%s\"\n",Comment);
  
              gettree();
!             VOID fprintf(stdout, "total revisions: %d;    ", TotalDeltas);
              if ( Head == nil || !selectflag || !descflag) {
!                 VOID putc('\n',stdout);
!                 if (descflag) VOID fputs("description:\n", stdout);
                  getdesc(descflag);
!                 VOID fputs("=============================================================================\n",stdout);
                  goto loopend;
              }
  
***************
*** 301,314 ****
              /*  reinitialize the date specification list   */
              currdate = duelst;
              while(currdate) {
!                 sprintf(currdate->strtdate,DATEFORM,0,0,0,0,0,0);
                  currdate = currdate->dnext;
              }
  
              if ( selectop || ( selectflag && descflag) )
!                 fprintf(stdout, "selected revisions: %d", revno);
!             putc('\n', stdout);
!             if (descflag) fputs("description:\n", stdout);
              getdesc(descflag);
              while( (nexttok != EOFILE) && readdeltalog());
              if (selectflag && descflag && revno) {
--- 310,323 ----
              /*  reinitialize the date specification list   */
              currdate = duelst;
              while(currdate) {
!                 VOID sprintf(currdate->strtdate,DATEFORM,0,0,0,0,0,0);
                  currdate = currdate->dnext;
              }
  
              if ( selectop || ( selectflag && descflag) )
!                 VOID fprintf(stdout, "selected revisions: %d", revno);
!             VOID putc('\n', stdout);
!             if (descflag) VOID fputs("description:\n", stdout);
              getdesc(descflag);
              while( (nexttok != EOFILE) && readdeltalog());
              if (selectflag && descflag && revno) {
***************
*** 317,325 ****
                  if (nextlex(), nexttok != EOFILE)
                      fatserror("syntax error; expecting EOF");
              }
!             fputs("=============================================================================\n",stdout);
          loopend:
!             fclose(finptr);
          } while( ++argv, --argc >= 1);
          exit(nerror!=0);
  }
--- 326,334 ----
                  if (nextlex(), nexttok != EOFILE)
                      fatserror("syntax error; expecting EOF");
              }
!             VOID fputs("=============================================================================\n",stdout);
          loopend:
!             VOID fclose(finptr);
          } while( ++argv, --argc >= 1);
          exit(nerror!=0);
  }
***************
*** 409,449 ****
          if ( ( node == nil) || ( node->selector == 'u'))
              return;
  
!         fprintf(stdout,"----------------------------\n");
!         fprintf(stdout, "revision %s        ",node->num);
          if ( node->lockedby )
!            fprintf(stdout, "locked by: %s;       ", node->lockedby);
!         putc('\n', stdout);
  
!         fputs("date: ",stdout);
!         PRINTDATE(stdout,node->date); putc(' ',stdout);
!         PRINTTIME(stdout,node->date);
!         fprintf(stdout, ";  author: %s;  ", node->author);
!         fprintf(stdout, "state: %s;  ", node->state);
  
          if ( editscript )
             if(trunk)
!               fprintf(stdout,"lines added/del: %d/%d",
                               editscript->deletelns, editscript->insertlns);
             else
!               fprintf(stdout,"lines added/del: %d/%d",
                               editscript->insertlns, editscript->deletelns);
  
!         putc('\n', stdout);
  
          branchnum = & (branch[0]);
          newbranch = node->branches;
          if ( newbranch ) {
!            fputs("branches:  ", stdout);
             while( newbranch ) {
                  getbranchno(newbranch->hsh->num, branchnum);
!                 fprintf(stdout, "%s;  ", branchnum);
                  newbranch = newbranch->nextbranch;
             }
!            putc('\n', stdout);
          }
  
!         fputs(node->log,stdout);
  }
  
  
--- 418,458 ----
          if ( ( node == nil) || ( node->selector == 'u'))
              return;
  
!         VOID fprintf(stdout,"----------------------------\n");
!         VOID fprintf(stdout, "revision %s        ",node->num);
          if ( node->lockedby )
!            VOID fprintf(stdout, "locked by: %s;       ", node->lockedby);
!         VOID putc('\n', stdout);
  
!         VOID fputs("date: ",stdout);
!         VOID PRINTDATE(stdout,node->date); VOID putc(' ',stdout);
!         VOID PRINTTIME(stdout,node->date);
!         VOID fprintf(stdout, ";  author: %s;  ", node->author);
!         VOID fprintf(stdout, "state: %s;  ", node->state);
  
          if ( editscript )
             if(trunk)
!               VOID fprintf(stdout,"lines added/del: %d/%d",
                               editscript->deletelns, editscript->insertlns);
             else
!               VOID fprintf(stdout,"lines added/del: %d/%d",
                               editscript->insertlns, editscript->deletelns);
  
!         VOID putc('\n', stdout);
  
          branchnum = & (branch[0]);
          newbranch = node->branches;
          if ( newbranch ) {
!            VOID fputs("branches:  ", stdout);
             while( newbranch ) {
                  getbranchno(newbranch->hsh->num, branchnum);
!                 VOID fprintf(stdout, "%s;  ", branchnum);
                  newbranch = newbranch->nextbranch;
             }
!            VOID putc('\n', stdout);
          }
  
!         VOID fputs(node->log,stdout);
  }
  
  
***************
*** 702,708 ****
          if ( root->selector == 's') {
               if ( cmpnum(root->date, pd->strtdate) >= 0 &&
                    cmpnum(root->date, pd->enddate) <= 0)
! 		strcpy(pd->strtdate, root->date);
          }
  
          recentdate(root->next, pd);
--- 711,717 ----
          if ( root->selector == 's') {
               if ( cmpnum(root->date, pd->strtdate) >= 0 &&
                    cmpnum(root->date, pd->enddate) <= 0)
! 		VOID strcpy(pd->strtdate, root->date);
          }
  
          recentdate(root->next, pd);
***************
*** 850,856 ****
  	    return nil;
  	}
  	ftm = localtime(&unixtime);
! 	sprintf(target,DATEFORM,
  	ftm->tm_year,ftm->tm_mon+1,ftm->tm_mday,ftm->tm_hour,ftm->tm_min,ftm->tm_sec);
  	return target;
  }
--- 859,865 ----
  	    return nil;
  	}
  	ftm = localtime(&unixtime);
! 	VOID sprintf(target,DATEFORM,
  	ftm->tm_year,ftm->tm_mon+1,ftm->tm_mday,ftm->tm_hour,ftm->tm_min,ftm->tm_sec);
  	return target;
  }
***************
*** 895,902 ****
  		if (procdate(switchflag?nextdate->enddate:nextdate->strtdate,
  			     rawdate)==nil) continue;
  		if ( c == ';' || c == '\0') {  /*  case: -d date  */
! 		    strcpy(nextdate->enddate,nextdate->strtdate);
! 		    sprintf(nextdate->strtdate,DATEFORM,0,0,0,0,0,0);
                      nextdate->dnext = duelst;
                      duelst = nextdate;
  		    goto end;
--- 904,911 ----
  		if (procdate(switchflag?nextdate->enddate:nextdate->strtdate,
  			     rawdate)==nil) continue;
  		if ( c == ';' || c == '\0') {  /*  case: -d date  */
! 		    VOID strcpy(nextdate->enddate,nextdate->strtdate);
! 		    VOID sprintf(nextdate->strtdate,DATEFORM,0,0,0,0,0,0);
                      nextdate->dnext = duelst;
                      duelst = nextdate;
  		    goto end;
***************
*** 925,931 ****
  	    datelist = nextdate;
       end:
  /*
! 	    printf("startdate: %s; enddate: %s;\n", nextdate->strtdate,nextdate->enddate);
  */
  	    if ( c == '\0')  return;
              while( (c = *++argv) == ';' || c == ' ' || c == '\t' || c =='\n');
--- 934,940 ----
  	    datelist = nextdate;
       end:
  /*
! 	    VOID printf("startdate: %s; enddate: %s;\n", nextdate->strtdate,nextdate->enddate);
  */
  	    if ( c == '\0')  return;
              while( (c = *++argv) == ';' || c == ' ' || c == '\t' || c =='\n');
***************
*** 948,954 ****
          /*  free the previous numeric revision list  */
          pt = Revlst;
          while( pt) {
!            free(pt);
             pt = pt->rnext;
          }
          Nextdotstring = &Dotstring[0]; /* reset buffer */
--- 957,963 ----
          /*  free the previous numeric revision list  */
          pt = Revlst;
          while( pt) {
!            free((char *)pt);
             pt = pt->rnext;
          }
          Nextdotstring = &Dotstring[0]; /* reset buffer */
***************
*** 1014,1020 ****
                  Revlst = pt;
               }
               else
!                 free(pt);
               ptr = ptr->rnext;
          }
  
--- 1023,1029 ----
                  Revlst = pt;
               }
               else
!                 free((char *)pt);
               ptr = ptr->rnext;
          }
  
diff -c /arch/4.3/usr/src/new/rcs/src/sccstorcs.c /usr/poppy/guy/src/cmd/rcs/src/sccstorcs.c
*** /arch/4.3/usr/src/new/rcs/src/sccstorcs.c	Wed Oct 31 10:48:08 1984
--- /usr/poppy/guy/src/cmd/rcs/src/sccstorcs.c	Mon Jul 28 23:33:17 1986
***************
*** 1,5 ****
  static char *RCSid =
! "$Header: sccstorcs.c,v 1.4 84/10/17 21:12:11 root Exp $";
  
  /*
   * SCCSTORCS - build RCS file from SCCS file preserving deltas.
--- 1,7 ----
+ #ifndef lint
  static char *RCSid =
! "$Header: sccstorcs.c,v 1.5 86/07/28 23:30:51 guy Exp $";
! #endif
  
  /*
   * SCCSTORCS - build RCS file from SCCS file preserving deltas.
***************
*** 12,17 ****
--- 14,22 ----
   * author.
   *
   * $Log:	sccstorcs.c,v $
+  * Revision 1.5  86/07/28  23:30:51  guy
+  * More "lint" cleanups.
+  * 
   * Revision 1.4  84/10/17  21:12:11  root
   * Added check for having multiple deltas in a row for the same revision.
   * --ks
***************
*** 37,42 ****
--- 42,61 ----
   * 
   */
  
+ #if defined(USG) || defined(BSD)
+ #define VOID	(void)
+ #else
+ #define VOID
+ #endif
+ 
+ extern char *strcpy();
+ extern char *strcat();
+ #ifdef USG
+ extern int sprintf();
+ #else
+ extern char *sprintf();
+ #endif
+ 
  #include <stdio.h>
  
  #define TRUE	1
***************
*** 74,84 ****
  } HEADER;
  
  
  quit (fmt, args)
  char *fmt;
  {
!     fprintf (stderr, "sccstorcs: ");
      _doprnt(fmt, &args, stderr);
      exit (1);
  }
  
--- 93,108 ----
  } HEADER;
  
  
+ /*VARARGS1*/
  quit (fmt, args)
  char *fmt;
  {
!     VOID fprintf (stderr, "sccstorcs: ");
! #ifdef VFPRINTF
!     VOID vfprintf(stderr, fmt, &args);
! #else
      _doprnt(fmt, &args, stderr);
+ #endif VFPRINTF
      exit (1);
  }
  
***************
*** 101,107 ****
  char *str;
  {
      register char *p = xalloc ((unsigned) (strlen (str) + 1));
!     strcpy (p, str);
      return (p);
  }
  
--- 125,131 ----
  char *str;
  {
      register char *p = xalloc ((unsigned) (strlen (str) + 1));
!     VOID strcpy (p, str);
      return (p);
  }
  
***************
*** 128,134 ****
      register DELTA *delta;
      char rev[32];
  
!     sscanf (line, "%*s %*s %s", rev);
      delta = (DELTA *) xalloc (sizeof (DELTA));
      delta -> revision = string (rev);
      delta -> commentary = NULL;
--- 152,158 ----
      register DELTA *delta;
      char rev[32];
  
!     VOID sscanf (line, "%*s %*s %s", rev);
      delta = (DELTA *) xalloc (sizeof (DELTA));
      delta -> revision = string (rev);
      delta -> commentary = NULL;
***************
*** 147,154 ****
  
      len = strlen (old_str) + strlen (str);
      newstring = (char *) xalloc ((unsigned) (len + 1));
!     strcpy (newstring, old_str);
!     strcat (newstring, str);
      free (old_str);
      return (newstring);
  }
--- 171,178 ----
  
      len = strlen (old_str) + strlen (str);
      newstring = (char *) xalloc ((unsigned) (len + 1));
!     VOID strcpy (newstring, old_str);
!     VOID strcat (newstring, str);
      free (old_str);
      return (newstring);
  }
***************
*** 245,260 ****
      FILE *fd;
      if (strncmp (sname (sccsfile), "s.", 2) != 0)	/* An SCCS file? */
      {
! 	fprintf (stderr, "%s: not an SCCS file.\n", sccsfile);
  	return (NULL);
      }
      if ((fd = fopen (sccsfile, "r")) == NULL)
      {
! 	fprintf (stderr, "%s: cannot open.\n", sccsfile);
  	return (NULL);
      }
      header = collect_header (fd);
!     fclose (fd);
      return (header);
  }
  
--- 269,284 ----
      FILE *fd;
      if (strncmp (sname (sccsfile), "s.", 2) != 0)	/* An SCCS file? */
      {
! 	VOID fprintf (stderr, "%s: not an SCCS file.\n", sccsfile);
  	return (NULL);
      }
      if ((fd = fopen (sccsfile, "r")) == NULL)
      {
! 	VOID fprintf (stderr, "%s: cannot open.\n", sccsfile);
  	return (NULL);
      }
      header = collect_header (fd);
!     VOID fclose (fd);
      return (header);
  }
  
***************
*** 266,282 ****
      int count;
      if (userlist == NULL)
  	return (0);
!     sprintf (command, "%s -a", RCS);
      for (count = 0; userlist; userlist = userlist -> next, count++)
      {
  	if (count > 0)
! 	    strcat (command, ",");
! 	strcat (command, userlist -> user);
      }
!     strcat (command, " ");
!     strcat (command, rcsfile);
      if (trace || verbose)
! 	printf ("%% %s\n", command);
      if (trace)
  	return (0);
      return (system (command));
--- 290,306 ----
      int count;
      if (userlist == NULL)
  	return (0);
!     VOID sprintf (command, "%s -a", RCS);
      for (count = 0; userlist; userlist = userlist -> next, count++)
      {
  	if (count > 0)
! 	    VOID strcat (command, ",");
! 	VOID strcat (command, userlist -> user);
      }
!     VOID strcat (command, " ");
!     VOID strcat (command, rcsfile);
      if (trace || verbose)
! 	VOID printf ("%% %s\n", command);
      if (trace)
  	return (0);
      return (system (command));
***************
*** 289,305 ****
      extern FILE *popen();
      FILE *pd;
  
!     sprintf (command, "%s -i -U %s", RCS, rcsfile);
      if (trace || verbose)
! 	printf ("%% %s\n", command);
      if (trace)
      {
! 	printf ("Description:\n%s\n", null(description));
  	return (0);
      }
      if ((pd = popen (command, "w")) == NULL)
  	return (-1);
!     fprintf (pd, "%s", description ? description : "\n");
      return (pclose (pd));
  }
  
--- 313,329 ----
      extern FILE *popen();
      FILE *pd;
  
!     VOID sprintf (command, "%s -i -U %s", RCS, rcsfile);
      if (trace || verbose)
! 	VOID printf ("%% %s\n", command);
      if (trace)
      {
! 	VOID printf ("Description:\n%s\n", null(description));
  	return (0);
      }
      if ((pd = popen (command, "w")) == NULL)
  	return (-1);
!     VOID fprintf (pd, "%s", description ? description : "\n");
      return (pclose (pd));
  }
  
***************
*** 313,322 ****
  	/*
  	 * Get the SCCS file.
  	 */
! 	sprintf (command, "%s -p -r%s %s > %s",
  	    GET, delta -> revision, sccsfile, rcsfile);
  	if (trace || verbose)
! 	    printf("%% %s\n", command);
  	if (!trace)
  	{
  	    if (system (command))
--- 337,346 ----
  	/*
  	 * Get the SCCS file.
  	 */
! 	VOID sprintf (command, "%s -p -r%s %s > %s",
  	    GET, delta -> revision, sccsfile, rcsfile);
  	if (trace || verbose)
! 	    VOID printf("%% %s\n", command);
  	if (!trace)
  	{
  	    if (system (command))
***************
*** 323,333 ****
  		return (-1);
  	}
  
! 	sprintf (command, "%s -r%s %s", CI, delta -> revision, rcsfile);
  	if (trace || verbose)
! 	    printf("%% %s\n", command);
  	if (trace)
! 	    printf("Commentary:\n%s\n", null(delta -> commentary));
  	else
  	{
  	    extern FILE *popen ();
--- 347,357 ----
  		return (-1);
  	}
  
! 	VOID sprintf (command, "%s -r%s %s", CI, delta -> revision, rcsfile);
  	if (trace || verbose)
! 	    VOID printf("%% %s\n", command);
  	if (trace)
! 	    VOID printf("Commentary:\n%s\n", null(delta -> commentary));
  	else
  	{
  	    extern FILE *popen ();
***************
*** 336,342 ****
  	    if ((pd = popen (command, "w")) == NULL)
  		return (-1);
  	    if (delta -> commentary)
! 		fprintf (pd, delta -> commentary);
  	    if ((x = pclose (pd)) != 0)
  		return (x);
  	}
--- 360,366 ----
  	    if ((pd = popen (command, "w")) == NULL)
  		return (-1);
  	    if (delta -> commentary)
! 		VOID fprintf (pd, delta -> commentary);
  	    if ((x = pclose (pd)) != 0)
  		return (x);
  	}
***************
*** 348,356 ****
  char *rcsfile;
  {
      char command[512];
!     sprintf (command, "%s -L %s", RCS, rcsfile);
      if (trace || verbose)
! 	printf ("%% %s\n", command);
      if (trace)
  	return (0);
      return (system (command));
--- 372,380 ----
  char *rcsfile;
  {
      char command[512];
!     VOID sprintf (command, "%s -L %s", RCS, rcsfile);
      if (trace || verbose)
! 	VOID printf ("%% %s\n", command);
      if (trace)
  	return (0);
      return (system (command));
***************
*** 382,405 ****
      register DELTA *d;
      register USERLIST *u;
  
!     printf ("\n%s:\n", sccsfile);
!     printf ("------------------------------------------------------------\n");
      if (header -> description)
! 	printf ("Descriptive text:\n%s", header -> description);
  
      if (header -> userlist)
      {
! 	printf ("\nUser access list:\n");
  	for (u = header -> userlist; u; u = u -> next)
! 	    printf ("%s\n", u -> user);
      }
  
      for (d = header -> deltas; d; d = d -> next)
      {
! 	printf ("\nRelease: %s\n", d -> revision);
! 	printf ("Commentary:\n%s", d -> commentary);
      }
!     printf ("------------------------------------------------------------\n");
  }
  
  main (argc, argv)
--- 406,429 ----
      register DELTA *d;
      register USERLIST *u;
  
!     VOID printf ("\n%s:\n", sccsfile);
!     VOID printf ("------------------------------------------------------------\n");
      if (header -> description)
! 	VOID printf ("Descriptive text:\n%s", header -> description);
  
      if (header -> userlist)
      {
! 	VOID printf ("\nUser access list:\n");
  	for (u = header -> userlist; u; u = u -> next)
! 	    VOID printf ("%s\n", u -> user);
      }
  
      for (d = header -> deltas; d; d = d -> next)
      {
! 	VOID printf ("\nRelease: %s\n", d -> revision);
! 	VOID printf ("Commentary:\n%s", d -> commentary);
      }
!     VOID printf ("------------------------------------------------------------\n");
  }
  
  main (argc, argv)
***************
*** 418,424 ****
  		trace = TRUE;
  		break;
  	    default: 
! 		fprintf (stderr, "Unknown switch \"%s\".\n", argv[1]);
  		exit (1);
  	}
      }
--- 442,448 ----
  		trace = TRUE;
  		break;
  	    default: 
! 		VOID fprintf (stderr, "Unknown switch \"%s\".\n", argv[1]);
  		exit (1);
  	}
      }
diff -c /arch/4.3/usr/src/new/rcs/src/snoop.c /usr/poppy/guy/src/cmd/rcs/src/snoop.c
*** /arch/4.3/usr/src/new/rcs/src/snoop.c	Thu May 12 07:38:00 1983
--- /usr/poppy/guy/src/cmd/rcs/src/snoop.c	Mon Jul 28 23:33:31 1986
***************
*** 1,8 ****
  /*
   *                     Logging of RCS commands co and ci
   */
   static char rcsid[]=
!  "$Header: /usr/wft/RCS/SRC/RCS/snoop.c,v 3.2 82/12/04 17:14:31 wft Exp $ Purdue CS";
  /*******************************************************************
   * This program appends argv[1] to the file SNOOPFILE.
   * To avoid overlaps, it creates a lockfile with name lock in the same
--- 1,10 ----
  /*
   *                     Logging of RCS commands co and ci
   */
+ #ifndef lint
   static char rcsid[]=
!  "$Header: snoop.c,v 3.3 86/07/28 23:31:07 guy Exp $ Purdue CS";
! #endif
  /*******************************************************************
   * This program appends argv[1] to the file SNOOPFILE.
   * To avoid overlaps, it creates a lockfile with name lock in the same
***************
*** 24,29 ****
--- 26,34 ----
  
  
  /* $Log:	snoop.c,v $
+  * Revision 3.3  86/07/28  23:31:07  guy
+  * More "lint" cleanups.
+  * 
   * Revision 3.2  82/12/04  17:14:31  wft
   * Added rcsbase.h, changed SNOOPDIR to SNOOPFILE, reintroduced
   * error message in case of permanent locking.
***************
*** 62,71 ****
  {       int tries;
          register char * lastslash, *sp;
  
!         strcpy(lockfname,SNOOPFILE);
          lastslash = sp = lockfname;
          while (*sp) if (*sp++ =='/') lastslash=sp; /* points beyond / */
!         strcpy(lastslash,",lockfile");
          tries=0;
          while (((lockfile=creat(lockfname, 000)) == -1) && (tries<=MAXTRIES)) {
                  tries++;
--- 67,76 ----
  {       int tries;
          register char * lastslash, *sp;
  
!         VOID strcpy(lockfname,SNOOPFILE);
          lastslash = sp = lockfname;
          while (*sp) if (*sp++ =='/') lastslash=sp; /* points beyond / */
!         VOID strcpy(lastslash,",lockfile");
          tries=0;
          while (((lockfile=creat(lockfname, 000)) == -1) && (tries<=MAXTRIES)) {
                  tries++;
***************
*** 72,88 ****
                  sleep(5);
          }
          if (tries<=MAXTRIES) {
!                 close(lockfile);
                  if ((logfile=fopen(SNOOPFILE,"a")) ==NULL) {
!                         fprintf(stderr,"Can't open logfile %s\n",SNOOPFILE);
                  } else {
!                         fputs(argv[1],logfile);
!                         putc('\n',logfile);
!                         fclose(logfile);
                  }
!                 unlink(lockfname);
          } else {
!                 fprintf(stderr,"RCS logfile %s seems permanently locked.\n",SNOOPFILE);
!                 fprintf(stderr,"Please alert system administrator\n");
          }
  }
--- 77,93 ----
                  sleep(5);
          }
          if (tries<=MAXTRIES) {
!                 VOID close(lockfile);
                  if ((logfile=fopen(SNOOPFILE,"a")) ==NULL) {
!                         VOID fprintf(stderr,"Can't open logfile %s\n",SNOOPFILE);
                  } else {
!                         VOID fputs(argv[1],logfile);
!                         VOID putc('\n',logfile);
!                         VOID fclose(logfile);
                  }
!                 VOID unlink(lockfname);
          } else {
!                 VOID fprintf(stderr,"RCS logfile %s seems permanently locked.\n",SNOOPFILE);
!                 VOID fprintf(stderr,"Please alert system administrator\n");
          }
  }
