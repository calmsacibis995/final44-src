From karels  Fri Sep 27 10:17:53 1985
Received: by monet.berkeley.edu (5.24/1.2)
	id AA00587; Fri, 27 Sep 85 10:17:53 PDT
Date: Fri, 27 Sep 85 10:17:53 PDT
From: karels (Mike Karels)
Message-Id: <8509271717.AA00587@monet.berkeley.edu>
To: beta43_bugs
Subject: testing mail alias
Status: RO

test

From chris@mimsy.umd.edu  Mon Sep 30 15:12:06 1985
Received: by monet.berkeley.edu (5.26/1.2)
	id AA01179; Mon, 30 Sep 85 15:12:06 PDT
Received: by mimsy.umd.edu (5.5/4.7)
	id AA02486; Mon, 30 Sep 85 18:12:08 EDT
Date: Mon, 30 Sep 85 18:12:08 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8509302212.AA02486@mimsy.umd.edu>
To: beta43_bugs
Subject: Schizophrenia in /sys
Status: RO

if_loop.c does not to know whether it belongs in sys/net or
sys/netinet.  (There is one copy in each directory.)  sys/net seems
the better place to me; and conf/files agrees.

(In other words, remove netinet/if_loop.c . . . .)

Chris

From eric  Wed Oct  2 12:29:32 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA10554; Wed, 2 Oct 85 12:29:32 PDT
Date: Wed, 2 Oct 85 12:29:32 PDT
From: eric (Eric Allman)
Message-Id: <8510021929.AA10554@monet.berkeley.edu>
To: beta43_sites
Subject: sendmail problem on 4.3 beta tape
Phone: (415) 548-3211
Status: O

It turns out that there were problems with both versions of sendmail as
sent out on the 4.3 beta tape.  You have two options:

* If you want to run the older (probably more stable, but much less
  interesting) version, add:

	(void) signal(SIGCHLD, SIG_DFL);

  in daemon.c just after the comment beginning "CHILD -- return to caller".

* If you want to run the newer version, pick up a new copy from public
  FTP on ucbarpa.Berkeley.EDU (~ftp/pub/sendmail.tar).  This tape was
  thrown together rather hastily, so please let me know if there are any
  files missing or the like.

eric

From chris@mimsy.umd.edu  Thu Oct  3 14:16:29 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA14958; Thu, 3 Oct 85 14:16:29 PDT
Received: by mimsy.umd.edu (5.5/4.7)
	id AA08041; Thu, 3 Oct 85 17:15:52 EDT
Date: Thu, 3 Oct 85 17:15:52 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8510032115.AA08041@mimsy.umd.edu>
To: beta43_bugs
Subject: Trivial bug in vax/Locore.c
Status: O

the `code' for copyoutstr should says *udaddr = *kaddr, not *kaddr = *udaddr.

(I know - who cares?)

From chris@gyre.umd.edu  Thu Oct  3 22:45:55 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA15944; Thu, 3 Oct 85 22:45:55 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA03828; Fri, 4 Oct 85 01:46:15 EDT
Date: Fri, 4 Oct 85 01:46:15 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510040546.AA03828@gyre.umd.edu>
To: beta43_bugs
Subject: ping checksum code is wrong
Status: O

Index: etc/ping.c 4.3BSD Fix

Description:
	The checksum code does not handle carries when adding together
	the two 16-bit adders.  Also, if it manages to generate -0, it
	does not convert it back to +0.

Repeat-By:
	Got me.

Fix: (untested!)
	change the code at the end to read as follows:

	/*
	 * add back carry outs from top 16 bits to low 16 bits
	 */
	sum += (sum >> 16);	/* add hi 16 to low 16 */
	sum += (sum >> 16);	/* fold in new carry if any */
	answer = ~sum;		/* truncate to 16 bits */
	if (answer == 0xffff)
		answer = 0;	/* convert -0 to 0 */
	return (answer);

Chris

From chris@gyre.umd.edu  Sat Oct  5 02:33:13 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00682; Sat, 5 Oct 85 02:33:13 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA02570; Sat, 5 Oct 85 05:33:30 EDT
Date: Sat, 5 Oct 85 05:33:30 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510050933.AA02570@gyre.umd.edu>
To: beta43_bugs
Subject: param.c nclist is too big
Status: O

Index: sys/conf/param.c 4.3Beta Fix

Description:
	param.c should probably have nclist changed to be based on
	CBLOCK or CBSIZE; when the size changed the number of clist
	characters doubled, and this is not really necessary.

	Also, the config documentation no longer bears much
	resemblance to the code.  The appendix is way out of date.

Repeat-By:
	examination

Fix:
	I long ago changed nclist to

		int	nclist = (3200 + 512 * MAXUSERS) / (CROUND + 1);

	which computes the same nclist as the old expression with
	the old CROUND.  Someone should probably think about the
	definition a bit first though.

(I am still installing all the changes into our kernel; *real*
bug reports will probably soon follow, if there are any real
bugs . . . .)

Chris

From chris@gyre.umd.edu  Sat Oct  5 03:21:53 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00907; Sat, 5 Oct 85 03:21:53 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA06255; Sat, 5 Oct 85 06:22:15 EDT
Date: Sat, 5 Oct 85 06:22:15 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510051022.AA06255@gyre.umd.edu>
To: beta43_bugs
Subject: catman strangeness
Status: O

Index: src/etc/catman.c 4.3Beta

Description:
	The comment near the line 183 about not unlinking directories
	makes sense; the code underneath does not---it is checking for
	S_IFCHR, not S_IFREG.  Surely that is not correct....

Repeat-By:
	Examination.

Chris

From chris@gyre.umd.edu  Sat Oct  5 06:01:04 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA01069; Sat, 5 Oct 85 06:01:04 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA08520; Sat, 5 Oct 85 09:01:24 EDT
Date: Sat, 5 Oct 85 09:01:24 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510051301.AA08520@gyre.umd.edu>
To: beta43_bugs
Subject: You probably already know this, but . . .
Status: O

the distributed `vax/machdep.c' will not compile because TXDB_CONS is
not defined in the distributed `vax/cons.h'.

Chris

From bloom  Sat Oct  5 18:41:22 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA02318; Sat, 5 Oct 85 18:41:22 PDT
Date: Sat, 5 Oct 85 18:41:22 PDT
From: bloom (Jim Bloom)
Message-Id: <8510060141.AA02318@monet.berkeley.edu>
To: beta43_bugs
Subject: ftp core dumps when given an address in place of a hostname
Index: ucb/ftp/ftp.c
Status: O

The fix to /usr/src/ucb/ftp/ftp.c is:


Oct  5 18:40 1985  SCCS/s.ftp.c: -r5.1 vs. -r5.2 Page 1

49a50
> 		static char *addrbuf;
59a61
> 		def.h_addr_list = &addrbuf;


From blia.UUCP!eric@ucsf-cgl.ARPA  Tue Oct  8 00:19:24 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA10872; Tue, 8 Oct 85 00:19:24 PDT
Received: by ucsf-cgl.ARPA (4.46/GSC3.5)
	id AA20113; Tue, 8 Oct 85 00:17:26 PDT
Received: by blia.BLI (5.9/4.37)
	id AA24786; Mon, 7 Oct 85 16:41:39 PDT
From: blia.UUCP!eric@ucsf-cgl.ARPA (Eric Allman)
Message-Id: <8510072341.AA24786@blia.BLI>
To: beta43_bugs@ucsf-cgl.ARPA
Subject: problems with 4.3 beta install
Date: 07 Oct 85 16:41:36 PDT (Mon)
Status: O

I had the following problems doing the Beta install:

 * The following files were missing from the list of precious files
   that should be saved during the conversion:

	/usr/src/sys/conf/X (where X is your system)
	/usr/src/sys/sys/tty_conf.c (for local line disciplines)
	/usr/src/sys/vax/conf.c (for local [bc]devsw entries)
	/usr/lib/Mail.rc
	/usr/lib/sendmail.cf

 * On page 14, the commands:

	# cd /usr/src
	# tar xpb 20

   should be:

	# cd /usr/src
	# mt fsf
	# tar xpbf 20 /dev/rmt12

   /dev/rmt12 should be used if extracting vfont -- in any case, it's
   faster to say "mt offl" than "mt fsf 4" if you make the wrong guess.

 * If "make depend" fails in /sys/X, a bogus assym.s file is left around.
   I don't see any obvious way to fix this.

 * DM's are not included in the GENERIC system with the DH's, which are.
   This can cause port switchers and the like to be unusable.  Minor
   perhaps, but annoying.

 * You should warn people to run /etc/mkpasswd after copying in their old
   password file -- things are pretty wierd until you do that.

 * Section 3.2 indicates that you can just copy over /etc/ttys from a
   4.2 system.  This would be quite unfortunate.

 * /usr/ucb/Mail as distributed on the tape doesn't work -- recompiling
   from the source fixes it.

That's all I can remember for now.  Overall it went very smoothly.

eric

From blia.UUCP!eric@ucsf-cgl.ARPA  Tue Oct  8 00:19:27 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA10875; Tue, 8 Oct 85 00:19:27 PDT
Received: by ucsf-cgl.ARPA (4.46/GSC3.5)
	id AA20119; Tue, 8 Oct 85 00:17:32 PDT
Received: by blia.BLI (5.9/4.37)
	id AA26821; Mon, 7 Oct 85 21:25:33 PDT
From: blia.UUCP!eric@ucsf-cgl.ARPA (Eric Allman)
Message-Id: <8510080425.AA26821@blia.BLI>
To: beta43_bugs@ucsf-cgl.ARPA
Subject: other minor problems
Date: 07 Oct 85 21:25:31 PDT (Mon)
Status: O

There is a Makefile in /usr/local -- this should probably be mentioned
somewhere.

The XNS trace program /etc/trsp doesn't seem to be distributed.  Boo hiss.

eric

From mcvax!jaap@seismo.CSS.GOV  Thu Oct 10 12:27:06 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA27395; Thu, 10 Oct 85 12:27:06 PDT
Return-Path: <mcvax!jaap>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Thu, 10 Oct 85 15:16:44 EDT
Received: by mcvax.UUCP; Thu, 10 Oct 85 18:51:56 +0100 (MET)
From: mcvax!jaap@seismo.CSS.GOV (Jaap Akkerhuis)
Received: by mcvax.UUCP; Thu, 10 Oct 85 18:51:41 +0100 (MET)
Message-Id: <8510101751.AA05009@mcvax.UUCP>
To: mckusick, beta43_bugs
Cc: jim@seismo.CSS.GOV
Organisation: Centrum voor Wiskunde en Informatica
	      Kruislaan 413, 1098 SJ Amsterdam, The Netherlands
Phone: +31 20 5924144, +31 20 991022
Telex: 12571 (mactr nl)
Subject: 4.3 Beta tapes. Bug or feature?
Date: 10 Oct 85 18:51:39 N (Thu)
Status: O

Well, we got the beta tapes, but there is something wrong with it.

There are three tapes, one labeled reel1 007, containing:
 203    512 blocks
   1      0 tapemark
 205  10240 blocks
   1      0 tapemark
 422  10240 blocks
   1      0
2983  10240 blocks
   3      0 tapemark

Another one labeled reel1 008, containing:
 203    512 blocks
   1      0 tapemark
 205  10240 blocks
   1      0 tapemark
 422  10240 blocks
   1      0 tapemark
2983  10240 blocks
   3      0 tapemark

The third one labeled reel2 007, containing:
 714  10240 blocks
   1      0 tapemark
2477  10240 blocks
   1      0 tapemark
 571  10240 blocks
   3      0 tapemark

So it looks likes we got two copies of tape 1, and somebody else got our
copy of the usr contributed software and ingres. So we are relatively
well off, the people who have our tape 3 will have some trouble booting...
Do I need to take any action about this?

	Jaap	(mcvax!jaap)

From nsc!chuqui@decwrl.ARPA  Thu Oct 10 14:24:37 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA27800; Thu, 10 Oct 85 14:24:37 PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA24664; Thu, 10 Oct 85 12:21:45 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA07760; Thu, 10 Oct 85 12:19:03 pdt
Date: Thu, 10 Oct 85 12:19:03 pdt
From: nsc!chuqui@decwrl.ARPA (Chuq Von Rospach)
Message-Id: <8510101919.AA07760@nsc.UUCP>
To: 43bugs@decwrl.ARPA
Subject: test message -- ignore
Status: O


Setting up a forwarding aliase to berkeley. Please ignore this message (I'll
know it works when it doesn't come back....)

chuq

From nsc!chuqui@decwrl.ARPA  Thu Oct 10 15:48:32 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA28080; Thu, 10 Oct 85 15:48:32 PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA27966; Thu, 10 Oct 85 15:47:51 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA12107; Thu, 10 Oct 85 15:45:44 pdt
Date: Thu, 10 Oct 85 15:45:44 pdt
From: nsc!chuqui@decwrl.ARPA (Chuq Von Rospach)
Message-Id: <8510102245.AA12107@nsc.UUCP>
To: 43bugs@decwrl.ARPA
Subject: Verifying receipt of tape...
Status: O


This is a quick note to let the people at Berkeley know that we have
received the 4.3 beta tape whole and have gotten it up on a spare 750 here.
We have set up two aliases to make communication easier:
	o nsc!43bugs: This alias forwards to our local 4.3 group 
		and to the Berkeley people at 'beta43_bugs@monet'
	o 43folks: our local group of hackers.

If you want to let us know anything here at National, drop us a line at
nsc!43folks. Our voice contact will be Linda Lyons, our voice backup is
Harlan McGann, both at (408) 733-2600. 

Verified bug reports should be sent to 43bugs (which redistributes to 43folks
as well). Internal comments should go to 43folks so we don't bother
Berkeley unneccessarily.

chuq von rospach
National Semiconduct
(408) 733-2600 x242

From nsc!chuqui@decwrl.ARPA  Thu Oct 10 16:05:22 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA28195; Thu, 10 Oct 85 16:05:22 PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA28222; Thu, 10 Oct 85 16:05:11 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA12480; Thu, 10 Oct 85 16:02:53 pdt
Date: Thu, 10 Oct 85 16:02:53 pdt
From: nsc!chuqui@decwrl.ARPA (Chuq Von Rospach)
Message-Id: <8510102302.AA12480@nsc.UUCP>
To: 43bugs@decwrl.ARPA
Subject: problems with "Installing and Operating..." document
Status: O


I loaded up our 4.3 system based on the April 1, 1985 version of the 
"Installing and Operating 4.3BSD on the Vax document". I've found a few
problems that you ought to consider in future revisions of the procedures.

In Section 2.4 "Restoring the root file system"

    The procedure does not cover creating the appropriate mag tape devices
    in /dev prior to running xtr. You should probably add a step which 
    runs them through the "cd /dev ; MAKEDEV yy0" to get things set up
    right. 

    Also, the MAKEDEV as distributed on the Beta tape for the miniroot does
    not create the 6250 (*mt16*) devices, so you need to know how to mknod
    to properly get data off the 6250 tapes. 

    Finally, my tape drive doesn't read 6250 properly when accessed as mt0,
    so xtr didn't work right. It would make sense to extend the "tape=yy"
    define to "tape=yynum" and allow them to define a device such as rmt16
    instead of forcing them to device 0. If the MAKEDEV sets things up
    right, this is a bit more flexible and a lot less device dependent.

In Section 2.7 "setting up the /usr filesystem"

    It turns out that our magtape rewound after extracting the root in
    section 2.4, so the sequence

	# cd /usr		(make /usr the current directory)
	# mt fsf

    did not work properly. I suggest you change that procedure to

	# cd /usr
	# mt rew
	# mt fsf 3

    because it guarantees getting you to the known point regardless of
    whether or not your tape rewinds when you're not looking.

When you try to set the date (top of page 14), the following error
messages are printed out:

    # date 8510101207
    <37>Oct 10 04:02:47 date: date: set by root
    bind: Can't assign requested address
    thu Oct 10 12:07:01 PDT 1985
    #

It looks like date has been modified to tell someone (I'm assuming syslogd
or timed) that the date has been changed, and while in the miniroot they
aren't running. you probably want to warn the uninitiated to expect these
messages and to ignore them.

***
In general, these are nitpicks -- the system came up without much of a
whimper and running the document as a novice would (at least, I tried to)
didn't show up anything earthshaking. In the space of a couple of hours, we
ended up with a booted, functioning, talking to the world 4.3 system, and
I'm impressed.
***

chuq von rospach
National Semiconductor
(408) 733-2600 x242


From nsc!chuqui@decwrl.ARPA  Thu Oct 10 16:11:09 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA28238; Thu, 10 Oct 85 16:11:09 PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA28317; Thu, 10 Oct 85 16:10:22 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA12547; Thu, 10 Oct 85 16:09:01 pdt
Date: Thu, 10 Oct 85 16:09:01 pdt
From: nsc!chuqui@decwrl.ARPA (Chuq Von Rospach)
Message-Id: <8510102309.AA12547@nsc.UUCP>
To: 43bugs@decwrl.ARPA
Subject: Two networking flakes
Status: O


I've found two immediate networking flakes. Are you aware of these?

Our other machines are all running BRL release 3 of 4.2. All of the
networking commands seem to work fine except rwho -- none of the BRL
based machines recognize the 4.3 machine being there (rlogin, telnet, and
rcp all talk just fine), but the 4.3 machine reports the packets from the
other systems no problem. 

The second flake: If you rlogin to the 4.3 machine (rlogging in to itself
qualifies as well, so it is independent of BRL code) to a non-existant
account, ("rlogin cthulhu -l nothere") and type a ^D to the "Password:"
prompt, the system will cycle through a series of "login:" "Password:"
and finally close the connection. It looks as if something isn't resetting
EOF properly, but I haven't had time to check. Have you seen this
elsewhere?

chuq von rospach
national Semiconductor
(408)733-2600 X242


From nsc!decwrl!bloom  Thu Oct 10 17:59:20 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA28596; Thu, 10 Oct 85 17:59:20 PDT
Received: by decwrl.ARPA (4.22.01/4.7.34)
	id AA29643; Thu, 10 Oct 85 17:59:13 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA15251; Thu, 10 Oct 85 17:58:01 pdt
Received: from monet.berkeley.edu (ucbmonet.arpa.ARPA) by decwrl.ARPA (4.22.01/4.7.34)
	id AA28518; Thu, 10 Oct 85 16:32:53 pdt
Received: by monet.berkeley.edu (5.28/1.2)
	id AA28293; Thu, 10 Oct 85 16:32:17 PDT
Date: Thu, 10 Oct 85 16:32:17 PDT
From: nsc!decwrl!bloom (Jim Bloom)
Message-Id: <8510102332.AA28293@monet.berkeley.edu>
To: nsc!chuqui@decwrl.ARPA (Chuq Von Rospach)
Cc: nsc!43bugs@decwrl.ARPA
Subject: Re: Two networking flakes
In-Reply-To: Your message of Thu, 10 Oct 85 16:09:01 pdt.
	     <8510102309.AA12547@nsc.UUCP>
Status: O

Your problem with rwho has to do with broadcasts.  The default
broadcast address under 4.3 has a host part of all 1's, while
4.2 uses all 0's.  Until all of your machines have been upgraded
to 4.3, you can use the new option to ifconfig to set the 
broadcast address.  Look in the manual page for the exact format.

We will look into the other problem.

				Jim

From helge  Fri Oct 11 12:15:54 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA12666; Fri, 11 Oct 85 12:15:54 PDT
Date: Fri, 11 Oct 85 12:15:54 PDT
From: helge (Helge Skrivervik)
Message-Id: <8510111915.AA12666@monet.berkeley.edu>
To: beta43_bugs
Subject: major problem
Status: O

in addition to the missing vv driver - our most apparent problem
is that no berkeley nost knows about any nta hosts
anymore. this has been happening over the last few months, and 
the current status is that no hosts are recognized by sendmail.
is there an easy way to get around this??

helge

From sjk@sri-spam  Fri Oct 11 14:13:09 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00278; Fri, 11 Oct 85 14:13:09 PDT
Received: by sri-spam.ARPA (5.4/4.16)
	id AA22794; Fri, 11 Oct 85 14:11:38 PDT
Date: Fri, 11 Oct 85 14:11:38 PDT
From: sjk@sri-spam (Scott J. Kramer)
Message-Id: <8510112111.AA22794@sri-spam.ARPA>
To: beta43_bugs@ucbmonet
Subject: minor cosmetics...
Status: O

/nbsd/usr/src/etc/named/ns_main.c:
	ns_main.c	2.5 (Berkeley) 9/17/85
271c271
< 	fprintf(stderr, "Usage: nameser [-d #] [-p port] [{-b} bootfile]\n");
---
> 	fprintf(stderr, "Usage: named [-d #] [-p port] [{-b} bootfile]\n");

/nbsd/usr/src/etc/dump/Makefile:
	Makefile	5.2 (Berkeley) 6/18/85
9c9
< #	dumpitime.c		reads /etc/ddate
---
> #	dumpitime.c		reads /etc/dumpdates

From chris@gyre.umd.edu  Sat Oct 12 06:44:49 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA08494; Sat, 12 Oct 85 06:44:49 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA14306; Sat, 12 Oct 85 09:44:59 EDT
Date: Sat, 12 Oct 85 09:44:59 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510121344.AA14306@gyre.umd.edu>
To: beta43_bugs
Subject: /usr/src/bin/Makefile includes `strip' in ${STD}
Status: O

Index: /usr/src/bin/Makefile 4.3Beta Fix

Description:
	Somehow `strip' got added to ${STD}; this is obviously wrong
	since it is mentioned explicitly everywhere it is needed, and
	it would be `make depend'ed twice where it is.  (Oddly enough,
	the dependency list mentions it only once....)

Repeat-By:
	inspection

Fix:
	Remove strip from STD=...

From chris@gyre.umd.edu  Sat Oct 12 07:11:59 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA08519; Sat, 12 Oct 85 07:11:59 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA14482; Sat, 12 Oct 85 10:12:09 EDT
Date: Sat, 12 Oct 85 10:12:09 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510121412.AA14482@gyre.umd.edu>
To: beta43_bugs
Subject: passwd will still dbm_close(NULL) if no /etc/passwd db
Status: O

Index: /usr/src/bin/passwd.c 4.3Beta Fix

Description:
	If there is no password database, passwd will `close' NULL,
	closing two random fd's and freeing NULL.

Repeat-By:
	There may be no symptoms.  The bug, however, is obvious.

Fix:
	Near line 180, change

		dbm_close(dp);

	to

		if (dp != NULL)
			dbm_close(dp);


From chris@gyre.umd.edu  Sat Oct 12 12:08:29 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA08897; Sat, 12 Oct 85 12:08:29 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA07862; Sat, 12 Oct 85 14:38:24 EDT
Date: Sat, 12 Oct 85 14:38:24 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510121838.AA07862@gyre.umd.edu>
To: beta43_bugs
Subject: libc/net/hosttable/Makefile has `-X' instead of `-x'
Status: RO

Index: /usr/src/lib/libc/net/hosttable/Makefile 4.3Beta Fix

Description:
	The ld command for the profiled files has an uppercase
	`X' rather than a lowercase `x'; for this reason `make'
	fails.

Repeat-By:
	Run `make' in that directory

Fix:
	Change the `X' to an `x' of course.

From chris@gyre.umd.edu  Mon Oct 14 08:24:27 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA29832; Mon, 14 Oct 85 08:24:27 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA14644; Mon, 14 Oct 85 11:24:55 EDT
Date: Mon, 14 Oct 85 11:24:55 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510141524.AA14644@gyre.umd.edu>
To: beta43_bugs
Subject: netstat problem
Status: O

Index: /usr/src/ucb/netstat/host.c 4.3Beta Fix

Description:
	host.c compiles with a warning due to h_addr being #define'd to
	h_addr_list[0] in <netdb.h>; it wants to access a netimp h_addr
	but is getting a strange member instead.  Whether this causes
	any real problems, I do not know; but it will likely not work
	on some machines.

Repeat-By:
	Just recompile netstat.

Fix:
	#undef h_addr just before using it at line 70 in host.c.

Chris

From helge@ODIN.GOV.NOR.ARPA  Mon Oct 14 12:20:35 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA03653; Mon, 14 Oct 85 12:20:35 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA04485; Mon, 14 Oct 85 20:20:12 -0200
Date: Mon, 14 Oct 85 20:20:12 -0200
From: helge@ODIN.GOV.NOR (Helge Skrivervik)
Message-Id: <8510141820.AA04485@odin.ARPA>
To: beta43_bugs@ucbmonet
Subject: status report
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

10/14/85

Here is a preliminary report from our beta testing of 4.3.
Some of the problems listed have been corrected already; they
are included for completeness only:

- when running fsck for the first time on a 4.2 file system
	we got a lot of messages "DIRECTORY ...: LENGTH xx (usually 24)
	NOT MULTIPLE OF 512 (ADJUSTED)". If this is to be expected, the
	installation guide should mention it.

- typo in restore: the initial message from restore(8) about starting
	the search from the last tape has a typo: "towards towards".

- if_vv.c is missing (this has been corrected)

- vvprt_hdr is undefined (referenced in the vv driver)

- bbnnet software does not compile because KERN_RECOV is undefined
	(this has been corrected)

- it would be extremely beneficial if the MTU could be set from ifconfig

- telnet to localhost crashes the system (panic: segmentation fault).
	we have not yet checked if this can be repeated. A few other system
	crashes remain to be analyzed.

- The MAKEDEV script does not work correctly for dmf? if dh? exists

- The dmf controller address in the GENERIC configuration is different
	from what I believe is that standard unibus address (and different
	from the address specified in the man page)

- We have not been able to get rdump to work correctly. After the first
	dump phase starts ("dumping directories"), dump exits with the
	message "the entire dump is aborted". No other messages are
	given, on the local or the remote machine. (running berkeley
	networking software)

- /usr/ucb/Mail does not work as distributed (works when reading mail, not
	when sending mail, complains about a /tmp file being non-existant).
	this has been corrected by uploading a new binary from monet.

- rcp(1) , when copying one or more files FROM the local machine, should
	first check that at least one of the speciified files exist, before
	setting up the connection.

- /etc/route does not work when the vv interface is configured into the 
	system. we are
	currently looking into this. it fails in the ioctl at the bottom
	of newroute: invalid argument. /etc/route works with the generic
	kernel.




helge

From helge%nta-vax.arpa.GOV%nta-vax.arpa@NTA-VAX.ARPA  Mon Oct 14 13:04:17 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00278; Mon, 14 Oct 85 13:04:17 PDT
Date: Fri, 11 Oct 85 12:57:18 PDT
From: helge%nta-vax.arpa.GOV%nta-vax.arpa@NTA-VAX.ARPA (Helge Skrivervik)
Posted-Date: Fri, 11 Oct 85 12:57:18 PDT
Message-Id: <8510111957.AA01874@nta-vax.arpa.ARPA>
Received: by nta-vax.arpa.ARPA (5.9/3.21)
	id AA01874; Fri, 11 Oct 85 12:57:18 PDT
To: beta43_bugs@ucbmonet
Subject: mail (ucbmail) problem
Cc: helge%nta-vax.arpa.GOV%nta-vax.arpa@NTA-VAX.ARPA,
        paal%nta-vax.arpa.GOV%nta-vax.arpa@NTA-VAX.ARPA
Status: O

ucbmail as distributed does not work:

Script started on Fri Oct 11 12:37:51 1985
nta-vax% ls -l /usr/ucb/mail
-rwxr-xr-x  2 root        71680 Sep 19 01:37 /usr/ucb/mail*
nta-vax% !$ helge
/usr/ucb/mail helge
/tmp/Rs01701: No such file or directory
nta-vax% ls -ld /tmp
drwxrwxrwx  3 root          512 Oct 11 12:34 /tmp/
nta-vax% exit
nta-vax% 
------------------------
the current version of ucbmail when copied from monet
seems to work ok.

helge


From helge@ODIN.GOV.NOR.ARPA  Mon Oct 14 13:47:47 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00378; Mon, 14 Oct 85 13:47:47 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA04972; Mon, 14 Oct 85 21:47:52 -0200
Date: Mon, 14 Oct 85 21:47:52 -0200
From: helge@ODIN.GOV.NOR (Helge Skrivervik)
Message-Id: <8510141947.AA04972@odin.ARPA>
To: beta43_bugs@ucbmonet
Subject: /etc/route
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

something must be broken either in the socket code or in the vv driver,
as reported earlier, /etc/route add ... always fails in the ioctl
at the end of newroute (invalid argument) when the vv driver is configured
into the system. a system with the il driver only works fine.
a quick fix to this would be greatly appreciated.

helge

From obrien@rand-unix.ARPA  Mon Oct 14 14:05:51 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00511; Mon, 14 Oct 85 14:05:51 PDT
Return-Path: <obrien@rand-unix.ARPA>
Received: by rand-unix.ARPA; Mon, 14 Oct 85 13:46:47 pdt
From: Michael O'Brien <obrien@rand-unix.ARPA>
Message-Id: <8510142046.AA09254@rand-unix.ARPA>
Date: 14 Oct 85 13:46:42 PDT (Mon)
To: beta43_bugs
Subject: 4.3 is up
Status: O

	I brought 4.3 beta up this weekend with few problems.  Here is
what I encountered (some of it has little to do with 4.3 per se):

	1) The beta distribution did not include a boot cassette or
floppy.  I assumed that the relevant disk partitions probably had not
changed so I elected to use the 4.2 boot cassette.  The particular
configuration of our 750 make other alternatives much more painful.

	I couldn't find the 4.2 boot cassette so I decided to make one
from first principles using the 4.2 sys/stand and sys/cassette stuff.
"make; make install" created a boot cassette that loaded "copy" and
then halted.  Restoring the original image of the "cassette" file
created a tape that worked.  Obviously something sour in the 4.2
standalone stuff...I haven't been tracking reports on that.

	2) There are some fluffs on p. 14 of "Installing and Operating".
In the first text paragraph, "files" -> "file", "continues this" ->
"continues from this".  Also, in the command script following, there is
"cd .." followed by "cd /", which seems odd.

	3) Curiously, when I unmounted and "fsck"ed /usr, it
didn't seem to know where it had last been mounted, though the second
time I mounted and unmounted it, the mount point was remembered.

	4) As a data point, /usr, /usr/sys, /usr/src, and the
user-contributed stuff just fit on an RA60.  Takes up 103%.

	I suppose I should also try the toggle-in MT boot code.
I may do that soon.

From helge@ODIN.GOV.NOR.ARPA  Mon Oct 14 15:24:43 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA00843; Mon, 14 Oct 85 15:24:43 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA05567; Mon, 14 Oct 85 23:24:48 -0200
Date: Mon, 14 Oct 85 23:24:48 -0200
From: helge@ODIN.GOV.NOR (Helge Skrivervik)
Message-Id: <8510142124.AA05567@odin.ARPA>
To: beta43_bugs@ucbmonet
Subject: minor bug in vv driver
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

a minor bug in if_vv.c (vvioctl)
line 967
<		return(EADDRNOTAVAIL);
----
> 		error = EADDRNOTAVAIL;


the bug causes the routine to return without resetting the ipl

helge

From helge@ODIN.GOV.NOR.ARPA  Tue Oct 15 01:18:54 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA03240; Tue, 15 Oct 85 01:18:54 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA08539; Tue, 15 Oct 85 08:54:03 -0200
Date: Tue, 15 Oct 85 08:54:03 -0200
From: helge@ODIN.GOV.NOR.ARPA (Helge Skrivervik)
Message-Id: <8510150654.AA08539@odin.ARPA>
To: beta43_bugs@ucbmonet
Subject: make depend
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

when configuring new systems, make depend some times generates
duplicate entries in the resulting makefile. We have had this happen
twice so far; both times there were one duplicate entry, and both
times it was an if_??? file.

helge

From helge@ODIN.GOV.NOR.ARPA  Tue Oct 15 17:09:03 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA06491; Tue, 15 Oct 85 17:09:03 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA17953; Wed, 16 Oct 85 01:08:40 -0200
Date: Wed, 16 Oct 85 01:08:40 -0200
From: helge@ODIN.GOV.NOR (Helge Skrivervik)
Message-Id: <8510152308.AA17953@odin.ARPA>
To: beta43_bugs@monet
Subject: route
Status: O

any hints as to what we can do to get routing to work
when the vv driver is in the system?? is there someone we
should talk to about the problem?? as you can tell, we are getting
desperate...


helge

From helge@ODIN.GOV.NOR.ARPA  Wed Oct 16 02:18:12 1985
Received: by monet.berkeley.edu (5.28/1.2)
	id AA08526; Wed, 16 Oct 85 02:18:12 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA00533; Wed, 16 Oct 85 10:18:22 -0200
Date: Wed, 16 Oct 85 10:18:22 -0200
From: helge@ODIN.GOV.NOR (Helge Skrivervik)
Message-Id: <8510160818.AA00533@odin.ARPA>
To: beta43_bugs@monet
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

thanks for the responses. Notice that mail to nta-vax will never get here
until the route problem has been fixed, since the only known address to
nta-vax in arpa land is thru the ring interface.
The route problem does not have anything
to do with the networking software used as far as I can tell.
It is present with both berkeley and BBN networking software.

will check out the mail sources.

by the way, the file /usr/include/time.h includes itself, which
obviously creates some problems. I assume that this has been corrected
at berkeley.

helge

From chris@gyre.umd.edu  Wed Oct 16 19:26:30 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA03361; Wed, 16 Oct 85 19:26:30 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA03499; Wed, 16 Oct 85 22:27:23 EDT
Date: Wed, 16 Oct 85 22:27:23 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510170227.AA03499@gyre.umd.edu>
To: beta43_bugs
Subject: Trivial bug in /usr/src/bin/Makefile
Status: O

Index: /usr/src/bin/Makefile 4.3Beta

Description:
	The `depend' entry does not depend on expr.c, but uses it; if you
	have done a `make clean', `make depend' fails.

	Also, the file really ought to use `> makedep' in case a partial
	one exists from an interrupted `make depend'.

Repeat-By:
	% cd /usr/src/bin; make clean; make depend

From mike@BRL.ARPA  Fri Oct 18 00:07:14 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA08164; Fri, 18 Oct 85 00:07:14 PDT
Message-Id: <8510180707.AA08164@monet.berkeley.edu>
Date:     Fri, 18 Oct 85 3:07:36 EDT
From: Mike Muuss <mike@BRL.ARPA>
To: mckusick, karels, bloom
Cc: beta43_bugs, Lamas@BRL.ARPA, PHD@BRL.ARPA
Subject:  BRL observations
Status: O

I've been working on the 4.3 Beta tape this week, with a number of
observations.  First, could you please add <Lamas@BRL.ARPA> to the
beta43_bugs list?

1)  A 9766 on an SI disk controller is still autoconfigured as an
Ampex 9300.  This really sucks.

*)  Booting the GENERIC kernel, de0 zaps vv0's ring.  Not really
a bug, but worth noting.  (de0 and vv0 seem to have the same csr addr).

*)  /etc/config silently ignores controller and device specifications
which are not in conf/file, BUT it still generates vectors and XXdriver
entries, which you hear about after running the whole "make".

*)  The tape didn't seem to have vaxif/if_vv.c

*)  /etc/ifconfig seems to always finish up by perror() EPROTONOTSUPPORTED.

*)  The distribution contains 3 messages mailed to "root".

*)  MAKEDEV can't make hp8 or higher;  vgr has 13 hp disks...

*)  syslogd complains when started about "*" and such stuff, but seems
to otherwise work.

*)  More clues about having to run mkpasswd after each edit of /etc/passwd
would be a good thing, perhaps in passwd(5), getpwent(3), etc.

*)  When trying to compile the BBN TCP, bbnnet/icmp.c (and others)
do not have KERN_RECOV defined;  I added an "options KERN_RECOV=LOG_NOTICE"
to the config file as a workaround.

*)  When an IMP is configured in, bbnnet/in.c needs to have the functions
in_netof() and in_iaonnetof() un-#ifdef'ed out -- they are used.

*)  When compiling a BBN TCP, symorder warns that tcb and ucb are not found.

*)  The manual page for ping seems to have been lost;  I'll put a copy
of ours into ~mike/ping.8 on ucbmonet.

*)  When making heavy use of UDP in the BBN TCP, the kernel panics with
the message "out of mbuf map".  The same tests havn't had any problems
with the Berkeley TCP.  Is there a fix?

*)  You don't seem to have PREEN, from UofMd -- I can send it;
it replaces fsck -p in /etc/rc, and with lots of heads it greatly
speeds reboot times.

More items as I find them.
	Best,
	 -Mike

From mike@BRL.ARPA  Fri Oct 18 03:20:47 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA08676; Fri, 18 Oct 85 03:20:47 PDT
Message-Id: <8510181020.AA08676@monet.berkeley.edu>
Date:     Fri, 18 Oct 85 5:56:05 EDT
From: Mike Muuss <mike@BRL.ARPA>
To: Mike Muuss <mike@BRL.ARPA>
Cc: mckusick, karels, bloom, beta43_bugs, Lamas@BRL.ARPA, PHD@BRL.ARPA
Subject:  Re:  BRL observations
Status: O

A few more comments:

*)  Even with the 18-Oct versions of the bbnnet code, heavy use of
UDP with the BBN net reliably crashes the machine, whereas the Berkeley
version works fine (although sometimes running out of buffer space
temporarily).

*)  The bbnnet kernel is unwilling to accept network routes, either
explicit or default.  ("/etc/route add 0 192.5.21.5 3" gets EINVAL).
This prevents real use of this kernel.

*)  A simple addition:  could the host name string be included in
the syslog() print for each bad login?  It's really frustrating to
have the console say "ROOT ACCESS DENIED (ttyp0)" and not know if
it's from a local machine, or some random hacker elsewhere.

I consider items #2 to be high priority, and I intend to try to track
it down on my own.  Is anybody else working on this, or am I on my
own completely?
	Best,
	 -Mike

From sjk@ucbarpa  Fri Oct 18 10:06:18 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA09428; Fri, 18 Oct 85 10:06:18 PDT
Received: by ucbarpa (5.28/5.12)
	id AA18240; Fri, 18 Oct 85 10:06:03 PDT
Date: Fri, 18 Oct 85 10:06:03 PDT
From: sjk@ucbarpa (Scott J. Kramer)
Message-Id: <8510181706.AA18240@ucbarpa>
Cc: beta43_bugs@ucbmonet
Subject: obsolete Mail.help
Index: 	ucb/Mail/misc/Mail.help 4.3BSD
Status: O

Description:
	The default Mail.help refers to "obsolete" files.
Repeat-By:
	Peruse /usr/lib/Mail.help.
Fix:
10c10
< pre <message list>		make messages go back to /usr/mail
---
> pre <message list>		make messages go back to /usr/spool/mail
22c22
< Distribution names are defined in .sendrc in your home directory.
---
> Distribution names are defined in .mailrc in your home directory.

From chris@gyre.umd.edu  Fri Oct 18 22:48:46 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA13085; Fri, 18 Oct 85 22:48:46 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA27345; Sat, 19 Oct 85 01:49:39 EDT
Date: Sat, 19 Oct 85 01:49:39 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510190549.AA27345@gyre.umd.edu>
To: beta43_bugs
Subject: Sendmail infinite loops if it cannot create queue entries
Status: O

Index: /usr/src/usr.lib/sendmail/src/{queue.c,err.c} 4.3Beta Fix

Description:
	queuename calls syserr if it cannot make up a queue name.
	syserr calls queuename if it does not have a queue name.
	This leads to endless recursion and eventually, after
	consuming a truly incredible total of resources, a core
	dump or other nasty (but hardly untimely) end.

Repeat-By:
	I imagine making the queue directory unwritable would do
	it, or making sendmail attempt to queue things in a nonexistent
	directory.  I am not certain why it is happening now.

Fix:
	I can see no reason for `insure'ing (how about `ensure'ing?)
	that sendmail has a queue name for the syslog entry.  If
	CurEnv->e_id == NULL, simply leave the queue name field blank,
	or insert something like "[no envelope]".

Chris

From chris@gyre.umd.edu  Sat Oct 19 00:23:21 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA13239; Sat, 19 Oct 85 00:23:21 PDT
Received: by gyre.umd.edu (5.5/4.7)
	id AA00686; Sat, 19 Oct 85 03:24:14 EDT
Date: Sat, 19 Oct 85 03:24:14 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510190724.AA00686@gyre.umd.edu>
To: beta43_bugs
Subject: sendmail, /etc Makefiles still do not specify owner root
Status: O

Index: /usr/src/etc/Makefile,/usr/src/usr.lib/sendmail/src/Makefile 4.3Beta

Description:
	Both of these makefiles install files that should be setuid
	root (shutdown and sendmail respectively).  Neither of
	these forces the owner of the file to be root, so that if
	`install' installs things as `bin' or some other inocuous
	user, one must fix the files by hand.

Repeat-By:
	change /usr/bin/install to default owners to someone other
	than root.

I know, why would you want to do such a thing.  Well it helps keep
things straight around here as to what is *supposed* to be setuid
and files are only because some fumble fingered super user set the
wrong modes.

From phil  Sun Oct 20 00:34:03 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA15732; Sun, 20 Oct 85 00:34:03 PDT
Date: Sun, 20 Oct 85 00:34:03 PDT
From: phil (Phil Lapsley)
Message-Id: <8510200734.AA15732@monet.berkeley.edu>
To: beta43_bugs
Subject: finger.c
Status: O

     I don't know if this is in the 4.3 beta version of finger,
but it is certainly on the finger on monet.  With the new version
of the hostent structure for the gethostby*() routines and the
name server, finger dumps core on numeric internet addresses.
The problem behind this is that finger tries to act like a
gethostbyname() worked when it has a numeric address, by created
a little static hostent structure.  The problem is that
h_addr is now #define'ed to h_addr_list[0], which finger doesn't
know about.  Consequently, h_addr_list is undefined, and the'
program bus errors.

     Fixed source is in ~phil/fixedfinger.c on monet.

						Phil

From chris@gyre.umd.edu  Mon Oct 21 09:18:13 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA00256; Mon, 21 Oct 85 09:18:13 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA02408; Sun, 20 Oct 85 05:05:19 EDT
Date: Sun, 20 Oct 85 05:05:19 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510200905.AA02408@gyre.umd.edu>
To: beta43_bugs
Subject: pascal generates wrong .stabs for array of array of
Cc: chris@gyre.umd.edu
Status: O

Index: /usr/src/ucb/pascal/src/stab.c 4.3Beta Fix

Description:
	The code for generating array types to dbx does not give dbx
	quite what it wants for multidimensional arrays.  To dbx, these
	should be repeated `array of <type>'s, but pc is putting out
	only the <type>s.

Repeat-By:
	Use `pc -w -g -C' (probably only `-g' required) to....

	Compile the following program, run dbx, and ask `whatis a':

		program main;
		var a:array[1..3,1..7]of integer;
		begin a[1][2]:=3 end.

	or

	Compile the following program and attempt to run dbx:

		program main;
		var foo:record a:array[1..3,1..7]of integer; end;
		begin foo.a[1][2]:=3; end.

Fix:
	Apply the diffs below.

Chris
-----

*** stab.c.ucb	Sat Oct 12 11:11:54 1985
--- stab.c	Sun Oct 20 04:54:15 1985
***************
*** 250,254 ****
	    starthere += strlen(enclosing[i]) + 1;
	}
! 	*starthere-- = '\0'; /* remove last colon */
	if (starthere >= &buffer[BUFSIZ-1]) {
	    panic("snestspec");
--- 250,254 ----
	    starthere += strlen(enclosing[i]) + 1;
	}
! 	*--starthere = '\0'; /* remove last colon */
	if (starthere >= &buffer[BUFSIZ-1]) {
	    panic("snestspec");
***************
*** 615,620 ****
      register struct nl *p;
  
-     putprintf("a", 1);
      for (p = t->chain; p != NIL; p = p->chain) {
	gentype(p);
	putprintf(";", 1);
--- 615,620 ----
      register struct nl *p;
  
      for (p = t->chain; p != NIL; p = p->chain) {
+ 	putprintf("a", 1);
	gentype(p);
	putprintf(";", 1);

From karels  Mon Oct 21 12:03:32 1985
Received: by monet.berkeley.edu (5.29/1.2)
	id AA01342; Mon, 21 Oct 85 12:03:32 PDT
Date: Mon, 21 Oct 85 12:03:32 PDT
From: karels (Mike Karels)
Message-Id: <8510211903.AA01342@monet.berkeley.edu>
To: beta43_sites
Subject: beta test status
Status: O

Thanks for all of the feedback so far.  It appears that things are running
fairly succesfully at the sites that I've heard from.  I've summarized
the more useful bug fixes here, so not everyone will have to deal with the
same problems.

Incidentally, some of the bug reports have been sent using sendbug
to 4bsd-bugs@ucbarpa.  As much as I hate to discourage using sendbug,
I would prefer that beta test bugs be sent to beta43_bugs@monet.berkeley.edu
or ucbvax!beta43_bugs@monet.  Sendbug could be modified to use that address
for now if you prefer.

I would like to get status reports from the sites that haven't yet sent
anything, just to have an idea of how far the testing is proceeding.
Thanks for all of your help.

		Mike


1. There were two versions of sendmail on the tape, both with some problems.
Eric sent a message about this earlier with the fix for the one in /usr/src.
The newer, more experimental version on the end of the tape has been updated,
and is available by anonymous ftp from ucbarpa in pub/sendmail.tar.

2. The binary of /usr/ucb/mail was mysteriously broken.  Recompilation fixes
the problem.

3. There was a bug fix for config in the printed change list; unfortunately
it was incomplete.  The problem was multiple inclusions of files like if_uba.o
which have multiple entries in files.* with different dependencies.
A diff containing the complete fix follows; it includes an unrelated change
to allow .o files to be configured:
8c8
< static char sccsid[] = "@(#)mkmakefile.c	5.2 (Berkeley) 9/17/85";
---
> static char sccsid[] = "@(#)mkmakefile.c	5.5 (Berkeley) 10/14/85";
34c34
<  * Lookup a file, by make.
---
>  * Lookup a file, by name.
192c192
< 	register struct file_list *tp;
---
> 	register struct file_list *tp, *pf;
238c238
< 	if ((tp = fl_lookup(this)) && (tp->f_type != INVISIBLE || tp->f_flags))
---
> 	if ((pf = fl_lookup(this)) && (pf->f_type != INVISIBLE || pf->f_flags))
288c288,289
< 	tp = new_fent();
---
> 	if (tp == 0)
> 		tp = new_fent();
323c324,325
< 	tp = new_fent();
---
> 	if (tp == 0)
> 		tp = new_fent();
334a337,338
> 	if (pf && pf->f_type == INVISIBLE)
> 		pf->f_flags = 1;		/* mark as duplicate */
448a453,456
> 	if (och == 'o') {
> 		fprintf(f, "%so:\n\t-cp ../%so .\n", tail(np), np);
> 		continue;
> 	}

4. The change to syslog priorities didn't get made in the bbnnet directory.
Each occurrence of KERN_RECOV should be changed to LOG_INFO.

5. The binary of /etc/arp was out of date.  Recompilation will fix it.
This was due to a change in <netinet/if_ether.h>.

6. There was a bug in ftp, finger and probably other programs that tried
to fill in a hostent structure when given an address in dot notation
rather than a hostname.  The diff for ftp was sent earlier, but is included
here; the others can be fixed similarly:

Oct  5 18:40 1985  SCCS/s.ftp.c: -r5.1 vs. -r5.2 Page 1

49a50
> 		static char *addrbuf;
59a61
> 		def.h_addr_list = &addrbuf;

7. The driver for the Proteon ring interfaces (vaxif/if_vv.c) was omitted
in error.  If anyone who needs it hasn't gotten a copy, let me know and I'll
send it.

8. There was an obscure problem with TCP (netinet).  Under certain
circumstances, it would incorrectly consider the window closed and refuse
to accept data.  Under these conditions, FTP, etc. would create a zero-length
file and then wait forever.  The fixes are as follows:

Oct 14 17:43 1985  SCCS/s.tcp_seq.h: -r6.2 vs. -r6.3 Page 1

25c25
< 	(tp)->rcv_nxt = (tp)->irs + 1
---
> 	(tp)->rcv_adv = (tp)->rcv_nxt = (tp)->irs + 1


Oct 14 17:41 1985  SCCS/s.tcp_input.c: -r6.13 vs. -r6.14 Page 1

329c329
< 	tp->rcv_wnd = MAX(sbspace(&so->so_rcv), tp->rcv_adv - tp->rcv_nxt);
---
> 	tp->rcv_wnd = sbspace(&so->so_rcv);
331a332
> 	tp->rcv_wnd = MAX(tp->rcv_wnd, (short)(tp->rcv_adv - tp->rcv_nxt));


From schoch@orion.ARPA  Tue Oct 22 15:45:49 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA07997; Tue, 22 Oct 85 15:45:49 PDT
Received: by orion.ARPA (4.24/1.2)
	id AA08268; Tue, 22 Oct 85 11:59:08 pdt
Date: Tue, 22 Oct 85 11:59:08 pdt
From: Steve Schoch <schoch@orion.ARPA>
Message-Id: <8510221859.AA08268@orion.ARPA>
Subject: Short summary of the problem
Index: 	/sys/vaxuba/idc.c 4.3BSD
Apparently-To: beta43_bugs@monet.berkeley.edu
Status: O

Description:
	When the idc driver gets an ecc error (on the VAX 11/730) it
	prints "idcecc: HELP!", and hangs the system.
Repeat-By:
	Find a file on an rb drive on a 730 with a bad block and cat it.
Fix:
	The following changes will fix the problem.  The system hangs when
	the 730 does a extzv instruction on a unibus device register, but
	not when the instruction is bicl3, which is what the new source
	generates.
	------- idc.c -------
	705d704
	< 	printf("idcecc: HELP!\n");
	723c722
	< 		addr = ptob(ubp->uba_map[reg+btop(byte)].pg_pfnum)+
	---
	> 		addr = ptob(*(int *)&ubp->uba_map[reg+btop(byte)]&0x1fffff)+

From salkind@nyu-acf8.arpa  Tue Oct 22 19:18:59 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA09183; Tue, 22 Oct 85 19:18:59 PDT
Date: Tue, 22 Oct 85 22:18:46 EDT
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8510230218.AA01997@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Tue, 22 Oct 85 22:18:46 EDT
To: beta43_bugs@nyu-acf8.arpa
Subject: nyu machine acf8 now running 4.3 beta
Status: O

This is a quick summary of some problems I noticed bring up 4.3bsd.
This report is not in the standard "Berkeley Bug Format"; I hope that
is OK.

sample /usr/lib/crontab:  there are two entries for newsyslog; one
in /usr/adm and one in /usr/spool/mqueue (the second doesn't exist
on the distribution tape).

/usr/ucb/{mail,Mail}:	binary seems bad.  I recompiled and then
everything worked ok.

syslogd:  the version distributed is old and out of date, and it does
not correspond to the manual page.  I took the one from ucbmonet
along with the new header file syslog.h, compiled it, and it worked.
Also now corresponds roughly to the documentation.

/etc/syslog.conf:  there is a line in there of the form
	mail.*		/usr/spool/mqueue/syslog
This doesn't work in any version of syslog I have tried.  The line
	mail.info	/usr/spool/mqueue/syslog
works.

/usr/preserve:  I suggest the mode on this directory be changed from
755 to 1777.

/usr/lib/sendmail:  our binary seemed to do wierd things.  To
recompile, first note that syslog.h and sysexits.h are out of date
and should be replaced (in /usr/src/usr.lib/sendmail/include).
I did this, and sendmail now runs fine.
it should be ok.

/usr/src/new/rcs:  there are changes that need to be made here for
stick eof.  Interested?  If so, I will send them in a separate message.

/usr/src/new/notes:  this version is totally obsolete.
I recommend you have either Ray Essick (essick@b.cs.uiuc.edu)
or me send you the new version.   I volunteer to
coordinate this with Ray if you want.

---

The following comments apply to the Installing/Operating 4.3BSD
document:

Converting 4.2bsd filesystems:  I got many messages of the form
"Directory not a multiple of 512 bytes" from 4.3 fsck.
fsck -y took care of these babies.  A note on this should be added.

I assume the "additional notes" distributed will also be in some
document somewhere.

page 12, middle, I recommend:
(see section 6.1 and appendix C if the system does not reboot properly)

page 13, 7 from bottom:  (possibly) "mt fsf" should be "mt fsf 3" (I believe
the previous command rewinds the tape, but I didn't bootstrap our system
this way).

page 13, 4 from bottom, change "files" to "file"

page 14, 6 from top, remove the "cd .." command (the location in
comments is wrong, besides)

page 21 (kernel organization), should have the /sys/bbnnet listed.

page 22, middle, the word "LOCAL" should be "local"

page 28 (adding users section), I recommend that some mention of
the mkpasswd command be put here.

page 30, bottom, add /usr/bin/{uuname,uuq,uusnap} to list of
available uucp commands.

page 35 (regenerating /etc/hosts), some mention should be made of
the mkhosts program

page 37, top: mention that telnetd, ftpd, sendmail, and routed
already come up enabled by the system.

appendix a:  don't forgot to update the count of records on the tape
before shipping the final release.

---

I hope to be sending you a few more reports soon.  Thanks again for
letting us become a test site.

	Lou Salkind

From mike@BRL.ARPA  Wed Oct 23 05:05:00 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA20490; Wed, 23 Oct 85 05:05:00 PDT
Message-Id: <8510231205.AA20490@monet.berkeley.edu>
Date:     Wed, 23 Oct 85 7:53:07 EDT
From: Mike Muuss <mike@BRL.ARPA>
To: Gurwitz@BBN-VAX.ARPA, Lam@BBN-VAX.ARPA, beta43_bugs@BRL.ARPA
Cc: Baker@ISI.ARPA, Lamas@BRL.ARPA, PHD@BRL.ARPA
Subject:  BBN TCP/UDP problems
Status: O

While attempting a comparison between the 4.3 Berkeley and BBN networking
code, I have been encountering a number of difficulties with the BBN code.
Fixes (if known) would be appreciated;  I'll make do with what I've got
otherwise -- it will be enough.

*)  The problem with adding routes was explained to me by Kirk -- a
specially compiled version of /etc/route did the trick.

*)  The problems with compiling the code as it came on the 4.3beta
tapes has been ACKed by Berkeley, and fixed on monet.

*)  When configuring a kernel for BBN networking with an IMP interface
present, the routines if_netof and in_iaonnetof in bbnnet/in.c
are used.  They were wrapped in #ifdef never directives.

*)  When making heavy use of UDP, the system will reliably crash.
Seems to be an mbuf leak in the UDP code.

*)  The BBN kernel will not run the 4.3 /etc/ping;  it seems like changing
a "break" to a "goto pasup" in icmp.c page 9 would do the trick, but
I have not experimented.

*)  The BBN kernel "pings out" our local gateway, claiming that ICMP
checksum FFFF != 0000.  We currently think the gateway is right, but
have asked the TCP-IP list for an opinion.

*)  Having recompiled the BBN kernel without the "BBNPING" feature,
things work better w.r.t. the gateway routing, but we experienced one
system crash in icmp_addr+0x21:	movl	(r0),(r1)
I wasn't doing anything at the time.

*)  I have obtained some oddball behavior while testing across the SATNET
to a straight 4.2BSD VAX at UCL:

		  BRL xmit	BRL rcv
		---------------------------
 4.3 Berkeley	| no		yes
 4.3 BBN	| no		no

In all "no" cases, the sender claims "connection reset by peer",
while the receiver never notices that anything is wrong (except no data).
I never was patient enough to wait for the timeout.  I can't attribute
this to an ICMP message.  In all cases, the UCL machine seemed to
stop transmitting (as observed by a netstat -i 1) about 20-30 seconds
before the connection broke.  HOWEVER, while performing these tests,
I was running a continuous PING study of the UCL machine from another
machine on another IMP port here, with packet loss of about 6%, and
round trip times running about 2.9 seconds (64 byte ICMP packets).
Anybody have any ideas?  The UCL machine being straight 4.2 (with no
bug fixes) introduces lots of extra unknowns, but....

Any and all help appreciated!
	Best,
	 -Mike

From nsc!chongo@decwrl.DEC.COM  Wed Oct 23 19:14:45 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA03487; Wed, 23 Oct 85 19:14:45 PDT
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA29956; Wed, 23 Oct 85 18:20:21 pdt
Received: by nsc.UUCP (4.12/4.7)
	id AA24449; Wed, 23 Oct 85 18:10:23 pdt
Date: Wed, 23 Oct 85 18:10:23 pdt
From: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Message-Id: <8510240110.AA24449@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: typo in xtr
Status: O

The xtr installation shell script from the BETA tape had a line of the form:

	mt -t ...

this should be:

	mt -f ...

chongo <> /\**/\

From baker@ipto.ARPA  Wed Oct 23 20:47:41 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA04073; Wed, 23 Oct 85 20:47:41 PDT
Received: by ipto.ARPA (4.12/4.7)
	id AA00607; Wed, 23 Oct 85 23:48:03 edt
Date: Wed 23 Oct 85 23:47:57-EDT
From: Bob Baker <BAKER@IPTO.ARPA>
Subject: 4.3 bugs (features?)
To: beta43_bugs
Cc: Baker@IPTO.ARPA
Message-Id: <VAX-MM(161)+TOPSLIB(113) 23-Oct-85 23:47:57.IPTO.ARPA>
Status: O

Here are some problems I've seen under 4.3 on ucbarpa:

1. When I log into ucbarpa, my command number always starts at 26.
Commands 1-25 in my history list are from long ago and never change.

2. If I telnet to ucbarpa from ipto.arpa (Vax-750, 4.2, milnet) and
give the script command, the message "Script started, file is typescript"
comes out.  But if I rlogin from ipto.arpa to ucbarpa, the message
usually doesn't come out.  Sometimes it comes out partially and is
overwritten by the first prompt of the new shell.  This problem
doesn't happen when I rlogin to a 4.2 machine (sri-spam) across
several nets.

3. When I telnet from ucbarpa to some smtp server, the first command I
give always produces a "syntax error" message.  The attached script
shows this problem when going from ucbarpa back to itself and also
to a tops-20 system.

Bob Baker

Script started on Wed Oct 23 20:05:56 1985
ucbarpa 26% telnet ucbarpa 25
Trying...
Connected to ucbarpa.
Escape character is '^]'.
220 ucbarpa Sendmail 5.29/5.13 ready at Wed, 23 Oct 85 20:08:41 PDT
noop
500 Command unrecognized
noop
200 OK
quit
221 ucbarpa closing connection
Connection closed by foreign host.
ucbarpa 27% telnet usc-isi 25
Trying...
Connected to usc-isi.arpa.
Escape character is '^]'.
220 USC-ISI.ARPA Simple mail transfer ready
help
500 Syntax error - command unrecognized
help
250 Try: Quit Helo Help Rset Data Rcpt Mail Expn Vrfy or Rubo
quit
221 USC-ISI.ARPA SMTP closing connection
Connection closed by foreign host.
ucbarpa 28% exit
ucbarpa 29% 
-------

From bloom  Wed Oct 23 21:35:10 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA04269; Wed, 23 Oct 85 21:35:10 PDT
Date: Wed, 23 Oct 85 21:35:10 PDT
From: bloom (Jim Bloom)
Message-Id: <8510240435.AA04269@monet.berkeley.edu>
To: Bob Baker <BAKER@IPTO.ARPA>
Cc: beta43_bugs
Subject: Re: 4.3 bugs (features?)
In-Reply-To: Your message of Wed 23 Oct 85 23:47:57-EDT.
	     <VAX-MM(161)+TOPSLIB(113) 23-Oct-85 23:47:57.IPTO.ARPA>
Status: O

	Here are some problems I've seen under 4.3 on ucbarpa:

	1. When I log into ucbarpa, my command number always starts at 26.
	Commands 1-25 in my history list are from long ago and never change.

This arises from a feature of /bin/csh.  It uses the variable savehist set
to a number of commands of history to save.  From your description, I think
you do not have it set normally, but it was set at one time.  Upon start up,
/bin/csh checks to see if the file .history is in your home directory and
reads it in if it exists.  The two choices for dealing with this are to 
remove .history in your home directory, or to add the line 

	set savehist=25		(or other value)

to your .cshrc.

	2. If I telnet to ucbarpa from ipto.arpa (Vax-750, 4.2, milnet) and
	give the script command, the message "Script started, file is typescript"
	comes out.  But if I rlogin from ipto.arpa to ucbarpa, the message
	usually doesn't come out.  Sometimes it comes out partially and is
	overwritten by the first prompt of the new shell.  This problem
	doesn't happen when I rlogin to a 4.2 machine (sri-spam) across
	several nets.

This problem has been fixed, but the new version has not been installed yet
on all of the machines at Berkeley.

	3. When I telnet from ucbarpa to some smtp server, the first command I
	give always produces a "syntax error" message.  The attached script
	shows this problem when going from ucbarpa back to itself and also
	to a tops-20 system.

I suspect that this has something to do with the protocol negotiation used
by telnet when establishing a connection.  Telnet sends a sequence of 
characters in the data stream that a telnet server would recognize, but
are not recognized by smtp.  These characters would not show up in script,
since the remote smtp does not do character echo.  I'll look into this some
more and see if this is the actual problem.

					Jim Bloom

From baker@ipto.ARPA  Wed Oct 23 22:56:50 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA04654; Wed, 23 Oct 85 22:56:50 PDT
Received: by ipto.ARPA (4.12/4.7)
	id AA01068; Thu, 24 Oct 85 01:56:54 edt
Date: Thu 24 Oct 85 01:56:42-EDT
From: Bob Baker <BAKER@IPTO.ARPA>
Subject: Re: 4.3 bugs (features?)
To: bloom
Cc: beta43_bugs, Baker@IPTO.ARPA
Message-Id: <VAX-MM(161)+TOPSLIB(113) 24-Oct-85 01:56:42.IPTO.ARPA>
In-Reply-To: Message from "bloom@monet.berkeley.edu (Jim Bloom)" of Wed, 23 OctBaker
Status: O

Jim,

Thanks for the quick answers.  I've fixed my history problem.

I think you're right about the telnet option codes.  The ucbarpa user telnet
is sending a DO SGA that's messing up the smtp server.  The same thing would
probably also happen with the ftp server (port 21).

The tops-20 user telnet doesn't have this problem because it doesn't
send option negotiations when opening connections to the ftp and smtp
ports.  On the other hand, it does send options on other telnet-type
ports, like the arpanet tacacs user database tool on port 65 at isic.
So it has some idea of which ports is should do options on, or maybe
which ones it shouldn't.  This would probably be a good improvement in
the 4.3 user telnet.  It's useful to telnet to smtp to vrfy user names
and expn address lists, and it looks bad to always have a spurious error
on the first command.

Bob
-------

From salkind@nyu-acf8.arpa  Thu Oct 24 04:13:47 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA05321; Thu, 24 Oct 85 04:13:47 PDT
Date: Thu, 24 Oct 85 07:15:26 edt
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8510241115.AA09954@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Thu, 24 Oct 85 07:15:26 edt
To: beta43_bugs
Subject: rcs changes
Status: O

I copied the changed rcs files to ucbmonet.  They are in ~salkind/rcs.
[I also included an extra file varargs.diff; this change is only necessary
for a Pyramid.]

I will let you know when the notes software is ready.  When it is,
I will put it on ucbmonet.

---

I noticed two more problems yesterday with the system:

	(minor) in /etc/inetd.conf, the uucp daemon wants to run as root,
	not as uucp.  uucpd does the setuid itself.

	the distributed version of /usr/lib/sendmail is not working well
	for me.  I had to go back to an older version.  I get errors
	of the form:
Oct 22 21:18:10 acf8 sendmail[1631]: AA01631: SYSERR: SMTP-MAIL: lost child: No children
Oct 21 04:32:45 acf8 sendmail[450]: AB00269: SYSERR: endmailer mail: wait: No children
	I mostly have trouble when I receive mail from internet hosts.
	I will investigate a bit more and let you know if I find anything.


Lou Salkind

From bloom  Thu Oct 24 08:10:33 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA05535; Thu, 24 Oct 85 08:10:33 PDT
Date: Thu, 24 Oct 85 08:10:33 PDT
From: bloom (Jim Bloom)
Message-Id: <8510241510.AA05535@monet.berkeley.edu>
To: salkind@nyu-acf8.arpa (Lou Salkind)
Cc: beta43_bugs
Subject: Re: rcs changes
In-Reply-To: Your message of Thu, 24 Oct 85 07:15:26 edt.
	     <8510241115.AA09954@nyu-acf8.arpa>
Status: O

I'll update the rcs sources.  Thanks for taking care of it.

There are some known problems with both versions of sendmail on
the beta tape.  Check with Miriam Amos here (miriam@monet) about
where the best updated copy of sendmail for you to take is.

					Jim

From schoch@orion.ARPA  Thu Oct 24 09:07:38 1985
Received: by monet.berkeley.edu (5.30/1.2)
	id AA05972; Thu, 24 Oct 85 09:07:38 PDT
Received: by orion.ARPA (4.24/1.2)
	id AA14807; Thu, 24 Oct 85 09:11:28 pdt
Date: Thu, 24 Oct 85 09:11:28 pdt
From: Steve Schoch <schoch@orion.ARPA>
Message-Id: <8510241611.AA14807@orion.ARPA>
To: beta43_bugs@monet
Subject: "make links" make too many links
Status: O

Index: 	/sys/bbnnet/udp_usrreq.c 4.3BSD

Description:
	udp_usrreq.o will be different depending on whether you have
	config'd for netinet or bbnnet.  However, "make links" will
	link udp_usrreq.o to ../GENERIC/udp_usrreq.o.  This means that
	if you have two systems, one with netinet config'd, and one
	with bbnnet config'd, the first make will compile udp_usrreq.c
	from the appropriate directory, and the second kernel will not
	recompile this file, but attempt to load it with the other
	files.
Repeat-By:
	Make two file in /sys/conf:  NETINET and BBNNET.  In NETINET have
	the line: "pseudo-device	inet".  In BBNNET have the
	line: "pseudo-device	bbnnet".
	% config NETINET
	Don't forget to run "make depend".
	% config BBNNET
	Don't forget to run "make depend".
	% cd ../NETINET
	% make depend
	% make links
	% cd ../BBNNET
	% make depend
	% make links
	% make vmunix
	<Works fine.>
	% cd ../NETINET
	% make vmunix
	<Comes up with "Undefined:">
Fix:
	Put the line "#ifdef BBNNET" at the start and the line
	"#endif BBNNET" at the end of /sys/bbnnet/udp_usrreq.c
	(It might be a good idea to do the equivalent to
	../netinet/udp_usrreq.c.)



From helge@ODIN.GOV.NOR.ARPA  Sat Oct 26 06:30:29 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA09497; Sat, 26 Oct 85 06:30:29 PDT
Received: by odin.ARPA (4.12/5.9)
	id AA19155; Sat, 26 Oct 85 14:31:36 -0200
Date: Sat, 26 Oct 85 14:31:36 -0200
From: helge@NTA-ODIN.ARPA (Helge Skrivervik)
Message-Id: <8510261231.AA19155@odin.ARPA>
To: beta43_bugs@ucbmonet
Cc: helge@ODIN.GOV.NOR.ARPA, paal@ODIN.GOV.NOR.ARPA
Status: O

1) sendmail: I created a compressed version of the sendmail.tar
file in ~ftp/pub. one meg is a little excessive thru satnet right now.
the new version is compiling now, but like many other programs,
it has problems with /usr/include/time.h.

2) systat: our compliments, this is an extremely useful tool --
It has bombed a couple of times (got no core dump, unfortunately),
always when using the :net mode, and seemingly related to
restart after having been suspended. Will look more into it later.

3) we are using X.25 thru a dmf32 and have been working on integrating
that into 4.3. One of the problems encountered has been finding out
how and where the interfaces get initialized; this has changed 
significantly since 4.2, and for now, we are kludgeing it. could
you point us to where we can find more details about this??

helge

From medin@orion.ARPA  Sat Oct 26 16:41:09 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA10984; Sat, 26 Oct 85 16:41:09 PDT
Received: by orion.ARPA (4.24/1.2)
	id AA22832; Sat, 26 Oct 85 16:41:37 pdt
Message-Id: <8510262341.AA22832@orion.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: 4.3 tn3270 doesnt work
Date: 26 Oct 85 16:41:34 PDT (Sat)
From: Milo S. Medin (NASA ARC Code EDN  Advanced Systems) <medin@orion.ARPA>
Status: O

Index: 	/usr/src/new/tn3270 4.3BSD

Description:

	When connecting to an IBM system on the internet and attempting
	to emulate a 3270 terminal with tn3270, the output is messed
	up.  That is, it seems to know the terminal's characteristics,
	because it sets inverse video and such properly, but doesnt
	put things in the right place on the screen.

Repeat-By:

	Make tn3270 attempt to telnet to a IBM machine that supports
	block mode emulation.  (e.g. tn3270 cmsa or tn3270 csc-oa.arpa)
	Watch the garbled output.


					Milo Medin
					NASA Ames Research Center


------- End of Forwarded Message

From bin@mimsy.umd.edu  Mon Oct 28 07:33:53 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06379; Mon, 28 Oct 85 07:33:53 PST
From: bin@mimsy.umd.edu
Received: by gyre.umd.edu (5.9/4.7)
	id AA07855; Mon, 28 Oct 85 10:34:24 EST
Date: Mon, 28 Oct 85 10:34:24 EST
Message-Id: <8510281534.AA07855@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: SYSMAP #defined to 25 rather than 27 in etc/pstat.c
Status: O

Index: /usr/src/etc/pstat.c 4.3Beta Fix

Description:
	SYSMAP should be 27, not 25.

Repeat-By:
	Examination.  Pstat on crash dumps will probably fail too.

Fix:
	what else?

Chris

From mcvax!dpk@seismo.CSS.GOV  Mon Oct 28 10:33:26 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00716; Mon, 28 Oct 85 10:33:26 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 28 Oct 85 13:18:14 EST
Received: by mcvax.UUCP; Mon, 28 Oct 85 18:11:59 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Mon, 28 Oct 85 18:11:45 +0100 (MET)
Message-Id: <8510281711.AA20780@mcvax.UUCP>
Date:     Mon, 28 Oct 85 18:14:25 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: mrose@uci-750a.arpa, mmdf2@csnet-relay.arpa, Bug-MH@uci.arpa
Subject:  4.3BSD/MH/MMDF Bugs
Status: O

I have spent the past weekend trying to bring up the about combination
on the 4.3Beta system.  It was not easy.

1.  The mode of /usr/src/new/mh/config/config.c was 444, making it impossible
	for the mhconfig program to create make a new version.

2.  The mode of /usr/src/new/mh/uip/version.c was 444, making it impossible
	for version.sh to make a new version.c.  I also believe that
	version.o is made in the wrong order (made after the linking instead
	of before it). 
    The uip makefile should probably have a line that makes $(CMDS) and $(MISC)
	dependent on version.o, instead of having "all" dependent on $(CMD),
	$(MISC), and version.o.

3. uip/post.c: (line 817), the code with server should be conditional on SENDMTS.

4. uip/post.c: When the "backup" option was added to post.c by Berkeley, they
	broke post for use with MMDFMTS.  This can be fixed by movine the
	backup option strings back in the initialization and renumbering
	the option numbers.

5. uip/post.c uip/rcvdist.c: For MMDFII, post should call mmdf_init().
	[--> See meta comment below <--]

====== post.c ======
2c2
< static char sccsid[] = "@(#)post.c	1.2 (Berkeley) 5/4/85";
---
> static char sccsid[] = "@(#)post.c	1.2 (Berkeley) 5/4/85;  %I%	(CWI)	%E%";
111a112,116
> #define BACKSW 26
>     "backup", 0,
> #define NBACKSW 27
>     "nobackup", 0,
> 
113c118
< #define	DLVRSW	26
---
> #define	DLVRSW	28
118c123
< #define	CLIESW	26
---
> #define	CLIESW	28
120c125
< #define	SERVSW	27
---
> #define	SERVSW	29
122c127
< #define	SNOOPSW	28
---
> #define	SNOOPSW	30
126,130d130
< #define BACKSW 29
<     "backup", 0,
< #define NBACKSW 30
<     "nobackup", 0,
< 
308a309,311
> #ifdef MMDFII
>     mmdf_init (invo_name);
> #endif MMDFII
316c319
< 	if (*cp == '-')
---
> 	if (*cp == '-') {
474a478
> 	}
816a821,823
> #ifndef SENDMTS
>     sprintf (from, "%s@%s", getusr (), LocalName ());
> #else
821c828
< 
---
> #endif SENDMTS
822a830
> 

====== rcvdist.c ======
2c2
< static char sccsid[] = "@(#)rcvdist.c	1.1 (Berkeley) 2/3/85";
---
> static char sccsid[] = "@(#)rcvdist.c	1.1 (Berkeley) 2/3/85;  %I%	(CWI)	%E%";
42a43,45
> #ifdef MMDFII
>     mmdf_init (invo_name);
> #endif MMDFII


6. READ-ME file incorrectly states that you install MH by saying "make inst-all".
	Berkeley apparently changed this to "make install" but failed to update
	the documentation.

7. conf/makefiles/uip:  Incorrectly installs "spost" if the mail system is
	MMDF.  Spost should not be used with MMDF.

1c1
< #	uip	1.2	85/09/04
---
> #	uip	1.2	85/09/04;  %W%	(CWI)	%E%
30,31c30,31
< MFMISC	=	rcvdist slocal
< IMFMISC	=	inst-rcvdist inst-slocal
---
> MFMISC	=	rcvdist slocal spost
> IMFMISC	=	inst-rcvdist inst-slocal inst-spost
69c69
< 		spost $(MFMISC) $(OPTMISC)
---
> 		$(MFMISC) $(OPTMISC)
78c78
< 		inst-rcvpack inst-rcvtty inst-spost $(IMFMISC) $(IOPTMISC)
---
> 		inst-rcvpack inst-rcvtty $(IMFMISC) $(IOPTMISC)
747a748
> @BEGIN: SENDMTS
763a765
> @END: SENDMTS


8. conf/config/config.c:  #ifdef BERK assumed that SENDMTS was also defined.
	This is not necessarily true.

2c2
< static char *sccsid="@(#)config.c	1.2 (Berkeley) 9/4/85";
---
> static char *sccsid="@(#)config.c	1.2 (Berkeley) 9/4/85;  %I%	(CWI)	%E%";
143a144
> #ifdef SENDMTS
149c150,152
< 
---
> #else SENDMTS
> char   *postproc = etcpath (post);
> #endif SENDMTS


Meta comment:
	Once the above fixes were installed I was able to compile the system
	and run compose/post, but post died with a bus error, core dump.
	This was because it was calling mmdf using the mmdf library routines,
	some of which assume that you have called mmdf_init, or at least
	mmdf_fdinit beforehand.  This was not being done properly.  This
	is currently a real mess.  MH should not use the MMDF libraries
	but should instead just be a mail reader/composer.  It should use
	the documented section 1/5/8 interface to the mail system... but
	its a bit late for that now.  Also, the used of separate libaries
	makes things difficult due to the junk in config/mts.c and mmdf/hosts.c
	really wanting to be in the same file.

9. conf/config/mts.c
	Added config variables locname and locdomain, and internal variables
	mhlocname, mhlocdomain so that mh programs can get the local host name
	without calling on MMDF routines (and thus mmdf_init).  These should
	be set to the values from the mmdftailor file.  Conditional on MMDFMTS.

1a2
> static char sccsid[]="%W%	(CWI)	%E%";
91a93,94
> char	*mhlocname = "lochost";
> char	*mhlocdomain = "locdomain";
133a137,138
>     "locname", &mhlocname,
>     "locdomain", &mhlocdomain,
343a349,352
> #ifndef	ALTOS
> #ifdef MMDFMTS
> extern char *mhlocname;
> extern char *mhlocdomain;
345c354,369
< #ifdef	ALTOS
---
> gethostname (name, len)
> register char   *name;
> register int	len;
> {
>     char    buffer[BUFSIZ];
> 
>     mts_init ("mh");
>     if (mhlocdomain && *mhlocdomain)
> 	strncpy (name, sprintf (buffer, "%s.%s", mhlocname, mhlocdomain), len);
>     else
> 	strncpy (name, mhlocname, len);
> 
>     return OK;
> }
> #endif MMDFMTS
> #else	ALTOS


10. conf/config/mtstailor
	Added condition lines to add locname and locdomain to the mtstailor
	file if MMDFMTS.

0a1,4
> @BEGIN: MMDFMTS
> locname:	locname
> locdomain:	locdomain
> @END: MMDFMTS

11.  mmdf/hosts.c: Moved its gethostname fake to config/mts.c along with
	the other gethostname fakes, since this is where it is called from
	anyways, and now it uses the mhlocname and mhlocdomain instead of
	the variables from MMDF.

1a2
> static char sccsid[]="%W%	(CWI)	%E%";
57c58
< 	mmdf_init (invo_name);
---
> 	mts_init (invo_name);
71,93d71
< 
< #ifndef	ALTOS
< extern char *locname;
< extern char *locdomain;
< 
< gethostname (name, len)
< register char   *name;
< register int	len;
< {
<     char    buffer[BUFSIZ];
< 
<     if (!inited) {
< 	mmdf_init (invo_name);
< 	inited = 1;
<     }
<     if (locdomain && *locdomain)
< 	strncpy (name, sprintf (buffer, "%s.%s", locname, locdomain), len);
<     else
< 	strncpy (name, locname, len);
< 
<     return OK;
< }
< #endif	not ALTOS

Not as easy as I would have hoped, but hopefully worth it in the long
run.  I will send another note if I encounter any other problems

From mcvax!dpk@seismo.CSS.GOV  Mon Oct 28 10:39:58 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00737; Mon, 28 Oct 85 10:39:58 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 28 Oct 85 13:28:05 EST
Received: by mcvax.UUCP; Mon, 28 Oct 85 18:47:03 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Mon, 28 Oct 85 18:46:53 +0100 (MET)
Message-Id: <8510281746.AA21210@mcvax.UUCP>
Date:     Mon, 28 Oct 85 18:26:49 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: jaap@seismo.CSS.GOV, piet@seismo.CSS.GOV, dpk@seismo.CSS.GOV,
        lamas@brl.arpa
Subject:  bugs in /usr/src/new
Status: O

Trash in /usr/src/new/mmdf.   File "xdepend" is worthless.

/usr/src/new/jove is a moldy oldy version of Jove.  I thought they had
arranged to get you an up to date copy with BLIT support and advanced
features.  I can ship you a copy from here, but best get in touch
with jove-hackers@brl.arpa.  We have a contact at Berkeley in Evans
hall, but I forget his name.  I will try to get a copy of the latest
version into my directory on Monet.

That's all for now!

Cheers,
	-Doug-

From schoch@orion.ARPA  Mon Oct 28 11:39:06 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA01126; Mon, 28 Oct 85 11:39:06 PST
Received: by orion.ARPA (4.24/1.2)
	id AA26845; Mon, 28 Oct 85 11:39:26 pst
Date: Mon, 28 Oct 85 11:39:26 pst
From: Steve Schoch <schoch@orion.ARPA>
Message-Id: <8510281939.AA26845@orion.ARPA>
To: beta43_bugs@monet
Subject: a 11/730 will not boot if /vmunix is on a bad (ecc) block
Status: O

Index:	/sys/stand/idc.c 4.3BSD

Description:
	When booting off rb, as most 730's do, if the idc driver finds
	a bad sector that can be fixed with ecc, it will skip that sector
	altogether, which will cause /vmunix not to boot.
Repeat-By:
	Keep copying /vmunix until you get a "soft ecc" message on the
	console when you read that file.  Then try to boot that file.
Fix:
	Here is the new driver (/sys/stand/idc.c) with ecc code.  The
	compiled boot program is still small enough to be loaded.
/*
 * Copyright (c) 1982 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */

/*
 * IDC (RB730)
 */
#include "../machine/pte.h"

#include "../h/param.h"
#include "../h/inode.h"
#include "../h/fs.h"

#include "../h/vmmac.h"

#include "../vaxuba/idcreg.h"
#include "../vaxuba/ubareg.h"

#include "saio.h"
#include "savax.h"

u_short	idcstd[] = { 0175606 };
short	rb02_off[] = { 0, 400, 0, -1, -1, -1, -1, -1 };
short	rb80_off[] = { 0, 37, 0, -1, -1, -1, 115, 305 };

int idc_type[4];

idcopen(io)
	register struct iob *io;
{
	register struct idcdevice *idcaddr;
	register int i;

	idcaddr = (struct idcdevice *)((caddr_t)ubauba(io->i_unit) + 0x200);
	if (io->i_boff < 0 || io->i_boff > 7)
		_stop("idc bad unit");
	idcaddr->idcmpr = IDCGS_GETSTAT;
	idcaddr->idccsr = IDC_GETSTAT|(io->i_unit<<8);
	idcwait(idcaddr);
	i = idcaddr->idcmpr;
	idcaddr->idccsr = IDC_CRDY|(1<<(io->i_unit+16));
	idcwait(idcaddr);
	idcaddr->idccsr = (io->i_unit<<8)|IDC_RHDR;
	idcwait(idcaddr);
	if (idcaddr->idccsr & IDC_ERR) {
		printf("idc error: idccsr %x\n", idcaddr->idccsr);
		_stop("idc fatal error");
	}
	i = idcaddr->idcmpr;
	i = idcaddr->idcmpr;
	if (idcaddr->idccsr & IDC_R80) {
		idc_type[io->i_unit] = 1;
		io->i_boff = rb80_off[io->i_boff] * NRB80SECT * NRB80TRK;
	} else {
		idc_type[io->i_unit] = 0;
		io->i_boff = rb02_off[io->i_boff] * NRB02SECT/2 * NRB02TRK;
	}
	if (io->i_boff < 0)
		_stop("idc%d: bad unit type", io->i_unit);
}

idcstrategy(io, func)
	register struct iob *io;
{
	register struct idcdevice *idcaddr;
	int com;
	daddr_t bn;
	short dn, cn, sn, tn;
	short ccleft, thiscc = 0;
	int ubinfo, errcnt = 0;
	int csr;

	idcaddr = (struct idcdevice *)((caddr_t)ubauba(io->i_unit) + 0x200);
	ubinfo = ubasetup(io, 1);
	bn = io->i_bn;
	ccleft = io->i_cc;
retry:
	dn = io->i_unit;
	if (idc_type[dn]) {
		cn = bn/(NRB80SECT*NRB80TRK);
		sn = bn%NRB80SECT;
		tn = (bn / NRB80SECT) % NRB80TRK;
		thiscc = (NRB80SECT - sn) * 512;
	} else {
		cn = 2*bn/(NRB02SECT*NRB02TRK);
		sn = (2*bn)%NRB02SECT;
		tn = (2*bn / NRB02SECT) % NRB02TRK;
		thiscc = (NRB02SECT - sn) * 256;
	}
	thiscc = MIN(thiscc, ccleft);
	idcaddr->idccsr = IDC_CRDY|IDC_SEEK|(dn<<8)|(1<<(dn+16));
	idcaddr->idcdar = (cn<<16)|(tn<<8)|sn;
	idcaddr->idccsr = IDC_SEEK|(dn<<8);
	idcwait(idcaddr);
	idcaddr->idccsr &= ~IDC_ATTN;
	com = dn<<8;
	if (func == READ)
		com |= IDC_READ;
	else
		com |= IDC_WRITE;
	idcaddr->idccsr = IDC_CRDY|com;
	idcaddr->idcbar = ubinfo&0x3ffff;
	idcaddr->idcbcr = -thiscc;
	idcaddr->idcdar = (cn<<16)|(tn<<8)|sn;
	idcaddr->idccsr = com;
	idcwait(idcaddr);
	idcaddr->idccsr = IDC_CRDY|(dn<<8);
	if ((csr = idcaddr->idccsr) & IDC_ERR) {
		switch (csr & IDC_ECS) {
			int cc;
		    case IDC_ECS_SOFT:
			thiscc = idcecc(idcaddr, io, thiscc);
			printf("idc%d soft ecc (cyl,trk,sec)=(%d,%d,%d)\n",
				dn, cn, tn, sn);
			break;

		    case IDC_ECS_HARD:
		    default:
			printf("idc%d error: (cyl,trk,sec)=(%d,%d,%d) csr=%b\n",
			    dn, cn, tn, sn, csr, IDCCSR_BITS);
			if (errcnt == 10) {
				printf("idc: unrecovered error\n");
				ubafree(io, ubinfo);
				return (-1);
			}
			errcnt++;
			goto retry;	/* try again */
		}
	}
	ccleft -= thiscc;
	if (errcnt) {
		printf("idc: recovered by retry\n");
		errcnt = 0;
	}
	if (ccleft) {
		bn += thiscc/NBPG;
		ubinfo += thiscc;
		goto retry;
	}
	ubafree(io, ubinfo);
	return (io->i_cc);
}

idcwait(idcaddr)
	register struct idcdevice *idcaddr;
{
	register int i;

	while ((idcaddr->idccsr & (IDC_CRDY|IDC_DRDY)) != (IDC_CRDY|IDC_DRDY))
		for (i = 10; i; i--)
			;
}

/*ARGSUSED*/
idcioctl(io, cmd, arg)
	struct iob *io;
	int cmd;
	caddr_t arg;
{

	return (ECMD);
}

/*
 * returns: How many characters actually read;
 */
idcecc(idc, io, cc)
	register struct idcdevice *idc;
	struct iob *io;
	int cc;
{
	register int i;
	int bit, byte, mask;
	caddr_t addr;

	mask = idc->idceccpat;
	i = idc->idceccpos - 1;		/* -1 makes 0 origin */
	bit = i&07;
	i = (i&~07)>>3;
	/* -idc->idcbcr = how many characters read (including ecc sector) */
	byte = i + idc->idcbcr + cc - NRB80SECT;
	while (i < 512 && bit > -11) {
		addr = io->i_ma + byte;
		*(char *)addr ^= (mask<<bit);
		byte++;
		i++;
		bit -= 8;
	}
	return cc + idc->idcbcr;
}

From mrose@dewey.udel.EDU  Mon Oct 28 18:47:29 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA04040; Mon, 28 Oct 85 18:47:29 PST
Received: from localhost by Dewey.UDEL.EDU id a004601; 10 Mar 86 11:00 EST
To: Doug Kingston <mcvax!dpk@seismo.css.GOV>
Cc: beta43_bugs@monet.berkeley.edu, mmdf2@csnet-relay.ARPA, Bug-MH@uci.EDU
Reply-To: Bug-MH@uci.EDU
Subject: Re: 4.3BSD/MH/MMDF Bugs
In-Reply-To: Your message of Mon, 28 Oct 85 18:14:25 MET.
             <8510281711.AA20780@mcvax.UUCP>
Date: 10 Mar 86 10:59:50 EST (Mon)
Message-Id: <4057.510854390@dewey>
From: Marshall Rose <mrose@dewey.udel.EDU>
Status: O

Doug - you should have checked with me before modifying the code.  Sometime
after the Berkeley people took mh.5 from me, they sent back their changes.
I incorporated most, had problems with one or two.  I tried to raise the issue
(three times) but got no reply.

I will be sending a version of mh.6, once it leaves beta, to ucb.  If they
can include it in 4.3, fine!  If not, they should use your modifications.  Just
scanning through your message, it looks like I got about 95% of the stuff you
described already.  [ attn: UCB -- you can do whatever you want with MH, it's
public domain, but you might find it profitable to contact Bug-MH before doing
a port.  the choice is yours. ]

Re: garding the mmdf tailor file.  MH needs the information.  It should use it
from MMDF if it can instead of keeping a duplicate of the information (which
can get out of sync) elsewhere.  

/mtr

From entropy!hubert@uw-beaver.arpa  Mon Oct 28 19:46:09 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA04428; Mon, 28 Oct 85 19:46:09 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA17783; Mon, 28 Oct 85 19:51:01 PST
Return-Path: <entropy!hubert@uw-beaver.arpa>
Message-Id: <8510290351.AA17783@uw-beaver.arpa>
Received: by entropy.UUCP (5.9/4.7)
	id AA23449; Mon, 28 Oct 85 19:03:41 PST
Date: Mon, 28 Oct 85 19:03:41 PST
From: entropy!hubert@uw-beaver.arpa (Steve Hubert)
To: uw-beaver!beta43_bugs@monet.berkeley.edu
Subject: LOG_AUTH
Status: O

I am converting from the alpha tape I had to the beta tape you
just sent.  I am having some trouble.  In particular, 

  where is LOG_AUTH in su.c, login.c, etc. defined?

It doesn't seem to be in syslog.h.

Thanks
Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver

From bloom  Tue Oct 29 10:04:32 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00419; Tue, 29 Oct 85 10:04:32 PST
Date: Tue, 29 Oct 85 10:04:32 PST
From: bloom (Jim Bloom)
Message-Id: <8510291804.AA00419@monet.berkeley.edu>
To: entropy!hubert@uw-beaver.arpa (Steve Hubert)
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: LOG_AUTH
In-Reply-To: Your message of Mon, 28 Oct 85 19:03:41 PST.
	     <8510290351.AA17783@uw-beaver.arpa>
Status: O

It is in /sys/h/syslog.h.  The way it is set up is:

/usr/include/syslog.h symlink to sys/syslog.h
/usr/include/sys symlink to /sys/h

				Jim

From salkind@nyu-acf8.arpa  Tue Oct 29 13:11:24 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA01833; Tue, 29 Oct 85 13:11:24 PST
Date: Tue, 29 Oct 85 15:55:06 est
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8510292055.AA07924@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Tue, 29 Oct 85 15:55:06 est
To: beta43_bugs@monet.berkeley.edu
Subject: problems with trailers
Status: O

I am having trouble with trailers on our local ethernet.  We have deuna
interfaces.

When I enable trailers, after a while I start generating loads of bad
tcp/ip packets.  This implies to me that there is either a problem with
the page swapping code on output in if_uba.c or with the deuna's calling
of those routines.  Has anybody else come across this yet?

Somebody else reported a problem today with lpd getting hung talking to
a remote (4.2) machine.  I couldn't duplicate the problem when I came in,
so I will let you know if it happens again.

Other than these two problems (and the flakey sendmail problems I described
earlier), I have had no major troubles with the 4.3bsd.  I'll be bringing
up the XNS code later this week, and maybe then I'll have more to report.

On another front, Ray Essick has given me a pointer to his latest
notes code, so sometime in the next day or so I will put the code on
monet.  I will tell you when it is in place.

	Lou

From entropy!root@uw-beaver.arpa  Tue Oct 29 16:56:45 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02666; Tue, 29 Oct 85 16:56:45 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA28019; Tue, 29 Oct 85 16:52:28 PST
Return-Path: <entropy!root>
Message-Id: <8510300052.AA28019@uw-beaver.arpa>
Received: by entropy.UUCP (5.5/4.7)
	id AA08490; Tue, 29 Oct 85 16:31:07 PST
Date: Tue, 29 Oct 85 16:31:07 PST
From: entropy!root@uw-beaver.arpa (Mr. Entropy)
To: uw-beaver!beta43_bugs@monet.berkeley.edu
Subject: 4.3 Bug Report
Cc: entropy!uw-june!bob, lundberg@uw-beaver.arpa, uw-beaver!washington!burr
Status: O

The program /usr/src/usr.bin/uucp/acucntrl.c has at least one bug.  It
is sort of complicated.  The version I got on the beta tape is
sccsid=5.4.  That version has two problems that I know of.  The first
is that it is possible for more than one process to try to write to
/etc/ttys at once and mess things up.  This problem is fixed by the
later version that Rick Adams gave me.  That is his Rcsid=1.9 version.
The second problem is that the second field in /etc/ttys is not parsed
properly if it contains spaces embedded inside quotes (") which is
legal in that field.  Both versions 5.4 and 1.9 have that problem and
both are fixed by the following context diff.

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver


*** acucntrl.c.5.4	Tue Oct 29 15:46:39 1985
--- acucntrl.c.5.4.fix	Tue Oct 29 15:42:36 1985
***************
*** 461,470 ****
  	}
  	/* format is now */
  	/* ttyd0 std.100 dialup on secure # comment */
  	cp = lbuf;
  	for (i=0;*cp && i<3;i++) {
! 		while (*cp && *cp != ' ' && *cp != '\t')
  			cp++;
  		while (*cp && (*cp == ' ' || *cp == '\t'))
  			cp++;
  	}
--- 461,479 ----
  	}
  	/* format is now */
  	/* ttyd0 std.100 dialup on secure # comment */
+ 	/* except, 2nd item may have embedded spaces inside quotes, Hubert */
  	cp = lbuf;
  	for (i=0;*cp && i<3;i++) {
! 		if (*cp == '"') {
  			cp++;
+ 			while (*cp && *cp != '"')
+ 				cp++;
+ 			if (*cp != '\0')
+ 				cp++;
+ 		}else {
+ 			while (*cp && *cp != ' ' && *cp != '\t')
+ 				cp++;
+ 		}
  		while (*cp && (*cp == ' ' || *cp == '\t'))
  			cp++;
  	}

From salkind@nyu-robeson.arpa  Tue Oct 29 17:12:38 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02770; Tue, 29 Oct 85 17:12:38 PST
Date: Tue, 29 Oct 85 20:14:09 est
From: salkind@nyu-robeson.arpa (Lou Salkind)
Message-Id: <8510300114.AA08996@nyu-robeson.arpa>
Received: by nyu-robeson.arpa; Tue, 29 Oct 85 20:14:09 est
To: beta43_bugs@monet.berkeley.edu
Subject: notes source now on monet
Status: O

The current notes source is now in ~salkind/notes.  You probably
can just replace the old /usr/src/new/notes directory en masse.

	Lou

From mrose%NRTC.#USCnet@usc-ecl.arpa  Wed Oct 30 03:09:08 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA04685; Wed, 30 Oct 85 03:09:08 PST
Received: by ucbvax.berkeley.edu (5.31/1.2)
	id AA21772; Tue, 29 Oct 85 23:16:42 PST
Received: From nrtc-gremlin by NRTC id a028747 ;29 Oct 85 17:03 PST
To: Doug Kingston <mcvax!dpk%seismo@uci.edu>
Cc: beta43_bugs%monet@ucbvax.berkeley.edu, mmdf2@csnet-relay.arpa,
        Bug-MH@uci.edu
Reply-To: Bug-MH@UCI.EDU
Subject: Re: 4.3BSD/MH/MMDF Bugs
In-Reply-To: Your message of Mon, 28 Oct 85 18:14:25 MET.
Date: 29 Oct 85 17:03:20 PST (Tue)
Message-Id: <286.499482200@nrtc>
From: Marshall Rose <mrose%NRTC@usc-ecl.arpa>
Via:  Nrtc; 29 Oct 85 20:45:22
Status: O

    Now that I'm back on my development machine, I can answer your
    questions directly:
-----
Re: 1&2; modes of config.c and version.c

    Don't look at me, I didn't change the modes.  However, as suggested
    by Dave Yost, the mhconfig in mh.6 removes the files its going to
    update before it writes them (this is for his CTM).

    The update of version.c is a development tool for me, in the
    distributed version, it doesn't update (also, there's a CTM hack
    for version.c as well).
-----
Re: 3&4&5; post switches, -backup

    Actually, when Berkeley did the port they broke more things than
    that (try out aliasing some time!)  I took back all of their
    changes, was *extremely* happy with the speed improvements, and
    fixed the stuff they, uh, botched.  This all got done several months
    ago.  I didn't incorporate -backup or their "spost", because it
    breaks some major MH features.  I tried discussing it with 'em, but
    never got a reply.  So...
-----
Re: 5; see note later on
-----
Re: 6; READ-ME and make inst-all

    Well, either one works.  inst-all doesn't clean up, install does.
    READ-ME has more to say, in any event.
-----
Re: 7; installing spost

    Got fixed a long time ago, ancient history (although it is
    documented in the bug sections of your READ-ME).  It was rather
    irritating though.
-----
Re: 8; BERK assumes SENDMTS in conf/config/config.c

    Not any more, anyway like I mentioned above, spost never got
    included.
-----
Re: meta comment

    Doug - please send me via EMAIL the roff sources for man 1/3/8; if
    I'm doing something wrong in the interface to MMDF-II, I'd like to
    know about it.  Thanks!

    More on meta comment in next message.

-----
Re: 9&10&11; conf/config/mts.c and loc{name,domain}

    There wasn't locname in your version?  This is getting complicated.
    Kindly send me the following files intact and I'll see what's going
    on:

	conf/config/mts.c
	conf/config/mtstailor
	mmdf/hosts.c
-----
    I'll integrate your changes into the beta and send a tape to you.

/mtr


From chris@gyre.umd.edu  Wed Oct 30 15:50:28 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA08432; Wed, 30 Oct 85 15:50:28 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA16812; Wed, 30 Oct 85 18:50:45 EST
Date: Wed, 30 Oct 85 18:50:45 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8510302350.AA16812@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: kernel traps in hpstrategy if eagle breaks
Status: RO

Index: /sys/vaxmba/hp.c 4.3Beta

Description:
	If the hardware gets wedged just right some code in
	hpstrategy references some really ridiculous address.
	In particular one of our eagles was reporting 20
	tracks, 32 (instead of 48) sectors.

Repeat-By:
	Have flaky hardware?

I see nothing that should break if hpmaptype fails, but something
did; just thought I'd let you know.  But having the kernel handle
broken hardware is not something I consider terribly important.

From mcvax!dpk@seismo.CSS.GOV  Wed Oct 30 17:05:16 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA09225; Wed, 30 Oct 85 17:05:16 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Wed, 30 Oct 85 18:24:30 EST
Received: by mcvax.UUCP; Wed, 30 Oct 85 18:33:16 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Wed, 30 Oct 85 18:33:07 +0100 (MET)
Message-Id: <8510301733.AA15847@mcvax.UUCP>
Date:     Wed, 30 Oct 85 18:30:27 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Subject:  Still a glitch in sys/conf/newvers.sh
Status: O

I still had problems with it because my "SHELL" is /usr/local/...
which has a built in echo command that interpreted the \n.  Please
change the references to "echo" in newvers.sh to "/bin/echo".  This
will solve the problem.

	-Doug-

From JLarson.pa@Xerox.ARPA  Wed Oct 30 22:37:28 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA11682; Wed, 30 Oct 85 22:37:28 PST
Received: from Cabernet.ms by ArpaGateway.ms ; 30 OCT 85 22:37:19 PST
Date: 30 Oct 85 22:37:08 PST (Wednesday)
From: JLarson.pa@Xerox.ARPA
Subject: Bug fix: Loss of RFNMs on ARPAnet hosts
To: beta43_bugs@monet.berkeley.edu
Cc: JLarson.pa@Xerox.ARPA, BJackson.pa@Xerox.ARPA
Message-Id: <851030-223719-2132@Xerox>
Status: O

Could someone please install this bug fix in 4.3 ?  Weve seen this
problem too often on parcvax, and from a cursory glance at the Beta 4.3
source it hasn't been fixed yet.

Thanks,

John Larson
Xerox PARC

----------------------------------------------------------------
From: clyde@ut-ngp.UTEXAS (Clyde W. Hoover)
Subject: Loss of RFNMs on ARPAnet hosts (the REAL FIX)
Date: 29 Oct 85 18:22:41 GMT
To:       unix-wizards@brl-tgr.arpa

Index:	/sys/vaxif/if_acc.c 4.2BSD

APOLOGIA:
	The previous fix posted was **** ALL WRONG. ****

	My colleague who tracked down this bug did not (by his own admission)
	explain the nature of the bug sufficently, hence the wrong
	'fix'.  This person, who will remain nameless, has suffered
	and will continue to suffer the pains of the damned
	because *I* ended up looking stupid on USENET. (I know, USENET
	is full of stupid-looking people, but I was saving that for
	net.singles).
	Thanks to Art Berggreen <Art@ACC.ARPA> for his analysis of the
	problem (included below) and to my nameless colleagues for spending
	hours pouring over logic diagrams to figure out just how this bloody
	box works.

NOTE:	This is **not applicable** unless the modifications from Chris
Kent
	(cak@purdue.ARPA, posted 21 March 1984) have been made to
	/sys/netinet/tcp_output.c.  These modifications advertise a
	maximum TCP segment size that is tuned per network interface.

Description:
	Connections to certain hosts on the ARPAnet will start failing with
	"out of buffer space" messages.  Doing a 'netstat -h' shows
	that the host (or the gateway to it) has a RFNM count of 8.

	The RFNM count never drops below 8 and so the network path is
	unusable until the system is rebooted.

	The problem lies in the LH/DH-11 IMP interface.
	Sometimes, most likely always, it will not set the <END OF MESSAGE>
	flag in the control & status register if the input buffer is filled  
	at the same time that <LAST BIT SIGNAL> from the 
	IMP comes up.

	This causes the LH/DH driver to append the next 
	incoming message from the IMP to the the previous message.
	This process (appending of messages) will continue until
	a message SHORTER then the input buffer size is sent --
	a RFNM response does nicely.

	This results in the LOSS of the succeeding messages (e.g. RFNMs)
	since the 1822 protocol handling code expects to get only
	<ONE> message from the LH/DH at a time.

	This problem happens when the IMP MTU is advertised as the TCP
	maximum segment size (as is done by the TCP changes from cak@purdue).
	This allows an incoming message to be 1006 + 12 bytes long, which
	equals the size of the 1018 byte input buffer in
	the IMP (I believe) and so exercises the bug in the LH/DH.

	The described problem would appear to happen ONLY if a message
	from the IMP is one word longer than the buffer being read into.
	When the buffer fills, leaving the data that contains the Last
	Bit in the LH/DH data buffer, the Receive DMA terminates and
	the EOM flag is NOT ON (because the user has not yet DMA'd 
	the End-of-Message into memory).  What should happen when the
	Receive DMA is restarted, is that the remaining word is read into
memory
	and the DMA should terminate with the EOM flag ON.  If when the DMA is
	restarted, the internal EOM status is lost, the following message would
	be concatenated with the end of previous message.

	A better solution than reducing IMPMTU (which doesn't really
	fix the problem) would be to use I/O buffers that are slightly
	larger than IMPMTU (and of course setting the Receive Byte Counter
	to be larger than any expected message). 

Fix:
	/sys/vaxif/if_acc.c:


163c164
< 	     (int)btoc(IMPMTU)) == 0) {
---
> 	     (int)btoc(IMPMTU+2)) == 0) {
190c191
< 	addr->iwc = -(IMPMTU >> 1);
---
> 	addr->iwc = -((IMPMTU + 2) >> 1);
328,330c329,331
< 	len = IMPMTU + (addr->iwc << 1);
< 	if (len < 0 || len > IMPMTU) {
< 		printf("acc%d: bad length=%d\n", len);
---
> 	len = IMPMTU+2 + (addr->iwc << 1);
> 	if (len < 0 || len > IMPMTU+2) {
> 		printf("acc%d: bad length=%d\n", unit, len);
362c363
< 	addr->iwc = -(IMPMTU >> 1);
---
> 	addr->iwc = -((IMPMTU + 2)>> 1);

This fix really does the job properly.
-- 
Shouter-To-Dead-Parrots @ Univ. of Texas Computation Center; Austin,
Texas  

"All life is a blur of Republicans and meat." -Zippy the Pinhead

	clyde@ngp.UTEXAS.EDU, clyde@sally.UTEXAS.EDU
	...!ihnp4!ut-ngp!clyde, ...!allegra!ut-ngp!clyde


----------------------------------------------------------------


From chris@gyre.umd.edu  Fri Nov  1 22:34:54 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00381; Fri, 1 Nov 85 22:34:54 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03474; Thu, 31 Oct 85 22:27:52 EST
Date: Thu, 31 Oct 85 22:27:52 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511010327.AA03474@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: `co' endless loops due to EOF condition
Status: O

Index: /usr/src/new/rcs/src/rcsedit.c 4.3Beta Fix

Description:
	In certain situations, co will invoke rcsedit with a file
	pointer set at EOF, while co assumes that the pointer is
	set at the beginning of the file.  Due to a missing EOF-
	test, co then endless loops trying to read the first line
	of that file.

Repeat-By:
	I am not certain how to cause the problem.  I can send
	you an RCS file that invokes it if you wish.

Fix:
	swapeditfiles must always rewind, even if it thinks the
	file as it the beginning.  I have also included a test for
	the EOF condition, on the assumption that it is better that
	co quit immediately with an error than to make the poor
	user kill it without knowing what went wrong.

	Diffs below...

Chris

RCS file: RCS/rcsedit.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1003445	Thu Oct 31 22:21:28 1985
--- /tmp/,RCSt2003445	Thu Oct 31 22:21:31 1985
***************
*** 3,7 ****
   */
   static char rcsid[]=
!  "$Header: rcsedit.c,v 1.1 85/10/31 22:14:42 bin Exp $ Purdue CS";
  /**********************************************************************************
   *                       edits the input file according to a
--- 3,7 ----
   */
   static char rcsid[]=
!  "$Header: rcsedit.c,v 1.2 85/10/31 22:15:08 bin Exp $ Purdue CS";
  /**********************************************************************************
   *                       edits the input file according to a
***************
*** 23,28 ****
  
  /* $Log:	rcsedit.c,v $
!  * Revision 1.1  85/10/31  22:14:42  bin
!  * Initial revision
   * 
   * Revision 3.7  83/05/12  13:04:39  wft
--- 23,28 ----
  
  /* $Log:	rcsedit.c,v $
!  * Revision 1.2  85/10/31  22:15:08  bin
!  * Removed code that assumed that rewind at editline==1 was unnecessary.
   * 
   * Revision 3.7  83/05/12  13:04:39  wft
***************
*** 102,107 ****
                  faterror("write failed on %s -- file system full?",resultfile);
          fedit=fcopy;
!         if (editline!=1) rewind(fedit);
!         /* no need to rewind at beginning of file */
          editline = 1; linecorr=0;
          tmpptr=editfile; editfile=resultfile; resultfile=tmpptr;
--- 102,106 ----
                  faterror("write failed on %s -- file system full?",resultfile);
          fedit=fcopy;
! 	rewind(fedit);
          editline = 1; linecorr=0;
          tmpptr=editfile; editfile=resultfile; resultfile=tmpptr;
***************
*** 257,261 ****
                          for (i=length;i>0;i--) {
                                  /*skip next line*/
!                                 while (getc(fedit)!='\n');
                                  editline++;
                          }
--- 256,262 ----
                          for (i=length;i>0;i--) {
                                  /*skip next line*/
!                                 while ((c=getc(fedit))!='\n')
! 					if (c==EOF)
! 						faterror("EOF during edit");
                                  editline++;
                          }

From helge@nta-vax.arpa  Sun Nov  3 03:19:56 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06811; Sun, 3 Nov 85 03:19:56 PST
Date: Sun, 3 Nov 85 12:20:49 -0100
From: helge@nta-vax.ARPA (Helge Skrivervik)
Posted-Date: Sun, 3 Nov 85 12:20:49 -0100
Message-Id: <8511031120.AA04831@nta-vax.ARPA>
Received: by nta-vax.ARPA (5.31/3.21)
	id AA04831; Sun, 3 Nov 85 12:20:49 -0100
To: beta43_bugs@monet
Subject: games
Status: O

/usr/games/robots
bombs with "@Bus error".

helge

From sun!opus!gingell@ucb-vax.berkeley.edu  Mon Nov  4 15:57:35 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02901; Mon, 4 Nov 85 15:57:35 PST
Received: by ucb-vax.berkeley.edu (5.31/1.2)
	id AA14402; Mon, 4 Nov 85 09:27:27 PST
Received: from snail.sun.uucp by sun.uucp (3.0DEV4/SMI-2.0)
	id AA03801; Mon, 4 Nov 85 08:45:28 PST
Received: from opus.sun.uucp by snail.sun.uucp (3.0ALPHA/SMI-3.0DEV4)
	id AA04661; Mon, 4 Nov 85 08:47:06 PST
Received: by opus.sun.uucp (3.0/SMI-3.0DEV3)
	id AA03869; Mon, 4 Nov 85 08:48:02 PST
Date: Mon, 4 Nov 85 08:48:02 PST
From: sun!opus!gingell@ucb-vax.berkeley.edu (Rob Gingell)
Message-Id: <8511041648.AA03869@opus.sun.uucp>
To: ucbvax!monet.beta43_bugs
Subject: Handling of data connection abort in ftpd
Status: O

Subject: 	in.ftpd aborts entire file transfer session if a
		data connection fails.
Index:		Network
Category:  	File Transfer Protocol daemon
Severity:  	4
Release:  	4.3beta/ftpd.c 5.1

Description:
	During a 'RETR' operation, an abort of the data connection can
	cause the entire session to fail unnecessarily.  Such aborts could
	be a result of file creation or file space problems on the client's
	side and should terminate only the transfer of that single file.

Repeat-By:
	Attempt the retrieval of a long (>2048 bytes) remote file into a
	local file which is not writable.  The length restriction is to
	ensure that the daemon doesn't buffer an entire file and close
	the connection before the client aborts.  E.g.

	1. Create the file 'xyz', mode 444.
	2. Connect to a system, attempt the 'get' of a file of suitable
	   length into 'xyz', with 'get <file> xyz'.
	3. Transfer will fail, attempts to issue other commands from client
	   ftp will yield the error 'Not connected'.

Fix:
	File(s): /usr/src/etc/ftpd/ftpd.c

	When the daemon attempts to deliver data to the client, and the
	client aborts its end of the connection, the daemon will receive
	a SIGPIPE signal.  The manner in which SIGPIPE is currently handled
	does not permit the daemon to discriminate between data and control
	connections and thus it simply aborts the entire session.

	Fix: when sending data back to client ('send_data' as called from
	'retrieve' in ftpd.c) establish a local disposition for SIGPIPE.
	If transmission errors occur simply abort the data connection and
	return a failure reply on the control connection.  Should the
	control connection also fail, *then* the session will be aborted.

	The fix is implemented by a new function 'send_data', which jackets
	the call to the old 'send_data' (now renamed 'send_data_body') and
	which specifies that SIGPIPE is to be ignored during the execution
	of 'send_data_body'.  This will cause the abort to be returned as
	an I/O error to the output calls in 'send_data_body'.

	Part of the fix is also to surround the 'fclose' call in the 
	function 'retrieve' with calls to 'signal' to ignore and then
	restore the handling of SIGPIPE.  This is necessary to prevent
	'fclose' from causing a SIGPIPE when trying to flush buffers.

	The following "context diff" shows the changes to effect these
	fixes.

*** arch/4.3beta/usr/src/etc/ftpd/ftpd.c	Thu Jun  6 11:09:45 1985
--- ftpd.c	Thu Oct 31 07:45:12 1985
***************
*** 260,265
  	FILE *fin, *dout;
  	struct stat st;
  	int (*closefunc)();
  
  	if (cmd == 0) {
  #ifdef notdef

--- 221,227 -----
  	FILE *fin, *dout;
  	struct stat st;
  	int (*closefunc)();
+ 	int (*oldpipe)();	/* Hold value of SIGPIPE during close */
  
  	if (cmd == 0) {
  #ifdef notdef
***************
*** 293,298
  		reply(550, "%s: %s.", name, sys_errlist[errno]);
  	else
  		reply(226, "Transfer complete.");
  	fclose(dout), data = -1;
  done:
  	(*closefunc)(fin);

--- 255,266 -----
  		reply(550, "%s: %s.", name, sys_errlist[errno]);
  	else
  		reply(226, "Transfer complete.");
+ 	/*
+ 	 * If the transfer failed because the data connection got aborted,
+ 	 * then the fclose may cause a SIGPIPE trying to flush the buffers
+ 	 * and abort the whole session.  Ignore SIGPIPEs during the fclose.
+ 	 */
+ 	oldpipe = signal(SIGPIPE, SIG_IGN);
  	fclose(dout), data = -1;
  	signal(SIGPIPE, oldpipe);
  done:
***************
*** 294,299
  	else
  		reply(226, "Transfer complete.");
  	fclose(dout), data = -1;
  done:
  	(*closefunc)(fin);
  }

--- 262,268 -----
  	 */
  	oldpipe = signal(SIGPIPE, SIG_IGN);
  	fclose(dout), data = -1;
+ 	signal(SIGPIPE, oldpipe);
  done:
  	(*closefunc)(fin);
  }
***************
*** 413,418
  }
  
  /*
   * Tranfer the contents of "instr" to
   * "outstr" peer using the appropriate
   * encapulation of the date subject

--- 382,407 -----
  }
  
  /*
+  * Envelope for 'send_data_body'.  Allow data connections to fail without
+  * terminating the daemon, but SIGPIPE is set to be ignored so that if
+  * one occurs on the data channel we'll just catch the error return on
+  * the write rather than causing the whole session to abort.
+  */
+ 
+ send_data(instr, outstr)
+ 	FILE *instr;		/* Data being sent */
+ 	FILE *outstr;		/* Connection being transmitted upon */
+ {
+ 	int value;		/* Return value from send_data_body */
+ 	int (*oldpipe)();	/* Old handler for SIGPIPE */
+ 
+ 	oldpipe = signal(SIGPIPE, SIG_IGN);
+ 	value = send_data_body(instr, outstr);
+ 	signal(SIGPIPE, oldpipe);
+ 	return (value);	
+ }
+ 
+ /*
   * Tranfer the contents of "instr" to
   * "outstr" peer using the appropriate
   * encapulation of the date subject
***************
*** 420,426
   *
   * NB: Form isn't handled.
   */
! send_data(instr, outstr)
  	FILE *instr, *outstr;
  {
  	register int c;

--- 409,415 -----
   *
   * NB: Form isn't handled.
   */
! send_data_body(instr, outstr)
  	FILE *instr, *outstr;
  {
  	register int c;

From sun!opus!gingell@ucb-vax.berkeley.edu  Mon Nov  4 15:57:55 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02910; Mon, 4 Nov 85 15:57:55 PST
Received: by ucb-vax.berkeley.edu (5.31/1.2)
	id AA14305; Mon, 4 Nov 85 09:21:02 PST
Received: from snail.sun.uucp by sun.uucp (3.0DEV4/SMI-2.0)
	id AA03779; Mon, 4 Nov 85 08:44:28 PST
Received: from opus.sun.uucp by snail.sun.uucp (3.0ALPHA/SMI-3.0DEV4)
	id AA04650; Mon, 4 Nov 85 08:46:01 PST
Received: by opus.sun.uucp (3.0/SMI-3.0DEV3)
	id AA03865; Mon, 4 Nov 85 08:46:55 PST
Date: Mon, 4 Nov 85 08:46:55 PST
From: sun!opus!gingell@ucb-vax.berkeley.edu (Rob Gingell)
Message-Id: <8511041646.AA03865@opus.sun.uucp>
To: ucbvax!monet.beta43_bugs
Subject: Error handling of 'get' in ftp
Status: O

Subject: 	/usr/ucb/ftp mishandles local file creation/open errors
		on get/mget
Index:		Network
Category:  	File Transfer Protocol program
Severity:  	4
Release:  	4.3beta/ftp.c 5.1

Description:
	When attempting to 'get' a remote file, if the local destination
	is not writable, or for some other reason can not be created or
	opened, a slightly garbled error message is printed and further
	operations are 'confused', as though ftp and its server were out
	of synch.

Repeat-By:
	1. Create a file, say 'xyz', with mode 444.
	2. Run ftp with a target host of the local machine.
	3. Pick some file in $HOME to copy, say 'foo', and give the command
	   'get foo xyz'.
	4. Error message will name the file 'yz' and further commands will
	   get nonsensical responses.

Fix:
	File(s): /usr/src/ucb/ftp.c

	The problem with misnamed files is a result of inconsistent handling
	of the argument 'local' to the routine recvrequest in ftp.c.  This
	argument is a char * describing the local object to receive the file,
	and is either the string '-' (standard output), a string beginning
	with '|' (indicating pipe file through program), or a string 
	identifying the local file to receive the transfer.

	The handling of local is such that it must be checked consistently
	to determine if the leading '|' is present, in this case the program
	printed an error message as though it was there and skipped the first
	character.

	Fix: advance local over the '|' after there is no further need for
	its special handling, eliminating the need to check in further 
	error messages.

	The problem with confused program state is a result of the failure
	of recvrequest to read the completion reply from the remote host
	when the local file can not be created.  The next command gets
	the completion reply from this one and confusion ensues.

	Fix: always read the completion reply when completing any FTP
	'RETR' transaction.

	Note that symmetrical changes are also required to the routine
	'sendrequest', also in ftp.c.

	The following "context diff" shows the changes to effect these
	fixes.

*** arch/4.3beta/usr/src/ucb/ftp/ftp.c	Fri May 31 17:00:50 1985
--- ftp.c	Thu Oct 31 07:44:57 1985
***************
*** 233,239
  	if (strcmp(local, "-") == 0)
  		fin = stdin;
  	else if (*local == '|') {
! 		fin = popen(local + 1, "r");
  		if (fin == NULL) {
  			perror(local + 1);
  			goto bad;

--- 212,224 -----
  	if (strcmp(local, "-") == 0)
  		fin = stdin;
  	else if (*local == '|') {
! 		/*
! 		 * Advance local so further uses just yield file name
! 		 * thus later references for error messages need not check
! 		 * for '|' special case.
! 	 	 */
! 		local += 1;
! 		fin = popen(local, "r");
  		if (fin == NULL) {
  			perror(local);
  			goto bad;
***************
*** 235,241
  	else if (*local == '|') {
  		fin = popen(local + 1, "r");
  		if (fin == NULL) {
! 			perror(local + 1);
  			goto bad;
  		}
  		closefunc = pclose;

--- 220,226 -----
  		local += 1;
  		fin = popen(local, "r");
  		if (fin == NULL) {
! 			perror(local);
  			goto bad;
  		}
  		closefunc = pclose;
***************
*** 322,328
  	}
  	gettimeofday(&stop, (struct timezone *)0);
  	if (closefunc != NULL)
! 		(*closefunc)(fin);
  	(void) fclose(dout);
  	(void) getreply(0);
  done:

--- 307,313 -----
  	}
  	gettimeofday(&stop, (struct timezone *)0);
  	if (closefunc != NULL)
! 		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
  	(void) getreply(0);
***************
*** 324,330
  	if (closefunc != NULL)
  		(*closefunc)(fin);
  	(void) fclose(dout);
- 	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)

--- 309,314 -----
  	if (closefunc != NULL)
  		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
  	(void) getreply(0);
  	signal(SIGINT, oldintr);
***************
*** 326,331
  	(void) fclose(dout);
  	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("sent", bytes, &start, &stop);

--- 310,316 -----
  		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
+ 	(void) getreply(0);
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("sent", bytes, &start, &stop);
***************
*** 334,340
  	if (data >= 0)
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fin != NULL)
! 		(*closefunc)(fin);
  	goto done;
  }
  

--- 319,325 -----
  	if (data >= 0)
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fin != NULL)
! 		(*closefunc)(fin), closefunc = NULL;
  	goto done;
  }
  
***************
*** 385,391
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {
! 		fout = popen(local + 1, "w");
  		closefunc = pclose;
  	} else {
  		fout = fopen(local, mode);

--- 370,381 -----
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {
! 		/*
! 		 * Advance local over '|' so don't need to check for
! 		 * '|' special case any further.
! 		 */
! 		local += 1;
! 		fout = popen(local, "w");
  		closefunc = pclose;
  	} else {
  		fout = fopen(local, mode);
***************
*** 392,398
  		closefunc = fclose;
  	}
  	if (fout == NULL) {
! 		perror(local + 1);
  		goto bad;
  	}
  	din = dataconn("r");

--- 382,388 -----
  		closefunc = fclose;
  	}
  	if (fout == NULL) {
! 		perror(local);
  		goto bad;
  	}
  	din = dataconn("r");
***************
*** 460,467
  	gettimeofday(&stop, (struct timezone *)0);
  	(void) fclose(din);
  	if (closefunc != NULL)
! 		(*closefunc)(fout);
! 	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)

--- 450,456 -----
  	gettimeofday(&stop, (struct timezone *)0);
  	(void) fclose(din);
  	if (closefunc != NULL)
! 		(*closefunc)(fout), closefunc = NULL;
  done:
  	(void) getreply(0);
  	signal(SIGINT, oldintr);
***************
*** 463,468
  		(*closefunc)(fout);
  	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("received", bytes, &start, &stop);

--- 452,458 -----
  	if (closefunc != NULL)
  		(*closefunc)(fout), closefunc = NULL;
  done:
+ 	(void) getreply(0);
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("received", bytes, &start, &stop);

From nsc!lab@decwrl.DEC.COM  Mon Nov  4 18:33:10 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA04390; Mon, 4 Nov 85 18:33:10 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA03531; Mon, 4 Nov 85 18:34:16 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA18404; Mon, 4 Nov 85 18:19:11 pst
Date: Mon, 4 Nov 85 18:19:11 pst
From: nsc!lab@decwrl.DEC.COM (Larry Bassel)
Message-Id: <8511050219.AA18404@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: 5.4 version of rogue
Status: O

I found a few bugs (features?) in version 5.4 rogue in 4.3BSD:

1. Your strength will change wildly and randomly up to a limit of 31
for no apparent reason.

2. Many times when you do inventory with the "i" command, more than a 
screenful of items will be displayed, and/or the game will save itself
automatically (very annoying!).

3. I have gotten messages about "unknown trap". When I move onto these traps
I get all kinds of wierd messages, but no other noticeable effect.

Larry Bassel

From helge@ODIN.GOV.NOR.ARPA  Tue Nov  5 13:49:45 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA10405; Tue, 5 Nov 85 13:49:45 PST
Received: by odin.ARPA (4.12/5.9)
	id AA06887; Mon, 4 Nov 85 09:39:32 -0100
Date: Mon, 4 Nov 85 09:39:32 -0100
From: helge@ODIN.GOV.NOR.ARPA (Helge Skrivervik)
Message-Id: <8511040839.AA06887@odin.ARPA>
To: beta43_bugs@monet
Subject: permissions on /dev/kmem
Cc: helge@ODIN.GOV.NOR.ARPA
Status: O

the more restricted read permissions on /dev/kmem is creating
problems for some applications, such as emacs. What is the recommended
procedure for solving such problems (short of reverting to the old
permission settings)??

helge

From nsc!freak@decwrl.DEC.COM  Wed Nov  6 11:42:50 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06516; Wed, 6 Nov 85 11:42:50 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA01562; Wed, 6 Nov 85 11:43:38 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA08392; Tue, 5 Nov 85 23:53:48 pst
Date: Tue, 5 Nov 85 23:53:48 pst
From: nsc!freak@decwrl.DEC.COM (Curt Mayer)
Message-Id: <8511060753.AA08392@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: bad file on beta tape
Status: O

/usr/src/new/icon/v5g is a symbolic link to "."

chongo <> /\../\

From nsc!chongo@decwrl.DEC.COM  Wed Nov  6 11:43:31 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06527; Wed, 6 Nov 85 11:43:31 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA01577; Wed, 6 Nov 85 11:44:14 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA08447; Wed, 6 Nov 85 00:02:45 pst
Date: Wed, 6 Nov 85 00:02:45 pst
From: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Message-Id: <8511060802.AA08447@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: BUG REPORT FORM?
Status: O

At one time (under 4.2) you had a system which required bug reports to be sent
in under a given form.  In addition, you had a program which let the sender
know that the report had been received.  Is this true for the 4.3Beta bugs?

Is there a way that you would like to receive bug reports?

chongo <.> /\../\

From nsc!chongo@decwrl.DEC.COM  Wed Nov  6 11:43:52 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06538; Wed, 6 Nov 85 11:43:52 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA01568; Wed, 6 Nov 85 11:43:56 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA08411; Tue, 5 Nov 85 23:59:21 pst
Date: Tue, 5 Nov 85 23:59:21 pst
From: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Message-Id: <8511060759.AA08411@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: sccs uses wrong dir
Status: O

/usr/src/ucb/sccs.c wants to find sccs programs (admin, cdc, get, edit, ...)
under /usr/local, but the release tape has these programs under /usr/ucb.

chongo <> /\../\

From bloom  Wed Nov  6 12:14:35 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06655; Wed, 6 Nov 85 12:14:35 PST
Date: Wed, 6 Nov 85 12:14:35 PST
From: bloom (Jim Bloom)
Message-Id: <8511062014.AA06655@monet.berkeley.edu>
To: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Cc: beta43_bugs
Subject: Re: BUG REPORT FORM?
In-Reply-To: Your message of Wed, 6 Nov 85 00:02:45 pst.
	     <8511060802.AA08447@nsc.UUCP>
Status: O

That system still exists.  We are not using it for the beta test, but you
may use the format if you wish.  Since we are not running the software on
this end, you will not get acknowledgement of receipt.  This should be back
when the final release is out.

					Jim

From bloom  Wed Nov  6 12:22:19 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06698; Wed, 6 Nov 85 12:22:19 PST
Date: Wed, 6 Nov 85 12:22:19 PST
From: bloom (Jim Bloom)
Message-Id: <8511062022.AA06698@monet.berkeley.edu>
To: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Cc: beta43_bugs
Subject: Re: sccs uses wrong dir
In-Reply-To: Your message of Tue, 5 Nov 85 23:59:21 pst.
	     <8511060759.AA08411@nsc.UUCP>
Status: O

None of the sccs programs are on the tape.  It must be a problem at your
site.
					Jim

From entropy!hubert@uw-beaver.arpa  Wed Nov  6 14:34:25 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA07254; Wed, 6 Nov 85 14:34:25 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA24432; Wed, 6 Nov 85 14:32:53 PST
Return-Path: <entropy!hubert@uw-beaver.arpa>
Message-Id: <8511062232.AA24432@uw-beaver.arpa>
Received: by entropy.UUCP (5.5/4.7)
	id AA14429; Wed, 6 Nov 85 14:32:24 PST
Date: Wed, 6 Nov 85 14:32:24 PST
From: entropy!hubert@uw-beaver.arpa (Steve Hubert)
To: uw-beaver!beta43_bugs@monet.berkeley.edu
Subject: 4.3 Bug Report
Cc: entropy!uw-june!bob, lundberg@uw-beaver.arpa, uw-beaver!washington!burr
Status: O

We believe that the following two fixes to /sys/vaxuba/dmf.c are
appropriate.  They have solved problems we were having with dmf ports
on a Micom 600.  Something very close to this first appeared on netnews
a while back with regards to the 4.2 dmf.c  A context diff follows.

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver


*** dmf.c.orig	Wed Nov  6 14:24:31 1985
--- dmf.c.new	Wed Nov  6 14:24:36 1985
***************
*** 6,11 ****
--- 6,18 ----
   *	@(#)dmf.c	6.10 (Berkeley) 9/17/85
   */
  
+ /*
+  *	modified	10/18/85	nancy johnson burr
+  *			dmfrint:  Leave modem interrupts enabled on
+  *				  data set change.
+  *			dmfparam: Lower ipl on exit when t_ispeed==0.
+  */
+ 
  #include "dmf.h"
  #if NDMF > 0
  /*
***************
*** 374,380 ****
  					gsignal(tp->t_pgrp, SIGCONT);
  					addr->dmfcsr = DMF_IE | DMFIR_LCR |
  						unit;
! 					addr->dmftms = 0;
  					ttyflush(tp, FREAD|FWRITE);
  				}
  				tp->t_state &= ~TS_CARR_ON;
--- 381,390 ----
  					gsignal(tp->t_pgrp, SIGCONT);
  					addr->dmfcsr = DMF_IE | DMFIR_LCR |
  						unit;
! /* change the following line */
! 					/* addr->dmftms = 0; */
! /* to */
! 					addr->dmfun.dmfirw = DMFLCR_ENA;
  					ttyflush(tp, FREAD|FWRITE);
  				}
  				tp->t_state &= ~TS_CARR_ON;
***************
*** 528,533 ****
--- 538,544 ----
  	if ((tp->t_ispeed)==0) {
  		tp->t_state |= TS_HUPCLS;
  		(void) dmfmctl(unit, DMF_OFF, DMSET);
+ 		splx(s);	/* This was missing */
  		return;
  	}
  	lpar = (dmf_speeds[tp->t_ospeed]<<12) | (dmf_speeds[tp->t_ispeed]<<8);

From joel@isi-8600.arpa  Wed Nov  6 16:54:02 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA08126; Wed, 6 Nov 85 16:54:02 PST
Received: by isi-8600.arpa (5.15/1.2)
	id AA17844; Wed, 6 Nov 85 16:54:56 PST
Date: Wed 6 Nov 85 16:54:54-PST
From: "Joel Goldberger" <JOEL@isi-8600.arpa>
Subject: BBNNET option doesn't compile
To: beta43_bugs@monet.berkeley.edu
Cc: Joel@isi-8600.arpa
Message-Id: <VAX-MM(165)+TOPSLIB(113) 6-Nov-85 16:54:54.ISI-8600.ARPA>
Status: O

When trying to build a system with the BBNNET option many of the
modules won't compile because KERN_RECOV is undefined.

- Joel Goldberger -
-------

From bloom  Wed Nov  6 17:02:40 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA08214; Wed, 6 Nov 85 17:02:40 PST
Date: Wed, 6 Nov 85 17:02:40 PST
From: bloom (Jim Bloom)
Message-Id: <8511070102.AA08214@monet.berkeley.edu>
To: "Joel Goldberger" <JOEL@isi-8600.arpa>
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: BBNNET option doesn't compile
In-Reply-To: Your message of Wed 6 Nov 85 16:54:54-PST.
	     <VAX-MM(165)+TOPSLIB(113) 6-Nov-85 16:54:54.ISI-8600.ARPA>
Status: O

They should all be changed to LOG_INFO.

			Jim

From lam@BBN-VAX.ARPA  Wed Nov  6 17:25:16 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA08419; Wed, 6 Nov 85 17:25:16 PST
Message-Id: <8511070125.AA08419@monet.berkeley.edu>
Date:     Wed, 6 Nov 85 20:18:30 EST
From: Karen Lam <lam@BBN-VAX.ARPA>
To: beta43_bugs@monet.berkeley.edu
Cc: lam@BBN-VAX.ARPA
Subject:  bug in /sys/netimp/if_imp.c
Status: O

I believe line 417 in /sys/netimp/if_imp.c should be:

	impdst.sin_addr = IA_SIN(ifp->if_addrlist)->sin_addr;

rather than:

	impdst.sin_addr = IA_SIN(ifp->if_addrlist->ifa_addr)->sin_addr;
.

The latter causes compiling errors.


Karen

From joel@isi-8600.arpa  Thu Nov  7 10:10:48 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00551; Thu, 7 Nov 85 10:10:48 PST
Received: by isi-8600.arpa (5.15/1.2)
	id AA21950; Thu, 7 Nov 85 10:11:57 PST
Date: Thu 7 Nov 85 10:11:55-PST
From: "Joel Goldberger" <JOEL@isi-8600.arpa>
Subject: BBNNET option fails
To: beta43_bugs@monet.berkeley.edu
Cc: Joel@isi-8600.arpa
Message-Id: <VAX-MM(165)+TOPSLIB(113) 7-Nov-85 10:11:55.ISI-8600.ARPA>
Status: O

Building a system with:

options		BBNNET
options		BBNTRAPS
options		BBNPING
pseudo-device	bbnnet

config produces a Makefile that contains two entries for ../vaxif/if_uba
and the make produces an error message "Too many command lines for
if_uba.o" and the load reports multiply defined symbols as a result.

- Joel Goldberger -
-------

From chris@gyre.umd.edu  Thu Nov  7 15:19:52 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02333; Thu, 7 Nov 85 15:19:52 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03356; Thu, 7 Nov 85 18:21:58 EST
Date: Thu, 7 Nov 85 18:21:58 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511072321.AA03356@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Curses `ttytype' field is too small
Status: O

Index: /usr/src/usr.lib/libcurses/curses.c 4.3Beta Fix

Description:
	The `full name' string for the terminal is only ten
	characters.  This is far too small, causing some
	strings to overwrite various other important curses
	variables.

Repeat-By:
	Examination, or try this the termcap below with `talk'.
	(You may want to add this to the `official' termcap source
	too.)

Fix:
	Change the name length to at least 80 bytes.

Chris

# Anderson-Jacobson AJ510
AJ510|Anderson-Jacobson model 510:\
	:ic=:ip=.1*:so=\E"I:us=\E"U:cd=\E'P:\
	:ce=\E'L:cl=^L:cm=\E#%+ %+ :dl=2*\E&D:\
	:ue=\E"U:co#80:li#24:se=\E"I:al=2*\E&I:im=\E'I:ei=\E'J:\
	:dc=.1*\E'D:up=\EY:nd=\EX:bs:am:mi:ti=\E"N:te=\E"N:\
	:ku=\EY:kd=\EZ:kl=\EW:kr=\EX:pc=\177:

From chris@gyre.umd.edu  Thu Nov  7 15:36:58 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02498; Thu, 7 Nov 85 15:36:58 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03634; Thu, 7 Nov 85 18:38:53 EST
Date: Thu, 7 Nov 85 18:38:53 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511072338.AA03634@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: ptys can hang during close
Status: O

Index: /sys/sys/tty_pty.c 4.3Beta Fix?

Description:
	PTYs occasionally hang during close.  I think it is due to
	output waiting that never quite finishes going through.
	pstat invariably shows the hung ptys as state `O C A'.

Repeat-By:
	uncertain

Fix?:
	I think adding a wakeup in ptcclose after clearing tp->t_oproc
	suffices, but I am uncertain.

Chris

From chris@gyre.umd.edu  Thu Nov  7 15:39:36 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02508; Thu, 7 Nov 85 15:39:36 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03743; Thu, 7 Nov 85 18:41:34 EST
Date: Thu, 7 Nov 85 18:41:34 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511072341.AA03743@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Probably better fix for same bug
Status: O

Looks like moving tp->t_oproc=0 from after ttyflush to before ttyflush
is the right fix.  I think I forgot to mention that the wakeup I added
was on &tp->t_outq, which is of course done in ttyflush....

From bloom  Fri Nov  8 10:09:33 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA00523; Fri, 8 Nov 85 10:09:33 PST
From: bloom (Jim Bloom)
Message-Id: <8511081809.AA00523@monet.berkeley.edu>
To: Chris Torek <chris@gyre.umd.edu>
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: Curses `ttytype' field is too small
In-Reply-To: Your message of Thu, 7 Nov 85 18:21:58 EST.
	     <8511072321.AA03356@gyre.umd.edu>
Date: 08 Nov 85 10:09:31 PST (Fri)
Status: O

I'll fix the bug, but your termcap entry violates the manual page
for termcap entries  (see paragraph 2 or the manual page).  I may
fix the field by having it truncated to some reasonable number of
characters.

					Jim

From SATZ@SU-SIERRA.ARPA  Mon Nov 11 14:05:25 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA01703; Mon, 11 Nov 85 14:05:25 PST
Message-Id: <8511112205.AA01703@monet.berkeley.edu>
Date: Mon 11 Nov 85 14:05:00-PST
From: Greg Satz <SATZ@SU-SIERRA.ARPA>
Subject: Re: beta test status
To: karels@monet.berkeley.edu
Cc: beta43_bugs@monet.berkeley.edu, mogul@SU-NAVAJO.ARPA
In-Reply-To: Message from "karels@monet.berkeley.edu (Mike Karels)" of Mon 21 Oct 85 12:24:58-PDT
Phone: (415) 497-1004
Status: O

4.3 seems to be running fine at Stanford. I have installed and
successfully tested the packet filter on three out of the four network
interfaces. The biggest problem I had was with the 3mb ethernet driver.
We swab all packets because of the packet filter and it seems that the
ethernet type field was being swapped one too many times.

All of the changes to the kernel are on Monet in ~satz/sys. Let me know
if you have any questions. Hopefully you guys will have time to get this
into the next release.

Thanks for letting us be a beta test site. We really appreciate it.
-------

From mcvax!jaap@seismo.CSS.GOV  Mon Nov 11 14:55:27 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02072; Mon, 11 Nov 85 14:55:27 PST
Return-Path: <mcvax!jaap>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 11 Nov 85 17:22:19 EST
Received: by mcvax.UUCP; Mon, 11 Nov 85 21:52:37 +0100 (MET)
From: mcvax!jaap@seismo.CSS.GOV (Jaap Akkerhuis)
Received: by mcvax.UUCP; Mon, 11 Nov 85 21:52:29 +0100 (MET)
Message-Id: <8511112052.AA01880@mcvax.UUCP>
To: beta43_bugs@monet.berkeley.edu
Organisation: Centrum voor Wiskunde en Informatica
	      Kruislaan 413, 1098 SJ Amsterdam, The Netherlands
Phone: +31 20 5924144, +31 20 991022
Telex: 12571 (mactr nl)
Subject: Various little things
Date: 11 Nov 85 21:52:27 N (Mon)
Status: O


Here follows some remarks about 4.3. I installed the system pretending to be
a novice (Berkeley) user. The Installing notes were quite correct. There
were some minor mistakes. I skipped the formatting process, since the
disks has been formatted a lot while we were rotting the bugs out of the
SC3000 controller.

Page 9, just above 2.3 reads:
	"(As above, `#' erases characters and `@' erases lines.)"
    This is true, but also backspace (^H) and ^U works fine.

Page 14, 7 lines from the top:
	"(this takes a few minutes)"
    It actually takes a few seconds.

Page 14, 10 lines from the top:
	"# mt fsf"
    Since th last thing you have done before this was xtr (page 11,
    section 2.4) and xtr uses ts0, the tape is rewinded.. So the line
    should be:
    # mt fsf 3

    Also note the typo in the first line of the next alinea. (`Files'
    instead of `file'.

    In this state of installing 4.3, you are mounting and unmounting
    disks. Note that /etc/mtab as distributed is full of trash. So if
    you just want to know which disk is mounted you get bizarre results.
    I suggest to deliver an empty /etc/mtab on the distributed file
    system or have in the installation procedure an explicit action to
    copy /dev/null to /etc/mtab before newfs (line 6).

Page 15, line 1
    Although the document has a warning about possible tape position
    problems, you need to have a mt fsf or a dd command, to skip over
    the tape mark and to get to the next file.

The rest of the document was quite clear. I also didn't bother to check
this that much. People who are upgrading from 4.2 should have an idea what
they are doing anyway.

The rest of this mail consists of some more remarks which might or not
might be useful.

*) cp
	cp -r installs the directories before the files, this is a pain when
	the directories have mode 555.

*) dhu
	In the Generic system is the dhu driver not installed. This gives
	suprises when you bring it up multi user.

*) /usr/man/cat[1-8]
	The directories as delivered are owned by root and mode drwxr-xr-x.
	That makes them pretty useless.
	In general, I'm not really happy how the permissions are set up on
	the delivered file systems. They are very Berkeley dependent.

*) /etc/syslog
	See the next note from Jim, the last thing he did on mcvax before
	moving to bellcore.

	Well, syslog isn't actually broken, but none of the
	source, documentation or supplied config file agree
	with either of the other two.

	1) there is no facility called 'daemon'. This appears
	   both in the documentation and config file.

	2) you cannot wildcard the priority level as in
		mail.*
	   as the supplied config file would indicate.

	I've made a new config file, with log files in /usr/spool/syslog.
	Also there you will find a shell 'shuffle' which should be called
	from cron once per week to recycle the log files.

	I've also made a slight change to the syslogd source to allow
	the 'daemon' facility. Otherwise, syslogd can't even log
	its own actions such as shutting down!

	This all really needs a more thorough look or maybe an 
	updated source from monet. I leave it up to you to find
	that out, I've had enough.

	--jim

*) user contributed software
	I know that the B system is somewhere on monet. The idea was to
	include this into the user contributed software. It wasn't on the
	Beta tape. We really would like to have it on. Are there any actions
	I have to do which would it really make to go on the official
	release? I checked the system, and it installed and worked without any
	problem on 4.3.

*) troff -ms macros
	I have said this before but have to repeat it again. The new version
	of the -ms macros are incompatible with the standard V7 (and V8)
	version. I think that this is a very bad idea. The -ms macros used to
	be the most widespread on all system arounds. Now we have two classes
	of -ms macros. The standard version and the 4.2 or higher version.
	Be aware that this will generate complaints and won't improve the
	image of Berkeley. (I already can see the flanes in the line of:
		"I've been using -ms on the all the systems I could imagen,
		 from 6.2 to V8, but those Berkloids have really done it,
		 I will never trust a Berkeley system again... etc. etc."
	Although it is mentioned in the "A revised version of -ms"
	document, it is not mentioned in the manual that the old version of
	-ms is still available as -mos.

Regards,
	jaap

------- End of Forwarded Message

From mcvax!jaap@seismo.CSS.GOV  Mon Nov 11 15:47:24 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA02363; Mon, 11 Nov 85 15:47:24 PST
Return-Path: <mcvax!jaap>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 11 Nov 85 18:40:32 EST
From: mcvax!jaap@seismo.CSS.GOV
Received: by mcvax.UUCP; Tue, 12 Nov 85 00:36:56 +0100 (MET)
Message-Id: <8511112336.AA04187@mcvax.UUCP>
To: beta43_bugs@monet.berkeley.edu
Cc: mcvax!dpk@seismo.CSS.GOV, bellcore!yquem!jim@seismo.CSS.GOV
Organisation: Centrum voor Wiskunde en Informatica
	      Kruislaan 413, 1098 SJ Amsterdam, The Netherlands
Phone: +31 20 5924144, +31 20 991022
Telex: 12571 (mactr nl)
Subject: bug in vplotf, very square circles
Date: 12 Nov 85 00:36:54 N (Tue)
Status: O

Apparently the versatec in not really used a lot in Berkeley. 
/usr/lib/vplotf has the same bug we found (and reported) as in 4.2 .
Circles will be turned into squares, as shown by the next program:

	main() {
		openpl();
		space(0,0,2048,2048);
		circle(500, 500, 400);
		closepl();
	}

a.out | plot -Tver
gives a square as output.

Solution:
Change in /usr/src/usr.lib/lpr/filters/vplotf.c
around line 430
	#define labs(a) (a >= 0 ? a : -a)
into
	#define labs(a) ((a) >= 0 ? (a) : -(a))

and the circles will be less square.

	--jaap

PS. I have (kludgy) fixes to the versatec filters so they wotk bot only on a "Wide"
    Versatec but also on a V-80. Any interest in these?

From mcvax!dpk@seismo.CSS.GOV  Tue Nov 12 12:00:27 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06848; Tue, 12 Nov 85 12:00:27 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 12 Nov 85 10:17:33 EST
Received: by mcvax.UUCP; Tue, 12 Nov 85 15:16:40 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 12 Nov 85 15:15:58 +0100 (MET)
Message-Id: <8511121415.AA06087@mcvax.UUCP>
Date:     Tue, 12 Nov 85 15:10:21 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: termcap@monet.berkeley.edu, termcap@ucbvax.arpa
Subject:  Incomplete TTY5620 (DMD) Termcap
Status: O

The /etc/termcap file distributed wiht 4.3Beta is missing some
important capabilities supported by the default tty5620 terminal.

Below is a revised entry.

TD|dmd|5620|ttydmd|tty5620|5620	terminal 88 columns:\
	:co#88:li#70:am:cl=\E[H\E[J:bs:pt:\
	:cm=\E[%i%d;%dH:\
	:nd=\E[C:up=\E[A:\
	:cd=\E[J:ce=\E[K:\
	:al=\E[L:dl=\E[M:\
	:ic=\E[@:dc=\E[P:\
	:kl=\E[D:kr=\E[C:ku=\E[A:kd=\E[B:kh=\E[H:im=:ei=:dm=:\
	:AL=\E[%dL:DL=\E[%dM:\
	:IC=\E[%d@:DC=\E[%dP:\
	:sr=\E[T:sf=\E[S:

-Doug-

From mcvax!dpk@seismo.CSS.GOV  Tue Nov 12 12:01:08 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06867; Tue, 12 Nov 85 12:01:08 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 12 Nov 85 08:22:00 EST
Received: by mcvax.UUCP; Tue, 12 Nov 85 11:03:20 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 12 Nov 85 11:03:12 +0100 (MET)
Message-Id: <8511121003.AA18530@mcvax.UUCP>
Date:     Tue, 12 Nov 85 11:05:34 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: rick@seismo.CSS.GOV
Cc: beta43_bugs@monet.berkeley.edu, net-sources@brl.arpa
Subject:  flock.c and man page
Status: O

: This is a shar archive.  Extract with sh, not csh.
: While this is written for 4.2BSD, it can be easily rewritten
: for any UNIX with real locking.
echo 'x flock.c'
sed 's/^X//' <<'________This_Is_The_END________' >>flock.c
X#include <stdio.h>
X#include <sys/file.h>
X
Xmain(argc, argv)
Xint argc;
Xchar *argv[];
X{
X	int	fd;
X
X	if (argc < 3) {
X		fputs("usage: flock file command\n", stderr);
X		exit(1);
X	}
X	if ((fd = open (argv[1], 0)) < 0
X	  || flock (fd, LOCK_EX | LOCK_NB)) {
X		perror (argv[1]);
X	  	exit (1);
X	}
X
X	execvp(argv[2], &argv[2]);
X	perror(argv[2]);
X	exit(1);
X}
________This_Is_The_END________
echo 'x flock.l'
sed 's/^X//' <<'________This_Is_The_END________' >>flock.l
X.TH FLOCK 1  "2 May 1984"
X.UC 4
X.SH NAME
Xflock \- run a command with a file locked
X.SH SYNOPSIS
X.B flock
X.I filename
Xcommand [ arguments ]
X.SH DESCRIPTION
X.I Flock
Xexecutes
X.I command
Xafter opening the specified file and setting an exclusive lock
Xusing the flock(2) system call.
XIf the
X.I filename
Xcannot be opened or the lock cannot be set,
X.I flock
Xwill print a message on stderr,
Xthe
X.I command
Xwill not be executed, and
X.I flock
Xwill exit with a non-zero exit status.
XThe locked file descriptor is inherited by the
X.I command
Xso the lock will remain in effect until the
X.I command
Xand it children exit, or the file descriptor is closed or unlocked.
X.SH "SEE ALSO"
Xflock(2)
X.SH DIAGNOSTICS
X.I Flock
Xreturns the exit status of the subject command
Xif it was able to lock the file and run the command.
________This_Is_The_END________

From mcvax!dpk@seismo.CSS.GOV  Tue Nov 12 12:01:30 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06877; Tue, 12 Nov 85 12:01:30 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 12 Nov 85 08:30:43 EST
Received: by mcvax.UUCP; Tue, 12 Nov 85 11:45:12 +0100 (MET)
Resent-From: mcvax!dpk@seismo.CSS.GOV (Doug Kingston)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 12 Nov 85 11:44:46 +0100 (MET)
Resent-Message-Id: <8511121044.AA21376@mcvax.UUCP>
Received: from mcvax by sering.mcvax.UUCP id a004010; 12 Nov 85 7:41 MET
Received: by mcvax.UUCP; Tue, 12 Nov 85 07:38:29 +0100 (MET)
Old-Resent-From: seismo!BRL.ARPA!dpk
Received: from BRL-SEM.ARPA by seismo.CSS.GOV with SMTP; Mon, 11 Nov 85 20:55:11 EST
Old-Resent-Message-Id: <8511120155.AA02065@seismo.CSS.GOV>
Message-Id: <8511120155.AA02065@seismo.CSS.GOV>
Received: from brl-aos.arpa by SEM.BRL.ARPA id a027061; 7 Nov 85 10:55 EST
Received: from csnet-pdn-gw by AOS.BRL.ARPA id a007253; 7 Nov 85 10:53 EST
Received: from loki.arpa by CSNET-RELAY.ARPA id a007389; 7 Nov 85 10:42 EST
To: mmdf2@csnet-relay.arpa
Cc: van@monet.berkeley.edu
Subject: Can't Install MMDF2 Update #7?
Date: 07 Nov 85 10:31:14 EST (Thu)
From: Craig Partridge <mcvax!seismo!loki.arpa!craig@seismo.CSS.GOV>
Old-Resent-Date:  Mon, 11 Nov 85 20:31:53 EST
Old-Resent-To: dpk
Resent-Date:  Tue, 12 Nov 85 11:46:39 MET
Resent-To: beta43_bugs@monet.berkeley.edu
Status: O


    Patch for 4.3 turns out to have bugs in handling new context diffs if
you are on a non-VAX machine.  It doesn't check for null strings before calling
strlen(), and strlen() on some machines (in my case a SUN) doesn't check
for the null pointer before accessing it.

    These bugs cause patch to be unable to process Update #7 to mmdf2.

    A patch to patch is appended.  Since it doesn't cause the bug,
you can indeed use patch to patch itself.

Craig Partridge
CSNET Technical Staff

craig@csnet-sh or craig@sh.cs.net (CSNET)
craig@loki.bbn.com (ARPA)
{decvax,ihnp4,wjh12}!bbncca!craig (USENET)
- ---------------------
*** patch.c.old	Thu Nov  7 10:05:53 1985
- --- patch.c	Thu Nov  7 09:52:28 1985
***************
*** 1441,1447
  	    default:
  		fatal("Malformed patch at line %d: %s",p_input_line,buf);
  	    }
! 	    p_len[p_end] = strlen(p_line[p_end]);
  					/* for strncmp() so we do not have */
  					/* to assume null termination */
  	}

- --- 1441,1449 -----
  	    default:
  		fatal("Malformed patch at line %d: %s",p_input_line,buf);
  	    }
! 	    p_len[p_end] = 0;
! 	    if (p_line[p_end] != 0)
! 		p_len[p_end] = strlen(p_line[p_end]);
  					/* for strncmp() so we do not have */
  					/* to assume null termination */
  	}
***************
*** 1543,1549
  	    default:
  		fatal("Malformed patch at line %d: %s",p_input_line,buf);
  	    }
! 	    p_len[p_end] = strlen(p_line[p_end]);
  					/* for strncmp() so we do not have */
  					/* to assume null termination */
  	}

- --- 1545,1553 -----
  	    default:
  		fatal("Malformed patch at line %d: %s",p_input_line,buf);
  	    }
! 	    p_len[p_end] = 0;
! 	    if (p_line[p_end] != 0)
! 		p_len[p_end] = strlen(p_line[p_end]);
  					/* for strncmp() so we do not have */
  					/* to assume null termination */
  	}
***************
*** 1612,1618
  	    if (*buf != '<')
  		fatal("< expected at line %d of patch.\n", p_input_line);
  	    p_line[i] = savestr(buf+2);
! 	    p_len[i] = strlen(p_line[i]);
  	    p_char[i] = '-';
  	}
  	if (hunk_type == 'c') {

- --- 1616,1624 -----
  	    if (*buf != '<')
  		fatal("< expected at line %d of patch.\n", p_input_line);
  	    p_line[i] = savestr(buf+2);
! 	    p_len[i] = 0;
! 	    if (p_line[i] != 0)
! 		p_len[i] = strlen(p_line[i]);
  	    p_char[i] = '-';
  	}
  	if (hunk_type == 'c') {
***************
*** 1636,1642
  	    if (*buf != '>')
  		fatal("> expected at line %d of patch.\n", p_input_line);
  	    p_line[i] = savestr(buf+2);
! 	    p_len[i] = strlen(p_line[i]);
  	    p_char[i] = '+';
  	}
      }

- --- 1642,1650 -----
  	    if (*buf != '>')
  		fatal("> expected at line %d of patch.\n", p_input_line);
  	    p_line[i] = savestr(buf+2);
! 	    p_len[i] = 0;
! 	    if (p_line[i] != 0)
! 		p_len[i] = strlen(p_line[i]);
  	    p_char[i] = '+';
  	}
      }


From mcvax!dpk@seismo.CSS.GOV  Tue Nov 12 12:01:52 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA06887; Tue, 12 Nov 85 12:01:52 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 12 Nov 85 08:21:42 EST
Received: by mcvax.UUCP; Tue, 12 Nov 85 10:53:08 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 12 Nov 85 10:53:01 +0100 (MET)
Message-Id: <8511120953.AA17902@mcvax.UUCP>
Date:     Tue, 12 Nov 85 10:54:12 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu, sdcrdcf!lwall@seismo.CSS.GOV
Cc: dpk@seismo.CSS.GOV
Subject:  Problems with NEWS and RN on 4.3Beta
Status: O

I have just brought up news and rn on 4.3BSD/Beta with MMDF as the mail
system.  Two basic problems were found.  First, neither RN nor News used
the TIOCGWINSZ ioctl to get the size of the screen.  Second, RN had a
simplistic but easily fixed view of mailboxes.  Fixes follow for all of
the above.

For rn when using MMDF (which has sane message separaters), you will
need the following version of mbox.saver.  The program flock is a trivial
reworking of the "nice" program of V6 days.  All it does is flock arg1 and
then exec the arg2-N.  It can be omitted for systems that like to clobber
their mailboxes.  I will include the source for flock in another letter
if someone asks for it (it even has a man page...).  You probably want
to generalize the paths in this shellscript, but I wanted it to always
work here, hence the absolute paths.  (Our mailboxs are NOT uucp compatable.
This is a feature.  All mail messages comply RFC822.  No "From " lines.

NOTE: The following file has two echo commands that echo a line of
four control-A's.  Beware of terminal funniness.

#!/bin/sh
#
#	Arguments:
#	1 Full name of article (%A)
#	2 Public news spool directory (%P)
#	3 Directory of current newsgroup (%c)
#	4 Article number (%a)
#	5 Where in article to start (%B)
#	6 Newsgroup name (%C)
#	7 Save destination (%b)
#	8 First line of message, normally From...
#
exec /usr/local/flock $7 /bin/sh <<DONE >>"$7"
/bin/echo ''
case "$5" in
0)	/bin/echo "Received: from RN; `date`"
	/bin/echo "News-Article: $4 of $6:"
	;;
esac
/usr/ucb/tail +$5c $1
/bin/echo ''
DONE


 = = = = = = = = = = Cut here and feed to Patch = = = = = = = = = = = =

*** new/rn/o.respond.c	Fri Jun 21 19:57:22 1985
--- new/rn/respond.c	Tue Nov 12 00:36:52 1985
***************
*** 144,150 ****
  	}
  	s = savedest = savestr(s);	/* doesn't move any more */
  					/* make it handy for %b */
! 	if (!there) {
  	    if (mbox_always)
  		mailbox = TRUE;
  	    else if (norm_always)
--- 144,150 ----
  	}
  	s = savedest = savestr(s);	/* doesn't move any more */
  					/* make it handy for %b */
! 	if (!there || filestat.st_size == 0L) {
  	    if (mbox_always)
  		mailbox = TRUE;
  	    else if (norm_always)
***************
*** 153,160 ****
  		char *dflt = (instr(savename,"%a") ? "nyq" : "ynq");
  		
  		sprintf(cmd_buf,
! 		"\nFile %s doesn't exist--\n	use mailbox format? [%s] ",
! 		  s,dflt);
  	      reask_save:
  		in_char(cmd_buf);
  		putchar('\n') FLUSH;
--- 153,160 ----
  		char *dflt = (instr(savename,"%a") ? "nyq" : "ynq");
  		
  		sprintf(cmd_buf,
! 		"\nFile %s %s--\n	use mailbox format? [%s] ",
! 		  s, (there ? "is empty" : "doesn't exist"), dflt);
  	      reask_save:
  		in_char(cmd_buf);
  		putchar('\n') FLUSH;


*** new/rn/o.term.c	Fri Jun 21 19:57:21 1985
--- new/rn/term.c	Mon Nov 11 14:28:13 1985
***************
*** 201,206 ****
--- 201,218 ----
  	else
  	    CR = "\r";
      }
+ #ifdef TIOCGWINSZ
+     {
+     	struct winsize ws;
+ 
+     	if (ioctl (0, TIOCGWINSZ, &ws) == 0) {
+ 	    if (ws.ws_row)
+ 		LINES = ws.ws_row;
+ 	    if (ws.ws_col)
+ 		COLS = ws.ws_col;
+ 	}
+     }
+ #endif /* TIOCGWINSZ */
  #else
      ??????				/* Roll your own... */
  #endif

*** new/news/src/o.virtterm.c	Fri Jun  7 06:45:01 1985
--- new/news/src/virtterm.c	Mon Nov 11 15:00:35 1985
***************
*** 802,807 ****
--- 802,819 ----
  	if ((ROWS = tgetnum("li")) == -1
  	 || (COLS = tgetnum("co")) == -1)
  		xerror("Can't get screen size");
+ #ifdef TIOCGWINSZ
+ 	{
+     		struct winsize ws;
+ 
+ 	    	if (ioctl (0, TIOCGWINSZ, &ws) == 0) {
+ 			if (ws.ws_row)
+ 				ROWS = ws.ws_row;
+ 			if (ws.ws_col)
+ 				COLS = ws.ws_col;
+ 		}
+ 	}
+ #endif /* TIOCGWINSZ */
  	_zap();
  
  	if (CL == NULL)

----- End of forwarded messages

From schoch@orion.ARPA  Tue Nov 12 15:03:06 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA07560; Tue, 12 Nov 85 15:03:06 PST
Received: by orion.ARPA (5.31/1.2)
	id AA09323; Tue, 12 Nov 85 15:02:55 PST
Date: Tue, 12 Nov 85 15:02:55 PST
From: Steve Schoch <schoch@orion.arpa>
Message-Id: <8511122302.AA09323@orion.ARPA>
Subject: syslogd does not handle forwarding properly
Index: 	/usr/src/etc/syslogd.c 4.3BSD
Apparently-To: beta43_bugs@monet
Status: O

Description:
	If syslogd expects to forward a message (because a line of the
	form "fac.level	@host" in /etc/syslog.conf) it will either
	core-dump or not send the message to the remote machine.
Repeat-By:
	Put a forwarding line in /etc/syslog.conf and send a message
	to syslogd.
Fix:
	% diff /usr/src/etc/syslogd.c.old /usr/src/etc/syslogd.c
587,588c587,588
< 			(void) sprintf(line, "<%d>%.15s %s", pri, v[0].iov_base,
< 				v[4].iov_base);
---
> 			(void) sprintf(line, "<%d>%.15s %s", pri,
> 					iov[0].iov_base, iov[4].iov_base);

From entropy!hubert@uw-beaver.arpa  Thu Nov 14 11:26:33 1985
Received: by monet.berkeley.edu (5.31/1.2)
	id AA01032; Thu, 14 Nov 85 11:26:33 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA20429; Thu, 14 Nov 85 11:26:30 PST
Return-Path: <entropy!hubert@uw-beaver.arpa>
Message-Id: <8511141926.AA20429@uw-beaver.arpa>
Received: by entropy.UUCP (5.5/4.7)
	id AA07103; Thu, 14 Nov 85 11:25:51 PST
Date: Thu, 14 Nov 85 11:25:51 PST
From: entropy!hubert@uw-beaver.arpa (Steve Hubert)
To: uw-beaver!beta43_bugs@monet.berkeley.edu
Subject: 4.3 Bug Report
Cc: lundberg@uw-beaver.arpa, uw-beaver!larry!bob, uw-beaver!washington!burr
Status: O

I believe there are a couple of omissions in /usr/src/etc/syslogd.c.
I make these inferences based on the /etc/syslog.conf that was
distributed and on the contents of /usr/include/sys/syslog.h.  The
easiest one first.  In the declaration of FacNames in syslogd.c the line

   "daemon",	LOG_DAEMON,

is missing.

-----------------

In syslog.conf you have a priority of * for mail, ie. the line

mail.*			/usr/spool/mqueue/syslog

It doesn't look like * is a legal priority as syslogd.c stands.  You
must have intended to make it the same as a * for facilities but it
isn't so in my copy.

-----------------
If possible would one of you acknowledge that you have received this
so I know I am sending it to the proper address.  This is the third
letter I have sent to beta43_bugs.  Thanks.

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver

From chris@gyre.umd.edu  Fri Nov 15 17:51:14 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA07935; Fri, 15 Nov 85 17:51:14 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA04722; Fri, 15 Nov 85 20:51:45 EST
Date: Fri, 15 Nov 85 20:51:45 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511160151.AA04722@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: ncheck is incredibly slow, not to mention buggy
Status: O

Index: /usr/src/etc/ncheck.c 4.3Beta Fix

Description:
	The code in readdir() is just plain wrong.  It usually works,
	but quite slowly, and will not work properly on directories
	larger than the file system block size.

Repeat-By:
	time ncheck ...
	or inspection.

Fix:
	In readdir(), change the if statement to check whether
	blkoff(&sblock, dirp->loc)==0, not whether lblkno(...)==0;
	and move the assignment to lbn inside the `if'.

Chris

From jlarson.pa@Xerox.ARPA  Mon Nov 18 03:04:15 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA14650; Mon, 18 Nov 85 03:04:15 PST
Received: from Semillon.ms by ArpaGateway.ms ; 16 NOV 85 14:48:12 PST
Date: Sat, 16 Nov 85 14:48:06 PST
From: jlarson.pa@Xerox.ARPA
Subject: netstat -h broken
To: beta43_bugs@monet.berkeley.edu
Cc: VaxcSystem^.pa@Xerox.ARPA
Message-Id: <851116-144812-236@Xerox>
Status: O


Causes "Segmentation fault" on parcvax:

parcvax> netstat -h
IMP Host Table
Flags Host            Qcnt Q Address RFNM Timer
F     0.15.17.61      0    0         0    75
Segmentation fault


It doesn't seem to work on monet either:

monet> netstat -h
hosts: symbol not in namelist


From bin@mimsy.umd.edu  Mon Nov 18 03:08:07 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA14660; Mon, 18 Nov 85 03:08:07 PST
From: bin@mimsy.umd.edu
Received: by gyre.umd.edu (5.9/4.7)
	id AA06533; Sat, 16 Nov 85 17:08:42 EST
Date: Sat, 16 Nov 85 17:08:42 EST
Message-Id: <8511162208.AA06533@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Bug in finger
Status: O

Index: /usr/src/ucb/finger.c 4.3BSD Beta Fix

Description:
   When handed a net address instead of a host name, finger dies with a
bus error.

Repeat-By:
   finger @128.8.128.36

Fix:
   The problem is that the h_addr field of the hostent struct is now
a h_addr_list; with h_addr defined as "h_addr_list[0]", an assignment
to h_addr causes the crash.  Just allocate something to stick the 
address into (in the netfing() routine) and all will be well again.

	-Steve


From chris@gyre.umd.edu  Mon Nov 18 03:08:43 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA14672; Mon, 18 Nov 85 03:08:43 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA01382; Sun, 17 Nov 85 04:49:39 EST
Date: Sun, 17 Nov 85 04:49:39 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511170949.AA01382@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: rlogin has time-critical code that can fail
Status: O

Index: /usr/src/ucb/rlogin.c 4.3Beta

Description:
	The rlogin code calls rcmd() to get a socket.  This socket
	is not owned by anyone (see /sys/sys/uipc_socket.c$socreate(),
	et al.).  rlogin fiddles around for a while, and finally
	(after a fork()) calls reader, which calls fcntl to set
	the owner (so_pgrp) of the socket.

	Unfortunately, the window-size protocol depends on oob()
	noticing the input out-of-band data.  If the reader does
	not get around to setting the process group before the
	rlogin server sends its TIOCPKT_WINDOW message, the oob
	data will arrive at the socket but no signal will be sent
	(cf. /sys/sys/uipc_socket.c$sohasoutofband()).

Repeat-By:
	I have not seen this happen, but it seems like it is just
	waiting to leap out and bite someone on the nose.  (Remember:
	you read it here first :-) .)

Chris

From bloom  Mon Nov 18 09:32:14 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA15397; Mon, 18 Nov 85 09:32:14 PST
From: bloom (Jim Bloom)
Message-Id: <8511181732.AA15397@monet.berkeley.edu>
To: jlarson.pa@Xerox.ARPA
Cc: beta43_bugs@monet.berkeley.edu, VaxcSystem^.pa@Xerox.ARPA
Subject: Re: netstat -h broken
In-Reply-To: Your message of Sat, 16 Nov 85 14:48:06 PST.
	     <851116-144812-236@Xerox>
Date: 18 Nov 85 09:32:10 PST (Mon)
Status: O

It will never work on monet, monet doesn't have an IMP.  We'll
check it on our other machines and see how it behaves.

				Jim

From salkind@nyu-acf8.arpa  Mon Nov 18 19:48:29 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA18687; Mon, 18 Nov 85 19:48:29 PST
Date: Mon, 18 Nov 85 22:47:10 est
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8511190347.AA06265@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Mon, 18 Nov 85 22:47:10 est
To: beta43_bugs@monet.berkeley.edu
Subject: manual page for select(2)
Status: O

It claims readfds, writeffds, and exceptfds are of type (int *), but
actually they are of type (fd_set *).

	Lou

From chris@gyre.umd.edu  Mon Nov 18 20:13:29 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA18759; Mon, 18 Nov 85 20:13:29 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05351; Mon, 18 Nov 85 21:42:31 EST
Date: Mon, 18 Nov 85 21:42:31 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511190242.AA05351@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: quotacheck `makerawname' subroutine is wrong
Status: O

Index: /usr/src/etc/quotacheck.c 4.3Beta

Description:
	quotacheck's code to turn a disk drive name into the
	raw device name fails for drives whose name starts with
	the letter `r'.

Repeat-By:
	Run `quotacheck -v' on a file system which resides on
	an RA81:  You will see

		*** Checking quotas for /dev/ra0a (/)

	(substitute appropriate strings for 0a and /).

Chris

From mcvax!dpk@seismo.CSS.GOV  Tue Nov 19 09:57:22 1985
Received: by monet.berkeley.edu (5.31/1.3)
	id AA20486; Tue, 19 Nov 85 09:57:22 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 19 Nov 85 08:25:42 EST
Received: by mcvax.UUCP; Tue, 19 Nov 85 13:33:54 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 19 Nov 85 13:33:43 +0100 (MET)
Message-Id: <8511191233.AA16221@mcvax.UUCP>
Date:     Tue, 19 Nov 85 13:31:14 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: jaap@seismo.CSS.GOV, dpk@seismo.CSS.GOV
Subject:  Serious bug in "diff -c"
Status: O

The 4.3Beta version of diff still has problems.  The following set of
files exploits a bug that causes the last segment of the diff to not
be written out for a context diff.  I do not have a fix (yet).
"diff -c old new" shows the bug.

: This is a shar archive.  Extract with sh, not csh.
echo 'x old'
sed 's/^X//' <<'________This_Is_The_END________' >>old
X/*
X *                      U U _ W T M A I L . C
X *
X *      Part of the UUCP channel of the MMDF Mail system developed
X *      by Doug Kingston at the US Army, Ballistics Research Laboratory.
X *                              <DPK@BRL>
X *
X *      Low-level IO to handle mail delivery to the UUCP
X *      queuing system.  Calls are made from qu2uu_send.c.
X *
X *                  Original Version November 1981
X */
X
X#include "util.h"
X#include "mmdf.h"
X#include "ch.h"
X#include "ap.h"
X
Xextern struct ll_struct *logptr;
Xextern Chan *curchan;
Xextern char *Uuxstr;
Xextern int errno;
Xextern int pbroke;
X
Xextern int ap_outtype;
Xextern AP_ptr ap_s2tree ();
X
X/*
X *      -----  Variables Local to this Module  -----
X */
Xstatic FILE     *uucpf;                   /* used by POPEN(III) */
Xstatic char     nextnode[LINESIZE];
Xstatic char     who[LINESIZE];
X
X/**/
X
X/*
X *      uu_wtadr() takes the given host and address and generates
X *      a valid uucp style address and verifies that the given host
X *      is in the mapping tables.  If so, it then invokes UUCP with
X *      the appropriate arguments.
X */
Xuu_wtadr (host, adr, sender, realfrom)
X	char    *host, *adr, *sender, *realfrom;
X{
X    char        *index(), *rindex();
X    FILE        *popen();
X    short       result;
X    char        *bangptr;
X    long        timenow;
X    char        linebuf[LINESIZE];
X    char        *p, *lp;
X    AP_ptr      ap, local, domain, route;
X
X    ap_outtype = AP_733;        /* LMCL */
X#ifdef DEBUG
X    ll_log (logptr, LLOGBTR, "uu_wtadr()");
X    ll_log (logptr, LLOGFTR, "host='%s', adr='%s', sender='%s', realfrom='%s'",
X		host, adr, sender, realfrom );
X    ll_log (logptr, LLOGFTR, "ap_outtype = %o", ap_outtype);
X#endif
X
X    strcpy(nextnode,"");
X    strcpy(who,"");
X
X    if ((ap = ap_s2tree (adr)) == (AP_ptr) NOTOK)
X    {
X	ll_log (logptr, LLOGTMP, "Failure to parse address '%s'", adr);
X	return (RP_PARM);
X    }
X    ap_t2parts(ap, (AP_ptr *)0, (AP_ptr *)0, &local, &domain, &route);
X    lp = ap_p2s( (AP_ptr *)0, (AP_ptr *)0, local, domain, route);
X    p = index (lp, '@');
X    if (p != (char *)0)
X	*p = '\0';
X				/* SEK change % route to ! route        */
X				/* Only fix first % to allow for UUCP   */
X				/* -> 822 gatewaying                    */
X    if ((p = rindex (lp, '%')) != (char *) 0)
X    {
X	*p = '\0';
X	if (rindex (lp, '%') == (char *) 0)
X	{
X	    sprintf (linebuf, "%s!%s", ++p, lp);
X	    strcpy (adr, linebuf);
X	}
X	else
X	    *p = '%';
X    }
X    else 
X	strcpy(adr, lp);
X    free (lp);
X
X    ll_log (logptr, LLOGFST, "address = '%s'", adr);
X
X
X    if (host == NULL || host[0] == '\0') strcpy(who, adr);
X    else {
X	    if (!tb_k2val (curchan -> ch_table, TRUE, host, nextnode))
X		return (RP_USER);       /* No such host */
X	    sprintf(who, nextnode, adr);
X    }
X
X    /*
X     *  Now the fun part!     Move all but the first host name into
X     *  "who" buffer and then concatenate on the addressee's name
X     *  to form the UUCP pathname minus the first host.  Remember that
X     *  the address we form is relative to the REMOTE system.
X     */
X    if ((bangptr=index (who, '!')) != NULL)
X    {
X	/* There is at least one relay machine */
X	*bangptr++ = '\0';
X	strcpy (nextnode, who);
X	strcpy(who, bangptr);
X    }
X    else strcpy(nextnode, "");
X    lowerfy (nextnode);                 /* (just to be sure) */
X
X    /*
X     * Fix bug found by lee at Westfield                PJAC
X     */
X#ifdef  notdef
X    sprintf (linebuf, "%s %s!rmail \\(%s\\)", Uuxstr, nextnode, who);
X#else
X    sprintf (linebuf, "%s %s!rmail \\(%s%s\\)",
X		Uuxstr, nextnode, *who=='~' ? "\\\\" : "", who);
X#endif
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR, "calling uux with <%s>", linebuf);
X#endif
X
X    printx ("Queuing UUCP mail for %s via %s...\n",
X		who, nextnode);
X
X    if ((uucpf = popen (linebuf, "w")) == NULL) {
X	ll_log (logptr, LLOGFAT, "can't popen UUX (errno %d)", errno);
X	return (RP_AGN);
X    }
X
X    time (&timenow);
X    fprintf (uucpf, "From %s %.24s remote from %s\n",
X		realfrom, ctime(&timenow), curchan->ch_lname);
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR, "Done uu_wtadr().");
X#endif
X    return (RP_OK);
X}
X/**/
X
X/*
X *      UU_TXTCPY()
X *
X *      The special function of this guy is to grap the "From" line
X *      from the message header and move it to the first line and to
X *      put in standard UUCP form.  There are programs that depend
X *      on this line on less sophisticated systems.  I hate to louse
X *      up a perfectly good RFC733 letter but that's life!
X *
X *      Too refresh your memory, when this module is called, the "From"
X *      line has already been written out onto the pipe.  We now want
X *      copy the rest of the header out onto pipe a line at a time
X *      so that we cat remove the original From line.
X *
X *      SEK - have changed this.  Do not mungle now so we
X *      can use the deliver reformatting.
X *      It seems preferable to leave the orginal From: line
X *      Other sendmail and MMDF systems will prefer this
X *      Older systems will have to lump it
X */
X
Xuu_txtcpy()
X{
X    int     nread;
X    char    buffer[BUFSIZE];
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR," uu_txtcpy()");
X#endif
X
X    qu_rtinit (0L);             /* ready to read the text             */
X
X    while (!pbroke && (rp_gval (qu_rtxt (buffer, &nread)) == RP_OK))
X    {                             /* send the text                      */
X	if (fwrite (buffer, sizeof *buffer, nread, uucpf) == 0) {
X	    ll_log (logptr, LLOGFAT, "write on pipe error (errno %d)", errno);
X	    ll_log (logptr, LLOGFAT, "pclose returned %d", pclose (uucpf));
X	    return (RP_LIO);
X	}
X    }
X
X    fflush(uucpf);              /* see if the pipe broke */
X    if (pbroke) {
X	ll_log (logptr, LLOGFAT, "pipe broke -- probably bad host");
X	pclose(uucpf);
X	return (RP_LIO);
X    }
X
X
X    return (RP_MOK);              /* got the text out                   */
X}
X
X/*
X *      uu_wttend()  --  Cleans up after the UUCP
X */
Xuu_wttend()
X{
X	if (pclose (uucpf) != 0)
X		return (RP_LIO);
X	return (RP_MOK);
X}
X
X/**/
X
X/*
X *      LOWERFY()  -  convert string to lower case
X */
Xlowerfy (strp)
X	char *strp;
X{
X	while (*strp = uptolow (*strp))
X		strp++;
X}
________This_Is_The_END________
echo 'x new'
sed 's/^X//' <<'________This_Is_The_END________' >>new
X/*
X *                      U U _ W T M A I L . C
X *
X *      Part of the UUCP channel of the MMDF Mail system developed
X *      by Doug Kingston at the US Army, Ballistics Research Laboratory.
X *                              <DPK@BRL>
X *
X *      Low-level IO to handle mail delivery to the UUCP
X *      queuing system.  Calls are made from qu2uu_send.c.
X *
X *                  Original Version November 1981
X */
X
X#include "util.h"
X#include "mmdf.h"
X#include "ch.h"
X#include "ap.h"
X
Xextern struct ll_struct *logptr;
Xextern Chan *curchan;
Xextern char *Uuxstr;
Xextern int errno;
Xextern int pbroke;
X
Xextern int ap_outtype;
Xextern AP_ptr ap_s2tree ();
X
X/*
X *      -----  Variables Local to this Module  -----
X */
Xstatic FILE     *uucpf;                   /* used by POPEN(III) */
Xstatic char     nextnode[LINESIZE];
Xstatic char     who[LINESIZE];
X
X/**/
X
X/*
X *      uu_wtadr() takes the given host and address and generates
X *      a valid uucp style address and verifies that the given host
X *      is in the mapping tables.  If so, it then invokes UUCP with
X *      the appropriate arguments.
X */
Xuu_wtadr (host, adr, sender, realfrom)
X	char    *host, *adr, *sender, *realfrom;
X{
X    char        *index(), *rindex();
X    FILE        *popen();
X    short       result;
X    char        *bangptr;
X    long        timenow;
X    char        linebuf[LINESIZE];
X    char        *atp, *percentp, *lp;
X    AP_ptr      ap, local, domain;
X
X    ap_outtype = AP_733;        /* LMCL */
X#ifdef DEBUG
X    ll_log (logptr, LLOGBTR, "uu_wtadr()");
X    ll_log (logptr, LLOGFTR, "host='%s', adr='%s', sender='%s', realfrom='%s'",
X		host, adr, sender, realfrom );
X    ll_log (logptr, LLOGFTR, "ap_outtype = %o", ap_outtype);
X#endif
X
X    strcpy(nextnode,"");
X    strcpy(who,"");
X
X    if ((ap = ap_s2tree (adr)) == (AP_ptr) NOTOK)
X    {
X	ll_log (logptr, LLOGTMP, "Failure to parse address '%s'", adr);
X	return (RP_PARM);
X    }
X    ap_t2parts(ap, (AP_ptr *)0, (AP_ptr *)0, &local, &domain, 0);
X    lp = ap_p2s( (AP_ptr *)0, (AP_ptr *)0, local, domain, 0);
X
X    atp = index (lp, '@');
X    if (atp != (char *)0)
X	*atp++ = '\0';
X    if (lexequ(atp, host))
X	atp = (char *)0;	/* don't make path-to-foo!foo.uucp!user */
X	
X    percentp = rindex (lp, '%');
X    if (percentp != (char *) 0) {
X	*percentp = '\0';
X    	if (atp)
X	    sprintf (adr, "%s!%s!%s", atp, ++percentp, lp);
X    	else
X	    sprintf (adr, "%s!%s", ++percentp, lp);
X    } else if (atp) {
X	sprintf (adr, "%s!%s", atp, lp);
X    } else
X	strcpy(adr, lp);
X    free (lp);
X
X    ll_log (logptr, LLOGFST, "address = '%s'", adr);
X
X    if (host == NULL || host[0] == '\0') strcpy(who, adr);
X    else {
X	    if (!tb_k2val (curchan -> ch_table, TRUE, host, nextnode))
X		return (RP_USER);       /* No such host */
X	    sprintf(who, nextnode, adr);
X    }
X
X    /* Extract first host name for destination */
X    if ((bangptr=index (who, '!')) != NULL)
X    {
X	/* There is at least one relay machine */
X	*bangptr++ = '\0';
X	strcpy (nextnode, who);
X	strcpy(who, bangptr);
X    }
X    else strcpy(nextnode, "");
X
X    sprintf (linebuf, "%s %s!rmail \\(%s%s\\)",
X		Uuxstr, nextnode, *who=='~' ? "\\\\" : "", who);
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR, "calling uux with <%s>", linebuf);
X#endif
X
X    printx ("Queuing UUCP mail for %s via %s...\n",
X		who, nextnode);
X
X    if ((uucpf = popen (linebuf, "w")) == NULL) {
X	ll_log (logptr, LLOGFAT, "can't popen UUX (errno %d)", errno);
X	return (RP_AGN);
X    }
X
X    time (&timenow);
X    fprintf (uucpf, "From %s %.24s remote from %s\n",
X		realfrom, ctime(&timenow), curchan->ch_lname);
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR, "Done uu_wtadr().");
X#endif
X    return (RP_OK);
X}
X/**/
X
X/*
X *      UU_TXTCPY()
X *
X *      The special function of this guy is to grap the "From" line
X *      from the message header and move it to the first line and to
X *      put in standard UUCP form.  There are programs that depend
X *      on this line on less sophisticated systems.  I hate to louse
X *      up a perfectly good RFC733 letter but that's life!
X *
X *      Too refresh your memory, when this module is called, the "From"
X *      line has already been written out onto the pipe.  We now want
X *      copy the rest of the header out onto pipe a line at a time
X *      so that we cat remove the original From line.
X *
X *      SEK - have changed this.  Do not mungle now so we
X *      can use the deliver reformatting.
X *      It seems preferable to leave the orginal From: line
X *      Other sendmail and MMDF systems will prefer this
X *      Older systems will have to lump it
X */
X
Xuu_txtcpy()
X{
X    int     nread;
X    char    buffer[BUFSIZE];
X
X#ifdef DEBUG
X    ll_log (logptr, LLOGFTR," uu_txtcpy()");
X#endif
X
X    qu_rtinit (0L);             /* ready to read the text             */
X
X    while (!pbroke && (rp_gval (qu_rtxt (buffer, &nread)) == RP_OK))
X    {                             /* send the text                      */
X	if (fwrite (buffer, sizeof *buffer, nread, uucpf) == 0) {
X	    ll_log (logptr, LLOGFAT, "write on pipe error (errno %d)", errno);
X	    ll_log (logptr, LLOGFAT, "pclose returned %d", pclose (uucpf));
X	    return (RP_LIO);
X	}
X    }
X
X    fflush(uucpf);              /* see if the pipe broke */
X    if (pbroke) {
X	ll_log (logptr, LLOGFAT, "pipe broke -- probably bad host");
X	pclose(uucpf);
X	return (RP_LIO);
X    }
X
X
X    return (RP_MOK);              /* got the text out                   */
X}
X
X/*
X *      uu_wttend()  --  Cleans up after the UUCP
X */
Xuu_wttend()
X{
X	if (pclose (uucpf) != 0)
X		return (RP_LIO);
X	return (RP_MOK);
X}
X
X/**/
X
X/*
X *      LOWERFY()  -  convert string to lower case
X */
Xlowerfy (strp)
X	char *strp;
X{
X	while (*strp = uptolow (*strp))
X		strp++;
X}
________This_Is_The_END________


From nsc!chongo@decwrl.DEC.COM  Wed Nov 20 12:20:10 1985
Received: by monet.berkeley.edu (5.31/1.4)
	id AA00493; Wed, 20 Nov 85 12:20:10 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA15019; Wed, 20 Nov 85 03:21:44 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA29625; Wed, 20 Nov 85 01:17:29 pst
Date: Wed, 20 Nov 85 01:17:29 pst
From: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Message-Id: <8511200917.AA29625@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: bug in /dev/MAKEDEV
Status: O

/dev/MAKEDEV will not build the /dev files for 6250 BPI tapes (i.e., the files
built by the $twenty rule) because a match is made between the controller
name and full name.  That is, there is a line of the form:

	if [ $i = xy ] ...

where $i takes on values of the form:  xy0, xy1, ....   This means that
if statment is NEVER true and thus the 6250 special file is never built.
I suggest use of a switch statment and let a case of the form: 'xy*' do
the partial match.


chongo <*pheep*> /\43/\

From lam@BBN-VAX.ARPA  Wed Nov 20 13:56:31 1985
Received: by monet.berkeley.edu (5.31/1.4)
	id AA00893; Wed, 20 Nov 85 13:56:31 PST
Message-Id: <8511202156.AA00893@monet.berkeley.edu>
Date:     Wed, 20 Nov 85 16:54:27 EST
From: Karen Lam <lam@BBN-VAX.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject:  concurrency bug in bbnnet ic_output.c
Status: O

Hello,
   A performance enhancement that was made to the bbnnet routine icmp_addr()
(in ic_output.c) causes a concurrency problem.  If the reason icmp_addr()
was called is because ic_timeo() was called to ping somebody, rather
than because some packet came in and set the global inetifp, then
when icmp_addr() calls in_iafromif(inetifp), in_iafromif() will try
to reference a field of the unset inetifp.  This will crash the system.

   The temporary solution is to take out the performance enhancement --
that is, take out the #ifdef bsd42 below, and comment out the call to
in_iafromif().


/sys/bbnnet/ic_output.c:
________________________________________________________________

struct in_addr icmp_addr (ip)
struct ip	*ip;
{
    struct in_ifaddr *ia;

#ifdef bsd42   <============== TAKE THIS OUT ====================

    /* don't want broadcasts to match */
    if (! (ia = in_iawithaddr(ip->ip_dst, FALSE)))
    {
	/* hmm, try for the net... */
	if ((ia = in_iawithnet(ip->ip_dst)) == NULL)
	{
	    struct in_addr l;

	    /*
	     * The message will be sent by ip_send() who will
	     * route the message and discover that a local address
	     * should be set on the basis of the route used.
	     */
	    l.s_addr = INADDR_ANY;
	    return (l);
	}
    }
#endif	<==================== TAKE THIS OUT =======================

/*	<==================== PUT THIS IN =========================
    ia = in_iafromif(inetifp);
*/	<==================== PUT THIS IN =========================

    return (IA_INADDR(ia));
}


---------------------------------------------------------------------

I'm looking into a better solution.

Mike, as a general rule, if I have fixes for the bbnnet code, should
I just go ahead and fix them on monet, and tell you about it, or 
should I report them to you and let you fix them on monet?

Thanks.  How's it going?


Karen


From sutton%lumiere%tektronix.csnet@CSNET-RELAY.ARPA  Fri Nov 22 16:03:47 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA12237; Fri, 22 Nov 85 16:03:47 PST
Received: from tektronix by csnet-relay.csnet id al07029; 22 Nov 85 18:42 EST
From: Carl Sutton <sutton%lumiere%tektronix.csnet@CSNET-RELAY.ARPA>
Received: from lumiere by tektronix with smtp ; 22 Nov 85 13:44:48 PST
Comment: Message received over unauthenticated port at tektronix
Received: by lumiere (5.28/5.12),	id AA15012; Fri, 22 Nov 85 13:43:04 PST
Date: Fri, 22 Nov 85 13:43:04 PST
Message-Id: <8511222143.AA15012@lumiere>
Apparently-To: beta43_bugs%monet.berkeley.edu@csnet-relay
Status: O

Subject: Setsockopt(2) does not support NULL values as it did under 4.2
Index:	/sys/sys/uipc_syscalls.c

Description:
	Under 4.2 the following syntax was legal and provided the 
	correct behavior.
		setsockopt(sock, SOL_SOCKET, SO_KEEPALIVE, 0, 0);
	Under 4.3, this fails with EINVAL because there was no
	value passed in the 'optval' argument.
Repeat-By:
	Run a 4.2binary on a 4.3 system that attemts to set the socket
	options as above.
Fix:
    setsockopt()
    {
    	struct a {
    		int	s;
    		int	level;
    		int	name;
    		caddr_t	val;
    		int	valsize;
    	} *uap = (struct a *)u.u_ap;
    	struct file *fp;
    	struct mbuf *m = NULL;
    
    	fp = getsock(uap->s);
    	if (fp == 0)
    		return;
    	if (uap->valsize > MLEN) {
    		u.u_error = EINVAL;
    		return;
    	}
    	/*
    	 * Support setsockopt(s,level,name,0,0) syntax ala 4.2
    	 * Always allocat an mbuf.
    	 * If old style options, force a non zero value into the 
    	 * mbuf and set the length to sizeof(int).
    	 * tonyb@tek
    	 */
    #define CAN_UNSET \
    (SO_DEBUG|SO_KEEPALIVE|SO_DONTROUTE|SO_USELOOPBACK|SO_BROADCAST|SO_REUSEADDR)
    
    	m = m_get(M_WAIT, MT_SOOPTS);
    	if (m == NULL) {
    		u.u_error = ENOBUFS;
    		return;
    	}
    	if (uap->val) {
    		u.u_error =
    		    copyin(uap->val, mtod(m, caddr_t), (u_int)uap->valsize);
    		if (u.u_error) {
    			(void) m_free(m);
    			return;
    		}
    		m->m_len = uap->valsize;
    	} else {
    		if(uap->name & CAN_UNSET)  {
    			*mtod(m, int *) = ~0;
    			m->m_len = sizeof(int);
    		} else {
    			m_free(m); /* ERROR handled in sosetopt() */
    			m = (struct mbuf *)0;
    		}
    	}
    	u.u_error =
    	    sosetopt((struct socket *)fp->f_data, uap->level, uap->name, m);
    }

From chris@gyre.umd.edu  Sun Nov 24 22:20:38 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA17713; Sun, 24 Nov 85 22:20:38 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA08173; Sat, 23 Nov 85 02:32:49 EST
Date: Sat, 23 Nov 85 02:32:49 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511230732.AA08173@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu, donn@utah-cs.ARPA
Subject: llib-lc has wrong type for fseek()
Status: O

Index: /usr/src/usr.bin/lint/llib-lc 4.3Beta Fix

Description:
	fseek should be long() in llib-lc; it is not.

Repeat-By:
	Examination

Fix:
	Below.

Amazing how a four-character fix can turn into 18 lines,

Chris

RCS file: RCS/llib-lc,v
retrieving revision 1.1
diff -c2 -r1.1 llib-lc
*** /tmp/,RCSt1008164	Sat Nov 23 02:31:37 1985
--- llib-lc	Sat Nov 23 02:29:42 1985
***************
*** 270,274 ****
  	/* VARARGS2 */
  	fscanf( f, s ) FILE *f; char *s; {return(1);}
! 	fseek(f, o, p) FILE *f; long o; { return(0); }
  long	ftell(f) FILE *f; { return(0L); }
  int	fwrite( p, s, n, f ) char *p; FILE *f; {return(0);}
--- 270,274 ----
  	/* VARARGS2 */
  	fscanf( f, s ) FILE *f; char *s; {return(1);}
! long	fseek(f, o, p) FILE *f; long o; { return(0); }
  long	ftell(f) FILE *f; { return(0L); }
  int	fwrite( p, s, n, f ) char *p; FILE *f; {return(0);}

From nsc!chongo@decwrl.DEC.COM  Sun Nov 24 22:21:36 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA17725; Sun, 24 Nov 85 22:21:36 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA06539; Sun, 24 Nov 85 05:20:22 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA03379; Sun, 24 Nov 85 04:38:53 pst
Date: Sun, 24 Nov 85 04:38:53 pst
From: nsc!chongo@decwrl.DEC.COM (Landon Noll)
Message-Id: <8511241238.AA03379@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: ls -li
Status: O

When running ls with the options -li  (long and display inode number) in a
directory with inodes > 99999, a misaligned output results.  The -i option
of ls should output a 6 character field.

chongo <> /\oo/\

From chris@gyre.umd.edu  Sun Nov 24 23:20:38 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA17819; Sun, 24 Nov 85 23:20:38 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA08420; Sat, 23 Nov 85 02:39:26 EST
Date: Sat, 23 Nov 85 02:39:26 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8511230739.AA08420@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu, donn@utah-cs.ARPA
Subject: lint incorrectly complains about pointers to enums
Status: O

Index: /usr/src/lib/mip/optim.c 4.3Beta Fix

Description:
	Passing a pointer to an enum always elicits a lint warning,
	even when the types are correct.

Repeat-By:
	lint the following program:

		enum foo{a};try(bar)enum foo*bar;{try(bar);}

Fix: (from elsie!ado)
	Below.

Chris

*** optim.c.bak	Sun Aug 25 16:55:53 1985
--- optim.c	Sat Nov 23 02:26:35 1985
***************
*** 45,49 ****
--- 45,51 ----
  	TWORD t;
  
+ #ifndef LINT
  	if( (t=BTYPE(p->in.type))==ENUMTY || t==MOETY ) econvert(p);
+ #endif
  	if( oflag ) return(p);
  	ty = optype( o=p->in.op);

From van  Mon Nov 25 00:04:16 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA17753; Mon, 25 Nov 85 00:04:16 PST
From: van (Van Jacobson)
Message-Id: <8511250804.AA17753@monet.berkeley.edu>
To: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
Cc: beta43_bugs@monet.berkeley.edu, jaap@seismo.CSS.GOV, dpk@seismo.CSS.GOV
Subject: Re: Serious bug in "diff -c"
In-Reply-To: Your message of Tue, 19 Nov 85 13:31:14 MET.
Date: 25 Nov 85 00:04:10 PST (Mon)
Status: O

If I'm looking in the right place for the problem, this is a diff
feature, not a bug.  If a group of changes to the old file is 
entirely "deletes", diff -c suppresses the "new" lines (they
would just be a repeat of the lines you saw as context in the
"old" list).  Similarly, if a group of changes to the new file
is entirely "adds", the "old" lines are suppressed.  (The code
that's doing this is in routine dump_context_vec of diffreg.c,
the loops at lines 963 & 967.)

Patch was changed to know about possibly omitted context lines
in the new diff -c format.  Unfortunately, there was a bug if
a change with omitted new context lines was the last thing
in the diff file (as it was in your example).  I've put a quick
fix into patch for this bug (diff -c listing attached).  Larry
Wall has suggested a cleaner fix but it's a lot more work to
code and I probably won't get to it for a couple of weeks.

 - Van

------- patch.c -------
*** /tmp/d17859	Sun Nov 24 23:34:35 1985
--- patch.c	Sun Nov 24 23:28:51 1985
***************
*** 1465,1471 ****
  	    if (ret == Nullch) {
  		if (p_max - p_end < 4)
  		    Strcpy(buf,"  \n");	/* assume blank lines got chopped */
! 		else
  		    fatal("Unexpected end of file in patch.\n");
  	    }
  	    p_input_line++;
--- 1465,1479 ----
  	    if (ret == Nullch) {
  		if (p_max - p_end < 4)
  		    Strcpy(buf,"  \n");	/* assume blank lines got chopped */
! 		else if (p_end == repl_beginning) {
! 		    /* redundant 'new' context lines were omitted - set up */
! 		    /* to fill them in from the the old file's context */
! 		    fillsrc = 1;
! 		    filldst = p_end + 1;
! 		    fillcnt = p_max - repl_beginning;
! 		    p_end = p_max;
! 		    break;
! 		} else
  		    fatal("Unexpected end of file in patch.\n");
  	    }
  	    p_input_line++;

From salkind@nyu-acf8.arpa  Tue Nov 26 16:19:43 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA06557; Tue, 26 Nov 85 16:19:43 PST
Date: Tue, 26 Nov 85 19:18:17 est
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8511270018.AA15303@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Tue, 26 Nov 85 19:18:17 est
To: beta43_bugs@monet.berkeley.edu
Subject: ispunct() under 4.3
Status: O

I was porting some code that was failing mysteriously.  It turns out the
problem was that the definition of ispunct() has changed!

The major difference is that ispunct() now says ' ' (space) is not a
punct character.  Is this really the way you want things?  I would like
to know.

At any rate, I have rewritten the code so that it will work no matter the
definition.

	Lou


From salkind@nyu-acf8.arpa  Tue Nov 26 16:29:26 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA06605; Tue, 26 Nov 85 16:29:26 PST
Date: Tue, 26 Nov 85 19:28:04 est
From: salkind@nyu-acf8.arpa (Lou Salkind)
Message-Id: <8511270028.AA15321@nyu-acf8.arpa>
Received: by nyu-acf8.arpa; Tue, 26 Nov 85 19:28:04 est
To: beta43_bugs@monet.berkeley.edu
Subject: suggestion for sys call
Status: O

I wanted to throw this one out for your consideration:

	setpriority allows you to change the priority of a process,
	process group, or all processes owned by a user.

	kill allows you to signal either a process or a process group.
	However, you can't signal all processes owned by a user

It would be nice if kill, like setpriority, would allow you to
signal on all jobs owned by a single user.

We implemented this here a long time ago (all of about ten lines
in the kernel) and the call has proven to be VERY useful.  Makes it
easy to catch runaway forking programs, etc., etc.  Also modified
/bin/kill to have a syntax like /etc/renice.

You can consider this message just another "what I would like to see
in 4.3" request.  I was just in the mood.

	Lou

From chris@mimsy.umd.edu  Wed Nov 27 12:38:13 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA10568; Wed, 27 Nov 85 12:38:13 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA11283; Wed, 27 Nov 85 15:38:01 EST
Date: Wed, 27 Nov 85 15:38:01 EST
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8511272038.AA11283@mimsy.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: `stty' manual does not mention rows, cols
Status: O

Index: /usr/man/man1/stty.1 4.3Beta

Description:
	The description for `stty rows' and `stty cols' is missing.

Repeat-By:
	% man stty

Chris

From helge@ODIN.GOV.NOR.ARPA  Thu Nov 28 08:09:49 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA12621; Thu, 28 Nov 85 08:09:49 PST
Received: by odin.ARPA (4.12/5.9)
	id AA03414; Thu, 28 Nov 85 17:08:40 -0100
Date: Thu, 28 Nov 85 17:08:40 -0100
From: helge@NTA-ODIN.ARPA (Helge Skrivervik)
Message-Id: <8511281608.AA03414@odin.ARPA>
To: beta43_bugs@monet.berkeley.edu
Status: O

	From oyvind@nta-vax.arpa Thu Nov 28 11:03:42 1985
	Received: from nta-vax.ARPA (tor.ARPA) by odin.ARPA (4.12/5.9)
		id AA02378; Thu, 28 Nov 85 11:03:40 -0100
	Date: Thu, 28 Nov 85 11:05:57 -0100
	From: oyvind@nta-vax.ARPA (Oyvind Hvinden)
	Posted-Date: Thu, 28 Nov 85 11:05:57 -0100
	Message-Id: <8511281005.AA07586@nta-vax.ARPA>
	Received: by nta-vax.ARPA (5.31/3.21)
		id AA07586; Thu, 28 Nov 85 11:05:57 -0100
	To: helge@nta-vax.arpa
	Subject: 4.3 crash
	Cc: paal@nta-vax.arpa
	
	
	Han du sende dette til rette vedkommende p} Berkeley (de vil kontakte bbn
	selv om n|dvendig antar jeg):
	------------------------------------------------------------------------
	I would like to report a problem in the bbnnet code in 4.3.
	I have installed two extra entries in the proto switch as follows:
	
	#ifdef NTA-VAX
	
	{ SOCK_RAW,	&inetdomain,	RAWPROTO,	PR_ATOMIC|PR_ADDR,
	  raw_ip_input,	raw_ip_output,	0,		0,
	  raw_usrreq,
	  raw_init,		0,			0,		0,
	},
	
	{ SOCK_RAW,	&inetdomain,	TP4PROTO,	PR_ATOMIC|PR_ADDR,
	  raw_ip_input,	raw_ip_output,	0,		0,
	  raw_usrreq,
	  raw_init,		0,			0,		0,
	},
	#endif
	
	RAWPROTO is 255, TP4PROTO is 50.
	
	The system crashes on protection fault in the ic_errmsg routine called
	near the end of the ip_input routine. The ip datagram given to ip_input
	from the vv driver (via ipintr) is in two mbufs. The first one contains the
	20 byte ip header starting from offset e8, the header thus fills the 20 
	last bytes of the data space of that mbuf. Then in the next mbuf on offset
	20 hex (12 byte mbuf header + 20 byte vacated ip header space) the TP4
	packet starts.
	ic_errmsg is called with a pointer to the ip header in the first mbuf and 
	a 28 byte lenght parameter. Copying 28 bytes from offset e8 exceeds the
	mbuf with fault as result. This should be fixed.
	I have put a termporary fix in our system, disabling the ic_errmsg call.
	
	Another question is why shall packets destined to just a raw socket be copied
	and the original then discarded with an unreachable message generated?  Raw
	can be used for other things than getting copies of more common type
	packets (e.g udp, tcp). We use raw sockets to develop protocols on ip
	unrelated to other protocols now on top of ip.
	
	-- Oyvind Hvinden
	

From muller@nprdc.arpa  Sat Nov 30 11:30:39 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA00127; Sat, 30 Nov 85 11:30:39 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA03004; Sat, 30 Nov 85 11:10:36 pst
Date: Sat, 30 Nov 85 11:10:36 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8511301910.AA03004@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Status: O

Subject: logouts on modems do not always hang up the line
Index:	src/etc/getty/main.c 4.3BSD

Description:
	Modems, broadband networks and dataswitches depend on DTR drops
	to determine when a user has hung up on a line. However in an
	effort to make these devices "noise tolerant" many of them require
	that DTR remain down for at least 1/2 second. The time from
	init -> getty -> login is so fast on unloaded machines (such as
	8600's) that the time DTR is down can be quite short and is considered
	as "noise" by these devices. As a result these devices never respond
	to the DTR drop with a CARRIER drop, nor do they hangup (in the case
	of a modem).  The problem is that no minimium time is enforced for DTR
	drops (the time from logout to the time getty opens the line), so the 
	problem only occurs under certain low load conditions.
Repeat-By:
	Log into an unloaded machine through one of the following:

	develcon dataswitch
	Ungerman-Bass Net/One
	US robotics password modem

	and then log out. If the port is set up to hang up on close,
	you will not get another prompt (which is correct). If you
	do get a prompt, the time DTR was down was not at least 1/2 
	second.

	Keith Muller
	University of California, San Diego
	muller@nprdc
Fix:

RCS file: RCS/main.c,v
retrieving revision 1.1
diff -c -r1.1 main.c
*** /tmp/,RCSt1003271	Mon Nov 25 16:35:41 1985
--- main.c	Thu Nov 14 10:22:21 1985
***************
*** 136,141
  		strncat(ttyn, argv[2], sizeof(ttyn)-sizeof(dev));
  		chown(ttyn, 0, 0);
  		chmod(ttyn, 0622);
  		while (open(ttyn, O_RDWR) != 0) {
  			if (repcnt % 10 == 0) {
  				syslog(LOG_ERR, "%s: %m", ttyn);

--- 136,145 -----
  		strncat(ttyn, argv[2], sizeof(ttyn)-sizeof(dev));
  		chown(ttyn, 0, 0);
  		chmod(ttyn, 0622);
+ 		/*
+ 		 * Delay the open so DTR stays down long enough to be detected.
+ 		 */
+ 		sleep(2);
  		while (open(ttyn, O_RDWR) != 0) {
  			if (repcnt % 10 == 0) {
  				syslog(LOG_ERR, "%s: %m", ttyn);

From chris@gyre.umd.edu  Sat Nov 30 19:34:41 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA01833; Sat, 30 Nov 85 19:34:41 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA09880; Sat, 30 Nov 85 22:35:05 EST
Date: Sat, 30 Nov 85 22:35:05 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512010335.AA09880@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: timed Makefile is lazy
Status: O

Index: /usr/src/etc/timed/Makefile 4.3Beta Fix

Description:
	The `install' entry in the timed Makefile does not specify
	`-o root'.

Repeat-By:
	Change `install' script to make things owned by `bin' by
	default, then make install.

Fix:
	Below.

(What do you mean `trivial'? :-) )

Chris

RCS file: RCS/Makefile,v
retrieving revision 1.1
diff -c2 -r1.1 Makefile
*** /tmp/,RCSt1009874	Sat Nov 30 22:33:57 1985
--- Makefile	Sat Nov 30 22:31:04 1985
***************
*** 41,45 ****
  install: ${PROGRS}
  	install -s timed ${DESTDIR}/etc
! 	install -s -m 4511 timedc ${DESTDIR}/etc
  
  clean:
--- 41,45 ----
  install: ${PROGRS}
  	install -s timed ${DESTDIR}/etc
! 	install -s -o root -m 4511 timedc ${DESTDIR}/etc
  
  clean:

From chris@gyre.umd.edu  Sun Dec  1 23:43:13 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA05178; Sun, 1 Dec 85 23:43:13 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA12064; Mon, 2 Dec 85 02:01:46 EST
Date: Mon, 2 Dec 85 02:01:46 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512020701.AA12064@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: syslogd is missing a sigsetmask(omask)
Status: O

Index: /usr/src/etc/syslogd.c 4.3Beta Fix

Description:
	The logmsg() function in syslogd can return without restoring
	the old signal mask, if !Initialized and the message needs a
	date added.

Repeat-By:
	Inspection.

Fix:
	Add

		sigsetmask(omask);

	just after the `untty' and before the `return' in the code
	that logs to the console if all else fails.

Chris

From joel@isi-venera.arpa  Mon Dec  2 13:53:50 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA06929; Mon, 2 Dec 85 13:53:50 PST
Received: by isi-venera.arpa (5.31/1.2)
	id AA03008; Mon, 2 Dec 85 11:29:16 PST
Date: Mon 2 Dec 85 11:29:14-PST
From: "Joel Goldberger" <JOEL@isi-venera.arpa>
Subject: Sendmail 5.31 aliasing problem
To: beta43_bugs@monet.berkeley.edu
Cc: Joel@isi-venera.arpa
Message-Id: <VAX-MM(166)+TOPSLIB(114) 2-Dec-85 11:29:14.ISI-VENERA>
Status: O

We use a transformed TOPS-20 aliases file with user names in upper case.
If a local user appears on the RHS of an alias the resolution fails since
the upper case name will not be found by getpwnam in finduser (in recipient.c)

There is a notation in the version log that Eric removed the lowercasing to
allow file name case to be preserved, but it should have been put back in
before this call to getpwnam.  I have installed the following fix in
recipient.c

- Joel Goldberger -

----------------------------------------------------------------------
*** save/recipient.c	Fri Oct 25 16:38:47 1985
--- recipient.c	Mon Dec  2 11:19:41 1985
***************
*** 8,13 ****
--- 8,21 ----
  **  specifies the terms and conditions for redistribution.
  */
  
+ /*  $Header: recipient.c,v 1.2 85/12/02 11:19:22 joel Exp $
+  *
+  *  $Log:	recipient.c,v $
+  * Revision 1.2  85/12/02  11:19:22  joel
+  * Lowercase user name before checking for it in finduser.
+  * 
+  */
+ 
  #ifndef lint
  static char	SccsId[] = "@(#)recipient.c	5.4 (Berkeley) 9/19/85";
  #endif not lint
***************
*** 362,367 ****
--- 370,376 ----
  	}
  
  	/* look up this login name */
+ 	(void) makelower(name);
  	if ((pw = getpwnam(name)) != NULL)
  		return (pw);
  
-------

From mcvax!dpk@seismo.CSS.GOV  Tue Dec  3 05:35:37 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA09042; Tue, 3 Dec 85 05:35:37 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 3 Dec 85 08:24:01 EST
Received: by mcvax.UUCP; Tue, 3 Dec 85 13:25:29 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 3 Dec 85 13:25:18 +0100 (MET)
Message-Id: <8512031225.AA21308@mcvax.UUCP>
Date:     Tue, 3 Dec 85 13:19:02 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Subject:  netstat man page error
Status: O

The nroff directive .BR is used incorrectly.  Just grep for
"AF_".  It should be .B with the second word on the following
line.

-Doug-

From muller@nprdc.arpa  Tue Dec  3 12:38:52 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA10051; Tue, 3 Dec 85 12:38:52 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA02890; Tue, 3 Dec 85 12:38:34 pst
Date: Tue, 3 Dec 85 12:38:34 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8512032038.AA02890@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Status: RO

Subject: odd count dma's fail on emulex dmf, cntr-s control flow too slow
Index:	sys/vaxuba/dmf.c 4.3BSD

Description:
	1) The dmf driver cannot handle emulex dmf's because the emulex
	updates the address in the dma address register by even addresses (for
	unibus speed).  This means that reading this register after an odd
	number of characters are transmitted using dma results gives you an
	address that is one byte greater than the last character transmitted.
	The end result is that the calculation of the number of characters that
	needs to be flushed (by ndflush) is one character too many.
	2) The code that decides to use either dma or silo mode fails in
	that characters can be lost if a silo is full and another write
	is performed to that silo. The current space left in the silo should
	be accounted for when making the decison to use either dma or
	silo mode.
	3) For cntrl-s/cntrl-q control flow to work at 9600 baud (or faster)
	either the silo timeout has to be very small (a real performance
	loss) or the turning off of the transmiter has to be speeded up.
	4) Kernel printf were being done for silo overflows and dma errors.
Repeat-By:
	Run emulex versions of dmfs and do a write of a odd character line
	longer than mindma. The next line output will be missing the first
	character. Use a mix of 300 to 9600 baud terminals on a very loaded
	vax 750 and quite often the terminal running at 9600 buad will have
	their input buffers overflowed (ATT 5620's have this happen quite
	often).
Fix:
	The following diff fixes the problem. The fix is to store more
	information in the softc structure. This includes the state a
	line is in and the dma character count (to be used by ndflush).
	The handling of cntrl-s was speeded up by keeping the state of a
	line (stopped, doing dma, waiting for interrupt) and using this
	information to determine when to turn off the transmitter. The value
	of the silo timeout can be 25 ms instead of 10ms for a mix of lines
	from 300 to 9600 baud with this change.  Even under heavy load
	conditions no characters are lost. For 19200 baud though, 10 ms
	(or less) might be better choice for slow terminals (ATT 5620's)
	which have trouble with cntrl-s/cntrl-q flow.

	Keith Muller
	University of California
	muller@nprdc

RCS file: RCS/dmf.c,v
retrieving revision 1.1
diff -c -r1.1 dmf.c
*** /tmp/,RCSt1004351	Mon Dec  2 13:11:31 1985
--- dmf.c	Mon Dec  2 13:10:44 1985
***************
*** 66,72
  struct	uba_driver dmfdriver =
  	{ dmfprobe, 0, dmfattach, 0, dmfstd, "dmf", dmfinfo };
  
! int	dmf_timeout = 10;		/* silo timeout, in ms */
  int	dmf_mindma = 4;			/* don't dma below this point */
  
  /*

--- 67,73 -----
  struct	uba_driver dmfdriver =
  	{ dmfprobe, 0, dmfattach, 0, dmfstd, "dmf", dmfinfo };
  
! int	dmf_timeout = 25;		/* silo timeout, in ms */
  int	dmf_mindma = 4;			/* don't dma below this point */
  
  /*
***************
*** 119,125
  int	dmf_ubinfo[NUBA];		/* info about allocated unibus map */
  int	cbase[NUBA];			/* base address in unibus map */
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
- char	dmf_dma[NDMF*8];
  
  /*
   * Routine for configuration to set dmf interrupt.

--- 122,127 -----
  int	dmf_ubinfo[NUBA];		/* info about allocated unibus map */
  int	cbase[NUBA];			/* base address in unibus map */
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
  
  #define ST_OFF			1	/* xmtr turned off */
  #define ST_DMA			2	/* xmtr in DMA mode */
***************
*** 121,126
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
  char	dmf_dma[NDMF*8];
  
  /*
   * Routine for configuration to set dmf interrupt.
   */

--- 123,135 -----
  int	cbase[NUBA];			/* base address in unibus map */
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
  
+ #define ST_OFF			1	/* xmtr turned off */
+ #define ST_DMA			2	/* xmtr in DMA mode */
+ #define ST_INT			4	/* xmtr stopped in BUSY */
+ struct dmfa_softc {
+ 	short sc_state;			/* dmf state */
+ 	short sc_count;			/* dmf dma count */
+ } dmfa_softc[NDMF * 8];
  /*
   * Routine for configuration to set dmf interrupt.
   */
***************
*** 263,268
  		tp->t_ispeed = ISPEED;
  		tp->t_ospeed = ISPEED;
  		tp->t_flags = IFLAGS;
  		dmfparam(unit);
  	}
  	/*

--- 276,282 -----
  		tp->t_ispeed = ISPEED;
  		tp->t_ospeed = ISPEED;
  		tp->t_flags = IFLAGS;
+ 		dmfa_softc[unit].sc_state = 0;
  		dmfparam(unit);
  	}
  	/*
***************
*** 555,561
  	register struct dmfdevice *addr;
  	register struct uba_device *ui;
  	register int t;
! 	short cntr;
  
  	ui = dmfinfo[dmf];
  	addr = (struct dmfdevice *)ui->ui_addr;

--- 569,576 -----
  	register struct dmfdevice *addr;
  	register struct uba_device *ui;
  	register int t;
! 	struct dmfa_softc *sc0 = &dmfa_softc[u];
! 	register struct dmfa_softc *sc;
  
  	ui = dmfinfo[dmf];
  	addr = (struct dmfdevice *)ui->ui_addr;
***************
*** 562,568
  	while ((t = addr->dmfcsr) & DMF_TI) {
  		if (t & DMF_NXM)
  			/* SHOULD RESTART OR SOMETHING... */
! 			printf("dmf%d: NXM line %d\n", dmf, t >> 8 & 7);
  		t = t >> 8 & 7;
  		tp = tp0 + t;
  		tp->t_state &= ~TS_BUSY;

--- 577,583 -----
  	while ((t = addr->dmfcsr) & DMF_TI) {
  		if (t & DMF_NXM)
  			/* SHOULD RESTART OR SOMETHING... */
! 			log(LOG_WARNING, "dmf%d: NXM line %d\n", dmf, t >> 8 & 7);
  		t = t >> 8 & 7;
  		tp = tp0 + t;
  		sc = sc0 + t;
***************
*** 565,570
  			printf("dmf%d: NXM line %d\n", dmf, t >> 8 & 7);
  		t = t >> 8 & 7;
  		tp = tp0 + t;
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;

--- 580,586 -----
  			log(LOG_WARNING, "dmf%d: NXM line %d\n", dmf, t >> 8 & 7);
  		t = t >> 8 & 7;
  		tp = tp0 + t;
+ 		sc = sc0 + t;
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
***************
*** 568,583
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
! 		else if (dmf_dma[u + t]) {
! 			/*
! 			 * Do arithmetic in a short to make up
! 			 * for lost 16&17 bits.
! 			 */
! 			addr->dmfcsr = DMFIR_TBA | DMF_IE | t;
! 			cntr = addr->dmftba -
! 			    UBACVT(tp->t_outq.c_cf, ui->ui_ubanum);
! 			ndflush(&tp->t_outq, (int)cntr);
! 		}
  		if (tp->t_line)
  			(*linesw[tp->t_line].l_start)(tp);
  		else

--- 584,592 -----
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
! 		else if (sc->sc_state & ST_DMA)
! 			ndflush(&tp->t_outq, sc->sc_count);
! 		sc->sc_state = 0;
  		if (tp->t_line)
  			(*linesw[tp->t_line].l_start)(tp);
  		else
***************
*** 593,598
  {
  	register struct dmfdevice *addr;
  	register int unit, nch;
  	int s;
  	register int dmf;
  

--- 602,608 -----
  {
  	register struct dmfdevice *addr;
  	register int unit, nch;
+ 	register struct dmfa_softc *sc;
  	int s;
  	register int dmf;
  	register int use_dma;
***************
*** 595,600
  	register int unit, nch;
  	int s;
  	register int dmf;
  
  	unit = minor(tp->t_dev);
  	dmf = unit >> 3;

--- 605,611 -----
  	register struct dmfa_softc *sc;
  	int s;
  	register int dmf;
+ 	register int use_dma;
  
  	unit = minor(tp->t_dev);
  	dmf = unit >> 3;
***************
*** 598,603
  
  	unit = minor(tp->t_dev);
  	dmf = unit >> 3;
  	unit &= 07;
  	addr = (struct dmfdevice *)tp->t_addr;
  

--- 609,615 -----
  
  	unit = minor(tp->t_dev);
  	dmf = unit >> 3;
+ 	sc = &dmfa_softc[unit];
  	unit &= 07;
  	addr = (struct dmfdevice *)tp->t_addr;
  
***************
*** 612,619
  	if (tp->t_state&(TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
  		goto out;
  	/*
! 	 * If there are still characters in the silo,
! 	 * just reenable the transmitter.
  	 */
  	addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
  	if (addr->dmftsc) {

--- 624,630 -----
  	if (tp->t_state&(TS_TIMEOUT|TS_BUSY|TS_TTSTOP))
  		goto out;
  	/*
! 	 * If xmtr turned off, turn back on.
  	 */
  	if (sc->sc_state & ST_OFF){
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
***************
*** 615,622
  	 * If there are still characters in the silo,
  	 * just reenable the transmitter.
  	 */
! 	addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
! 	if (addr->dmftsc) {
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		tp->t_state |= TS_BUSY;

--- 626,632 -----
  	/*
  	 * If xmtr turned off, turn back on.
  	 */
! 	if (sc->sc_state & ST_OFF){
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		sc->sc_state &= ~ST_OFF;
***************
*** 619,626
  	if (addr->dmftsc) {
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
! 		tp->t_state |= TS_BUSY;
! 		goto out;
  	}
  	/*
  	 * If there are sleepers, and output has drained below low

--- 629,640 -----
  	if (sc->sc_state & ST_OFF){
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
! 		sc->sc_state &= ~ST_OFF;
! 		if (sc->sc_state & ST_INT){
! 			sc->sc_state &= ~ST_INT;
! 			tp->t_state |= TS_BUSY;
! 			goto out;
! 		}
  	}
  	/*
  	 * If there are sleepers, and output has drained below low
***************
*** 659,668
  	/*
  	 * If characters to transmit, restart transmission.
  	 */
! 	if (nch >= dmf_mindma) {
! 		register car;
! 
! 		dmf_dma[minor(tp->t_dev)] = 1;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);

--- 673,688 -----
  	/*
  	 * If characters to transmit, restart transmission.
  	 */
! 	if (nch) {
! 		use_dma = 1;
! 		if (nch < dmf_mindma){
! 			/*
! 			 * if not enough space in silo, must use dma
! 			 */
! 			addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
! 			if ((DMF_SILOCNT - addr->dmftsc) >= nch)
! 				use_dma = 0;
! 		}
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		if (use_dma) {
***************
*** 665,678
  		dmf_dma[minor(tp->t_dev)] = 1;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
! 		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);
! 		addr->dmfcsr = DMF_IE | DMFIR_TBA | unit;
! 		addr->dmftba = car;
! 		addr->dmftcc = ((car >> 2) & 0xc000) | nch;
! 		tp->t_state |= TS_BUSY;
! 	} else if (nch) {
! 		register char *cp = tp->t_outq.c_cf;
! 		register int i;
  
  		dmf_dma[minor(tp->t_dev)] = 0;
  		nch = MIN(nch, DMF_SILOCNT);

--- 685,692 -----
  		}
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
! 		if (use_dma) {
! 			register int car;
  
  			sc->sc_count = nch;
  			sc->sc_state |= ST_DMA;
***************
*** 674,687
  		register char *cp = tp->t_outq.c_cf;
  		register int i;
  
! 		dmf_dma[minor(tp->t_dev)] = 0;
! 		nch = MIN(nch, DMF_SILOCNT);
! 		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
! 		addr->dmflctms = addr->dmflctms | DMF_TE;
! 		addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
! 		for (i = 0; i < nch; i++)
! 			addr->dmftbuf = *cp++;
! 		ndflush(&tp->t_outq, nch);
  		tp->t_state |= TS_BUSY;
  	}
  out:

--- 688,709 -----
  		if (use_dma) {
  			register int car;
  
! 			sc->sc_count = nch;
! 			sc->sc_state |= ST_DMA;
! 			car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);
! 			addr->dmfcsr = DMF_IE | DMFIR_TBA | unit;
! 			addr->dmftba = car;
! 			addr->dmftcc = ((car >> 2) & 0xc000) | nch;
! 		} else {
! 			register char *cp = tp->t_outq.c_cf;
! 			register int i;
! 
! 			sc->sc_state &= ~ST_DMA;
! 			addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
! 			for (i = 0; i < nch; i++)
! 				addr->dmftbuf = *cp++;
! 			ndflush(&tp->t_outq, nch);
! 		}
  		tp->t_state |= TS_BUSY;
  	}
  out:
***************
*** 696,702
  	register struct tty *tp;
  {
  	register struct dmfdevice *addr;
! 	register unit = minor(tp->t_dev) & 7;
  	int s;
  
  	addr = (struct dmfdevice *)tp->t_addr;

--- 718,725 -----
  	register struct tty *tp;
  {
  	register struct dmfdevice *addr;
! 	register unit = minor(tp->t_dev);
! 	register struct dmfa_softc *sc = &dmfa_softc[unit];
  	int s;
  
  	addr = (struct dmfdevice *)tp->t_addr;
***************
*** 704,734
  	 * Block input/output interrupts while messing with state.
  	 */
  	s = spltty();
! 	if (flag) {
! 		addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
! 		if (addr->dmftsc) {
! 			/*
! 			 * Flush regardless of whether we're transmitting
! 			 * (TS_BUSY), if the silo contains untransmitted
! 			 * characters.
! 			 */
! 			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
! 			addr->dmflctms = addr->dmflctms | DMF_TE | DMF_FLUSH;
! 			/* this will interrupt so let dmfxint handle the rest */
! 			tp->t_state |= TS_FLUSH|TS_BUSY;
! 		}
! 	} else {
! 		if (tp->t_state & TS_BUSY) {
! 			/*
! 			 * Stop transmission by disabling
! 			 * the transmitter.  We'll pick up where we
! 			 * left off by reenabling in dmfstart.
! 			 */
! 			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
! 			addr->dmflctms = addr->dmflctms &~ DMF_TE;
! 			/* no interrupt here */
! 			tp->t_state &= ~TS_BUSY;
! 		}
  	}
  	splx(s);
  }

--- 727,746 -----
  	 * Block input/output interrupts while messing with state.
  	 */
  	s = spltty();
! 	addr->dmfcsr = DMFIR_LCR | (unit & 7) | DMF_IE;
! 	addr->dmflctms = addr->dmflctms & ~DMF_TE;
! 	sc->sc_state |= ST_OFF;
! 	if ((tp->t_state & TS_TTSTOP) == 0){
! 		tp->t_state |= TS_FLUSH|TS_BUSY;
! 		addr->dmflctms = addr->dmflctms | DMF_FLUSH;
! 	} else if (tp->t_state & TS_BUSY) {
! 		/*
! 		 * Stop transmission by disabling
! 		 * the transmitter.  We'll pick up where we
! 		 * left off by reenabling in dmfstart.
! 		 */
! 		sc->sc_state |= ST_INT;
! 		tp->t_state &= ~TS_BUSY;
  	}
  	splx(s);
  }

From muller@nprdc.arpa  Tue Dec  3 12:38:29 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA10049; Tue, 3 Dec 85 12:38:29 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA02885; Tue, 3 Dec 85 12:38:01 pst
Date: Tue, 3 Dec 85 12:38:01 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8512032038.AA02885@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Status: O

Subject: The parallel printer port of a dmf assumes a simple lineprinter
Index:	sys/vaxuba/dmf.c 4.3BSD

Description:
	1) The parallel printer port on a dmf assumes that it will only be used
	with character printers. This assumption means that the driver will
	truncate lines, map control characters, and insert line feeds and
	newlines. These assumptions prevent the use of the parallel port by
	laser printers and other such printing devices.
	2) Many printers use the offline signal on the parallel port to 
	indicate out of paper. This was incorrectly being treated as a fatal
	error (and was doing a kernel mode print!).
	3) The names given the parallel port csr's had very little meaning.
	4) A parallel port in use was incorrectly returning ENXIO instead
	of EBUSY.
Repeat-By:
	Hook up a printer such as a QMS 1200 or Xerox 9700 to the parallel port
	and try to download a font, the printer hangs.
Fix:
	The following are context diffs on dmfreg.h and dmf.c.
	Keith Muller
	University of California
	muller@nprdc


RCS file: RCS/dmfreg.h,v
retrieving revision 1.1
diff -c -r1.1 dmfreg.h
*** /tmp/,RCSt1004760	Mon Dec  2 13:34:19 1985
--- dmfreg.h	Fri Nov 22 12:05:09 1985
***************
*** 28,35
  		u_short	dmfirw;		/* indirect register word */
  		u_char	dmfirc[2];	/*    "         "    bytes */
  	} dmfun;
! 	short	dmfl[2];
! 	short	dmfd[4];
  };
  
  #define	dmfrsp	dmfrbuf		/* receive silo parameter register (wo) */

--- 28,36 -----
  		u_short	dmfirw;		/* indirect register word */
  		u_char	dmfirc[2];	/*    "         "    bytes */
  	} dmfun;
! 	short	dmfl_ctrl;	/* line printer control register */
! 	short	dmfl_indrct;	/* line printer indirect register */
! 	short	dmfd[4];	/* for dr11 (not implemented) */
  };
  
  #define	dmfrsp	dmfrbuf		/* receive silo parameter register (wo) */
***************
*** 133,138
  #define DMFL_BUFSIZ	512		/* max chars per dma */
  #define DMFL_DEFCOLS	132		/* default # of cols/line <=255 */
  #define DMFL_DEFLINES	66		/* default # of lines/page <=255 */
  
  /*
   *  Bits in the configuration register

--- 134,141 -----
  #define DMFL_BUFSIZ	512		/* max chars per dma */
  #define DMFL_DEFCOLS	132		/* default # of cols/line <=255 */
  #define DMFL_DEFLINES	66		/* default # of lines/page <=255 */
+ #define DMFL_OPTIONS	((1 << 8) | (1 << 9) | (1 << 15))
+ 					/* auto cr, real ff, no lower to upper */
  
  /*
   *  Bits in the configuration register

---------------------end of dmfreg diff-----------------------------------

RCS file: RCS/dmf.c,v
retrieving revision 1.1
diff -c -r1.1 dmf.c
*** /tmp/,RCSt1004351	Mon Dec  2 13:11:31 1985
--- dmf.c	Mon Dec  2 13:10:44 1985
***************
*** 30,36
   *			if 0, 132 will be used.
   * 16-23	number of lines/page on the line printer
   *			if 0, 66 will be used.
!  *
   */
  #include "../machine/pte.h"
  

--- 30,37 -----
   *			if 0, 132 will be used.
   * 16-23	number of lines/page on the line printer
   *			if 0, 66 will be used.
!  * 24		if 1 DO NOT use the auto format mode of the
!  *			line printer parallel port
   */
  #include "../machine/pte.h"
  
***************
*** 93,98
  	unsigned short dmfl_lines;	/* lines per page (66 def.) */
  	unsigned short dmfl_cols; 	/* cols per line (132 def.) */
  	char dmfl_buf[DMFL_BUFSIZ];
  } dmfl_softc[NDMF];
  
  /*

--- 94,100 -----
  	unsigned short dmfl_lines;	/* lines per page (66 def.) */
  	unsigned short dmfl_cols; 	/* cols per line (132 def.) */
  	char dmfl_buf[DMFL_BUFSIZ];
+ 	unsigned short dmfl_format;	/* flag for auto form mode */
  } dmfl_softc[NDMF];
  
  /*
***************
*** 104,109
  #define OPEN 2		/* line printer is open */
  #define ERROR 4		/* error while printing, driver
  			 refuses to do anything till closed */
  
  #ifndef lint
  int	ndmf = NDMF*8;			/* used by iostat */

--- 106,112 -----
  #define OPEN 2		/* line printer is open */
  #define ERROR 4		/* error while printing, driver
  			 refuses to do anything till closed */
+ #define MOREIO 8	/* more data for printer */
  
  #ifndef lint
  int	ndmf = NDMF*8;			/* used by iostat */
***************
*** 190,196
  	printf(".\n");
  
  	if (dmfoptions & DMFC_LP)
! 		dmfaddr->dmfl[0] = DMFL_RESET;
  	/* NEED TO SAVE IT SOMEWHERE FOR OTHER DEVICES */
  	return (sizeof (struct dmfdevice));
  }

--- 199,205 -----
  	printf(".\n");
  
  	if (dmfoptions & DMFC_LP)
! 		dmfaddr->dmfl_ctrl = DMFL_RESET;
  	/* NEED TO SAVE IT SOMEWHERE FOR OTHER DEVICES */
  	return (sizeof (struct dmfdevice));
  }
***************
*** 207,212
  	dmfsoftCAR[ui->ui_unit] = ui->ui_flags & 0xff;
  	dmfl_softc[ui->ui_unit].dmfl_cols = cols==0?DMFL_DEFCOLS:cols;
  	dmfl_softc[ui->ui_unit].dmfl_lines = lines==0?DMFL_DEFLINES:lines;
  }
  
  

--- 216,225 -----
  	dmfsoftCAR[ui->ui_unit] = ui->ui_flags & 0xff;
  	dmfl_softc[ui->ui_unit].dmfl_cols = cols==0?DMFL_DEFCOLS:cols;
  	dmfl_softc[ui->ui_unit].dmfl_lines = lines==0?DMFL_DEFLINES:lines;
+ 	if ((ui->ui_flags >> 24) & 0x1)
+ 		dmfl_softc[ui->ui_unit].dmfl_format = (2 << 8);
+ 	else
+ 		dmfl_softc[ui->ui_unit].dmfl_format = (2 << 8) | DMFL_FORMAT;
  }
  
  
***************
*** 834,841
  
  
  	dmf = DMFL_UNIT(dev) ;
! 	if(((sc= &dmfl_softc[dmf])->dmfl_state & OPEN) ||
! 		((ui=dmfinfo[dmf]) == 0) || ui->ui_alive == 0)
  			return(ENXIO);
  	addr = (struct dmfdevice *)ui->ui_addr;
  	if((addr->dmfl[0] & DMFL_OFFLINE))

--- 846,852 -----
  
  
  	dmf = DMFL_UNIT(dev) ;
! 	if (dmf >= NDMF || (ui = dmfinfo[dmf]) == 0 || ui->ui_alive == 0)
  			return(ENXIO);
  	sc = &dmfl_softc[dmf];
  	if (sc->dmfl_state & OPEN)
***************
*** 837,842
  	if(((sc= &dmfl_softc[dmf])->dmfl_state & OPEN) ||
  		((ui=dmfinfo[dmf]) == 0) || ui->ui_alive == 0)
  			return(ENXIO);
  	addr = (struct dmfdevice *)ui->ui_addr;
  	if((addr->dmfl[0] & DMFL_OFFLINE))
  	{

--- 848,856 -----
  	dmf = DMFL_UNIT(dev) ;
  	if (dmf >= NDMF || (ui = dmfinfo[dmf]) == 0 || ui->ui_alive == 0)
  			return(ENXIO);
+ 	sc = &dmfl_softc[dmf];
+ 	if (sc->dmfl_state & OPEN)
+ 		return(EBUSY);
  	addr = (struct dmfdevice *)ui->ui_addr;
  	if ((addr->dmfl_ctrl & DMFL_OFFLINE)){
  /*
***************
*** 838,846
  		((ui=dmfinfo[dmf]) == 0) || ui->ui_alive == 0)
  			return(ENXIO);
  	addr = (struct dmfdevice *)ui->ui_addr;
! 	if((addr->dmfl[0] & DMFL_OFFLINE))
! 	{
! 		/*printf("dmf: line printer offline/jammed\n");*/
  		return(EIO);
  	}
  	if((addr->dmfl[0]&DMFL_CONV))

--- 852,861 -----
  	if (sc->dmfl_state & OPEN)
  		return(EBUSY);
  	addr = (struct dmfdevice *)ui->ui_addr;
! 	if ((addr->dmfl_ctrl & DMFL_OFFLINE)){
! /*
! 		log(LOG_WARNING, "dmf: line printer offline/jammed\n");
!  */
  		return(EIO);
  	}
  	if ((addr->dmfl_ctrl & DMFL_CONV)){
***************
*** 843,851
  		/*printf("dmf: line printer offline/jammed\n");*/
  		return(EIO);
  	}
! 	if((addr->dmfl[0]&DMFL_CONV))
! 	{
! 		printf("dmf:line printer disconnected\n");
  		return(EIO);
  	}
  

--- 858,865 -----
   */
  		return(EIO);
  	}
! 	if ((addr->dmfl_ctrl & DMFL_CONV)){
! 		log(LOG_WARNING, "dmf: line printer disconnected\n");
  		return(EIO);
  	}
  
***************
*** 849,855
  		return(EIO);
  	}
  
! 	addr->dmfl[0] = 0;
  	sc->dmfl_state |= OPEN;
  	return 0;
  }

--- 863,869 -----
  		return(EIO);
  	}
  
! 	addr->dmfl_ctrl = 0;
  	sc->dmfl_state |= OPEN;
  	return (0);
  }
***************
*** 851,857
  
  	addr->dmfl[0] = 0;
  	sc->dmfl_state |= OPEN;
! 	return 0;
  }
  
  dmflclose(dev,flag)

--- 865,871 -----
  
  	addr->dmfl_ctrl = 0;
  	sc->dmfl_state |= OPEN;
! 	return (0);
  }
  
  dmflclose(dev,flag)
***************
*** 858,864
  dev_t dev;
  int flag;
  {
! 	register int dmf= DMFL_UNIT(dev);
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  
  	dmflout(dev,"\f",1);

--- 872,878 -----
  dev_t dev;
  int flag;
  {
! 	register int dmf = DMFL_UNIT(dev);
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  	register struct uba_device *ui = dmfinfo[dmf];
  
***************
*** 860,865
  {
  	register int dmf= DMFL_UNIT(dev);
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  
  	dmflout(dev,"\f",1);
  	sc->dmfl_state = 0;

--- 874,880 -----
  {
  	register int dmf = DMFL_UNIT(dev);
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
+ 	register struct uba_device *ui = dmfinfo[dmf];
  
  	sc->dmfl_state = 0;
  	if(sc->dmfl_info != 0)
***************
*** 861,867
  	register int dmf= DMFL_UNIT(dev);
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  
- 	dmflout(dev,"\f",1);
  	sc->dmfl_state = 0;
  	if(sc->dmfl_info != 0)
  		ubarelse((struct dmfdevice *)(dmfinfo[dmf])->ui_ubanum,

--- 876,881 -----
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  	register struct uba_device *ui = dmfinfo[dmf];
  
  	sc->dmfl_state = 0;
  	if(sc->dmfl_info != 0)
  		ubarelse(ui->ui_ubanum, &(sc->dmfl_info));
***************
*** 864,874
  	dmflout(dev,"\f",1);
  	sc->dmfl_state = 0;
  	if(sc->dmfl_info != 0)
! 		ubarelse((struct dmfdevice *)(dmfinfo[dmf])->ui_ubanum,
! 			&(sc->dmfl_info));
! 
! 	((struct dmfdevice *)(dmfinfo[dmf]->ui_addr))->dmfl[0]=0;
! 	return 0;
  }
  
  dmflwrite(dev,uio)

--- 878,886 -----
  
  	sc->dmfl_state = 0;
  	if(sc->dmfl_info != 0)
! 		ubarelse(ui->ui_ubanum, &(sc->dmfl_info));
! 	((struct dmfdevice *)ui->ui_addr)->dmfl_ctrl = 0;
! 	return (0);
  }
  
  dmflwrite(dev,uio)
***************
*** 877,883
  {
  	register unsigned int n;
  	register int error;
! 	register struct dmfl_softc *sc;
  
  	sc = &dmfl_softc[DMFL_UNIT(dev)];
  	if(sc->dmfl_state&ERROR) return(EIO);

--- 889,895 -----
  {
  	register unsigned int n;
  	register int error;
! 	register struct dmfl_softc *sc = &dmfl_softc[DMFL_UNIT(dev)];
  
  	if(sc->dmfl_state & ERROR) 
  		return(EIO);
***************
*** 879,893
  	register int error;
  	register struct dmfl_softc *sc;
  
! 	sc = &dmfl_softc[DMFL_UNIT(dev)];
! 	if(sc->dmfl_state&ERROR) return(EIO);
! 	while(n=min(DMFL_BUFSIZ,(unsigned)uio->uio_resid))
! 	{
! 		if(error=uiomove(&sc->dmfl_buf[0],(int)n,
! 			UIO_WRITE,uio))
! 		{
! 			printf("uio move error\n");
! 			return(error);
  		}
  		if(error=dmflout(dev,&sc->dmfl_buf[0],n))
  		{

--- 891,907 -----
  	register int error;
  	register struct dmfl_softc *sc = &dmfl_softc[DMFL_UNIT(dev)];
  
! 	if(sc->dmfl_state & ERROR) 
! 		return(EIO);
! 	while ((n = (unsigned)uio->uio_resid) > 0){
! 		if (n > DMFL_BUFSIZ) {
! 			n = DMFL_BUFSIZ;
! 			sc->dmfl_state |= MOREIO;
! 		}else
! 			sc->dmfl_state &= ~MOREIO;
! 		if (error = uiomove(sc->dmfl_buf, n, UIO_WRITE, uio)){
! 			log(LOG_WARNING, "dmf: line printer uio move error\n");
! 			return (error);
  		}
  		if (error = dmflout(dev, sc->dmfl_buf, n))
  			return(error);
***************
*** 889,896
  			printf("uio move error\n");
  			return(error);
  		}
! 		if(error=dmflout(dev,&sc->dmfl_buf[0],n))
! 		{
  			return(error);
  		}
  	}

--- 903,909 -----
  			log(LOG_WARNING, "dmf: line printer uio move error\n");
  			return (error);
  		}
! 		if (error = dmflout(dev, sc->dmfl_buf, n))
  			return(error);
  	}
  	return (0);
***************
*** 892,898
  		if(error=dmflout(dev,&sc->dmfl_buf[0],n))
  		{
  			return(error);
- 		}
  	}
  	return 0;
  }

--- 905,910 -----
  		}
  		if (error = dmflout(dev, sc->dmfl_buf, n))
  			return(error);
  	}
  	return (0);
  }
***************
*** 894,900
  			return(error);
  		}
  	}
! 	return 0;
  }
  
  

--- 906,912 -----
  		if (error = dmflout(dev, sc->dmfl_buf, n))
  			return(error);
  	}
! 	return (0);
  }
  
  
***************
*** 910,917
  char *cp;
  int n;
  {
! 	register struct dmfl_softc *sc;
! 	register int dmf;
  	register struct uba_device *ui;
  	register struct dmfdevice *d;
  	register unsigned info;

--- 922,929 -----
  char *cp;
  int n;
  {
! 	register int dmf = DMFL_UNIT(dev);
! 	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  	register struct uba_device *ui;
  	register struct dmfdevice *d;
  	register unsigned info;
***************
*** 915,921
  	register struct uba_device *ui;
  	register struct dmfdevice *d;
  	register unsigned info;
! 	register unsigned i;
  
  	dmf = DMFL_UNIT(dev) ;
  	sc= &dmfl_softc[dmf];

--- 927,933 -----
  	register struct uba_device *ui;
  	register struct dmfdevice *d;
  	register unsigned info;
! 	register unsigned s;
  
  	if(sc->dmfl_state & ERROR)
  		return(EIO);
***************
*** 917,927
  	register unsigned info;
  	register unsigned i;
  
! 	dmf = DMFL_UNIT(dev) ;
! 	sc= &dmfl_softc[dmf];
! 	if(sc->dmfl_state&ERROR) return(EIO);
! 	ui= dmfinfo[dmf];
! 	/* allocate unibus resources, will be released when io
  	 * operation is done
  	 */
  	sc->dmfl_info=

--- 929,940 -----
  	register unsigned info;
  	register unsigned s;
  
! 	if(sc->dmfl_state & ERROR)
! 		return(EIO);
! 	ui = dmfinfo[dmf];
! 
! 	/*
! 	 * allocate unibus resources, will be released when io
  	 * operation is done
  	 */
  	if (sc->dmfl_info == 0)
***************
*** 924,939
  	/* allocate unibus resources, will be released when io
  	 * operation is done
  	 */
! 	sc->dmfl_info=
! 	info=
! 		uballoc(ui->ui_ubanum,cp,n,0);
! 	d= (struct dmfdevice *)ui->ui_addr;
! 	d->dmfl[0] = (2<<8) | DMFL_FORMAT; /* indir reg 2 */
! 	/* indir reg auto increments on r/w */
! 	/* SO DON'T CHANGE THE ORDER OF THIS CODE */
! 	d->dmfl[1] = 0; /* prefix chars & num */
! 	d->dmfl[1] = 0; /* suffix chars & num */
! 	d->dmfl[1] = info; 	/* dma lo 16 bits addr */
  
  	/* NOT DOCUMENTED !! */
  	d->dmfl[1] = -n;		/* number of chars */

--- 937,947 -----
  	 * allocate unibus resources, will be released when io
  	 * operation is done
  	 */
! 	if (sc->dmfl_info == 0)
! 		sc->dmfl_info = uballoc(ui->ui_ubanum, cp, n, 0);
! 	info = sc->dmfl_info;
! 	d = (struct dmfdevice *)ui->ui_addr;
! 	d->dmfl_ctrl = sc->dmfl_format; /* indir reg 2 */
  
  	/*
  	 * indir reg auto increments on r/w 
***************
*** 935,943
  	d->dmfl[1] = 0; /* suffix chars & num */
  	d->dmfl[1] = info; 	/* dma lo 16 bits addr */
  
! 	/* NOT DOCUMENTED !! */
! 	d->dmfl[1] = -n;		/* number of chars */
! 	/* ----------^-------- */
  
  	d->dmfl[1] = ((info>>16)&3) /* dma hi 2 bits addr */
  		| (1<<8) /* auto cr insert */

--- 943,958 -----
  	d = (struct dmfdevice *)ui->ui_addr;
  	d->dmfl_ctrl = sc->dmfl_format; /* indir reg 2 */
  
! 	/*
! 	 * indir reg auto increments on r/w 
! 	 * SO DON'T CHANGE THE ORDER OF THIS CODE
! 	 */
! 	d->dmfl_indrct = 0; 		/* prefix chars & num */
! 	d->dmfl_indrct = 0; 		/* suffix chars & num */
! 	d->dmfl_indrct = info; 		/* dma lo 16 bits addr */
! 	d->dmfl_indrct = -n;		/* number of chars in 2's complement */
! 	d->dmfl_indrct = ((info>>16)&3)|DMFL_OPTIONS;  /* dma hi 2 bits addr */
! 	d->dmfl_indrct = sc->dmfl_lines | (sc->dmfl_cols<<8); /* lines per page */
  
  	sc->dmfl_state |= ASLP;
  	s = spltty();
***************
*** 939,950
  	d->dmfl[1] = -n;		/* number of chars */
  	/* ----------^-------- */
  
- 	d->dmfl[1] = ((info>>16)&3) /* dma hi 2 bits addr */
- 		| (1<<8) /* auto cr insert */
- 		| (1<<9) /* use real ff */
- 		| (1<<15); /* no u/l conversion */
- 	d->dmfl[1] = sc->dmfl_lines 	/* lines per page */
- 		| (sc->dmfl_cols<<8);	/* carriage width */
  	sc->dmfl_state |= ASLP;
  	i=spltty();
  	d->dmfl[0] |= DMFL_PEN|DMFL_IE;

--- 954,959 -----
  	d->dmfl_indrct = ((info>>16)&3)|DMFL_OPTIONS;  /* dma hi 2 bits addr */
  	d->dmfl_indrct = sc->dmfl_lines | (sc->dmfl_cols<<8); /* lines per page */
  
  	sc->dmfl_state |= ASLP;
  	s = spltty();
  	d->dmfl_ctrl |= DMFL_PEN | DMFL_IE;
***************
*** 946,960
  	d->dmfl[1] = sc->dmfl_lines 	/* lines per page */
  		| (sc->dmfl_cols<<8);	/* carriage width */
  	sc->dmfl_state |= ASLP;
! 	i=spltty();
! 	d->dmfl[0] |= DMFL_PEN|DMFL_IE;
! 	while(sc->dmfl_state & ASLP)
! 	{
! 		sleep(&sc->dmfl_buf[0],(PZERO+8));
! 		while(sc->dmfl_state&ERROR)
! 		{
! 			timeout(dmflint,dmf,10*hz);
! 			sleep(&sc->dmfl_state,(PZERO+8));
  		}
  		/*if(sc->dmfl_state&ERROR) return (EIO);*/
  	}

--- 955,967 -----
  	d->dmfl_indrct = sc->dmfl_lines | (sc->dmfl_cols<<8); /* lines per page */
  
  	sc->dmfl_state |= ASLP;
! 	s = spltty();
! 	d->dmfl_ctrl |= DMFL_PEN | DMFL_IE;
! 	while(sc->dmfl_state & ASLP) {
! 		sleep((caddr_t)sc->dmfl_buf, (PZERO+8));
! 		while(sc->dmfl_state & ERROR) {
! 			timeout(dmflint, dmf, 15*hz);
! 			sleep((caddr_t)&sc->dmfl_state, (PZERO+8));
  		}
  	}
  	splx(s);
***************
*** 956,962
  			timeout(dmflint,dmf,10*hz);
  			sleep(&sc->dmfl_state,(PZERO+8));
  		}
- 		/*if(sc->dmfl_state&ERROR) return (EIO);*/
  	}
  	splx(i);
  	return(0);

--- 963,968 -----
  			timeout(dmflint, dmf, 15*hz);
  			sleep((caddr_t)&sc->dmfl_state, (PZERO+8));
  		}
  	}
  	splx(s);
  	return(0);
***************
*** 958,964
  		}
  		/*if(sc->dmfl_state&ERROR) return (EIO);*/
  	}
! 	splx(i);
  	return(0);
  }
  /* dmflint -- handle an interrupt from the line printer part of the dmf32

--- 964,970 -----
  			sleep((caddr_t)&sc->dmfl_state, (PZERO+8));
  		}
  	}
! 	splx(s);
  	return(0);
  }
  /*
***************
*** 961,967
  	splx(i);
  	return(0);
  }
! /* dmflint -- handle an interrupt from the line printer part of the dmf32
   *
   */
  

--- 967,974 -----
  	splx(s);
  	return(0);
  }
! /*
!  * dmflint -- handle an interrupt from the line printer part of the dmf32
   *
   */
  
***************
*** 969,976
  int dmf;
  {
  
! 	register struct uba_device *ui;
! 	register struct dmfl_softc *sc;
  	register struct dmfdevice *d;
  
  	ui= dmfinfo[dmf];

--- 976,983 -----
  int dmf;
  {
  
! 	register struct uba_device *ui = dmfinfo[dmf];
! 	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  	register struct dmfdevice *d;
  	short dmfl_stats;
  
***************
*** 972,977
  	register struct uba_device *ui;
  	register struct dmfl_softc *sc;
  	register struct dmfdevice *d;
  
  	ui= dmfinfo[dmf];
  	sc= &dmfl_softc[dmf];

--- 979,985 -----
  	register struct uba_device *ui = dmfinfo[dmf];
  	register struct dmfl_softc *sc = &dmfl_softc[dmf];
  	register struct dmfdevice *d;
+ 	short dmfl_stats;
  
  	d = (struct dmfdevice *)ui->ui_addr;
  	d->dmfl_ctrl &= ~DMFL_IE;
***************
*** 973,988
  	register struct dmfl_softc *sc;
  	register struct dmfdevice *d;
  
! 	ui= dmfinfo[dmf];
! 	sc= &dmfl_softc[dmf];
! 	d= (struct dmfdevice *)ui->ui_addr;
! 
! 	d->dmfl[0] &= ~DMFL_IE;
! 
! 	if(sc->dmfl_state&ERROR)
! 	{
! 		printf("dmfl: intr while in error state \n");
! 		if((d->dmfl[0]&DMFL_OFFLINE) == 0)
  			sc->dmfl_state &= ~ERROR;
  		wakeup(&sc->dmfl_state);
  		return;

--- 981,991 -----
  	register struct dmfdevice *d;
  	short dmfl_stats;
  
! 	d = (struct dmfdevice *)ui->ui_addr;
! 	d->dmfl_ctrl &= ~DMFL_IE;
! 	dmfl_stats = d->dmfl_ctrl;
! 	if (sc->dmfl_state & ERROR) {
! 		if ((dmfl_stats & DMFL_OFFLINE) == 0)
  			sc->dmfl_state &= ~ERROR;
  		wakeup((caddr_t)&sc->dmfl_state);
  		return;
***************
*** 984,990
  		printf("dmfl: intr while in error state \n");
  		if((d->dmfl[0]&DMFL_OFFLINE) == 0)
  			sc->dmfl_state &= ~ERROR;
! 		wakeup(&sc->dmfl_state);
  		return;
  	}
  	if(d->dmfl[0]&DMFL_DMAERR)

--- 987,993 -----
  	if (sc->dmfl_state & ERROR) {
  		if ((dmfl_stats & DMFL_OFFLINE) == 0)
  			sc->dmfl_state &= ~ERROR;
! 		wakeup((caddr_t)&sc->dmfl_state);
  		return;
  	}
  	if (dmfl_stats & DMFL_DMAERR)
***************
*** 987,999
  		wakeup(&sc->dmfl_state);
  		return;
  	}
! 	if(d->dmfl[0]&DMFL_DMAERR)
! 	{
! 		printf("dmf:NXM\n");
! 	}
! 	if(d->dmfl[0]&DMFL_OFFLINE)
! 	{
! 		printf("dmf:printer error\n");
  		sc->dmfl_state |= ERROR;
  	}
  	if(d->dmfl[0]&DMFL_PDONE)

--- 990,999 -----
  		wakeup((caddr_t)&sc->dmfl_state);
  		return;
  	}
! 	if (dmfl_stats & DMFL_DMAERR)
! 		log(LOG_WARNING, "dmf: line printer NXM");
! 	if (dmfl_stats & DMFL_OFFLINE) {
! 		log(LOG_WARNING, "dmf: line printer offline");
  		sc->dmfl_state |= ERROR;
  	}
  #ifdef notdef
***************
*** 996,1003
  		printf("dmf:printer error\n");
  		sc->dmfl_state |= ERROR;
  	}
- 	if(d->dmfl[0]&DMFL_PDONE)
- 	{
  #ifdef notdef
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);

--- 996,1001 -----
  		log(LOG_WARNING, "dmf: line printer offline");
  		sc->dmfl_state |= ERROR;
  	}
  #ifdef notdef
  	if(dmfl_stats & DMFL_PDONE) {
  		printf("bytes= %d\n",d->dmfl[1]);
***************
*** 999,1004
  	if(d->dmfl[0]&DMFL_PDONE)
  	{
  #ifdef notdef
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);
  #endif

--- 997,1003 -----
  		sc->dmfl_state |= ERROR;
  	}
  #ifdef notdef
+ 	if(dmfl_stats & DMFL_PDONE) {
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);
  	}
***************
*** 1001,1007
  #ifdef notdef
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);
- #endif
  	}
  	sc->dmfl_state &= ~ASLP;
  	wakeup(&sc->dmfl_buf[0]);

--- 1000,1005 -----
  	if(dmfl_stats & DMFL_PDONE) {
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);
  	}
  #endif
  	sc->dmfl_state &= ~ASLP;
***************
*** 1003,1008
  		printf("lines= %d\n",d->dmfl[1]);
  #endif
  	}
  	sc->dmfl_state &= ~ASLP;
  	wakeup(&sc->dmfl_buf[0]);
  	if(sc->dmfl_info != 0)

--- 1001,1007 -----
  		printf("bytes= %d\n",d->dmfl[1]);
  		printf("lines= %d\n",d->dmfl[1]);
  	}
+ #endif
  	sc->dmfl_state &= ~ASLP;
  	wakeup((caddr_t)sc->dmfl_buf);
  	if (sc->dmfl_info && (sc->dmfl_state & MOREIO) == 0)
***************
*** 1004,1014
  #endif
  	}
  	sc->dmfl_state &= ~ASLP;
! 	wakeup(&sc->dmfl_buf[0]);
! 	if(sc->dmfl_info != 0)
! 		ubarelse(ui->ui_ubanum,&sc->dmfl_info);
! 	sc->dmfl_info = 0;
! 
  }
  
  /* stubs for interrupt routines for devices not yet supported */

--- 1003,1011 -----
  	}
  #endif
  	sc->dmfl_state &= ~ASLP;
! 	wakeup((caddr_t)sc->dmfl_buf);
! 	if (sc->dmfl_info && (sc->dmfl_state & MOREIO) == 0)
! 		ubarelse(ui->ui_ubanum, &sc->dmfl_info);
  }
  
  /*
***************
*** 1011,1017
  
  }
  
! /* stubs for interrupt routines for devices not yet supported */
  
  dmfsrint() { printf("dmfsrint\n"); }
  

--- 1008,1016 -----
  		ubarelse(ui->ui_ubanum, &sc->dmfl_info);
  }
  
! /*
!  * stubs for interrupt routines for devices not yet supported 
!  */
  
  dmfsrint() 
  { 
***************
*** 1013,1019
  
  /* stubs for interrupt routines for devices not yet supported */
  
! dmfsrint() { printf("dmfsrint\n"); }
  
  dmfsxint() { printf("dmfsxint\n"); }
  

--- 1012,1021 -----
   * stubs for interrupt routines for devices not yet supported 
   */
  
! dmfsrint() 
! { 
! 	log(LOG_WARNING, "dmfsrint\n"); 
! }
  
  dmfsxint() 
  { 
***************
*** 1015,1021
  
  dmfsrint() { printf("dmfsrint\n"); }
  
! dmfsxint() { printf("dmfsxint\n"); }
  
  dmfdaint() { printf("dmfdaint\n"); }
  

--- 1017,1026 -----
  	log(LOG_WARNING, "dmfsrint\n"); 
  }
  
! dmfsxint() 
! { 
! 	log(LOG_WARNING, "dmfsxint\n"); 
! }
  
  dmfdaint()
  {
***************
*** 1017,1023
  
  dmfsxint() { printf("dmfsxint\n"); }
  
! dmfdaint() { printf("dmfdaint\n"); }
  
  dmfdbint() { printf("dmfdbint\n"); }
  

--- 1022,1031 -----
  	log(LOG_WARNING, "dmfsxint\n"); 
  }
  
! dmfdaint()
! {
! 	log(LOG_WARNING, "dmfdaint\n"); 
! }
  
  dmfdbint()
  {
***************
*** 1019,1025
  
  dmfdaint() { printf("dmfdaint\n"); }
  
! dmfdbint() { printf("dmfdbint\n"); }
! 
  
  #endif

--- 1027,1035 -----
  	log(LOG_WARNING, "dmfdaint\n"); 
  }
  
! dmfdbint()
! {
! 	log(LOG_WARNING, "dmfdbint\n"); 
! }
  
  #endif

From PeterKessler.pa@Xerox.ARPA  Tue Dec  3 13:35:35 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA10165; Tue, 3 Dec 85 13:35:35 PST
Received: from Chardonnay.ms by ArpaGateway.ms ; 03 DEC 85 13:34:18 PST
Date: Tue, 3 Dec 85 13:34:08 PST
From: PeterKessler.pa@Xerox.ARPA
Subject: UPPERCASE/lowercase in gethostbyname()
To: beta43_bugs@monet.berkeley.edu
Cc: VaxcSystem^.PA@Xerox.ARPA, PeterKessler.pa@Xerox.ARPA
Reply-To: PeterKessler.pa@Xerox.ARPA
Message-Id: <851203-133418-3853@Xerox>
Status: O

in /usr/src/lib/libc/net/hosttable/gethostnamadr.c: gethostbyname(),
there are two calls to strcmp() that don't take into account that some
people like to refer to host names (e.g. for telnet, ftp, etc.) with
UPPERCASE names (people from berkeley know they would never find
\fIme\fP making this mistake.  :-).  i don't know what the conventions
are, but it seems like an easy thing to fix if you want to make
gethostbyname() case-insensitive.  otherwise you have to find all the
places where it's called (e.g. ftp, telnet, all those unwritten network
hacks) and fix it in each one.
			... peter
p.s. how come there aren't tags files for everything distributed with
the system?

From mcvax!dpk@seismo.CSS.GOV  Tue Dec  3 14:09:47 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA10264; Tue, 3 Dec 85 14:09:47 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 3 Dec 85 16:59:39 EST
Received: by mcvax.UUCP; Tue, 3 Dec 85 21:20:16 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Tue, 3 Dec 85 21:20:11 +0100 (MET)
Message-Id: <8512032020.AA27960@mcvax.UUCP>
Date:     Tue, 3 Dec 85 21:23:38 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: jaap@seismo.CSS.GOV, dpk@seismo.CSS.GOV
Subject:  bug in ufs_namei.c?
Status: O

There is a check for the sign bit in namei around line 270 or so.

dirloop2:
	/*
	 * Copy next component of name to ndp->ni_dent.
	 */
	hash = 0;
	for (i = 0; *cp != 0 && *cp != '/'; cp++) {
		if (i >= MAXNAMLEN) {
			u.u_error = ENAMETOOLONG;
			goto bad;
		}
		if (*cp & 0200)
!!			if ((*cp&0377) == ('/'|0200) || flag != DELETE) {
				u.u_error = EINVAL;
				goto bad;
			}
		ndp->ni_dent.d_name[i++] = *cp;
		hash += (unsigned char)*cp * i;
	}

I think the line marked with "!!" should have && instead of ||.
Am I missing something?

-Doug-

From muller@nprdc.arpa  Wed Dec  4 02:06:57 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA12204; Wed, 4 Dec 85 02:06:57 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA07538; Wed, 4 Dec 85 02:06:48 pst
Date: Wed, 4 Dec 85 02:06:48 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8512041006.AA07538@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Status: O

Subject: odd count dma's fail on emulex dmf, ...... (more)
Index:	sys/vaxuba/dmf.c 4.3BSD

Description:
	Previous report with same Subject: line was missing the following
	change.
Repeat-By:
	As in previous report
Fix:

*** /tmp/,RCSt1008753	Wed Dec  4 01:36:14 1985
--- dmf.c	Wed Dec  4 01:35:44 1985
***************
*** 582,588
  		tp = tp0 + t;
  		sc = sc0 + t;
  		tp->t_state &= ~TS_BUSY;
! 		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
  		else if (sc->sc_state & ST_DMA)
  			ndflush(&tp->t_outq, sc->sc_count);

--- 582,588 -----
  		tp = tp0 + t;
  		sc = sc0 + t;
  		tp->t_state &= ~TS_BUSY;
! 		if (tp->t_state&TS_FLUSH) {
  			tp->t_state &= ~TS_FLUSH;
  			addr->dmfcsr = DMF_IE | DMFIR_LCR | t;
  			addr->dmflctms = addr->dmflctms | DMF_TE;
***************
*** 584,589
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
  		else if (sc->sc_state & ST_DMA)
  			ndflush(&tp->t_outq, sc->sc_count);
  		sc->sc_state = 0;

--- 584,592 -----
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH) {
  			tp->t_state &= ~TS_FLUSH;
+ 			addr->dmfcsr = DMF_IE | DMFIR_LCR | t;
+ 			addr->dmflctms = addr->dmflctms | DMF_TE;
+ 		}
  		else if (sc->sc_state & ST_DMA)
  			ndflush(&tp->t_outq, sc->sc_count);
  		sc->sc_state = 0;

From lam@BBN-VAX.ARPA  Thu Dec  5 11:29:49 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA17545; Thu, 5 Dec 85 11:29:49 PST
Message-Id: <8512051929.AA17545@monet.berkeley.edu>
Date:     Thu, 5 Dec 85 14:26:54 EST
From: Karen Lam <lam@BBN-VAX.ARPA>
To: beta43_bugs@monet.berkeley.edu
Cc: lam@BBN-VAX.ARPA
Subject:  Bug in sendit() and recvit() in /sys/sys/uipc_syscalls.c
Status: O

Here's one that has probably been around for a while (i.e. pre-4.3) ...

     In /sys/sys/uipc_syscalls.c, one of the first tests that the routine 
sendit() performs is to verify that the array of buffer addresses and lengths 
passed by the user is valid.  This is implemented in a loop of the form:

	iov = & iovec;
	for ( i = 0 ; i < iovlen ; i++ ) {
		if ( iov->iov_len < 0 ) {
			u.u_error = EINVAL;
			return;
		}

		if ( iov->iov_len == 0 )
			continue;

		if ( useracc (...) == 0 )
			.
			.

		iov ++;
	}

Note that `iov' will *not* be advanced if the vector it currently points to
specifies a buffer length of zero.  This means that the remaining buffer
addresses and lengths WILL NOT BE VALIDATED!

     The obvious fix is to changed the second `if' to read:

		if ( iov->iov_len == 0 ) {
			iov ++;
			continue;
		}

A more straightforward implementation of the loop would actually be:

	iov = & iovec;
	for ( i = 0 ; i < iovlen ; i++ ) {
		if ( iov->iov_len < 0 ) {
			u.u_error = EINVAL;
			return;
		}

		if ( iov->iov_len != 0 ) {
			if ( useracc (...) == 0 )
				.
				.
		}

		iov ++;
	}

     Note: the routine recvit() (the counterpart to sendit()) has the
same bug.



Karen

From helge@nta-vax.arpa  Thu Dec  5 15:07:12 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA18333; Thu, 5 Dec 85 15:07:12 PST
Date: Fri, 6 Dec 85 00:08:32 -0100
From: helge@nta-vax.ARPA (Helge Skrivervik)
Posted-Date: Fri, 6 Dec 85 00:08:32 -0100
Message-Id: <8512052308.AA05619@nta-vax.ARPA>
Received: by nta-vax.ARPA (5.31/3.21)
	id AA05619; Fri, 6 Dec 85 00:08:32 -0100
To: beta43_bugs@monet.berkeley.edu
Subject: systat
Cc: helge@nta-vax.arpa
Status: O

bombs with 'segmentation fault' when the
'No symbols in Namelist' error occurs (and leaves the terminal
with no echo)

helge

From nsc!jima@decwrl.DEC.COM  Thu Dec  5 15:47:51 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA18616; Thu, 5 Dec 85 15:47:51 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA07234; Thu, 5 Dec 85 15:48:08 pst
Received: by nsc.UUCP (4.12/4.7)
	id AA24166; Thu, 5 Dec 85 15:24:16 pst
Date: Thu, 5 Dec 85 15:24:16 pst
From: nsc!jima@decwrl.DEC.COM (Jim Avera)
Message-Id: <8512052324.AA24166@nsc.UUCP>
To: 43bugs@decwrl.DEC.COM
Subject: awk malloc/free bug fix
Status: O

Awk fix for bad malloc/free usage.
----------------------------------

Awk as distributed with 4.2 BSD, 4.3 BSD (beta release), and AT&T 
system V release 3.0 (beta release) contains bugs which cause malloc'ed
storage to be freed more than once.  Following are fixes for these bugs.

OVERVIEW
  The code in file b.c which builds and destroys "follow sets" frees some
  malloc'ed storage blocks more than once.  On VAX/4.[23] BSD, this has no 
  overt ill effects, but when awk was ported to other environments malloc
  went fatally insane as a reulst of the redundant free() calls.

  The problem is easily demonstrated by linking awk with a version of malloc.c
  compiled with DEBUG defined, which enables checking for redundant frees.

  The present repairman (nsc!jima) doesn't deeply understand the code in b.c, 
  but believes that the fixes given here are correct.  A trace of 
  malloc & free calls was done with several large awk programs, and a 
  mechanical verification showed no missing or redundant free calls.

DESCRIPTION OF CHANGES

1. In cfoll(), the "follow sets" corresponding to tree leaves are created.
   Each LEAF tree node contains an index into the array foll[].  Foll[]
   entries in turn point to dynamically allocated storage blocks containing 
   the actual "follow sets".  To save space, cfoll() reuses the same 
   storage block when identical information is referenced by several 
   foll[] entries.  That is, the foll[i] pointers are not all unique.

   Subsequently, freetr() is called to traverse the tree and release all 
   storage used by the tree, including the "follow set" blocks pointed to
   by the foll[] entries referenced by the leaves.  However, freetr() blindly
   called free() on every foll[] entry referenced by a leaf; when the same
   block was pointed to by several foll[] entries, it was freed several
   times.  To fix this, a new procedure free_foll() has been added which 
   searches for redundant foll[] entries and removes all identical entries at 
   once.  A global variable maxfoll is maintained giving the highest foll[] 
   index used, to avoid searching the entire array.
   
2. In cgotofn(), state[] entries contain pointers to dynamically allocated
   storage blocks, similar to foll[].  All of the state[] blocks are freed 
   near the end of the procedure.  However, state[0] doesn't point to a
   separately allocated block, but is initialized near the beginning of
   cgotofn() to be a copy of foll[0].  Since foll[0] is referenced by a 
   tree node, its storage block is freed when the tree is freed.  This
   caused a redundant free of the block pointed to by free[0] (and state[0]).
   To fix this, cgotofn is modified to avoid freeing state[0] as a special case.

THE FIX CODE 
  Following are the results of diff -c <old b.c> <new b.c> where <old b.c> 
  is the source in the 4.2BSD release, SCCSID "b.c 4.2 8/11/83".  This file
  is essentially identical in 4.3BSD (beta release) and System V.3.0.
  For each change, the lines in the old file are shown first, then the
  corresponding lines in the new file.  "+" in the margin means added line,
  "!" means changed line.  Nothing in margin means an unchanged line, shown
  for context only.

***************
*** 40,45
  
  int	setcnt;
  int	line;
  
  
--- 40,46 -----
  
  int	setcnt;
  int	line;
+ int	maxfoll;  /* index of highest foll[] entry set by cfoll() */
  
***************
*** 91,96  /* in procedure freetr() */
  {
  	switch(type(p)) {
  		LEAF
  			xfree(foll[(int) left(p)]);
  			xfree(p);
  			break;

--- 92,98 -----
  {
  	switch(type(p)) {
  		LEAF
+  			foll_free((int) left(p)); 
  			xfree(p);
  			break;
***************
*** 152,157  /* in procedure cfoll() */
  	int prev;
  	int *add();
  
  	switch(type(v)) {
  		LEAF
  			setcnt = 0;

--- 154,160 -----
  	int prev;
  	int *add();
  
+  	maxfoll = -1;
  	switch(type(v)) {
  		LEAF
  			setcnt = 0;
***************
*** 163,168
  			}
  			else
  				foll[ (int) left(v)] = foll[prev];
  			break;
  		UNARY
  			cfoll(left(v));

--- 166,172 -----
  			}
  			else
  				foll[ (int) left(v)] = foll[prev];
+  			if ((int)left(v) > maxfoll) maxfoll = (int)left(v);
  			break;
  		UNARY
  			cfoll(left(v));
***************
*** 487,494
  			pfa->st = (struct fa *) fatab[2*i];
  		}
  	}
! 	for (i=0; i<=n; i++) {
! 		xfree(state[i]);	/* free state[i] */
  		pfa = where[i];
  		pfa->st = where[0];
  		dprintf("state %d: (%o)\n", i, pfa, NULL);

--- 491,499 -----
  			pfa->st = (struct fa *) fatab[2*i];
  		}
  	}
!  	for (i=0; i<=n; i++) { 
!  		/* N.b. state[0] == foll[0], not separately allocated */
!  		if (i>0) xfree(state[i]);	/* free state[i] */
  		pfa = where[i];
  		pfa->st = where[0];
  		dprintf("state %d: (%o)\n", i, pfa, NULL);
***************
*** 537,539
  	} while(*p++ != 0);
  	return(0);
  }

--- 542,558 -----
  	} while(*p++ != 0);
  	return(0);
  }
+ 
+ /* Free foll[i], taking into account identical foll[] entries.
+    This is necessary because cfoll() uses the same physical follow set for
+    several foll[] entries when the set is identical.  Called by freetr().
+ */
+ foll_free(i)
+ {
+ 	register int j;
+ 	int *p = foll[i];
+ 	if (p==NULL) return;
+ 	for (j=0; j<=maxfoll; j++) 
+ 		if (foll[j]==p) foll[j]=NULL;
+ 	xfree(p);
+ } /* foll_free */

From schoch@orion.ARPA  Thu Dec  5 18:52:58 1985
Received: by monet.berkeley.edu (5.34/1.7)
	id AA19499; Thu, 5 Dec 85 18:52:58 PST
Received: by orion.ARPA (5.31/1.2)
	id AA24468; Thu, 5 Dec 85 18:03:55 PST
Date: Thu, 5 Dec 85 18:03:55 PST
From: Steve Schoch <schoch@orion.ARPA>
Message-Id: <8512060203.AA24468@orion.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: non-super-users can reset flags on an interface
Status: O

Index:	/sys/net/if.c 4.3BSD

Description:
	Ordinary (non-su'd) users can ifconfig an interface down, up, noarp,
	notrailers, etc.  Without ARP, there can be no TCP connections
	on that interface when an arp times-out.  It is kind of anoying
	to have your users shutting down network operations of your machine.
Repeat-By:
	Log in to any account, and type "/etc/ifconfig il0 down".  Then do
	a netstat -i.  The interface is marked down even if you weren't
	root.
Fix:
	Add these two lines to /sys/net/if.c.  For some reason, they
	were deleted between 4.2 and 4.3:
------- if.c -------
259a260,261
> 		if (!suser())
> 			return (u.u_error);
---------------------
ifioctl(so, cmd, data)
	struct socket *so;
	int cmd;
	caddr_t data;
{
	register struct ifnet *ifp;
	register struct ifreq *ifr;

	switch (cmd) {
..
..
..
		return (ENXIO);
	switch (cmd) {

	case SIOCGIFFLAGS:
		ifr->ifr_flags = ifp->if_flags;
		break;

	case SIOCSIFFLAGS:
-->		if (!suser())
-->			return (u.u_error);
		if (ifp->if_flags & IFF_UP && (ifr->ifr_flags & IFF_UP) == 0) {
			int s = splimp();
			if_down(ifp);
			splx(s);
		}
		ifp->if_flags = (ifp->if_flags & IFF_CANTCHANGE) |
			(ifr->ifr_flags &~ IFF_CANTCHANGE);
		if (ifp->if_ioctl)
			(void) (*ifp->if_ioctl)(ifp, cmd, data);
		break;

	default:

From mcvax!dpk@seismo.CSS.GOV  Mon Dec  9 17:33:26 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA08607; Mon, 9 Dec 85 17:33:26 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 9 Dec 85 10:19:53 EST
Received: by mcvax.UUCP; Mon, 9 Dec 85 15:42:19 +0100 (MET)
Received: from SERING.UUCP (sering) by mcvax.UUCP; Mon, 9 Dec 85 15:42:10 +0100 (MET)
Message-Id: <8512091442.AA07421@mcvax.UUCP>
Date:     Mon, 9 Dec 85 15:37:15 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: lamas@brl.arpa, bellcore!jim@seismo.CSS.GOV, sering!jaap@seismo.CSS.GOV,
        sering!dpk@seismo.CSS.GOV
Subject:  Bug in vm_page.c:fodkluster()
Status: RO

The computation of vmax in fodkluster() is incorrect.  The value
in the proc structure is in clicks, the use of btoc (bytes to clicks)
is bogus.  This should be removed.  The effect is to not form klusters
with pages in front of the desired page.

-Doug-

From muller@nprdc.arpa  Mon Dec  9 17:56:21 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA08844; Mon, 9 Dec 85 17:56:21 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA01369; Sun, 8 Dec 85 23:06:30 pst
Date: Sun, 8 Dec 85 23:06:30 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8512090706.AA01369@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Status: O

Subject: Unable to set DECCTLQ on specifc lines with getty
Index:	src/etc/getty/{subr.c init.c gettytab.h} 4.3BSD

Description:
	On many broadband systems (such as Ungerman Bass NET ONE) the
	network interface adaptors are used to match terminal baud
	rates to host baud rates. This done through buffering internal
	to the broadband. For this control flow to work at both ends
	(vax and terminal) the system uses cntrl-s/cntrl-q control flow.
	However if a line is NOT set up for DECCTLQ it restarts on any
	character sent not just cntrl-s. The two network adaptors get
	confused and data is lost. It should be possable to specify in
	gettytab that a line is to have DECCTLQ control flow on it.
Repeat-By:
	Connect to a vax though a Ungerman-Bass NET ONE line and try to
	run any io intensive process with a terminal baus rate less than
	the vaxs baud rate (300 baud terminal to a 9600 baud line).
	Or use a terminal which COUNTS contrl-s and cntrl-q (A ATT 5620
	with version 1.1 or 1.2 proms does this). Unless DECCTLQ is used on
	the line either data will be lost, or in the case of a 5620 the
	terminal will hang.
Fix:
	The following diffs allow DECCTLQ to be specified on a line by line
	basis for getty to set.

	Keith Muller
	University of California
	muller@nprdc

RCS file: RCS/gettytab.h,v
retrieving revision 1.1
diff -c -r1.1 gettytab.h
*** /tmp/,RCSt1009648	Sun Dec  8 22:40:53 1985
--- gettytab.h	Sun Dec  8 22:21:15 1985
***************
*** 104,109
  #define	HC	gettyflags[17].value
  #define UB	gettyflags[18].value
  #define AB	gettyflags[19].value
  
  int	getent();
  long	getnum();

--- 104,110 -----
  #define	HC	gettyflags[17].value
  #define UB	gettyflags[18].value
  #define AB	gettyflags[19].value
+ #define DX	gettyflags[20].value
  
  int	getent();
  long	getnum();

-----------------------------------------------------------------------------

RCS file: RCS/init.c,v
retrieving revision 1.1
diff -c -r1.1 init.c
*** /tmp/,RCSt1009667	Sun Dec  8 22:41:35 1985
--- init.c	Sun Dec  8 22:24:07 1985
***************
*** 87,91
  	{ "hc",	1 },			/* don't set hangup on close */
  	{ "ub", 0 },			/* unbuffered output */
  	{ "ab", 0 },			/* auto-baud detect with '\r' */
  	{ 0 }
  };

--- 87,92 -----
  	{ "hc",	1 },			/* don't set hangup on close */
  	{ "ub", 0 },			/* unbuffered output */
  	{ "ab", 0 },			/* auto-baud detect with '\r' */
+ 	{ "dx", 0 },			/* set decctlq */
  	{ 0 }
  };

  -------------------------------------------------------------------------

RCS file: RCS/subr.c,v
retrieving revision 1.1
diff -c -r1.1 subr.c
*** /tmp/,RCSt1009681	Sun Dec  8 22:42:19 1985
--- subr.c	Sun Dec  8 22:27:50 1985
***************
*** 189,194
  	if (XC)
  		f |= CTLECH;
  
  	return (f);
  }
  

--- 189,197 -----
  	if (XC)
  		f |= CTLECH;
  
+ 	if (DX)
+ 		f |= DECCTQ;
+ 
  	return (f);
  }
  

From lepreau  Tue Dec 10 04:58:29 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA10862; Tue, 10 Dec 85 04:58:29 PST
Date: Tue, 10 Dec 85 04:58:29 PST
From: lepreau (Jay Lepreau)
Message-Id: <8512101258.AA10862@monet.berkeley.edu>
To: beta43_bugs
Subject: Re: gethostbyname case sensitivity
Cc: PeterKessler.pa@xerox
Status: O

We have added the small amount of code needed to force lower case
to hosttable/gethostnamadr.c.  Would you like it?  You have done the
equivalent to the named version, so it ought to be made consistent in
any case.

I stuck in in my home dir on monet, gethostnamadr.c.
(I'll take care of it if you want.)

From @SRI-IU.ARPA:FROMME@SRI-IU  Tue Dec 10 11:30:07 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA11881; Tue, 10 Dec 85 11:30:07 PST
Date: Tue 10 Dec 85 11:29:51-PST
From: Brian Fromme <FROMME@SRI-IU.ARPA>
Subject: C compiler bug
To: karels@UCBVAX.BERKELEY.EDU, beta43_bugs@monet.berkeley.edu
Message-Id: <VAX-MM(164)+TOPSLIB(114)+PONY(0) 10-Dec-85 11:29:51.SRI-IU.ARPA>
Telephone: (415) 859-3448
Postal-Address: 333 Ravenswood Ave, Menlo Park, CA 94025
Status: O

We have found a compiler bug in the 4.3 release.  The nature of the bug is:

When the return value of an integer function is assigned to a floating
point local, an attempt to convert the type of the return value is made
(to a temporary), but then the unchanged register is used instead of the
temporary.  A code example will follow.

I have traked the bug as far as pcc/local2.c, in zzzcode, case 'P'.
The 4.2 compiler generated quite verbose code before to move the value
to a temporary, convert the type of the temporary, then move the temp
back to another register.  This code has been modified since 4.2 to be
more compact.

I may be able to fix the bug here, but would appreciate acknowledgement
as soon as you have a solution, as we have software that we would like
to get running before the next release tape.

Thanx very much.  (example follows)

 Brian
-------

int pixel(a,b,c)
{
	return(60);
}

main()
{
	float p1;

	if ((p1 = pixel(1,2,3)) == 0.0) printf("The c compiler is broken\n");
}

-------- Generated assembly code ---------
.data
.text
LL0:.align	1
.globl	_pixel
.set	L12,0x0
.data
.text
_pixel:.word	L12
movl	$60,r0
ret
.align	1
.globl	_main
.data
.align	2
L22:.double	0d0.00000000000000000000e+00
.text
.data	1
L24:.ascii	"The c compiler is broken\12\0"
.text
.set	L17,0x0
.data
.text
_main:.word	L17
subl2	$4,sp
pushl	$3
pushl	$2
pushl	$1
calls	$3,_pixel
cvtlf	r0,-4(fp)
cmpd	r0,L22		<- "r0" has not been converted to floating pt.
jneq	L21
pushal	L24
calls	$1,_printf
L21:ret
-------

From chris@gyre.umd.edu  Fri Dec 13 16:18:04 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA00568; Fri, 13 Dec 85 16:18:04 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA29261; Fri, 13 Dec 85 16:17:16 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA04599; Mon, 9 Dec 85 05:14:08 EST
Date: Mon, 9 Dec 85 05:14:08 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512091014.AA04599@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: finger daemone is unneccessarily restrictive
Status: O

Index: /usr/src/etc/fingerd.c 4.3Beta Fix

Description:
	The finger daemon allows only one argument (`/w', converted to
	`-l') and one user name.  This is silly.

Repeat-By:
	finger "user1 user2"@host

Fix:
	Below

Chris

RCS file: RCS/fingerd.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1004591	Mon Dec  9 05:12:40 1985
--- /tmp/,RCSt2004591	Mon Dec  9 05:12:41 1985
***************
*** 28,36 ****
  {
  	register char *sp;
! 	char line[512];
  	struct sockaddr_in sin;
  	int i, p[2], pid, status;
  	FILE *fp;
! 	char *av[4];
  
  	i = sizeof (sin);
--- 28,36 ----
  {
  	register char *sp;
! 	char line[1024];
  	struct sockaddr_in sin;
  	int i, p[2], pid, status;
  	FILE *fp;
! 	char *av[100];
  
  	i = sizeof (sin);
***************
*** 55,59 ****
  			while (*sp && !isspace(*sp))
  				sp++;
! 			*sp = '\0';
  		}
  	}
--- 55,59 ----
  			while (*sp && !isspace(*sp))
  				sp++;
! 			*sp++ = '\0';
  		}
  	}

From chris@gyre.umd.edu  Fri Dec 13 16:19:04 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA00576; Fri, 13 Dec 85 16:19:04 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA29271; Fri, 13 Dec 85 16:18:15 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA04838; Mon, 9 Dec 85 06:36:12 EST
Date: Mon, 9 Dec 85 06:36:12 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512091136.AA04838@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: There is no `f' manual
Status: O

Index: /usr/man/man1/f.1 4.3Beta Fix

Description:
	`man f' does not exist.

Repeat-By:
	`man f'

Fix:
	% cat /usr/man/man1/f.1
	.so man1/finger.1
	% rcsdiff -c2 -r1.2 -r1 /usr/man/man1/finger.1
	RCS file: RCS/finger.1,v
	retrieving revision 1.2
	retrieving revision 1.3
	diff -c2 -r1.2 -r1.3
	*** /tmp/,RCSt1004825	Mon Dec  9 06:34:10 1985
	--- /tmp/,RCSt2004825	Mon Dec  9 06:34:12 1985
	***************
	*** 8,12 ****
	  .UC 4
	  .SH NAME
	! finger \- user information lookup program
	  .SH SYNOPSIS
	  .B finger
	--- 8,12 ----
	  .UC 4
	  .SH NAME
	! finger, f \- user information lookup program
	  .SH SYNOPSIS
	  .B finger

Chris

From chris@gyre.umd.edu  Fri Dec 13 16:20:08 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA00585; Fri, 13 Dec 85 16:20:08 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA29295; Fri, 13 Dec 85 16:19:21 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05128; Mon, 9 Dec 85 07:07:02 EST
Date: Mon, 9 Dec 85 07:07:02 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512091207.AA05128@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Mail makefile compiles fmt without -O
Status: O

Index: /usr/src/ucb/Mail/Makefile 4.3Beta Fix

Description:
	`fmt' is compiled unoptimized.  (Big deal.)

Repeat-By:
	cd /usr/src/ucb/Mail; make fmt

Fix:
	Below

Chris

RCS file: RCS/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1005120	Mon Dec  9 07:05:58 1985
--- /tmp/,RCSt2005120	Mon Dec  9 07:05:59 1985
***************
*** 72,76 ****
  
  fmt:	fmt.c head.c
! 	$(CC) fmt.c head.c -o fmt
  	$(RM) fmt.o head.o
  	size fmt
--- 72,76 ----
  
  fmt:	fmt.c head.c
! 	$(CC) $(CFLAGS) fmt.c head.c -o fmt
  	$(RM) fmt.o head.o
  	size fmt

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sat Dec 14 14:59:19 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA03152; Sat, 14 Dec 85 14:59:19 PST
Received: from arizona by csnet-relay.csnet id aa18149; 14 Dec 85 17:48 EST
Received: from bocklin.arizona.uucp (bocklin.ARPA) by arizona.uucp (4.12/3.14)
	id AA07775; Sat, 14 Dec 85 15:22:04 mst
Received: by bocklin.arizona.uucp (4.12/3.14)
	id AA10011; Sat, 14 Dec 85 15:21:07 mst
Date: Sat, 14 Dec 85 15:21:07 mst
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8512142221.AA10011@bocklin.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: accumulated 4.3 buglist?
Status: O

We've been running beta 4.3 on our 8600 for a couple of weeks now
and we've found several problems (mostly minor except for one dealing
with mail aliased into a pipe (fixed in the "lightly tested" version of
sendmail)).

Do you have a list of now-known problems with beta 4.3?  (e.g. whatever
file this mail lands in)  If so, could you mail me it and then I'll
send you back a list of things that we've found that aren't on the list.

Do you by chance happen to have the changes document ready yet?

					Thanks,
					Bill Mitchell

From chris@gyre.umd.edu  Sat Dec 14 20:19:03 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA04336; Sat, 14 Dec 85 20:19:03 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA29357; Fri, 13 Dec 85 16:23:23 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05291; Mon, 9 Dec 85 07:23:08 EST
Date: Mon, 9 Dec 85 07:23:08 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512091223.AA05291@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: `fmt' could be better/fancier
Status: O

Index: /usr/src/ucb/Mail/fmt.c 4.3Beta not-a-bug-but-what-the-heck

Description:
	Oh good grief, this bug filer format does not work well for
	enhancements.

Here are the changes to fmt.c, and to the manual, to add a `goal
length' to fmt as well as a max, producing what typists generally
prefer.  (These were done by someone who knows typing, not by me,
by the way.)

Chris

RCS file: RCS/fmt.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1005282	Mon Dec  9 07:20:58 1985
--- /tmp/,RCSt2005282	Mon Dec  9 07:20:59 1985
***************
*** 13,17 ****
  #ifndef lint
  static char *sccsid = "@(#)fmt.c	5.2 (Berkeley) 6/21/85";
! #endif not lint
  
  #include <stdio.h>
--- 13,17 ----
  #ifndef lint
  static char *sccsid = "@(#)fmt.c	5.2 (Berkeley) 6/21/85";
! #endif
  
  #include <stdio.h>
***************
*** 22,35 ****
   * onto standard output.  Designed for use with Mail ~|
   *
!  * Syntax: fmt [ -width ] [ name ... ]
!  * Author: Kurt Shoens (UCB) 12/7/78
   */
  
  #define	NOSTR	((char *) 0)	/* Null string pointer for lint */
  
  int	pfx;			/* Current leading blank count */
  int	lineno;			/* Current input line */
  int	mark;			/* Last place we saw a head line */
- int	width = 72;		/* Width that we will not exceed */
  
  char	*calloc();		/* for lint . . . */
--- 22,41 ----
   * onto standard output.  Designed for use with Mail ~|
   *
!  * Syntax : fmt [ goal [ max ] ] [ name ... ]
!  * Authors: Kurt Shoens (UCB) 12/7/78;
!  *          Liz Allen (UMCP) 2/24/83 [Addition of goal length concept].
   */
  
+ /* LIZ@UOM 6/18/85 -- Don't need LENGTH any more.
+  * #define	LENGTH	72		Max line length in output
+  */
  #define	NOSTR	((char *) 0)	/* Null string pointer for lint */
  
+ /* LIZ@UOM 6/18/85 --New variables goal_length and max_length */
+ int	goal_length = 65;	/* Target or goal line length in output */
+ int	max_length = 75;	/* Max line length in output */
  int	pfx;			/* Current leading blank count */
  int	lineno;			/* Current input line */
  int	mark;			/* Last place we saw a head line */
  
  char	*calloc();		/* for lint . . . */
***************
*** 43,46 ****
--- 49,53 ----
  
  main(argc, argv)
+ 	int argc;
  	char **argv;
  {
***************
*** 47,52 ****
  	register FILE *fi;
  	register int errs = 0;
! 	register char *cp;
! 	int nofile;
  
  	setout();
--- 54,58 ----
  	register FILE *fi;
  	register int errs = 0;
! 	int number;		/* LIZ@UOM 6/18/85 */
  
  	setout();
***************
*** 53,58 ****
  	lineno = 1;
  	mark = -10;
  	if (argc < 2) {
- single:
  		fmt(stdin);
  		oflush();
--- 59,81 ----
  	lineno = 1;
  	mark = -10;
+ 	/*
+ 	 * LIZ@UOM 6/18/85 -- Check for goal and max length arguments 
+ 	 */
+ 	if (argc > 1 && (1 == (sscanf(argv[1], "%d", &number)))) {
+ 		argv++;
+ 		argc--;
+ 		goal_length = number;
+ 		if (argc > 1 && (1 == (sscanf(argv[1], "%d", &number)))) {
+ 			argv++;
+ 			argc--;
+ 			max_length = number;
+ 		}
+ 	}
+ 	if (max_length <= goal_length) {
+ 		fprintf(stderr, "Max length must be greater than %s\n",
+ 			"goal length");
+ 		exit(1);
+ 	}
  	if (argc < 2) {
  		fmt(stdin);
  		oflush();
***************
*** 59,76 ****
  		exit(0);
  	}
- 	nofile = 1;
  	while (--argc) {
! 		cp = *++argv;
! 		if (*cp == '-') {
! 			width = atoi(cp+1);
! 			if (width <= 0 || width >= BUFSIZ-2) {
! 				fprintf(stderr, "fmt:  bad width: %d\n", width);
! 				exit(1);
! 			}
! 			continue;
! 		}
! 		nofile = 0;
! 		if ((fi = fopen(cp, "r")) == NULL) {
! 			perror(cp);
  			errs++;
  			continue;
--- 82,88 ----
  		exit(0);
  	}
  	while (--argc) {
! 		if ((fi = fopen(*++argv, "r")) == NULL) {
! 			perror(*argv);
  			errs++;
  			continue;
***************
*** 79,84 ****
  		fclose(fi);
  	}
- 	if (nofile)
- 		goto single;
  	oflush();
  	exit(errs);
--- 91,94 ----
***************
*** 90,94 ****
   * and sending each line down for analysis.
   */
- 
  fmt(fi)
  	FILE *fi;
--- 100,103 ----
***************
*** 100,104 ****
  	c = getc(fi);
  	while (c != EOF) {
- 		
  		/*
  		 * Collect a line, doing ^H processing.
--- 109,112 ----
***************
*** 105,109 ****
  		 * Leave tabs for now.
  		 */
- 
  		cp = linebuf;
  		while (c != '\n' && c != EOF && cp-linebuf < BUFSIZ-1) {
--- 113,116 ----
***************
*** 126,130 ****
  		 * Toss anything remaining on the input line.
  		 */
- 
  		while (c != '\n' && c != EOF)
  			c = getc(fi);
--- 133,136 ----
***************
*** 133,137 ****
  		 * Expand tabs on the way to canonb.
  		 */
- 
  		col = 0;
  		cp = linebuf;
--- 139,142 ----
***************
*** 154,158 ****
  		 * Swipe trailing blanks from the line.
  		 */
- 
  		for (cp2--; cp2 >= canonb && *cp2 == ' '; cp2--)
  			;
--- 159,162 ----
***************
*** 171,175 ****
   * it on a line by itself.
   */
- 
  prefix(line)
  	char line[];
--- 175,178 ----
***************
*** 191,195 ****
  	 * when the indent changes due to a paragraph.
  	 */
- 
  	if (np != pfx && (np > pfx || abs(pfx-np) > 8))
  		oflush();
--- 194,197 ----
***************
*** 218,222 ****
   * line packer.
   */
- 
  split(line)
  	char line[];
--- 220,223 ----
***************
*** 224,227 ****
--- 225,229 ----
  	register char *cp, *cp2;
  	char word[BUFSIZ];
+ 	int wordl;		/* LIZ@UOM 6/18/85 */
  
  	cp = line;
***************
*** 228,237 ****
  	while (*cp) {
  		cp2 = word;
  
  		/*
! 		 * Collect a 'word,' allowing it to contain escaped
! 		 * white space.
  		 */
- 
  		while (*cp && *cp != ' ') {
  			if (*cp == '\\' && isspace(cp[1]))
--- 230,239 ----
  	while (*cp) {
  		cp2 = word;
+ 		wordl = 0;	/* LIZ@UOM 6/18/85 */
  
  		/*
! 		 * Collect a 'word,' allowing it to contain escaped white
! 		 * space. 
  		 */
  		while (*cp && *cp != ' ') {
  			if (*cp == '\\' && isspace(cp[1]))
***************
*** 238,251 ****
  				*cp2++ = *cp++;
  			*cp2++ = *cp++;
  		}
  
  		/*
! 		 * Guarantee a space at end of line.
! 		 * Two spaces after end of sentence punctuation.
  		 */
- 
  		if (*cp == '\0') {
  			*cp2++ = ' ';
! 			if (any(cp[-1], ".:!?"))
  				*cp2++ = ' ';
  		}
--- 240,253 ----
  				*cp2++ = *cp++;
  			*cp2++ = *cp++;
+ 			wordl++;/* LIZ@UOM 6/18/85 */
  		}
  
  		/*
! 		 * Guarantee a space at end of line. Two spaces after end of
! 		 * sentence punctuation. 
  		 */
  		if (*cp == '\0') {
  			*cp2++ = ' ';
! 			if (any(cp[-1], ".:!"))
  				*cp2++ = ' ';
  		}
***************
*** 253,257 ****
  			*cp2++ = *cp++;
  		*cp2 = '\0';
! 		pack(word);
  	}
  }
--- 255,262 ----
  			*cp2++ = *cp++;
  		*cp2 = '\0';
! 		/*
! 		 * LIZ@UOM 6/18/85 pack(word); 
! 		 */
! 		pack(word, wordl);
  	}
  }
***************
*** 266,270 ****
   * leading tabs are reinserted.
   */
- 
  char	outbuf[BUFSIZ];			/* Sandbagged output line image */
  char	*outp;				/* Pointer in above */
--- 271,274 ----
***************
*** 273,277 ****
   * Initialize the output section.
   */
- 
  setout()
  {
--- 277,280 ----
***************
*** 285,292 ****
   * line.  If the word is too long to fit all by itself on a line,
   * just give it its own and hope for the best.
   */
  
! pack(word)
  	char word[];
  {
  	register char *cp;
--- 288,308 ----
   * line.  If the word is too long to fit all by itself on a line,
   * just give it its own and hope for the best.
+  *
+  * LIZ@UOM 6/18/85 -- If the new word will fit in at less than the
+  *	goal length, take it.  If not, then check to see if the line
+  *	will be over the max length; if so put the word on the next
+  *	line.  If not, check to see if the line will be closer to the
+  *	goal length with or without the word and take it or put it on
+  *	the next line accordingly.
   */
  
! /*
!  * LIZ@UOM 6/18/85 -- pass in the length of the word as well
!  * pack(word)
!  *	char word[];
!  */
! pack(word,wl)
  	char word[];
+ 	int wl;
  {
  	register char *cp;
***************
*** 295,308 ****
  	if (outp == NOSTR)
  		leadin();
! 	t = strlen(word);
! 	s = outp-outbuf;
! 	if (t+s <= width) {
! 		
  		/*
! 		 * In like flint!
  		 */
! 
! 		for (cp = word; *cp; *outp++ = *cp++)
! 			;
  		return;
  	}
--- 311,329 ----
  	if (outp == NOSTR)
  		leadin();
! 	/*
! 	 * LIZ@UOM 6/18/85 -- change condition to check goal_length; s is the
! 	 * length of the line before the word is added; t is now the length
! 	 * of the line after the word is added
! 	 *	t = strlen(word);
! 	 *	if (t+s <= LENGTH) 
! 	 */
! 	s = outp - outbuf;
! 	t = wl + s;
! 	if ((t <= goal_length) ||
! 	    ((t <= max_length) && (t - goal_length <= goal_length - s))) {
  		/*
! 		 * In like flint! 
  		 */
! 		for (cp = word; *cp; *outp++ = *cp++);
  		return;
  	}
***************
*** 311,316 ****
  		leadin();
  	}
! 	for (cp = word; *cp; *outp++ = *cp++)
! 		;
  }
  
--- 332,336 ----
  		leadin();
  	}
! 	for (cp = word; *cp; *outp++ = *cp++);
  }
  
***************
*** 320,324 ****
   * line prefix.
   */
- 
  oflush()
  {
--- 340,343 ----
***************
*** 334,338 ****
   * output on standard output (finally).
   */
- 
  tabulate(line)
  	char line[];
--- 353,356 ----
***************
*** 344,348 ****
  	 * Toss trailing blanks in the output line.
  	 */
- 
  	cp = line + strlen(line) - 1;
  	while (cp >= line && *cp == ' ')
--- 362,365 ----
***************
*** 353,357 ****
  	 * Count the leading blank space and tabulate.
  	 */
- 
  	for (cp = line; *cp == ' '; cp++)
  		;
--- 370,373 ----
***************
*** 376,380 ****
   * leading blanks.
   */
- 
  leadin()
  {
--- 392,395 ----
***************
*** 392,396 ****
   * a headline detector in head.c
   */
- 
  char *
  savestr(str)
--- 407,410 ----
***************
*** 405,409 ****
  	}
  	copy(str, top);
! 	return(top);
  }
  
--- 419,423 ----
  	}
  	copy(str, top);
! 	return (top);
  }
  
***************
*** 411,415 ****
   * Is s1 a prefix of s2??
   */
- 
  ispref(s1, s2)
  	register char *s1, *s2;
--- 425,428 ----
***************
*** 418,421 ****
  	while (*s1++ == *s2)
  		;
! 	return(*s1 == '\0');
  }
--- 431,434 ----
  	while (*s1++ == *s2)
  		;
! 	return (*s1 == '\0');
  }

RCS file: RCS/fmt.1,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1005252	Mon Dec  9 07:18:44 1985
--- /tmp/,RCSt2005252	Mon Dec  9 07:18:46 1985
***************
*** 11,14 ****
--- 11,15 ----
  .SH SYNOPSIS
  .B fmt
+ [ goal [ maximum ] ]
  [
  name ...
***************
*** 17,25 ****
  .I Fmt
  is a simple text formatter which reads the concatenation of input
! files (or standard input if none are given) and produces on
! standard output a version of its input with lines as close to
! 72 characters long as possible.  The spacing at the beginning
! of the input lines is preserved in the output, as are blank lines
! and interword spacing.
  .PP
  .I Fmt
--- 18,27 ----
  .I Fmt
  is a simple text formatter which reads the concatenation of input
! files (or standard input if none are given) and produces on standard
! output a version of its input with lines as close to the goal length
! as possible without exceeding the maximum.  The goal length defaults
! to 65 and the maximum to 75.  The spacing at the beginning of the
! input lines is preserved in the output, as are blank lines and
! interword spacing.
  .PP
  .I Fmt
***************
*** 41,44 ****
--- 43,48 ----
  .SH AUTHOR
  Kurt Shoens
+ .br
+ Liz Allen (added goal length concept)
  .SH BUGS
  The program was designed to be simple and fast \- for more complex

From chris@gyre.umd.edu  Sat Dec 14 20:33:29 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA04360; Sat, 14 Dec 85 20:33:29 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA29308; Fri, 13 Dec 85 16:20:23 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA04857; Mon, 9 Dec 85 06:40:25 EST
Date: Mon, 9 Dec 85 06:40:25 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512091140.AA04857@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: `finger' manual is missing much information
Status: O

Index: /usr/man/man1/finger.1 4.3Beta Fix

Description:
	Many of the flags to `finger' are missing from the manual
	page.  Some of what it says is hard to correlate with what
	it does.  In general it is in sad shape.

Repeat-By:
	% man finger
	(note no `w' option)
	% finger -w
	(note `w' output)
	(etc)

Fix:
	Below.  Unfortunately, this is what I did for my local
	finger, which is not the same as your finger; but it at
	least has some of the missing information.

Chris

RCS file: RCS/finger.1,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1004842	Mon Dec  9 06:38:39 1985
--- /tmp/,RCSt2004842	Mon Dec  9 06:38:40 1985
***************
*** 11,17 ****
  .SH SYNOPSIS
  .B finger
! [
! options
! ] name ...
  .SH DESCRIPTION
  By default
--- 11,15 ----
  .SH SYNOPSIS
  .B finger
! [ options ] name ...
  .SH DESCRIPTION
  By default
***************
*** 18,30 ****
  .I finger
  lists the login name, full name, terminal name and write status
! (as a '*' before the terminal name if write permission is denied),
  idle time, login time, and office location and phone number
  (if they are known) for each current UNIX user.
! (Idle time is minutes if it is a single integer, hours and minutes if a ':'
! is present, or days and hours if a 'd' is present.)
  .PP
  A longer format also exists and is used by
  .I finger
! whenever a list of peoples names is given.  (Account names as well as
  first and last names of users are accepted.)
  This format is multi-line, and includes all the information described above
--- 16,28 ----
  .I finger
  lists the login name, full name, terminal name and write status
! (as a `*' before the terminal name if write permission is denied),
  idle time, login time, and office location and phone number
  (if they are known) for each current UNIX user.
! (Idle time is minutes if it is a single integer, hours and minutes if a `:'
! is present, or days if a `d' is present.)
  .PP
  A longer format also exists and is used by
  .I finger
! whenever a list of names is given.  (Login names as well as
  first and last names of users are accepted.)
  This format is multi-line, and includes all the information described above
***************
*** 35,56 ****
  directory, and the project on which they are working from the file
  .I \&.project
! also in the home directory.
  .PP
  .I Finger
  options include:
  .TP
- .B \-m
- Match arguments only on user name.
- .TP
  .B \-l
  Force long output format.
  .TP
  .B \-p
! Suppress printing of the
  .I \&.plan
! files
  .TP
! .B \-s
! Force short output format.
  .SH FILES
  .ta 2i
--- 33,95 ----
  directory, and the project on which they are working from the file
  .I \&.project
! also in their home directory.
  .PP
+ .I Name
+ arguments may include users on remote machines in the format
+ .IR user @ host ;
+ this asks the network finger server on the other machine for
+ information.
  .I Finger
+ normally attempts to propagate flag arguments, but this
+ is not standard and may need to be suppressed with the
+ .B -S
+ option in order to get anything from the other machine.
+ .PP
+ .I Finger
  options include:
  .TP
  .B \-l
  Force long output format.
  .TP
+ .B \-b
+ A `briefer' long form; like
+ .B \-l
+ except that the home directory and login shell information is suppressed.
+ .TP
+ .B \-s
+ Force short output format (useful when names are given).
+ .TP
+ .B \-w
+ A `narrow' version; like
+ .B \-s
+ without the full name field.
+ .TP
+ .B \-f
+ Suppress the header on short formats.
+ .TP
  .B \-p
! Suppress printing of
  .I \&.plan
! files (long and brief formats only).
  .TP
! .B \-h
! Suppress printing of
! .I \&.project
! files (long and brief formats only).
! .TP
! .B \-m
! Match
! .I name
! arguments only with login names, not full names.
! .TP
! .B \-S
! Obey the network standard when doing network fingers.  Only the
! `long format' argument will be propagated.  Normally all flags
! are propagated; and under the long format, forwarded mail produces
! a remote finger with the
! .B \-m
! option set as well.  If the remote finger server does not understand
! these options, try using
! .BR \-S .
  .SH FILES
  .ta 2i
***************
*** 64,82 ****
  .br
  ~/.project	projects
  .SH "SEE ALSO"
  chfn(1), w(1), who(1)
  .SH AUTHOR
! Earl T. Cohen
  .SH BUGS
! Only the first line of the
! .I .project
! file is printed.
  .PP
! The encoding of the gcos field is UCB dependent \- it knows that an office
! `197MC' is `197M Cory Hall', and that `529BE' is `529B Evans Hall'.
  .PP
! A user information data base is in the works and will radically alter
! the way the information that
! .I finger
! uses is stored.  Finger will require extensive modification when
! this is implemented.
--- 103,119 ----
  .br
  ~/.project	projects
+ .br
+ ~/.forward	mail forwarding files
  .SH "SEE ALSO"
  chfn(1), w(1), who(1)
  .SH AUTHOR
! Earl T. Cohen wrote the original version of finger.  Chris Torek
! completely rewrote it for the University of Maryland.
  .SH BUGS
! The `\-i' and `\-q' options in the original finger are not supported
! in the current finger.  Then again, they were never documented either.
  .PP
! The overly-restrictive network standard, and thus the `\-S' option,
! is silly.
  .PP
! The number and variety of options is absurd.

From chris@gyre.umd.edu  Mon Dec 16 02:31:51 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA07004; Mon, 16 Dec 85 02:31:51 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA07902; Mon, 16 Dec 85 01:41:26 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA00855; Mon, 16 Dec 85 02:12:08 EST
Received: by gyre.umd.edu (5.9/4.7)
	id AA10744; Mon, 16 Dec 85 02:11:56 EST
Date: Mon, 16 Dec 85 02:11:56 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512160711.AA10744@gyre.umd.edu>
To: beta43_bugs%monet.berkeley.edu@ucbvax.berkeley.edu
Subject: `man' could conceivably dereference a null pointer
Status: O

Index: /usr/src/ucb/man.c 4.3Beta Fix

Description:
	runpath() has a logic error.

Repeat-By:
	Symptomless on Vaxen.

Fix:
	Below.

Chris

(The funny mail path is 'cause the core gateway system is losing again.)

RCS file: RCS/man.c,v
retrieving revision 1.3
retrieving revision 1.4
diff -c2 -r1.3 -r1.4
*** /tmp/,RCSt1010730	Mon Dec 16 02:07:55 1985
--- /tmp/,RCSt2010730	Mon Dec 16 02:07:57 1985
***************
*** 165,169 ****
  {
  
! 	if (ac > 0 && strcmp(av[0], "-M") == 0 || strcmp(av[0], "-P") == 0) {
  		if (ac < 2) {
  			fprintf(stderr, "%s: missing path\n", av[0]);
--- 165,169 ----
  {
  
! 	if (ac > 0 && (strcmp(av[0], "-M") == 0 || strcmp(av[0], "-P") == 0)) {
  		if (ac < 2) {
  			fprintf(stderr, "%s: missing path\n", av[0]);

From mcvax!piet@seismo.CSS.GOV  Tue Dec 17 05:28:23 1985
Received: by monet.berkeley.edu (5.36/1.7)
	id AA10903; Tue, 17 Dec 85 05:28:23 PST
Return-Path: <mcvax!piet>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Tue, 17 Dec 85 08:23:31 EST
Received: by mcvax.UUCP; Tue, 17 Dec 85 13:11:58 +0100 (MET)
Received: by mcvax.UUCP; Tue, 17 Dec 85 13:11:49 +0100 (MET)
Message-Id: <8512171211.AA01366@mcvax.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: sendmail bug
Date: 17 Dec 85 13:11:46 N (Tue)
From: Piet Beertema <mcvax!piet@seismo.CSS.GOV>
Status: RO

There's an apparently long-standing bug in sendmail. Take the following
definitions in a sendmail.cf:

CZxxx yyy zzz

FZfile %[xyz ]

where "file" contains "xxx yyy zzz". (Very useful e.g. if you want to
read your local LAN hostnames plus nicknames from /etc/hosts).

The CZ class definition correctly gives three classes "xxx", "yyy" and
"zzz". But the FZ class definition only gives a class "xxx yyy zzz",
which is NOT split up further; in this case in the rewriting rules "$=Z"
only matches the first class "xxx".

The bug is easily fixed: in the routine fileclass() replace the "class
setting" by the same code as used in the 'C' case.


	Piet

From nsc!chongo@decwrl.DEC.COM  Thu Dec 19 02:53:57 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA17863; Thu, 19 Dec 85 02:53:57 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA13867; Thu, 19 Dec 85 02:55:48 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA01293; Thu, 19 Dec 85 01:46:29 pst
Date: Thu, 19 Dec 85 01:46:29 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 19 Dec 85 01:46:29 pst
Message-Id: <8512190946.AA01293@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: trying to compile sendmail
Status: O

When trying to build sendmail (/usr/src/usr.lib/sendmail) we some unresolved
symbols.  The following symbols:

		_smtpinit
		_smtprcpt
		_smtpdata
		_smtpquit
		_SmtpError
	
are found in the file /usr/src/usr.lib/sendmail/src/usersmtp.c.  However
these functions are blocked by a:

			# ifndef SMTP

line.  Should this be a:

			# ifdef SMTP

or should something else change?  (it does compile when this is done...)

chongo <> /\oo/\

From mcvax!piet@seismo.CSS.GOV  Thu Dec 19 16:03:42 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA02065; Thu, 19 Dec 85 16:03:42 PST
Return-Path: <mcvax!piet>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Thu, 19 Dec 85 14:30:35 EST
Received: by mcvax.UUCP; Thu, 19 Dec 85 17:07:18 +0100 (MET)
Received: by mcvax.UUCP; Thu, 19 Dec 85 17:07:07 +0100 (MET)
Message-Id: <8512191607.AA13212@mcvax.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: sendmail typo
Date: 19 Dec 85 17:07:00 N (Thu)
From: Piet Beertema <mcvax!piet@seismo.CSS.GOV>
Status: O

README-FOR_NAME_SERVER has a typo:

R$+<@$-.ARPA>	$@$<@$[$2.ARPA$]>

should read:

R$+<@$-.ARPA>	$@$1<@$[$2.ARPA$]>



	Piet


From mcvax!piet@seismo.CSS.GOV  Thu Dec 19 16:04:12 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA02078; Thu, 19 Dec 85 16:04:12 PST
Return-Path: <mcvax!piet>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Thu, 19 Dec 85 14:29:43 EST
Received: by mcvax.UUCP; Thu, 19 Dec 85 16:35:15 +0100 (MET)
Received: by mcvax.UUCP; Thu, 19 Dec 85 16:34:56 +0100 (MET)
Message-Id: <8512191534.AA12859@mcvax.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: another sendmail bug
Cc: rick@seismo.CSS.GOV
Date: 19 Dec 85 16:34:52 N (Thu)
From: Piet Beertema <mcvax!piet@seismo.CSS.GOV>
Status: O

arpadate.c, as included in the 4.3 sendmail, gives the wrong sign when
converting the European timezones, e.g. "MET" = "+0100", not "-0100".


	Piet

From SATZ@SU-SIERRA.ARPA  Fri Dec 20 09:19:54 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA06346; Fri, 20 Dec 85 09:19:54 PST
Message-Id: <8512201719.AA06346@monet.berkeley.edu>
Date: Fri 20 Dec 85 09:17:20-PST
From: Greg Satz <SATZ@SU-SIERRA.ARPA>
Subject: open, O_EXCL, and symbolic links
To: beta43_bugs@monet.berkeley.edu
Phone: (415) 497-1004
Status: O

I just discovered that opening a file with O_EXCL causes the namei
lookup in copen to not follow symbolic links. Was there a specific
reason for this change? This arises because my host table build script
relies upon symbolic links to put the .dir and .pag files on another
partition (as my root is not big enough). This stopped working.

Why make the exception for O_EXCL?
-------

From karels  Mon Dec 23 12:30:24 1985
Received: by monet.berkeley.edu (5.38/5.16)
	id AA24376; Mon, 23 Dec 85 12:30:24 PST
From: karels (Mike Karels)
Message-Id: <8512232030.AA24376@monet.berkeley.edu>
To: beta43_sites
Subject: 4.3 back on track
Date: 23 Dec 85 12:30:17 PST (Mon)
Status: O

I am pleased to announce that the political problems which had delayed
the 4.3BSD release have been resolved.  We are therefore on our final
approach to the release, which should happen in 6-8 weeks.  I will
be gone until Jan. 6.  When I return, I will send out diffs and/or pointers
to bug fixes and other changes since the beta release.  If you have
bug reports/fixes/other changes which have not yet been sent in,
please get them to us as soon as possible, preferably by mid-January,
or give us advance warning.  Thanks,

		Mike

From sun!spartan!dwc@ucbvax.berkeley.edu  Thu Dec 26 17:09:03 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA00671; Thu, 26 Dec 85 17:09:03 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA05417; Thu, 26 Dec 85 17:08:56 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA14254; Thu, 26 Dec 85 17:04:24 PST
Received: from spartan.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA03112; Thu, 26 Dec 85 17:02:23 PST
Received: by spartan.sun.uucp (3.0/SMI-3.0DEV3)
	id AA14313; Thu, 26 Dec 85 17:04:15 PST
Date: Thu, 26 Dec 85 17:04:15 PST
From: sun!spartan!dwc@ucbvax.berkeley.edu (Don Cragun)
Message-Id: <8512270104.AA14313@spartan.sun.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: Bug in link system call
Cc: datsun!shannon
Status: O

Subject: link() does not check for link count overflow
Index:  kernel
Category:  other(link system call)
Severity:  2
Status:  open

Release:  detected in 4.3beta, probably present in several other systems
Customer:  Don Cragun, Sun Microsystems
Description:
        Some system verification tests fail because the link() sytem call code
        in sys/ufs_syscalls.c does not check for the link count overflowing a
	signed short.  In fact, the code will allow 65535 links to be created,
	but none of the links can be removed after 32767 links have been
	created.  If 65535 links to a file exist and another link is made, the
	link will succeed, but all further attempts to use the file will fail
	because the link count will have wrapped to 0.
Repeat-By:
        You don't want to repeat this.  It will cause severe headaches while
        trying to patch the destroyed file system back to a sane state.  It
        could be repeated by using the following in sh:
                i=2
                >1 
                while [ $i -lt 32769 ]
                do
                        ln 1 $i
                        i=`expr $i + 1`
                done
        Note that the C version of this will run for over 30 hours on a Sun 2.
Fix:
	Put the "#define MAXLINK 32767"*** back in param.h and change the
	following line of code in link():
                ip->i_nlink++;
        to:
                if(ip->i_nlink == MAXLINK) {
			u.u_error = EMLINK;
                        iput(ip);
                        return;
                }
                ip->i_nlink++;
	
	*** Note: You may want to define MAXLINK as some smaller value.  System
	V uses 1000.  I can't imagine any legitimate need for more than 1000
	links to a file.
Date-resolved:
Resolution:

	Thanks,
	Don Cragun,
	(amdahl | ihnp4 | ucbvax)!sun!dwc
	(415)960-7487

From sun!shannon@ucbvax.berkeley.edu  Thu Dec 26 19:33:30 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA00794; Thu, 26 Dec 85 19:33:30 PST
Received: by ucbvax.berkeley.edu (5.31/1.7)
	id AA06510; Thu, 26 Dec 85 19:33:23 PST
Received: by sun.uucp (3.0-/SMI-2.0)
	id AA14695; Thu, 26 Dec 85 18:32:39 PST
Date: Thu, 26 Dec 85 18:32:39 PST
From: sun!shannon@ucbvax.berkeley.edu (Bill Shannon)
Message-Id: <8512270232.AA14695@sun.uucp>
Subject: unused macros in systm.h
Index: 	sys/h/systm.h 4.3BSD
To: beta43_bugs@monet.berkeley.edu
Status: O

Description:
	The macros queue() and dequeue() are defined at the end of
	systm.h but are never used.
Repeat-By:
	Remove the definitions of the macros and rebuild the entire
	system, noting that it still builds just fine.
Fix:
	Remove the macros.

From obrien@rand-unix.ARPA  Mon Dec 30 12:39:31 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA07309; Mon, 30 Dec 85 12:39:31 PST
Return-Path: <obrien@rand-unix.ARPA>
Received: by rand-unix.ARPA; Mon, 30 Dec 85 11:49:58 pst
From: Michael O'Brien <obrien@rand-unix.ARPA>
Message-Id: <8512301949.AA20423@rand-unix.ARPA>
Date: 30 Dec 85 11:49:55 PST (Mon)
To: beta43_bugs@monet.berkeley.edu
Cc: terry@rand-unix.ARPA, guyton@rand-unix.ARPA
Subject: sys/vax/autoconf.c
Status: O


	Description: MBA with nothing on it hangs machine on second boot.
		     We gave a disk back to DEC but kept the MBA.  We
		     plugged a Massbus terminator directly into the MBA
		     jack on the back of the 750.  This was MBA0.  Tape
		     drive was still on MBA1.  When the machine was first
		     turned on it booted just fine, saw both mba's.  Any
		     subsequent reboot would hang during autoconfig after
		     printing the line for mba0.  Power had to be cycled
		     to allow a reboot.  Very reproducible.

	Know fix: We moved the tape drive to MBA0 and built a kernel that
		  didn't know about MBA1.  It still found MBA1 at boot
		  but at least it doesn't hang on a reboot now.  Configuring
		  a kernel that knows about mba1 but not mba0, and leaving
		  the tape on mba1, doesn't work.  It still hangs on
		  reboot after printing the line about mba0.

From obrien@rand-unix.ARPA  Mon Dec 30 17:53:53 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08241; Mon, 30 Dec 85 17:53:53 PST
Return-Path: <obrien@rand-unix.ARPA>
Received: by rand-unix.ARPA; Mon, 30 Dec 85 11:44:04 pst
From: Michael O'Brien <obrien@rand-unix.ARPA>
Message-Id: <8512301944.AA20350@rand-unix.ARPA>
Date: 30 Dec 85 11:43:59 PST (Mon)
To: beta43_bugs@monet.berkeley.edu
Subject: cmd/etc/cron.c
Status: O


	Description: documentation doesn't mention the new "user"
		     field in /usr/lib/crontab.

	To reproduce: try putting in an old format entry: it won't
		      be run.

From sjk@sri-spam.ARPA  Mon Dec 30 18:02:46 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08288; Mon, 30 Dec 85 18:02:46 PST
Received: by sri-spam.arpa (5.4/4.16)
	id AA07015; Mon, 30 Dec 85 18:03:20 PST
Date: Mon, 30 Dec 85 18:03:20 PST
From: sjk@sri-spam.ARPA (Scott J. Kramer)
Message-Id: <8512310203.AA07015@sri-spam.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: sprintf() documentation
Status: O

One of our users noticed this difference between Berkeley and Bell UNIX:

    Date: 30 Dec 85 17:04:21 PST (Mon)
    To: sjk@sri-spam
    Subject: printf family of routines
    From: Tim Ehrhart <ehrhart@sri-spam>

    Scott, 
    I think we have a case of Bell vs. Berkley here. On Bell versions
    of UNIX this family is all integer functions which return the
    number of characters trans- mitted. The boys from Berkeley return
    the status from an "ferror" call in printf and fprintf and return
    the string pointer in sprintf. I preferred using sprintf on Bell
    UNIX because of its extended error detection as opposed to using
    "strcpy" (which only returns the pointer). That is it returned the
    number of characters copied for a string copy operation. On
    Berkeley UNIX I will have to use either sprintf or strcpy, capture
    the char pointer returned from the function, then do a strlen call
    to achieve the same error checking as on Bell UNIX.
    Oh well, thanx
    Tim

In stdio.h on a VAX:

    #ifdef vax
    char	*sprintf();		/* too painful to do right */
    #endif

Thus, /usr/man/man3/printf.3s could be changed:

    % diff printf.3s~ printf.3s
    28c28
    < .B sprintf(s, format
    ---
    > .B char *sprintf(s, format

scott

From chris@gyre.umd.edu  Tue Dec 31 01:58:14 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA09011; Tue, 31 Dec 85 01:58:14 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA11693; Tue, 31 Dec 85 04:59:06 EST
Date: Tue, 31 Dec 85 04:59:06 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512310959.AA11693@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu, rick@seismo.ARPA
Subject: conn.c has some editor-typos in it
Status: O

Index: /usr/src/usr.bin/uucp/conn.c 4.3Beta Fix

Description:
	conn.c generates some dead code.  I think it does not affect
	operation, but it was easier to remove it than to figure out
	what it really did.

Repeat-By:
	Inspection

Fix:
	Below

Chris

RCS file: RCS/conn.c,v
retrieving revision 1.4
diff -c2 -r1.4 conn.c
*** /tmp/,RCSt1011629	Tue Dec 31 04:40:21 1985
--- conn.c	Tue Dec 31 04:39:59 1985
***************
*** 1,3 ****
! /* $Header: conn.c,v 1.4 85/10/21 00:26:42 bin Exp $ */
  /* from:  @(#)conn.c	5.2 (Berkeley) 7/2/83 */
  
--- 1,3 ----
! /* $Header: /usr/src/usr.bin/uucp/RCS/conn.c,v 1.5 85/12/31 04:39:07 bin Exp $ */
  /* from:  @(#)conn.c	5.2 (Berkeley) 7/2/83 */
  
***************
*** 931,944 ****
    		if (tl <= tn || tn < th)
    			return MGrade;
!   	} else
! 
! 	if (i < 2)
! 		return MGrade;
! 	if (th < tl) { 	/* crosses midnight */
! 		if (tl <= tn || tn < th)
! 			return MGrade;
! 	} else
  		if (tl <= tn && tn < th)
  			return MGrade;
  	return FAIL;
  }
--- 931,938 ----
    		if (tl <= tn || tn < th)
    			return MGrade;
!   	} else {
  		if (tl <= tn && tn < th)
  			return MGrade;
+ 	}
  	return FAIL;
  }

From chris@gyre.umd.edu  Tue Dec 31 04:35:01 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA09361; Tue, 31 Dec 85 04:35:01 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA12304; Tue, 31 Dec 85 07:35:54 EST
Date: Tue, 31 Dec 85 07:35:54 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8512311235.AA12304@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: n/troff \o bug (from polyof!john)
Status: O

Index: /usr/src/usr.bin/troff/n9.c 4.3Beta Fix

Description:
	Nroff and troff can overrun the bounds of two arrays when
	processing \o escapes containing too many characters.  The
	problem is that while it ensures that bounds never go beyond
	NOV, it also stores a terminating 0 after the last character
	and width in the arrays `o' and `w'.

Repeat-By:
	Symptomless on Vaxen and Suns (or perhaps Sun has already
	fixed the bug).

Fix:
	Below.  Alternatively, one could store the 0 iff the arrays
	are not full; but this was easier.

Chris

RCS file: RCS/n9.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1012282	Tue Dec 31 07:30:26 1985
--- /tmp/,RCSt2012282	Tue Dec 31 07:30:28 1985
***************
*** 103,107 ****
  setov(){
  	register i, j, k;
! 	int *p, delim, o[NOV], w[NOV];
  
  	if((delim = getch()) & MOT)return;
--- 103,107 ----
  setov(){
  	register i, j, k;
! 	int *p, delim, o[NOV+1], w[NOV+1];
  
  	if((delim = getch()) & MOT)return;

From hilbert!hubert@uw-beaver.arpa  Tue Dec 31 17:17:29 1985
Received: by monet.berkeley.edu (5.38/1.7)
	id AA10514; Tue, 31 Dec 85 17:17:29 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA05293; Tue, 31 Dec 85 17:19:07 PST
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.15/1.0.Entropy)
	id AA08409; Tue, 31 Dec 85 17:16:58 PST
Date: Tue, 31 Dec 85 17:16:58 PST
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Tue, 31 Dec 85 17:16:58 PST
Message-Id: <8601010116.AA08409@hilbert.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: msgs problems
Cc: uw-beaver!washington!burr
Status: O

I am having trouble getting msgs to work properly through the sendmail
interface.  I have the usual /usr/lib/aliases line and am using the
version of sendmail that came as the last file on the beta distribution
tape.  If you have any desire to see my sendmail.cf file or would like
more information you are more than welcome.

Here's the problem.  If I mail to "msgs" the job is queued in mqueue.
When the queue runs I get the following mail returned indicating a
failure but the message actually gets posted to /usr/msgs.

----------------
From MAILER-DAEMON Mon Dec 30 17:24:00 1985
Received: by hilbert.UUCP (5.15/1.0.Entropy)
	id AA01040; Mon, 30 Dec 85 17:23:57 PST
Date: Mon, 30 Dec 85 17:23:57 PST
From: Mail Delivery Subsystem <MAILER-DAEMON>
Subject: Returned mail: Internal error
Posted-Date: Mon, 30 Dec 85 17:23:57 PST
Message-Id: <8512310123.AA01040@hilbert.UUCP>
To: hubert
Status: RO

   ----- Transcript of session follows -----
451 endmailer sh: wait: No children
554 "|/usr/ucb/msgs -s"... Internal error

   ----- Unsent message follows -----
Received: by hilbert.UUCP (5.15/1.0.Entropy)
	id AA00657; Mon, 30 Dec 85 16:42:38 PST
Date: Mon, 30 Dec 85 16:42:38 PST
From: Steve Hubert <hubert>
Posted-Date: Mon, 30 Dec 85 16:42:38 PST
Message-Id: <8512310042.AA00657@hilbert.UUCP>
To: msgs
Subject: test message

Text of test message.

----------------

If I run the queue manually with "/usr/lib/sendmail -q" everything
seems to work just fine.

I would like to be able to have it work somehow first of all, and I
would like to have it work so that it doesn't queue the job if possible.
Thanks.


Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 hilbert!hubert@uw-beaver.arpa

From schoch@orion.ARPA  Thu Jan  2 11:34:17 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA14299; Thu, 2 Jan 86 11:34:17 PST
Received: by orion.ARPA (5.31/1.2)
	id AA10587; Thu, 2 Jan 86 11:34:45 PST
Date: Thu, 2 Jan 86 11:34:45 PST
From: Steve Schoch <schoch@orion.ARPA>
Message-Id: <8601021934.AA10587@orion.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: Manual for lastcomm(1) is wrong
Status: O

Index:	/usr/man/man1/lastcomm.1 4.3BSD

Description:
	The manual entry for lastcomm is wrong.  The description for the
	flags field says that an 'X' means the process was terminated with
	a SIGTERM, when it really means that the process was terminated
	with ANY signal.
Fix:
	Change to "``X'' indicates the command was terminted with a signal."

From chris@gyre.umd.edu  Fri Jan  3 14:49:51 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA21339; Fri, 3 Jan 86 14:49:51 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA10298; Fri, 3 Jan 86 17:50:04 EST
Date: Fri, 3 Jan 86 17:50:04 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601032250.AA10298@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: lint complains about optarg, optind `used but not defined'
Status: O

Index: /usr/src/usr.bin/lint/llib-lc 4.3Beta Fix

Description:
	getopt is not in the llib-lc library.

Repeat-By:
	Run lint on the following:

		#include <stdio.h>

		extern char *optarg;
		extern int optind;

		main(argc, argv)
			char **argv;
		{
			int c;

			c = getopt(argc, argv, "x");
			if (c != EOF)
				putchar(c);
		}

	Note that the program compiles, but will not lint.

Fix:
	Unfortunately, this includes my own local `error' stuff,
	so you will need to edit it.  (Or install error, which
	I think would be a good idea, but . . . .)

Chris

RCS file: RCS/llib-lc,v
retrieving revision 1.2
retrieving revision 1.3
diff -c2 -r1.2 -r1.3
*** /tmp/,RCSt1010263	Fri Jan  3 17:46:31 1986
--- /tmp/,RCSt2010263	Fri Jan  3 17:46:36 1986
***************
*** 292,293 ****
--- 292,302 ----
  	sscanf( s, f ) char *s, *f; { return(1); }
  	ungetc( c, f ) FILE *f; {  return(c); }
+ 
+ 	/* System V compatibility */
+ int	getopt(argc, argv, options) char **argv, *options; { return '?'; }
+ char	*optarg;
+ int	optind;
+ 
+ 	/* locals */
+ 	/* VARARGS3 */
+ 	error(quit, e, fmt) char *fmt; {;}

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 17:50:39 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA03435; Sun, 5 Jan 86 17:50:39 PST
Received: from arizona by csnet-relay.csnet id a023568; 5 Jan 86 4:35 EST
Received: by arizona.uucp (5.15/3.14)
	id AA01546; Sun, 5 Jan 86 02:19:23 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA24497; Sun, 5 Jan 86 02:19:21 MST
Date: Sun, 5 Jan 86 02:19:21 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601050919.AA24497@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: setuid csh scripts don't work
Status: O

It seems that setuid csh scripts don't work.  Create (e.g.) /tmp/xx to
contain:

	#!/bin/csh -f
	/bin/date
	
chmod 4755 /tmp/xx

If you run it as yourself, it works.  su to somebody else, even root, and
then run it.  It says "csh: Permission denied".

It can be setuid to root, and then root can run it, but nobody else.

This worked ok on 4.2, /bin/sh works on 4.3, and the 4.2 csh binary works
on 4.3.

The problem seems to be related to the segment in csh/sh.c:

	if (!batch && (uid != geteuid() || getgid() != getegid())) {
		errno = EACCES;
		child++;			/* So this ... */
		Perror("csh");			/* ... doesn't return */
	}

batch is set by the presence of the as-far-as-I-can-see undocumented -b
option.  Thus,

	#!/bin/csh -f -b
	/bin/date
	
does work.

It looks like this is supposed to be some sort of security feature, i.e.,
-b must be specified to make setuid scripts work.  If so, this should be
in the changes document as well as the man page.

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 17:51:38 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA03457; Sun, 5 Jan 86 17:51:38 PST
Received: from arizona by csnet-relay.csnet id a024251; 5 Jan 86 6:16 EST
Received: by arizona.uucp (5.15/3.14)
	id AA01579; Sun, 5 Jan 86 02:37:07 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA24535; Sun, 5 Jan 86 02:37:05 MST
Date: Sun, 5 Jan 86 02:37:05 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601050937.AA24535@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: "rm -f" generates error message
Status: O

The man page for rm states "No questions are asked and no errors are reported
when the -f (force) option is given.", but the command

	rm -f
	
generates the message

	usage: rm [-rif] file ...

This diff shows how to restore the old behavior.  (Incidentally, I tried
"rm -f" on several other local UNIX systems and 4.3 is the only one
that squawks.)

*** /usr/src/bin/rm.c	Mon Mar 18 13:48:12 1985
--- rm.c	Sat Jan  4 04:43:56 1986
***************
*** 57,63
  			}
  	}
  
! 	if (argc < 2) {
  		fprintf(stderr, "usage: rm [-rif] file ...\n");
  		exit(1);
  	}

--- 57,63 -----
  			}
  	}
  
! 	if (argc < 2 && !fflg) {
  		fprintf(stderr, "usage: rm [-rif] file ...\n");
  		exit(1);
  	}
[and following...]
	while (--argc > 0)
		(void) rm(*++argv, 0);

	exit(errcode != 0);

Thus it goes on to exit with an rc of 0 (as on 4.2) a couple of statements
later.

I happened to stumble on this because the command line processor for
Icon ("icont") does an "rm -f" (no other args) in certain case.

I guess it could be argued that "rm -f" should generate a usage message, but
for the sake of compatibility it makes sense to preserve the old behavior.

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 17:52:03 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA03471; Sun, 5 Jan 86 17:52:03 PST
Received: from arizona by csnet-relay.csnet id aa24251; 5 Jan 86 6:17 EST
Received: by arizona.uucp (5.15/3.14)
	id AA01752; Sun, 5 Jan 86 03:45:20 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA24745; Sun, 5 Jan 86 03:45:17 MST
Date: Sun, 5 Jan 86 03:45:17 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601051045.AA24745@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: minor nits
Status: O

Here's collection of minor problems and suggestions that didn't seem
to merit individual messages.  In no particular order:

	I found that "du -s /" works nicely to adjust directory lengths
	 to multiples of 512 on pre-4.3 filesystems.
	 
	As someone noted earlier, /usr/games/robots bus errors on startup.
	 I did try recompiling it, but that didn't help.  I didn't
	 investigate further.  (No robotics lab here!)

	I'm told that the output format for gprof has changed.  This was
	 reported by a user who had written some programs to process
	 gprof output...  No big deal, but it should be mentioned in the
	 changes document.  We're fresh out of 4.2 systems so I can't
	 easily produce a "before and after" picture.
	 
	"4.3 BSD" is misspelled in /sys/consolerl/anyboo.com.  It begins:

	   ! Load 'boot.' and boot the ULTRIX operating system.

	The new -M option on man is really nice, but it would be nicer if
	 it looked for an environment variable, say, MANPATH and used
	 the value therein in lieu of a -M specification.
	 
	For kernel configuration on our 8600 I noted that "vangogh" at
	 UCB is apparently an 8600 and its config contains a cpu spec for both
	 VAX780 and VAX8600.  It wasn't clear at the time whether just
	 "cpu VAX8600" was enough or if VAX780 was included as a hack.

	Sendmail now seems to preserve case in :include file names (maybe
	 other files as well; I just thought of that).  For example,
	 on 4.2 a mailing list that :included /x/y/Z would really include
	 /x/y/z, but on 4.3, it looks for /x/y/Z.  The change is perhaps
	 worth a mention.  (Perhaps this is a new sendmail config option;
	 I haven't looked at the 4.3 sendmail documents.)
	 
	A very transient sendmail problem that we had on 4.2 seems to be
	 present on 4.3 as well.  A number of local mailing lists in
	 /usr/lib/aliases expand to several users and a file or two to record
	 the traffic, for example:

	 	lab: cwf,mms,whm,lab-f,lab-daily
		lab-f: /usr/lab/mail/mail
		lab-daily: /usr/lab/mail/daily
	 
	 On about roughly one message out of one hundred, the message
	  will be bounced with something like (an actual excerpt):
	  
		   ----- Transcript of session follows -----
		554 /usr/lab/mail/daily... Service unavailable
		554 /usr/lab/mail/daily... Service unavailable
	
		   ----- Unsent message follows -----

	  In this case, the message ended up in both files.  On 4.2,
	   I don't recall ever finding the message in the file.
	   
	  Perhaps I should gather some more data on this, but I thought
	   it was worth a mention.

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 17:52:40 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA03484; Sun, 5 Jan 86 17:52:40 PST
Received: from arizona by csnet-relay.csnet id ab24251; 5 Jan 86 6:17 EST
Received: by arizona.uucp (5.15/3.14)
	id AA01797; Sun, 5 Jan 86 04:01:05 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA24802; Sun, 5 Jan 86 04:01:03 MST
Date: Sun, 5 Jan 86 04:01:03 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601051101.AA24802@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: gripe gripe gripe -- mallocs via fopen
Status: O

I've got to say that the line in the "Dear Beta Sites" document which
reads

	"Note that file ("iob") entries may be allocated by malloc from
	fopen; this has been known to cause problems with programs that
	use their own memory allocators."

deserves a little more emphasis.  This is CERTAIN BAD NEWS for any
system that assumes that it's going to have a contiguous data space once
it gets started.  Our Icon language system is one such system and I'm sure
that there are other systems around that assume a contiguous data space.
(Of course, even in 4.2, an opendir can cause expansion via sbrk.)

It appears that on a vanilla 4.3 system, an sbrk occurs on the 33rd open
(in the absence of closes, frees, and other mallocs), so since most programs
never have that many open files, it's almost reasonable to ignore this
problem.

I can see the merit of not automatically allocating 1 Kbyte+ of iob
entries, but I think a reasonable compromise would be to provide some way
for programs that have a need for a contiguous data space to have it.
Perhaps a subroutine that would allocate a block of iobs and then fill in
the entries. This could be called during a program's initialization phase
prior to when it takes control of memory.  Other routes could be taken
by system implementors -- do a big malloc and then free it, supply
an alternate version of _findiop, getdtable() opens of /dev/null followed
by closes, etc., but I think the right thing to do would be to supply an
"out" as part of 4.3.

It's also worth mentioning that there's been some shouting at VMS about
a similar problem: the Record Mangler System allocates buffers in the
user's P0 space.

And you should have heard what Ralph Griswold said when I told him of
this problem. (!)

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 23:41:19 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA05339; Sun, 5 Jan 86 23:41:19 PST
Received: from arizona by csnet-relay.csnet id aa01371; 6 Jan 86 2:39 EST
Received: by arizona.uucp (5.15/3.14)
	id AA04274; Sun, 5 Jan 86 22:37:10 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA01267; Sun, 5 Jan 86 22:37:08 MST
Date: Sun, 5 Jan 86 22:37:08 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601060537.AA01267@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: non-blocking I/O bug?
Status: O

I don't know if this is a bug or a feature, but the program:

#include	<sys/file.h>
main ()
{
	fcntl (0, F_SETFL, FNDELAY);
}

leaves FNDELAY set on stdin in the parent.  Or something like that.
When the shell tries to do its next read from the terminal, it gets
an EWOULDBLOCK error.  The 4.3 csh explicitly looks for this error
and if it occurs, it does an ioctl with FIONBIO to turn off the
non-blocking mode and things are just fine.  However, sh does not
look for this and earlier cshs don't look for this either and it
results in a forced logout.

We came across this under 4.2 and while the 4.3 csh hides the problem,
it seems surprising that the non-blocking attribute is set in the parent.
It also is the case that using "dup(0)" rather than just "0" causes
the same effect, so it looks like the attribute is really associated
with the terminal rather than the descriptor.

Is this a bug or a feature?  If the latter, is it documented somewhere?

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sun Jan  5 23:41:29 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA05345; Sun, 5 Jan 86 23:41:29 PST
Received: from arizona by csnet-relay.csnet id ab01371; 6 Jan 86 2:39 EST
Received: by arizona.uucp (5.15/3.14)
	id AA04761; Mon, 6 Jan 86 00:37:45 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA01525; Mon, 6 Jan 86 00:37:40 MST
Date: Mon, 6 Jan 86 00:37:40 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601060737.AA01525@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: odds and ends about 4.3 dmf, dmz, and uda drivers
Status: O

We have Emulex DMFs on a 785 (I'm not sure of the exact DMF model, but
I can find out) and genvmunix locks up during the boot.  It prints
all the configuration stuff, thinks the DMFs are Able vmz32/n's,
and when it should print the "erase ..." message, it instead prints
"dmfdaint" -- that's all the handler for that interrupt appears to do --
and freezes up only to be aroused by a ^P Halt.

We plugged in the dmf driver we had been using on 4.2, the one from
Chris Maloney at MDDC, and that seems to work just fine.  There have
been several 4.3 bug reports about the dmf driver and I'm wondering
what state things are in.  Should we just stick with the Maloney driver
or wait for fixes for the 4.3 driver or what?  The Maloney driver seems
to work just fine so I guess our only concern is that the Maloney driver
might be behind the times in some way.

However, the inability of genvmunix to boot on VAXs with these Emulex
could be a real problem for somebody that only has one VAX.  (Not to
mention those that don't have the Maloney driver.)

Moving right along to the DMZ-32...There was no driver on the tape we
got, but I see that one is in place on monet now.  We got lined up with
a copy that apparently came from UCB c. 10/17 and it seems to work ok
on our 8600.  I notice that the one on monet has had considerable work
done on it since 10/17; is it ok if I pick up a copy of that?  (I assume
that it works. (?))

Also, pstat should look for dmzs.  (Be sure to fix that Sysmap value!)

About the UDA driver...We've been using the RIACS driver and it seems to
deal well with some fairly bogus RA81s that we have.  I note that the
4.3 uda.c seems to have no provisions to handle bad blocks and it looks
like it's just had cosmetic changes since 4.2.  (When we first tried to
bring up 4.2 on one of our 785s, it would lock up while untarring onto
an RA81.)  To get to the point, I'd assume that you folks have seen
the RIACS driver, and I wonder why you've stuck with the originally-Ultrix
(?) driver.  As a specific question, if you get a bad block on a UDA
disk with the 4.3 driver, how do you deal with that?  Do you recommend
the 4.3 driver over the RIACS driver?

In 4.2, autoconf.c called a driver's slave routine with a third argument,
ui->ui_ctlr.  While the documentation only specifies two arguments and
all of the standard 4.2 drivers used two arguments, the RIACS uda driver
happened to use the third argument.  This is certainly easy to find and
fix, but it might be worth mentioning in the changes document.

From bloom  Mon Jan  6 10:43:20 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA06846; Mon, 6 Jan 86 10:43:20 PST
From: bloom (Jim Bloom)
Message-Id: <8601061843.AA06846@monet.berkeley.edu>
To: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: setuid csh scripts don't work
In-Reply-To: Your message of Sun, 5 Jan 86 02:19:21 MST.
	     <8601050919.AA24497@megaron.arizona.uucp>
Date: 06 Jan 86 10:43:17 PST (Mon)

We haven't updated the documentation yet to correspond to the
change.  There were too many holes in setuid shell scripts and
this was part of the crack down on the holes.

					Jim

From terry@randgr.ARPA  Mon Jan  6 17:53:55 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08556; Mon, 6 Jan 86 17:53:55 PST
Received: by randgr.arpa; Mon, 6 Jan 86 17:39:28 PST
From: Terry West <terry@randgr.ARPA>
Message-Id: <8601070139.AA14465@randgr.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: obrien%rand-unix@randgr.ARPA, terry%rand-unix@randgr.ARPA
Subject: Problems with /etc/rmt.
Index: /usr/src/etc/rmt.c 4.3BSD
Date: 06 Jan 86 17:39:25 PST (Mon)

Description:
	We noticed that our remote dumps (from Suns) are taking twice
	as long with 4.3 vs 4.2.

Repeat-By:
	Here's the results from an rtar comparing the 4.3 /etc/rmt binary
	on a 4.3 system vs. a 4.2 /etc/rmt binary on the same 4.3 system

	    4.3:  1.7u 30.4s 2:42 19% 8+8k 408+3io 0pf+0w
	    4.2:  1.7u 26.5s 1:21 34% 8+8k 407+3io 0pf+0w
			     ^^^^
Partial Fix:
(1)     At line 196 in the routine checkbuf(), add

	    maxrecsize = size;

	so subsequent checkbuf() calls need not free/malloc again.

(2)     After making the above change, it still ran slow.
	In comparing the 4.2 code, I noted that the 'setsockopt' code
	at the end of checkbuf() is new.  By commenting out this
	code, all runs as fast as 4.2.  I don't know why, though.

#ifdef  RUNSLOW
	/*
	 *  Rand:  don't know why yet, but this causes thru-put to
	 *  decrease by about half?...
	 */
	while (size > 1024 &&
	       setsockopt(0, SOL_SOCKET, SO_RCVBUF, &size, sizeof (size)) < 0)
		size -= 1024;
#endif


    Terry West
    <terry@rand-unix.ARPA>

From nsc!chongo@decwrl.DEC.COM  Mon Jan  6 18:02:37 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08583; Mon, 6 Jan 86 18:02:37 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA12610; Mon, 6 Jan 86 18:04:37 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA00206; Thu, 2 Jan 86 02:11:25 pst
Date: Thu, 2 Jan 86 02:11:25 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 2 Jan 86 02:11:25 pst
Message-Id: <8601021011.AA00206@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: sendmail bug

When we send mail from our 4.2 system to the 4.3 system, the 4.3 sendmail
sends back an error message (see below).  All messages DO get through, but
the 4.3 sendmail kicks back an error message every time.  Is this a known
bug and is there a known fix?

NOTE: Cthulhu is the 4.3 system, nsc is the 4.2 system.

	From MAILER-DAEMON@cthulhu.NSC Thu Jan  2 01:55:08 1986
	Received: from cthulhu.NSC by nsc.NSC (4.12/6.0.GT)
		id AA26256; Thu, 2 Jan 86 01:55:04 pst
	Received-Date: Thu, 2 Jan 86 01:55:04 pst
	Received: from nsc.NSC (nsc) by cthulhu.NSC (5.9/6.0.GT)
		id AA02044; Thu, 2 Jan 86 01:54:03 PST
	Date: Thu, 2 Jan 86 01:54:53 pst
	From: Mail Delivery Subsystem <MAILER-DAEMON@cthulhu.NSC>
	Subject: Returned mail: Internal error
	Posted-Date: Thu, 2 Jan 86 01:54:53 pst
	Message-Id: <8601020954.AA02044@cthulhu.NSC>
	To: <chongo@nsc.NSC>
	
	   ----- Transcript of session follows -----
	<<< QUIT
	451 endmailer mail: wait: No children
	554 <chongo@cthulhu.NSC>... Internal error
	
	   ----- Unsent message follows -----
	Received: from nsc.NSC (nsc) by cthulhu.NSC (5.9/6.0.GT)
		id AA02042; Thu, 2 Jan 86 01:54:03 PST
	Received-Date: Thu, 2 Jan 86 01:54:03 PST
	Received: by nsc.NSC (4.12/6.0.GT)
		id AA26216; Thu, 2 Jan 86 01:54:53 pst
	Date: Thu, 2 Jan 86 01:54:53 pst
	From: Landon Noll <chongo@nsc.NSC>
	Posted-Date: Thu, 2 Jan 86 01:54:53 pst
	Message-Id: <8601020954.AA26216@nsc.NSC>
	To: chongo@cthulhu.NSC
	Subject: hi

chongo <> /\../\

From nsc!chongo@decwrl.DEC.COM  Mon Jan  6 18:03:13 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08590; Mon, 6 Jan 86 18:03:13 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA12618; Mon, 6 Jan 86 18:04:48 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA01326; Thu, 2 Jan 86 04:15:22 pst
Date: Thu, 2 Jan 86 04:15:22 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 2 Jan 86 04:15:22 pst
Message-Id: <8601021215.AA01326@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: patch and diff -c

As documented in the diff(1) man page, diff -c's output is different from
that of 4.2bsd.  In regards to patch:

	Changes which lie within <context> lines of each
	other are grouped together on output.

The version of patch as shipped with 4.3Beta is not aware of this change
and can not process this new change in diff.

I suggest two methods to fix this problem:

	1) teach patch to understand the new diff -c output

	2) add a flag to diff (say -C) which causes contextual diffs to
	   work as they did under 4.2.

chongo <> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Mon Jan  6 18:03:40 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08596; Mon, 6 Jan 86 18:03:40 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA12630; Mon, 6 Jan 86 18:05:17 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA05259; Thu, 2 Jan 86 08:18:16 pst
Date: Thu, 2 Jan 86 08:18:16 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 2 Jan 86 08:18:16 pst
Message-Id: <8601021618.AA05259@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: slight problem rebuilding /usr/ucb/Mail

I encountered a slight problem rebuilding the Mail program.  It seems that
the xstr file (str.o?) was botched.  The problem was solved by cleaning
away all .o files and rebuilding again.

chongo <.> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Mon Jan  6 18:20:45 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08688; Mon, 6 Jan 86 18:20:45 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA12624; Mon, 6 Jan 86 18:05:02 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA25836; Thu, 2 Jan 86 07:39:36 pst
Date: Thu, 2 Jan 86 07:39:36 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 2 Jan 86 07:39:36 pst
Message-Id: <8601021539.AA25836@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: dump does not deal with second tape

When we do a level 0 dump of a large partition, dump fails to continue
with the second tape.

our command:

	/etc/dump 0undf 6250 /dev/rmt0 /dev/rra0g

tail of output of dump:

	DUMP: Tape rewinding
	DUMP: Change tapes: Mount tape #2
	DUMP: fopen on /dev/tty fails
	DUMP: Child 19898 returns LOB status 204
	DUMP: Bad return code from dump: 0

We are using a vax 750 with the following lines on our conf file:

	master		ht0	at mba? drive 0
	tape		tu0	at ht0 slave 0

chongo <> /\oo/\

From nsc!chongo@cthulhu.ARPA  Mon Jan  6 19:55:21 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA08957; Mon, 6 Jan 86 19:55:21 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA14481; Mon, 6 Jan 86 19:57:17 pst
Received: from cthulhu.NSC by nsc.NSC (4.12/6.0.GT)
	id AA00551; Mon, 6 Jan 86 19:50:33 pst
Received: by cthulhu.NSC (5.9/6.0.GT)
	id AA02187; Mon, 6 Jan 86 19:49:11 PST
Date: Mon, 6 Jan 86 19:49:11 PST
From: Landon Noll <nsc!chongo@cthulhu.ARPA>
Posted-Date: Mon, 6 Jan 86 19:49:11 PST
Message-Id: <8601070349.AA02187@cthulhu.NSC>
To: 43bugs@cthulhu
Subject: bug in tar.1 man page

The tar man page has two bugs relating to the -C flag.  One bug is a
deviation from the standard way to show flags and another bug is in
the actual example.

*** /usr/man/tar.1	Mon Jan  6 19:43:48 1986
--- /usr/man/tar.1	Mon Jan  6 19:43:49 1986
***************
*** 147,153 ****
  .I tar
  can work across a communications channel where the blocking may not
  be maintained.
! .PP
  If a file name is preceded by 
  .BR \-C ,
  then 
--- 147,154 ----
  .I tar
  can work across a communications channel where the blocking may not
  be maintained.
! .TP 10
! .B C
  If a file name is preceded by 
  .BR \-C ,
  then 
***************
*** 159,165 ****
  relative path names.  For example, to archive files from /usr/include
  and from /etc, one might use
  .ti +0.5i
! tar c -C /usr include -C / etc
  .PP
  Previous restrictions dealing with
  .IR tar 's
--- 160,166 ----
  relative path names.  For example, to archive files from /usr/include
  and from /etc, one might use
  .ti +0.5i
! tar c -C /usr/include -C /etc
  .PP
  Previous restrictions dealing with
  .IR tar 's

chongo <> /\oo/\

From whm%arizona.csnet@CSNET-RELAY.ARPA  Tue Jan  7 02:07:44 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA09411; Tue, 7 Jan 86 02:07:44 PST
Received: from arizona by csnet-relay.csnet id ac03327; 7 Jan 86 4:40 EST
Received: by arizona.uucp (5.15/3.14)
	id AA09896; Mon, 6 Jan 86 23:44:33 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA04381; Mon, 6 Jan 86 23:44:32 MST
Date: Mon, 6 Jan 86 23:44:32 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601070644.AA04381@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: ruptime is technophobic

ruptime still can't believe that a machine could possibly be up for more
than 3*30*24*60*60 seconds == about 3 months, but such occurrences are
not uncommon.

Why not just take that test out or make the cutoff something like a year?

From whm%arizona.csnet@CSNET-RELAY.ARPA  Tue Jan  7 02:05:24 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA09397; Tue, 7 Jan 86 02:05:24 PST
Received: from arizona by csnet-relay.csnet id ab03327; 7 Jan 86 4:39 EST
Received: by arizona.uucp (5.15/3.14)
	id AA09848; Mon, 6 Jan 86 23:29:30 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA04251; Mon, 6 Jan 86 23:29:28 MST
Date: Mon, 6 Jan 86 23:29:28 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601070629.AA04251@megaron.arizona.uucp>
To: beta43_sites@monet.berkeley.edu
Subject: Ethernet wierdness on an 8600

We've been having some strange ethernet problems on an 8600 and I was
wondering if anyone might have any suggestions on investigating this
problem or if anyone else is having this same problem.

We've got a DEUNA on our 8600 and several times in the last few days,
a condition has appeared wherein network transmission has (effectively)
ground to a halt.  Typically, the folks rlogged in from the Suns will
start experiencing sluggish terminal echo, then their connections start
being dropped, then lpc starts thinking that the VAX with the printer
is down, and so forth.  Pinging around indicates that all the other hosts
on the local net are just fine, but when pinging from the 8600, the
packet loss is often 50% or higher.  Typically, (based on the icmp
sequence numbers), every other packet is lost.  That is, packet #s 1,
3, 5, 7, ... are lost and this every-other lossage can continue for
dozens of packets.  Then, it'll typically miss two and then get right back
to the every-other lossage.  The net eventually becomes catatonic from
the 8600, but just fine elsewhere.  Rebooting the 8600 invariably
fixes the problem.

netstat -i and -s don't appear to show anything unusual, but I'm really
not sure what I should be looking for.

Note that we're running 4.3 on three other VAXs (a 780 and two 785s) and
we've had no ethernet problems whatsoever on them.

Any and all suggestions will be greatly appreciated.

From aps@decwrl.DEC.COM  Tue Jan  7 09:13:27 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA10149; Tue, 7 Jan 86 09:13:27 PST
Received: from granite.DEC.COM (granite) by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA24374; Tue, 7 Jan 86 09:11:43 pst
Received: by granite.DEC.COM (4.12/4.7.34)
	id AA09648; Tue, 7 Jan 86 09:09:36 pst
Date: Tue, 7 Jan 86 09:09:36 pst
From: aps@decwrl.DEC.COM (Armando P. Stettner)
Message-Id: <8601071709.AA09648@granite.DEC.COM>
To: beta43_sites@monet.berkeley.edu, whm%arizona.CSNET@CSNET-RELAY.ARPA
Subject: Re:  Ethernet wierdness on an 8600

I am running Ultrix on my 8600 (no flames please!!!) and have
not seen this problem.  What kind of ethernet do you have and
what is the coniguration of the UNIBUS with the ethernet on it??
	aps.

From lepreau@utah-cs.ARPA  Tue Jan  7 15:20:01 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA12953; Tue, 7 Jan 86 15:20:01 PST
Received: by utah-cs.ARPA (5.5/4.40.2)
	id AA07725; Tue, 7 Jan 86 16:20:32 MST
Date: Tue, 7 Jan 86 16:20:32 MST
Message-Id: <8601072320.AA07725@utah-cs.ARPA>
From: Jay Lepreau <lepreau@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: Fix for TAC tcp problem

Mike:
I wrote to the BBN TAC people about this and they maintain (rightly,
I'm afraid) that the window field is undefined unless the ACK bit is
set, cause it's meaningless since it's relative to ti_ack (which should
also be ignored if ACK is off).  Since the "step6" code refs ti_ack a
couple times as well as ti_win and I'm not at home in the code, I just
took the simple step of zeroing the fields at the very top of
tcp_input, if appropriate.  The same could be done for "urp", and
perhaps should, but that is currently taken care of with an explicit
check for URG later on.

We've been running with this in sid 6.16 w/o problems.

Diff vs. sid current monet 6.18:
257,258d256
< 	ti->ti_ack = ntohl(ti->ti_ack);
< 	ti->ti_win = ntohs(ti->ti_win);
259a258,263
> 	if (tiflags & TH_ACK) {
> 		ti->ti_ack = ntohl(ti->ti_ack);
> 		ti->ti_win = ntohs(ti->ti_win);
> 	}
> 	else
> 		ti->ti_ack = ti->ti_win = 0;

From nsc!chongo@decwrl.DEC.COM  Tue Jan  7 16:08:27 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA13334; Tue, 7 Jan 86 16:08:27 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA01432; Tue, 7 Jan 86 16:09:38 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA16248; Tue, 7 Jan 86 14:50:15 pst
Date: Tue, 7 Jan 86 14:50:15 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Tue, 7 Jan 86 14:50:15 pst
Message-Id: <8601072250.AA16248@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: correction to my tar.1 man bug

My bug regarding the -C option has only half correct.

The first half, not having the ".TP 10" and ".B C" was a proper fix.

The last half, dealing with the example was not a bug.  sorry.

chongo <*blush*> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Tue Jan  7 16:09:01 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA13349; Tue, 7 Jan 86 16:09:01 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA01460; Tue, 7 Jan 86 16:10:15 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA16533; Tue, 7 Jan 86 15:00:10 pst
Date: Tue, 7 Jan 86 15:00:10 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Tue, 7 Jan 86 15:00:10 pst
Message-Id: <8601072300.AA16533@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: SIGUSR1 and SIGUSR2

SIGUSR1 and SIGUSR2:

These signals are in signal.h, but are not documented in the signal.3C
man page.  Signal #29, according to signal.h, has been skipped.  Why?'
Is this because someone wanted the user defined signals to start at
the top of the signal mask and go down (in which case they should be
signal #32,31 and not signal #31,30) or was it that signal #29 was
being reserved for something else or ...

chongo <> /\oo/\

From chris@gyre.umd.edu  Wed Jan  8 00:31:06 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA15747; Wed, 8 Jan 86 00:31:06 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA01970; Wed, 8 Jan 86 03:32:07 EST
Date: Wed, 8 Jan 86 03:32:07 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601080832.AA01970@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: man 5 passwd has one too many bugs

Index: /usr/man/man5/passwd.5 4.3Beta

Description:
	One of the two `bugs' listed in man 5 passwd has already
	been fixed.

Repeat-By:
	% man 5 passwd

Chris

From chris@mimsy.umd.edu  Wed Jan  8 01:47:56 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA16045; Wed, 8 Jan 86 01:47:56 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA14045; Wed, 8 Jan 86 04:48:39 EST
Date: Wed, 8 Jan 86 04:48:39 EST
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8601080948.AA14045@mimsy.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Incorrect mhash entries can be left behind

(I could swear I sent this earlier but just in case...)
Index: /sys/sys/sys_inode.c,/sys/sys/ufs_bmap.c 4.3Beta Fix

Description:
	Writing over an executable does not always clobber its text
	pages from the cmhash tables.  The problem is that if a
	file is being extended, bmap() can turn a fragment into a
	full block, thereby moving the disk address of the text
	page.  If the fragment is later reused, an exec of the new
	file may `page in' the old overwritten text as a reclaim.
	Normally this is taken care of in rwip(), where each written
	block is munhash()ed; but when a fragment is moved the wrong
	block number is used.

Repeat-By:
	From the description, you have no doubt guessed that it is
	not easily repeatable.

Fix:
	Well, there are umpteen ways to do it; the easiest would
	probably be to hack up bmap() to munhash() any fragments
	it moves, since it only ever does that on behalf of rwip()
	extending a file.  Actually, I guess the place to put that
	would be in realloccg.  (Come to think of it I had better
	check to see whether you did that already... if I can ever
	get this connection to connect...

	Bingo.

	Never mind.)

From neil%unix.computer-science.manchester.ac.uk@Cs.Ucl.AC.UK  Wed Jan  8 05:54:37 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA17361; Wed, 8 Jan 86 05:54:37 PST
Message-Id: <8601081354.AA17361@monet.berkeley.edu>
Received: from unix.computer-science.manchester.ac.uk by 44d.Cs.Ucl.AC.UK 
           via Janet with NIFTP  id a000253; 7 Jan 86 11:40 GMT
Date:     Tue, 7 Jan 86 11:45:10 GMT
From: Neil Todd <neil%unix.computer-science.manchester.ac.uk@cs.ucl.ac.uk>
To: beta43_bugs@monet.berkeley.edu
Subject:  Timezones and Daylight Saving Time (For the UK)


Although I'm not a primary 4.3 Beta I have a copy of the tapes sent
to Amsterdam, Kirk McKusick and Mike Karels know about this.


Is is too late to get the proper daylight saving time entries for the
UK inserted into the source ?. I would say that there is a
very strong case for dropping the WET timezone in favour of GMT and BST
(British Summer Time), as only the UK and Portugal are in this zone 
(and there are more Brits using BSD than Portuguese).

I enclose amended copies of /usr/src/libc/gen/ctime.c and 
/usr/src/libc/gen/timezone.c


				Neil Todd


JANET:-		neil@uk.ac.man.cs.ux		* Dept of Computer Science
UUCP:-		mcvax!ukc!man.cs.ux!neil	* University of Manchester
ARPA:-		neil%uk.ac.man.cs.ux@ucl.cs	* Oxford Road
PHONE:-		(+44) 61 273 7121 Ext 5018	* Manchester M13 9PL


/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
static char sccsid[] = "@(#)ctime.c	5.2 (Berkeley) 6/24/85";
#endif not lint

/*
 * This routine converts time as follows.
 * The epoch is 0000 Jan 1 1970 GMT.
 * The argument time is in seconds since then.
 * The localtime(t) entry returns a pointer to an array
 * containing
 *  seconds (0-59)
 *  minutes (0-59)
 *  hours (0-23)
 *  day of month (1-31)
 *  month (0-11)
 *  year-1970
 *  weekday (0-6, Sun is 0)
 *  day of the year
 *  daylight savings flag
 *
 * The routine calls the system to determine the local
 * timezone and whether Daylight Saving Time is permitted locally.
 * (DST is then determined by the current local rules)
 *
 * The routine does not work
 * in Saudi Arabia which runs on Solar time.
 *
 * asctime(tvec))
 * where tvec is produced by localtime
 * returns a ptr to a character string
 * that has the ascii time in the form
 *	Thu Jan 01 00:00:00 1970\n\0
 *	0123456789012345678901234 5
 *	0	  1	    2
 *
 * ctime(t) just calls localtime, then asctime.
*
*********************************************************************
*
* N.B.  This routine has been fixed up for British Daylight Saving Time
* ====
*
* neil@uk.ac.man.cs.ux 18-DEC-85
*
*********************************************************************
 */

#include <sys/time.h>
#include <sys/types.h>
#include <sys/timeb.h>

static	char	cbuf[26];
static	int	dmsize[12] =
{
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31
};

/*
 * The following table is used for 1974 and 1975 and
 * gives the day number of the first day after the Sunday of the
 * change.
 */
struct dstab {
	int	dayyr;
	int	daylb;
	int	dayle;
};

static struct dstab usdaytab[] = {
	1974,	5,	333,	/* 1974: Jan 6 - last Sun. in Nov */
	1975,	58,	303,	/* 1975: Last Sun. in Feb - last Sun in Oct */
	0,	119,	303,	/* all other years: end Apr - end Oct */
};
static struct dstab ausdaytab[] = {
	1970,	400,	0,	/* 1970: no daylight saving at all */
	1971,	303,	0,	/* 1971: daylight saving from Oct 31 */
	1972,	303,	58,	/* 1972: Jan 1 -> Feb 27 & Oct 31 -> dec 31 */
	0,	303,	65,	/* others: -> Mar 7, Oct 31 -> */
};

/*
 * The European tables ... based on hearsay
 * Believed correct for:
 *	WE:	Great Britain(WRONG use gbdaytab), Portugal? (yes NCT)
 *	ME:	Belgium, Luxembourg, Netherlands, Denmark, Norway,
 *		Austria, Poland, Czechoslovakia, Sweden, Switzerland,
 *		DDR, DBR, France, Spain, Hungary, Italy, Jugoslavia
 *		Finland (EE timezone, but ME dst rules)
 * Eastern European dst is unknown, we'll make it ME until someone speaks up.
 *	EE:	Bulgaria, Greece, Rumania, Turkey, Western Russia
 *
 * Ireland is unpredictable.  (Years when Easter Sunday just happens ...)
 * Years before 1983 are suspect.
 */

/* NCT addition */
static struct dstab gbdaytab[] = {
	0,	91,	303,
};
static struct dstab wedaytab[] = {
	1983,	89,	296,	/* 1983: end March - end Oct */
	0,	89,	303,	/* others: end March - end Oct */
};

static struct dstab medaytab[] = {
	1983,	89,	296,	/* 1983: end March - end Oct */
	0,	89,	272,	/* others: end March - end Sep */
};

/*
 * Canada, same as the US, except no early 70's fluctuations.
 * Can this really be right ??
 */
static struct dstab candaytab[] = {
	0,	119,	303,	/* all years: end Apr - end Oct */
};

static struct dayrules {
	int		dst_type;	/* number obtained from system */
	int		dst_hrs;	/* hours to add when dst on */
	struct	dstab *	dst_rules;	/* one of the above */
	enum {STH,NTH}	dst_hemi;	/* southern, northern hemisphere */
} dayrules [] = {
	DST_USA,	1,	usdaytab,	NTH,
	DST_AUST,	1,	ausdaytab,	STH,
	DST_GMT,	1,	gbdaytab,	NTH,	/* NCT Addition */
	DST_WET,	1,	wedaytab,	NTH,
	DST_MET,	1,	medaytab,	NTH,
	DST_EET,	1,	medaytab,	NTH,	/* XXX */
	DST_CAN,	1,	candaytab,	NTH,
	-1,
};

struct tm	*gmtime();
char		*ct_numb();
struct tm	*localtime();
char	*ctime();
char	*ct_num();
char	*asctime();

char *
ctime(t)
time_t *t;
{
	return(asctime(localtime(t)));
}

struct tm *
localtime(tim)
time_t *tim;
{
	register int dayno;
	register struct tm *ct;
	register dalybeg, daylend;
	register struct dayrules *dr;
	register struct dstab *ds;
	int year;
	time_t copyt;
	struct timeval curtime;
	struct timezone zone;

	gettimeofday(&curtime, &zone);
	copyt = *tim - (time_t)zone.tz_minuteswest*60;
	ct = gmtime(&copyt);
	dayno = ct->tm_yday;
	for (dr = dayrules; dr->dst_type >= 0; dr++)
		if (dr->dst_type == zone.tz_dsttime)
			break;
	if (dr->dst_type >= 0) {
		year = ct->tm_year + 1900;
		for (ds = dr->dst_rules; ds->dayyr; ds++)
			if (ds->dayyr == year)
				break;
		dalybeg = ds->daylb;	/* first Sun after dst starts */
		daylend = ds->dayle;	/* first Sun after dst ends */
		dalybeg = sunday(ct, dalybeg);
		daylend = sunday(ct, daylend);
		switch (dr->dst_hemi) {
		case NTH:
		    if (!(
		       (dayno>dalybeg || (dayno==dalybeg && ct->tm_hour>=2)) &&
		       (dayno<daylend || (dayno==daylend && ct->tm_hour<1))
		    ))
			    return(ct);
		    break;
		case STH:
		    if (!(
		       (dayno>dalybeg || (dayno==dalybeg && ct->tm_hour>=2)) ||
		       (dayno<daylend || (dayno==daylend && ct->tm_hour<2))
		    ))
			    return(ct);
		    break;
		default:
		    return(ct);
		}
	        copyt += dr->dst_hrs*60*60;
		ct = gmtime(&copyt);
		ct->tm_isdst++;
	}
	return(ct);
}

/*
 * The argument is a 0-origin day number.
 * The value is the day number of the first
 * Sunday on or before the day.
 */
static
sunday(t, d)
register struct tm *t;
register int d;
{
	if (d >= 58)
		d += dysize(t->tm_year) - 365;
	return(d - (d - t->tm_yday + t->tm_wday + 700) % 7);
}

struct tm *
gmtime(tim)
time_t *tim;
{
	register int d0, d1;
	long hms, day;
	register int *tp;
	static struct tm xtime;

	/*
	 * break initial number into days
	 */
	hms = *tim % 86400;
	day = *tim / 86400;
	if (hms<0) {
		hms += 86400;
		day -= 1;
	}
	tp = (int *)&xtime;

	/*
	 * generate hours:minutes:seconds
	 */
	*tp++ = hms%60;
	d1 = hms/60;
	*tp++ = d1%60;
	d1 /= 60;
	*tp++ = d1;

	/*
	 * day is the day number.
	 * generate day of the week.
	 * The addend is 4 mod 7 (1/1/1970 was Thursday)
	 */

	xtime.tm_wday = (day+7340036)%7;

	/*
	 * year number
	 */
	if (day>=0) for(d1=70; day >= dysize(d1); d1++)
		day -= dysize(d1);
	else for (d1=70; day<0; d1--)
		day += dysize(d1-1);
	xtime.tm_year = d1;
	xtime.tm_yday = d0 = day;

	/*
	 * generate month
	 */

	if (dysize(d1)==366)
		dmsize[1] = 29;
	for(d1=0; d0 >= dmsize[d1]; d1++)
		d0 -= dmsize[d1];
	dmsize[1] = 28;
	*tp++ = d0+1;
	*tp++ = d1;
	xtime.tm_isdst = 0;
	return(&xtime);
}

char *
asctime(t)
struct tm *t;
{
	register char *cp, *ncp;
	register int *tp;

	cp = cbuf;
	for (ncp = "Day Mon 00 00:00:00 1900\n"; *cp++ = *ncp++;);
	ncp = &"SunMonTueWedThuFriSat"[3*t->tm_wday];
	cp = cbuf;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	cp++;
	tp = &t->tm_mon;
	ncp = &"JanFebMarAprMayJunJulAugSepOctNovDec"[(*tp)*3];
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	*cp++ = *ncp++;
	cp = ct_numb(cp, *--tp);
	cp = ct_numb(cp, *--tp+100);
	cp = ct_numb(cp, *--tp+100);
	cp = ct_numb(cp, *--tp+100);
	if (t->tm_year>=100) {
		cp[1] = '2';
		cp[2] = '0' + (t->tm_year-100) / 100;
	}
	cp += 2;
	cp = ct_numb(cp, t->tm_year+100);
	return(cbuf);
}

dysize(y)
{
	if((y%4) == 0)
		return(366);
	return(365);
}

static char *
ct_numb(cp, n)
register char *cp;
{
	cp++;
	if (n>=10)
		*cp++ = (n/10)%10 + '0';
	else
		*cp++ = ' ';
	*cp++ = n%10 + '0';
	return(cp);
}


/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
static char sccsid[] = "@(#)timezone.c	5.1 (Berkeley) 5/30/85";
#endif not lint

/*
 * The arguments are the number of minutes of time
 * you are westward from Greenwich and whether DST is in effect.
 * It returns a string
 * giving the name of the local timezone.
 *
 * Sorry, I don't know all the names.
 */

static struct zone {
	int	offset;
	char	*stdzone;
	char	*dlzone;
} zonetab[] = {
	-1*60, "MET", "MET DST",	/* Middle European */
	-2*60, "EET", "EET DST",	/* Eastern European */
	4*60, "AST", "ADT",		/* Atlantic */
	5*60, "EST", "EDT",		/* Eastern */
	6*60, "CST", "CDT",		/* Central */
	7*60, "MST", "MDT",		/* Mountain */
	8*60, "PST", "PDT",		/* Pacific */
	/* there's no way to distinguish this from WET */
	0, "GMT", "BST",		/* fixed by NCT */
#ifdef notdef
	0*60, "WET", "WET DST",		/* Western European */
#endif
	-10*60, "EST", "EST",		/* Aust: Eastern */
	-10*60+30, "CST", "CST",	/* Aust: Central */
	-8*60, "WST", 0,		/* Aust: Western */
	-1
};

char *timezone(zone, dst)
{
	register struct zone *zp;
	static char czone[10];
	char *sign;
	register char *p, *q;
	char *getenv(), *index();

	if (p = getenv("TZNAME")) {
		if (q = index(p, ',')) {
			if (dst)
				return(++q);
			else {
				*q = '\0';
				strncpy(czone, p, sizeof(czone)-1);
				czone[sizeof(czone)-1] = '\0';
				*q = ',';
				return (czone);
			}
		}
		return(p);
	}
	for (zp=zonetab; zp->offset!=-1; zp++)
		if (zp->offset==zone) {
			if (dst && zp->dlzone)
				return(zp->dlzone);
			if (!dst && zp->stdzone)
				return(zp->stdzone);
		}
	if (zone<0) {
		zone = -zone;
		sign = "+";
	} else
		sign = "-";
	sprintf(czone, "GMT%s%d:%02d", sign, zone/60, zone%60);
	return(czone);
}


From whm%arizona.csnet@CSNET-RELAY.ARPA  Wed Jan  8 07:22:22 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA17659; Wed, 8 Jan 86 07:22:22 PST
Received: from arizona by csnet-relay.csnet id a017371; 8 Jan 86 9:36 EST
Received: by arizona.uucp (5.15/3.14)
	id AA04905; Wed, 8 Jan 86 02:01:48 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA13987; Wed, 8 Jan 86 02:01:39 MST
Date: Wed, 8 Jan 86 02:01:39 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601080901.AA13987@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: micro bug in whatis and apropos man pages

Under FILES, they claim to reference /usr/lib/whatis, but the whatis
file is now in the root of each man tree.  E.g., /usr/man/whatis.

From lepreau@utah-cs.ARPA  Wed Jan  8 13:19:02 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA18871; Wed, 8 Jan 86 13:19:02 PST
Received: by utah-cs.ARPA (5.5/4.40.2)
	id AA25545; Wed, 8 Jan 86 14:19:30 MST
Date: Wed, 8 Jan 86 14:19:30 MST
Message-Id: <8601082119.AA25545@utah-cs.ARPA>
From: Jay Lepreau <lepreau@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Cc: peter@utah-cs.ARPA, kalash@ucbingres.arpa
Subject: 4.3 beta ingres apparently is quite broken

Peter Ford (peter@utah-cs.arpa) has been handling this and has sent the
details to Joe, but has gotten no substantive response yet.  The
non-commercial ingres is still used by lots of sites, particularly
Universities for teaching purposes, and a working version really needs
to be on the tape.

From @rand-unix.ARPA:guyton%condor@rand-unix.ARPA  Wed Jan  8 17:34:02 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA21407; Wed, 8 Jan 86 17:34:02 PST
Return-Path: <guyton@condor>
Received: from condor.arpa (condor) by rand-unix.ARPA; Wed, 8 Jan 86 17:10:19 pst
Received: from localhost by condor.arpa; Wed, 8 Jan 86 17:09:48 pst
From: Jim Guyton <guyton%condor@rand-unix.ARPA>
Message-Id: <8601090109.AA03321@condor.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: James_Guyton <guyton@rand-unix.ARPA>, obrien@rand-unix.ARPA,
        terry@rand-unix.ARPA
Subject: telnetd and binary mode
Date: 08 Jan 86 17:09:44 PST (Wed)

Description:

	Implementation of binary mode in telnet daemon wrong.

	Telling the 4.3BSD server telnet to go into binary mode
	currently puts the tty into RAW mode.  This isn't
	necessary and will sometimes even logout the user.

Repeat-by:

	Use a TAC to login to a 4.3 site.
	Use the commands "@B O S" and "@B I S"
	Watch your connection close.


Fix:    Comment out the code!

% diff telnetd.c new-telnetd.c
427c427
< 		mode(RAW, 0);
---
> 	/*      mode(RAW, 0);   */
464c464
< 		mode(0, RAW);
---
> 	/*      mode(0, RAW);   */
496c496
< 		mode(RAW, 0);
---
> 	/*      mode(RAW, 0);   */

From @rand-unix.ARPA:guyton%condor@rand-unix.ARPA  Wed Jan  8 21:59:42 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA23011; Wed, 8 Jan 86 21:59:42 PST
Return-Path: <guyton@condor>
Received: from condor.arpa (condor) by rand-unix.ARPA; Wed, 8 Jan 86 21:34:21 pst
Received: from localhost by condor.arpa; Wed, 8 Jan 86 21:18:02 pst
From: Jim Guyton <guyton%condor@rand-unix.ARPA>
Message-Id: <8601090518.AA03665@condor.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: James_Guyton <guyton@rand-unix.ARPA>, obrien@rand-unix.ARPA,
        terry@rand-unix.ARPA
Subject: /etc/savecore and minimum free disk space calculation
Date: 08 Jan 86 21:17:58 PST (Wed)

Description:

     Two bugs [same chunk of code, so one bug report]

	   1)  Savecore does not include frag blocks in calculating
	       the amount of free disk space.

	   2a) The savecore man page doesn't mention that the number
	       supplied in the "minfree" file is compared to the
	       number of free blocks left on the disk, ignoring any
	       filesystem minfree percentage [fs_minfree].

	   or [take your pick as to which one, I prefer 2a]

	   2b) Savecore does not subtract the minfree percentage during
	       its calcuation of free disk space.

Fix [to (1) only]:
% diff savecore.c.orig savecore.c
369c369,371
<       spacefree = fs.fs_cstotal.cs_nbfree * fs.fs_bsize / 1024;
---
> /*   space free does not subtract the fs_minfree percentage! */
>       spacefree = ((fs.fs_cstotal.cs_nbfree * fs.fs_frag ) +
>                    fs.fs_cstotal.cs_nffree) * fs.fs_fsize / 1024;

From kalash@ingres.berkeley.edu  Wed Jan  8 22:08:05 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA23030; Wed, 8 Jan 86 22:08:05 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA26202; Wed, 8 Jan 86 22:00:38 PST
Received: by ucbingres.ARPA (5.5/4.2)
	id AA10016; Wed, 8 Jan 86 21:58:27 PST
Date: Wed, 8 Jan 86 21:58:27 PST
From: kalash@ingres.berkeley.edu (Joe Kalash)
Message-Id: <8601090558.AA10016@ucbingres.ARPA>
To: beta43_bugs@monet.berkeley.edu, lepreau@utah-cs.arpa
Subject: Re:  4.3 beta ingres apparently is quite broken
Cc: anton@ingres.berkeley.edu, peter@utah-cs.arpa,
        utah-cs.kalash@ucbarpa.berkeley.edu

	I have not heard anything in any form (good, bad or indefferent).
While I am no longer with the project, I am willing to help as much as I
can. Can someone tell me more, 4.3 Ingres passed all of our internal
validation suites?

			Joe

From anton@ucbingres  Thu Jan  9 01:09:14 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA23866; Thu, 9 Jan 86 01:09:14 PST
Received: by ucbingres.ARPA (5.5/4.2)
	id AA10474; Thu, 9 Jan 86 01:07:04 PST
Date: Thu, 9 Jan 86 01:07:04 PST
From: anton@ucbingres (Jeff Anton)
Message-Id: <8601090907.AA10474@ucbingres.ARPA>
To: beta43_bugs@monet.berkeley.edu, lepreau@utah-cs.arpa
Subject: 4.3 beta university INGRES bugs
Cc: kalash@ucbingres, peter@utah-cs.arpa

Bug reports related to university INGRES should be sent to
ingres@ingres.berkeley.edu.  We are interested in possible bugs in the
system, and know that the distributed source was in less than ideal condition.
The PDP is not supported at all, but it may be possible with much
work.  Our own bug list is very short for our current version.
				Jeff Anton
				Ingres Group

From peter%utah-muddy@utah-cs.arpa  Thu Jan  9 09:40:37 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA25198; Thu, 9 Jan 86 09:40:37 PST
Received: from utah-muddy.ARPA by utah-cs.ARPA (5.5/4.40.2)
	id AA22489; Thu, 9 Jan 86 10:41:05 MST
Received: by utah-muddy.ARPA (5.31/4.40.2)
	id AA16323; Thu, 9 Jan 86 10:41:01 MST
Date: Thu, 9 Jan 86 10:41:01 MST
From: peter%utah-muddy@utah-cs.arpa (Peter S. Ford)
Message-Id: <8601091741.AA16323@utah-muddy.ARPA>
To: anton@ingres.berkeley.edu, beta43_bugs@monet.berkeley.edu,
        lepreau@utah-cs.arpa
Subject: Re:  4.3 beta university INGRES bugs

The bug in question involved ingres attempting to exec
~ingres/bin/ksort where ~ingres/bin/ksort (as communicated by Joe
Kalash) no longer exists in the latest version of INGRES.

I no longer have the output from this problem (this occured in early
december in one of the classes using ingres), but I will rebuild ingres,
restore the database and try to replicate the problem.

Are there plans to distribute a version of ingres different from the 
sources which came with the 4.3 beta tapes?

Peter Ford (peter@utah-cs).

From lepreau  Thu Jan  9 16:16:12 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA28784; Thu, 9 Jan 86 16:16:12 PST
Date: Thu, 9 Jan 86 16:16:12 PST
From: lepreau (Jay Lepreau)
Message-Id: <8601100016.AA28784@monet.berkeley.edu>
To: beta43_bugs
Subject: sys/vax/cons.c cnputc() does its own delaying

..instead of using DELAY, so it's not parameterized.

From lepreau@utah-cs.ARPA  Fri Jan 10 14:13:41 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA00816; Fri, 10 Jan 86 14:13:41 PST
Received: by utah-cs.ARPA (5.5/4.40.2)
	id AA01220; Fri, 10 Jan 86 15:14:12 MST
Date: Fri, 10 Jan 86 15:14:12 MST
From: lepreau@utah-cs.arpa (Jay Lepreau)
Message-Id: <8601102214.AA01220@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: dh.c/dmintr bug? (from net)

Path: utah-cs!seismo!rochester!ritcv!rocksvax!z
>From: z@rocksvax.UUCP (Jim Ziobro)
Newsgroups: net.bugs.4bsd
Subject: dh/dm hangup problem
Message-ID: <1642@rocksvax.UUCP>
Date: Wed, 4 Dec 85 21:00:19 MST
Organization: Xerox: Henrietta, NY

Revisions: 4.2BSD and 4.3BSD (Beta)

Index: /sys/vaxuba/dh.c

Problem: dm handler fails to lock out interrupts.

Repeat by: Toggle the carrier on one of the multiplexors lines.  Then
	watch random login processes get hangup signals.  This problem
	was discovered on an Emulex CS-11 with 32 lines.

Fix: Add an spl5/splx to the dm interrupt handler.

This is a fix for 4.2:

*** dh.c.ucb	Fri Jul 29 10:33:35 1983
--- dh.c	Wed Dec  4 22:40:35 1985
***************
*** 699,704
  	register struct uba_device *ui;
  	register struct tty *tp;
  	register struct dmdevice *addr;
  
  	ui = dminfo[dm];
  	if (ui == 0)

--- 699,705 -----
  	register struct uba_device *ui;
  	register struct tty *tp;
  	register struct dmdevice *addr;
+ 	int s;
  
  	ui = dminfo[dm];
  	if (ui == 0)
***************
*** 703,708
  	ui = dminfo[dm];
  	if (ui == 0)
  		return;
  	addr = (struct dmdevice *)ui->ui_addr;
  	if (addr->dmcsr&DM_DONE) {
  		if (addr->dmcsr&DM_CF) {

--- 704,713 -----
  	ui = dminfo[dm];
  	if (ui == 0)
  		return;
+ 	/*
+ 	If you have two dm's the second may interrupt so block it.
+ 	*/
+ 	s = spl5();
  	addr = (struct dmdevice *)ui->ui_addr;
  	if (addr->dmcsr&DM_DONE) {
  		if (addr->dmcsr&DM_CF) {
***************
*** 731,735
  		}
  		addr->dmcsr = DM_IE|DM_SE;
  	}
  }
  #endif

--- 736,741 -----
  		}
  		addr->dmcsr = DM_IE|DM_SE;
  	}
+ splx(s);
  }
  #endif
-- 
//Z\\
James M. Ziobro
Ziobro.Henr@Xerox.ARPA
{rochester,amd,sunybcs,ihnp4}!rocksvax!z

From eric  Fri Jan 10 15:44:36 1986
Received: by monet.berkeley.edu (5.38/1.7)
	id AA01081; Fri, 10 Jan 86 15:44:36 PST
From: eric (Eric Allman)
Message-Id: <8601102344.AA01081@monet.berkeley.edu>
To: Piet Beertema <mcvax!piet@seismo.CSS.GOV>
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: sendmail bug
In-Reply-To: Your message of 17 Dec 85 13:11:46 N (Tue).
	     <8512171211.AA01366@mcvax.UUCP>
Date: 10 Jan 86 15:44:26 PST (Fri)

This is not really a bug, but I am willing to make the change anyway
because I can't see that it could ever hurt anything.

eric

From SATZ@SU-SIERRA.ARPA  Fri Jan 10 17:32:38 1986
Received: by monet.berkeley.edu (5.43/1.7)
	id AA02056; Fri, 10 Jan 86 17:32:38 PST
Message-Id: <8601110132.AA02056@monet.berkeley.edu>
Date: Fri 10 Jan 86 17:31:54-PST
From: Greg Satz <SATZ@SU-SIERRA.ARPA>
Subject: C optimizer bug
To: beta43_bugs@monet.berkeley.edu
Phone: (415) 497-1004

I don't think this is a 4.3 related, but I thought I would report it
anyway since it bit me while building a kernel.

I found a nasty bug in the C optimizer. If a calls with zero arguments
follows a clr, the optimizer will convert the calls to use the register
that was cleared instead of the $0. The only reason I found this was
because the calls was for splimp and the vax/inline program complained.
I dug around c2 a little and found that clr saves $0 in regs and that
the calls is finding that before the real $0. I won't pretend to know
what to do about it, however.

Here is an example:

	.text
	.align	1
	.globl	_mpurge
_mpurge:
	.word	L367
	jbr 	L369
L370:
	movl	4(ap),r11
	clrl	r7
	calls	$0,_splimp	; this get converted to calls r7,_splimp
	movl	r0,-4(fp)
	clrl	r8
L373:
	cmpl	r8,$512
	jgeq	L372
L374:
	cvtwl	_cmhash[r8],r0
	mull2	$20,r0
	addl2	_cmap,r0
	movl	r0,r10
	cmpl	r10,_ecmap
	jneq	L375
	jbr 	L371
L375:
	cmpl	16(r10),r11
	jneq	L376
	movw	4(r10),_cmhash[r8]
	jbr 	L377
L376:
L380:
	movl	r10,r9
	movzwl	4(r10),r0
	mull2	$20,r0
	addl2	_cmap,r0
	movl	r0,r10
	cmpl	r10,_ecmap
	jneq	L381
	jbr 	L382
L381:
	cmpl	16(r10),r11
	jneq	L383
	jbr 	L379
L383:
L378:
	jbr 	L380
L379:
	movw	4(r10),4(r9)
L377:
	incl	r7
	clrl	16(r10)
	clrl	12(r10)
	clrw	4(r10)
	jbr 	L374
L382:
L371:
	incl	r8
	jbr 	L373
L372:
	pushl	-4(fp)
	calls	$1,_splx
L384:
	movl	r7,r0
	decl	r7
	tstl	r0
	jeql	L385
	pushl	r11
	calls	$1,_vn_rele
	jbr 	L384
L385:
	ret
	.set	L367,0xf80
L369:
	subl2	$4,sp
	jbr 	L370
-------

From Cbjones%cs.ucl.ac.uk@Cs.Ucl.AC.UK  Mon Jan 13 02:35:26 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA05810; Mon, 13 Jan 86 02:35:26 PST
Message-Id: <8601131035.AA05810@monet.berkeley.edu>
Date:     Mon, 13 Jan 86 10:09:20 GMT
From: Cbjones%cs.ucl.ac.uk@cs.ucl.ac.uk
To: beta43_bugs@monet.berkeley.edu
Cc: mckusick@monet.berkeley.edu, karels@monet.berkeley.edu,
        cbjones%cs.ucl.ac.uk@cs.ucl.ac.uk
Subject:  Big problems trying to boot 4.3 Beta tape on 8600

I have an authorised copy of the Beta 4.3 Tape sent to Amsterdam.



I have just tried to boot the 4.3 system from tape onto my new Vax 8600.
The hand bootstrap loads the tape monitor program ok from a TU80.
However once I call for the "copy" program it seeks the program on the
TU80, loads it, gives me the "From:" prompt, to which I reply "ts(0,1)",
the tape then moves to the begining of the next file on the tape, it then
asks me for the "To:" device, to which I reply "ra(0,1)", at which point
the whole thing hangs up. The RA81 device is spun up but the "A" light
on it doesn't come on at any point.

I've checked out the UDA50 and the disks using the DEC Diagnostics.
The rest of the system checks out ok under the diagnostics as well.

Here is what the DEC autosizer says is on my system :-

_CSA0	console		HUB	00000000
_KA0	KA86	HUB	00000000	G-floating instructions=Yes H-floating
instructions=Yes WCS last address=00001FFF(X) Accelerator type=1
_SIO	SBIA	HUB	60080000
_DW0	DW780	_SIO	60006000	TR=3. BR=4.
_LPA	LP11	_DW0	6013FF4C	CSR=777514(O) VECTOR=000200(O) BR=4.
_LPA0	LP04	_LPA	00000000
_MSA0	TU80	_DW0	6013F550	TU80_CSR_ADDRESS=772520(O) TU80_VECTOR=000224(O) BR_LEVEL=5.
_XEA0	UNA11	_DW0	6013F948	CSR=774510(O) VECTOR=000120(O) BR=5.
_DW2	DW780	_SIO	6000A000	TR=5. BR=4.
_DUA	UDA50	_DW2	601BF468	UDAIP=772150(O) Vector=000154(O) BR=5.
Burst_Rate=2.
_DUA0	RA81	_DUA	00000000
_DUA1	RA81	_DUA	00000000
_TXA	DHU11	_DW0	6013E120	CSR=760440(O) VECTOR=000300(O) BR=5.
_OAA	DR11C	_DW0	6013EF80	CSR=767600(O) VECTOR=000320(O) BR=5.
_TXB	DHU11	_DW0	6013E130	CSR=760460(O) VECTOR=000310(O) BR=5.


I've checked that the tape isn't corrupt by booting it onto a 750, that worked
perfectly.

I would appreciate any suggestions that you may have to get the 8600 booted.
Please reply to me at the following addresses :-

cbjones@ucl.cs.arpa	(MAIN)
idc%uk.ac.york.minster@ucl.cs.arpa	(CC)

My usual address (neil%uk.ac.man.cs.ux@ucl.cs.arpa) is not possible because
the 8600 has the network links.


Thanks for your time.

Neil Todd
Unix Systems' Manager
Dept of Computer Science
University of Manchester
ENGLAND


From bloom  Mon Jan 13 08:47:05 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA06646; Mon, 13 Jan 86 08:47:05 PST
From: bloom (Jim Bloom)
Message-Id: <8601131647.AA06646@monet.berkeley.edu>
To: Cbjones%cs.ucl.ac.uk@cs.ucl.ac.uk
Cc: beta43_bugs@monet.berkeley.edu
Subject: Re: Big problems trying to boot 4.3 Beta tape on 8600
In-Reply-To: Your message of Mon, 13 Jan 86 10:09:20 GMT.
	     <8601131035.AA05810@monet.berkeley.edu>
Date: 13 Jan 86 08:47:02 PST (Mon)

If you look at the autosizer output, you will notice that the
UDA is attached to UBA2, not UBA0 as your command suggested.
Try using "ra(16,0)" for now.  During the early boot process
and in making the console rl02, you will need to know about
the actual hardware and not just logical values.

I'm not sure if the documentation describes the values to put
in the registers for the booting correctly.  Read the code in
/sys/stand/boot.c.

					Jim Bloom

From chris@gyre.umd.edu  Mon Jan 13 12:36:21 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA07774; Mon, 13 Jan 86 12:36:21 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA15895; Sun, 12 Jan 86 05:53:37 EST
Date: Sun, 12 Jan 86 05:53:37 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601121053.AA15895@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Revised `man' man page after preceding changes

Index: /usr/man/man1/man.1 4.3Beta Fix

Description:
	If you incorporate the previous changes, the manual page
	needs updating.  (Obvious, but I often forget; I figured
	this might be helpful anyway.)

Repeat-By:
	These bug report forms can get out of hand.

Fix:
	Below.

Chris

RCS file: RCS/man.1,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1015885	Sun Jan 12 05:51:23 1986
--- /tmp/,RCSt2015885	Sun Jan 12 05:51:24 1986
***************
*** 105,111 ****
  path (a la the shell) with the
  .B \-M
! flag.  The search path is a colon (`:') separated list
  of directories in which manual subdirectories may be found;
! e.g. ``/usr/local:/usr/man''.  If a search path is supplied
  with the 
  .B \-k
--- 105,113 ----
  path (a la the shell) with the
  .B \-M
! flag or via the environment variable ``MANPATH''.  (Flag arguments
! override environment variables.)  The search path is a
! colon (`:') separated list
  of directories in which manual subdirectories may be found;
! e.g. ``/usr/local/man:/usr/man''.  If a search path is supplied
  with the 
  .B \-k

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 12:44:37 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA07829; Mon, 13 Jan 86 12:44:37 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA01721; Mon, 13 Jan 86 12:44:30 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA15039; Mon, 13 Jan 86 10:17:42 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA16099; Mon, 13 Jan 86 10:17:02 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10358; Mon, 13 Jan 86 10:19:20 PST
Date: Mon, 13 Jan 86 10:19:20 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601131819.AA10358@gorodish.sun.uucp>
Subject: rlogging out blows away all processes attached to your terminal
Index: 	etc/rlogind.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	As its final act before "exit"ing, "rlogind" does a kill(0, SIGKILL).
	This is *extremely* antisocial, especially if you have done a "uucp"
	which starts up a "uucico".
Repeat-By:
	"rlogin" to a machine, start up a background job, and log out.
Fix:
	Get rid of the kill(0, SIGKILL) in "cleanup"; the "vhangup" there
	sends a SIGHUP, which is sufficient.

From chris@gyre.umd.edu  Mon Jan 13 13:36:11 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA08073; Mon, 13 Jan 86 13:36:11 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA15771; Sun, 12 Jan 86 05:37:01 EST
Date: Sun, 12 Jan 86 05:37:01 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601121037.AA15771@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: man has dead code, lacks `obvious' `feature'

Index: /usr/src/ucb/man.c 4.3Beta Fix

Description:
	There are some minor buglets in the path searching code
	revolving around the useless `ss' variable.  `man' has a
	compiled-in path as a default, but should use $MANPATH from
	the environment if it exists.  The code for handling
	subsections is unnecessarily complex.

Repeat-By:
	Examination.

Fix:
	Below.  You will need to weed out changes that do not apply,
	such as `/usr/local/man' and the `l' subsection in all
	manuals (which is really just some backwards compatibility
	that I intend to throw out soon anyway).  Also, this includes
	the previous fix I sent for a minor null pointer dereference
	bug, as I just made a diff from the beta version; patch
	may fail to do the right thing there as well.

Chris

RCS file: RCS/man.c,v
retrieving revision 1.1
retrieving revision 1.5
diff -c2 -r1.1 -r1.5
*** /tmp/,RCSt1015841	Sun Jan 12 05:45:50 1986
--- /tmp/,RCSt2015841	Sun Jan 12 05:45:52 1986
***************
*** 34,47 ****
  #define	CAT_S	"/bin/cat -s"		/* for '-' opt (no more) */
  
  #define TROFFCMD \
  "troff -t -man /usr/lib/tmac/tmac.vcat %s | /usr/lib/rvsort |/usr/ucb/vpr -t"
  
  #define	ALLSECT	"1nl6823457po"	/* order to look through sections */
  #define	SECT1	"1nlo"		/* sections to look at if 1 is specified */
! #define	SUBSEC1	"mcgprv"	/* subsections to try in section 1 */
! #define	SUBSEC2	"v"
! #define	SUBSEC3	"jxmsnvcf"
! #define	SUBSEC4	"pfvsn"
! #define	SUBSEC8	"vc"
  
  #define	WHATIS	"whatis"
--- 34,53 ----
  #define	CAT_S	"/bin/cat -s"		/* for '-' opt (no more) */
  
+ /*
  #define TROFFCMD \
  "troff -t -man /usr/lib/tmac/tmac.vcat %s | /usr/lib/rvsort |/usr/ucb/vpr -t"
+  */
+ #define	TROFFCMD	"ltroff -man %s"
  
  #define	ALLSECT	"1nl6823457po"	/* order to look through sections */
  #define	SECT1	"1nlo"		/* sections to look at if 1 is specified */
! #define	SUBSEC1	"lmcgprv"	/* subsections to try in section 1 */
! #define	SUBSEC2	"lv"
! #define	SUBSEC3	"ljxmsnvcf"
! #define	SUBSEC4	"lpfvsn"
! #define	SUBSEC5	"l"
! #define	SUBSEC6	"l"
! #define	SUBSEC7	"l"
! #define	SUBSEC8	"lvc"
  
  #define	WHATIS	"whatis"
***************
*** 50,54 ****
  int	cflag;
  char	*CAT	= CAT_;
! char	*manpath = "/usr/man";
  char	*strcpy();
  char	*strcat();
--- 56,61 ----
  int	cflag;
  char	*CAT	= CAT_;
! char	*manpath = "/usr/local/man:/usr/man";
! char	*getenv();
  char	*strcpy();
  char	*strcat();
***************
*** 69,73 ****
--- 76,83 ----
  	char *argv[];
  {
+ 	char *path;
  
+ 	if ((path = getenv("MANPATH")) != NULL)
+ 		manpath = path;
  	umask(02);
  	mypid = getpid();
***************
*** 159,163 ****
  {
  
! 	if (ac > 0 && strcmp(av[0], "-M") == 0 || strcmp(av[0], "-P") == 0) {
  		if (ac < 2) {
  			fprintf(stderr, "%s: missing path\n", av[0]);
--- 169,173 ----
  {
  
! 	if (ac > 0 && (strcmp(av[0], "-M") == 0 || strcmp(av[0], "-P") == 0)) {
  		if (ac < 2) {
  			fprintf(stderr, "%s: missing path\n", av[0]);
***************
*** 178,182 ****
  	char path[MAXPATHLEN+1], realname[MAXPATHLEN+1];
  	char cmdbuf[150];
- 	int ss;
  	struct stat stbuf, stbuf2;
  	int last;
--- 188,191 ----
***************
*** 184,187 ****
--- 193,200 ----
  	FILE *it;
  	char abuf[BUFSIZ];
+ 	static char *xref[9] = {
+ 		"", SUBSEC1, SUBSEC2, SUBSEC3, SUBSEC4,
+ 		SUBSEC5, SUBSEC6, SUBSEC7, SUBSEC8
+ 	};
  
  	strcpy(work, "manx/");
***************
*** 194,199 ****
  	}
  	if (section == 0) {
! 		ss = 0;
! 		for (section = *sp++; section; section = *sp++) {
  			work[3] = section;
  			work[last] = section;
--- 207,211 ----
  	}
  	if (section == 0) {
! 		while ((section = *sp++) != NULL) {
  			work[3] = section;
  			work[last] = section;
***************
*** 205,225 ****
  				char *cp;
  search:
! 				switch (work[last]) {
! 				case '1': cp = SUBSEC1; break;
! 				case '2': cp = SUBSEC2; break;
! 				case '3': cp = SUBSEC3; break;
! 				case '4': cp = SUBSEC4; break;
! 				case '8': cp = SUBSEC8; break;
! 				default:  cp = ""; break;
! 				}
  				while (*cp) {
  					work[last+1] = *cp++;
! 					if (pathstat(work, path, &stbuf)) {
! 						ss = work[last+1];
  						goto found;
- 					}
  				}
- 				if (ss = 0)
- 					work[last+1] = 0;
  			}
  		}
--- 217,226 ----
  				char *cp;
  search:
! 				cp = xref[work[last] - '0'];
  				while (*cp) {
  					work[last+1] = *cp++;
! 					if (pathstat(work, path, &stbuf))
  						goto found;
  				}
  			}
  		}
***************
*** 241,248 ****
  				sp = "\0";
  				goto search;
! 			}
! 			else if (section == 'o') {
  				char *cp;
  				char sec;
  				for (sec = '0'; sec <= '8'; sec++) {
  					work[last] = sec;
--- 242,249 ----
  				sp = "\0";
  				goto search;
! 			} else if (section == 'o') {
  				char *cp;
  				char sec;
+ 
  				for (sec = '0'; sec <= '8'; sec++) {
  					work[last] = sec;
***************
*** 249,269 ****
  					if (pathstat(work, path, &stbuf))
  						goto found;
! 					switch (work[last]) {
! 					case '1': cp = SUBSEC1; break;
! 					case '2': cp = SUBSEC2; break;
! 					case '3': cp = SUBSEC3; break;
! 					case '4': cp = SUBSEC4; break;
! 					case '8': cp = SUBSEC8; break;
! 					default:  cp = ""; break;
! 					}
  					while (*cp) {
  						work[last+1] = *cp++;
! 						if (pathstat(work, path, &stbuf)) {
! 							ss = work[last+1];
  							goto found;
- 						}
  					}
- 					if (ss = 0)
- 						work[last+1] = 0;
  				}
  			}
--- 250,259 ----
  					if (pathstat(work, path, &stbuf))
  						goto found;
! 					cp = xref[sec - '0'];
  					while (*cp) {
  						work[last+1] = *cp++;
! 						if (pathstat(work, path, &stbuf))
  							goto found;
  					}
  				}
  			}

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 15:56:15 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA09714; Mon, 13 Jan 86 15:56:15 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA05662; Mon, 13 Jan 86 15:55:59 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA17723; Mon, 13 Jan 86 14:33:10 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA17753; Mon, 13 Jan 86 14:32:30 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10503; Mon, 13 Jan 86 14:34:48 PST
Date: Mon, 13 Jan 86 14:34:48 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601132234.AA10503@gorodish.sun.uucp>
Subject: logging out from "telnet" blows away all processes attached
	to your terminal
Index: 	etc/telnetd.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	As its final act before "exit"ing, "telnetd" does a kill(0, SIGKILL).
	This is *extremely* antisocial, especially if you have done a "uucp"
	which starts up a "uucico".
Repeat-By:
	"telnet" to a 4.3BSD machine, start up a background job, and log out.
Fix:
	Get rid of the kill(0, SIGKILL) in "cleanup"; the "vhangup" there
	sends a SIGHUP, which is sufficient.

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 15:58:39 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA09738; Mon, 13 Jan 86 15:58:39 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA05686; Mon, 13 Jan 86 15:57:48 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA17833; Mon, 13 Jan 86 14:43:28 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA17791; Mon, 13 Jan 86 14:42:44 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10604; Mon, 13 Jan 86 14:45:01 PST
Date: Mon, 13 Jan 86 14:45:01 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601132245.AA10604@gorodish.sun.uucp>
Subject: Several bugs in "ftp"
Index: 	ucb/ftp/cmds.c ucb/ftp/ftp.c ucb/ftp/getpass.c ucb/ftp/main.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	1) The "!" command has an undocumented feature; if it's invoked in
	   the form "!<command>", the <command> is executed and control
	   returns to "ftp" when it exits.  This is nicely consistent
	   with most other UNIX commands (I wish more commands would
	   interpret an undecorated "!" as a request to spawn an
	   interactive subshell, as "ftp" does).  However, instead of
	   just handing the <command> to an "sh -c", it tries to do the
	   "glob"bing and tokenizing itself and does an "execvp" directly.
	   This does not work correctly.

	   Also, when invoked without a <command>, it prefixes the
	   shell's name with a "-", causing it to be run as a login shell,
	   which is wrong.  (And if the shell is not "sh", it prefixes
	   it with a "+" instead.)

	2) If you try to retrieve something into a local file, and you
	   don't have write permission on the file, it tests whether
	   you have write permission on the directory containing that file.
	   However, the test is wrong - if the local file name is a path
	   containing slashes, it does a test on a null pathname rather
	   than on the containing directory.

	3) When "ftp" is waiting for a reply code from the FTP server on
	   the other end, it loops, reading reply codes, until the
	   standard I/O buffer it's reading into is empty and there
	   is no more data to read from the descriptor for the connection
	   to the server.

	   This means that if the server sends two replies to a command
	   (i.e., a "Positive Preliminary Reply", like "Opening data
	   connection for...", followed by a "Positive Completion Reply",
	   like "Transfer complete"), and the two replies arrive in rapid
	   enough sequence, only the second reply will be seen.

	   A typical case where this causes a problem is in a "get" command.
	   "ftp" sends a "RETR" command and waits for a Positive Preliminary
	   Reply.  A Positive Preliminary Reply comes back, indicating that
	   the connection is opened; the data is sent, and a Positive
	   Completion Reply is sent indicating that the transfer is complete.
	   If all this data arrives before the "getreply" routine gets around
	   to reading the reply code or checking whether the socket is empty,
	   after reading the Positive Preliminary Reply it reads the Positive
	   Completion Reply, decides that it's not what it was expecting
	   (it's expecting a Positive Preliminary Reply), and doesn't bother
	   reading the data nor notifying the user that it didn't do any
	   reading (other than reporting 0 bytes transferred).

	4) "ftp" should permit passwords of at least 50 characters in
	   length; see a previous bug posting by, I believe, rws@mit-bold.
	   4.3BSD almost fixes this, but the code limits passwords
	   to 49 characters.

Repeat-By:
	1) Try

		ftp>!echo "*.c"

	   and notice that it does not print "*.c".  Then try

		ftp>!

	   and do a "ps"; note that you're running "-sh" or "+csh" (or
	   something like that).

	2) Try doing a "get" where the target file is not in the current
	   directory and is in a directory where you don't have write
	   permission.  It won't complain, but it won't do it either.

	3) I saw it while talking to a CCI Power 5/20 with UNET; it was
	   not reliably repeatable.  However, after the fix mentioned below
	   was applied, it never happened again.

Fix:
	Here's an omnibus set of fixes:

*** /archwizard/4.3beta/usr/src/ucb/ftp/cmds.c	Fri May 31 16:59:02 1985
--- 4.3.fixed/cmds.c	Wed Jul 31 16:34:12 1985
***************
*** 736,741
  			close(pid);
  		signal(SIGINT, SIG_DFL);
  		signal(SIGQUIT, SIG_DFL);
  		if (argc <= 1) {
  			shell = getenv("SHELL");
  			if (shell == NULL)

--- 744,755 -----
  			close(pid);
  		signal(SIGINT, SIG_DFL);
  		signal(SIGQUIT, SIG_DFL);
+ 		shell = getenv("SHELL");
+ 		if (shell == NULL)
+ 			shell = "/bin/sh";
+ 		namep = rindex(shell,'/');
+ 		if (namep == NULL)
+ 			namep = shell;
  		if (argc <= 1) {
  			if (debug) {
  				printf ("%s\n", shell);
***************
*** 737,752
  		signal(SIGINT, SIG_DFL);
  		signal(SIGQUIT, SIG_DFL);
  		if (argc <= 1) {
- 			shell = getenv("SHELL");
- 			if (shell == NULL)
- 				shell = "/bin/sh";
- 			namep = rindex(shell,'/');
- 			if (namep == NULL)
- 				namep = shell;
- 			strcpy(shellnam,"-");
- 			strcat(shellnam, ++namep);
- 			if (strcmp(namep, "sh") != 0)
- 				shellnam[0] = '+';
  			if (debug) {
  				printf ("%s\n", shell);
  				fflush (stdout);

--- 751,756 -----
  		if (namep == NULL)
  			namep = shell;
  		if (argc <= 1) {
  			if (debug) {
  				printf ("%s\n", shell);
  				fflush (stdout);
***************
*** 751,767
  				printf ("%s\n", shell);
  				fflush (stdout);
  			}
! 			execl(shell, shellnam, 0);
! 			perror(shell);
! 			exit(1);
! 		}
! 		cpp = &argv[1];
! 		if (argc > 2) {
! 			if ((gargs = glob(cpp)) != NULL)
! 				cpp = gargs;
! 			if (globerr != NULL) {
! 				printf("%s\n", globerr);
! 				exit(1);
  			}
  		}
  		if (debug) {

--- 755,771 -----
  				printf ("%s\n", shell);
  				fflush (stdout);
  			}
! 			execl(shell, shell, (char *)0);
! 		} else {
! 			char *args[4];	/* "sh" "-c" <command> NULL */
! 
! 			args[0] = shell;
! 			args[1] = "-c";
! 			args[2] = argv[1];
! 			args[3] = NULL;
! 			if (debug) {
! 				printf("%s -c %s\n", shell, argv[1]);
! 				fflush(stdout);
  			}
  			execv(shell, args);
  		}
***************
*** 763,768
  				printf("%s\n", globerr);
  				exit(1);
  			}
  		}
  		if (debug) {
  			register char **zip = cpp;

--- 767,773 -----
  				printf("%s -c %s\n", shell, argv[1]);
  				fflush(stdout);
  			}
+ 			execv(shell, args);
  		}
  		perror(shell);
  		exit(1);
***************
*** 764,780
  				exit(1);
  			}
  		}
! 		if (debug) {
! 			register char **zip = cpp;
! 
! 			printf("%s", *zip);
! 			while (*++zip != NULL)
! 				printf(" %s", *zip);
! 			printf("\n");
! 			fflush(stdout);
! 		}
! 		execvp(argv[1], cpp);
! 		perror(argv[1]);
  		exit(1);
  	}
  	if (pid > 0)

--- 769,775 -----
  			}
  			execv(shell, args);
  		}
! 		perror(shell);
  		exit(1);
  	}
  	if (pid > 0)

*** /archwizard/4.3beta/usr/src/ucb/ftp/ftp.c	Fri May 31 17:00:50 1985
--- 4.3.fixed/ftp.c	Fri Dec 13 12:52:25 1985
***************
*** 188,195
  				originalcode = code;
  			continue;
  		}
! 		if (expecteof || empty(cin))
! 			return (n - '0');
  	}
  }
  

--- 188,194 -----
  				originalcode = code;
  			continue;
  		}
! 		return (n - '0');
  	}
  }
  
***************
*** 193,212
  	}
  }
  
- empty(f)
- 	FILE *f;
- {
- 	long mask;
- 	struct timeval t;
- 
- 	if (f->_cnt > 0)
- 		return (0);
- 	mask = (1 << fileno(f));
- 	t.tv_sec = t.tv_usec = 0;
- 	(void) select(20, &mask, 0, 0, &t);
- 	return (mask == 0);
- }
- 
  jmp_buf	sendabort;
  
  abortsend()

--- 192,197 -----
  	}
  }
  
  jmp_buf	sendabort;
  
  abortsend()
***************
*** 362,368
  	oldintr = signal(SIGINT, abortrecv);
  	if (strcmp(local, "-") && *local != '|')
  		if (access(local, 2) < 0) {
! 			char *dir = rindex(local, '/');
  
  			if (dir != NULL)
  				*dir = 0;

--- 347,354 -----
  	oldintr = signal(SIGINT, abortrecv);
  	if (strcmp(local, "-") && *local != '|')
  		if (access(local, 2) < 0) {
! 			if (errno == ENOENT) {
! 				char *dir = rindex(local, '/');
  
  				if (dir != NULL)
  					*dir = 0;
***************
*** 364,375
  		if (access(local, 2) < 0) {
  			char *dir = rindex(local, '/');
  
! 			if (dir != NULL)
! 				*dir = 0;
! 			d = access(dir ? local : ".", 2);
! 			if (dir != NULL)
! 				*dir = '/';
! 			if (d < 0) {
  				perror(local);
  				goto bad;
  			}

--- 350,365 -----
  			if (errno == ENOENT) {
  				char *dir = rindex(local, '/');
  
! 				if (dir != NULL)
! 					*dir = 0;
! 				d = access(dir ? local : ".", 2);
! 				if (dir != NULL)
! 					*dir = '/';
! 				if (d < 0) {
! 					perror(local);
! 					goto bad;
! 				}
! 			} else {
  				perror(local);
  				goto bad;
  			}
***************
*** 501,507
  	}
  	if (!sendport)
  		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on)) < 0) {
! 			perror("ftp: setsockopt (resuse address)");
  			goto bad;
  		}
  	if (bind(data, (char *)&data_addr, sizeof (data_addr), 0) < 0) {

--- 491,497 -----
  	}
  	if (!sendport)
  		if (setsockopt(data, SOL_SOCKET, SO_REUSEADDR, &on, sizeof (on)) < 0) {
! 			perror("ftp: setsockopt (reuse address)");
  			goto bad;
  		}
  	if (bind(data, (char *)&data_addr, sizeof (data_addr), 0) < 0) {

*** /archwizard/4.3beta/usr/src/ucb/ftp/getpass.c	Fri May 31 17:01:19 1985
--- 4.3.fixed/getpass.c	Mon Jul 15 16:09:12 1985
***************
*** 30,36
  {
  	register char *p;
  	register c;
! 	static char pbuf[50];
  	int (*signal())();
  	int (*sig)();
  

--- 30,36 -----
  {
  	register char *p;
  	register c;
! 	static char pbuf[50+1];
  	int (*signal())();
  	int (*sig)();
  

*** /archwizard/4.3beta/usr/src/ucb/ftp/main.c	Fri May 31 17:08:42 1985
--- 4.3.fixed/main.c	Wed Jul 31 16:32:40 1985
***************
*** 265,271
  	argp = margv;
  	stringbase = line;		/* scan from first of buffer */
  	argbase = argbuf;		/* store from first of buffer */
! 	while (*argp++ = slurpstring())
  		margc++;
  }
  

--- 265,275 -----
  	argp = margv;
  	stringbase = line;		/* scan from first of buffer */
  	argbase = argbuf;		/* store from first of buffer */
! 	while (*stringbase == ' ' || *stringbase == '\t')
! 		stringbase++;		/* skip initial white space */
! 	if (*stringbase == '!') {	/* handle shell escapes specially */
! 		stringbase++;
! 		*argp++ = "!";		/* command name is "!" */
  		margc++;
  		while (*stringbase == ' ' || *stringbase == '\t')
  			stringbase++;		/* skip white space */
***************
*** 267,272
  	argbase = argbuf;		/* store from first of buffer */
  	while (*argp++ = slurpstring())
  		margc++;
  }
  
  /*

--- 271,287 -----
  		stringbase++;
  		*argp++ = "!";		/* command name is "!" */
  		margc++;
+ 		while (*stringbase == ' ' || *stringbase == '\t')
+ 			stringbase++;		/* skip white space */
+ 		if (*stringbase != '\0') {
+ 			*argp++ = stringbase;	/* argument is entire command string */
+ 			margc++;
+ 		}
+ 		*argp++ = NULL;
+ 	} else {
+ 		while (*argp++ = slurpstring())
+ 			margc++;
+ 	}
  }
  
  /*
***************
*** 282,291
  	register char *ap = argbase;
  	char *tmp = argbase;		/* will return this if token found */
  
- 	if (*sb == '!') {		/* recognize ! as a token for shell */
- 		stringbase++;
- 		return ("!");
- 	}
  S0:
  	switch (*sb) {
  

--- 297,302 -----
  	register char *ap = argbase;
  	char *tmp = argbase;		/* will return this if token found */
  
  S0:
  	switch (*sb) {
  

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 16:00:07 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA09759; Mon, 13 Jan 86 16:00:07 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA05723; Mon, 13 Jan 86 15:59:38 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA17862; Mon, 13 Jan 86 14:54:00 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA17862; Mon, 13 Jan 86 14:53:15 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10732; Mon, 13 Jan 86 14:55:33 PST
Date: Mon, 13 Jan 86 14:55:33 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601132255.AA10732@gorodish.sun.uucp>
Subject: Several problems with "mille"
Index: 	games/mille/init.c games/mille/mille.c games/mille/misc.c
	games/mille/move.c games/mille/roll.c games/mille/save.c
	games/mille/varpush.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	1) The 'o' command toggles a flag indicating whether to order
	the hand or not.  The version supplied in binary form, both in
	4.1BSD and 4.2BSD, also toggled the menu item for 'o' between
	"order hand" and "stop ordering".  Neither the source supplied with
	4.1BSD nor the source supplied with 4.2BSD built this version;
	the versions built with the source left the menu item as "order hand".

	2) Several "lint" errors show up when "mille" is "lint"ed.  There
	are a couple of unused variables, and several cases where an integer
	is passed to a routine expecting a pointer.  This causes problems
	on machines with 16-bit "int"s and 32-bit pointers.  There are a
	couple of "char" variables which should be "int"s, which might
	cause problems on machines with no signed "char"s (like the AT&T
	3B machines).  The time of day is declared as a "struct tm" rather
	than a "long" or "time_t" which causes considerable confusion, as
	well as forcing the module to include <time.h> which, for no good
	reason, is not present on 4.2BSD (it's moved to <sys/time.h> with
	no <time.h> left around).

	3) "rand" is assumed to return a number in the range 0 to 2^31 - 1
	on VAXes and a number in the range 0 to 2^15 - 1 on all other
	machines.  On 4.2BSD machines other than the VAX "rand" also returns
	numbers in the range 0 to 2^31 - 1.  We add a #define constant
	BSD, and assume 31-bit random numbers if it's defined and 15-bit
	random number otherwise.  (Make sure you #define this if building
	for 4.xBSD, including 4.1BSD.)

Repeat-By:
	1) Just try using the 'o' key and notice that the menu item doesn't
	change.

	2) Just try porting "mille" to a 16-bit-"int"/32-bit-pointer machine
	(like, to pick a random example, a CCI Power 5/20).

	3) Just try porting "mille" to a 4.2BSD machine other than a VAX
	(like, to pick a random example, a Sun or a CCI Power 6/32).
Fix:

*** init.c.orig	Tue Jun 18 20:11:41 1985
--- init.c	Thu Jan  2 13:27:07 1986
***************
*** 201,207
  			mvaddstr(13, 2, "d: discard #");
  			mvaddstr(14, 2, "w: toggle window");
  			mvaddstr(11, 21, "q: quit");
! 			mvaddstr(12, 21, "o: order hand");
  			mvaddstr(13, 21, "s: save");
  			mvaddstr(14, 21, "r: reprint");
  		}

--- 201,210 -----
  			mvaddstr(13, 2, "d: discard #");
  			mvaddstr(14, 2, "w: toggle window");
  			mvaddstr(11, 21, "q: quit");
! 			if (!Order)
! 				mvaddstr(12, 21, "o: order hand");
! 			else
! 				mvaddstr(12, 21, "o: stop ordering");
  			mvaddstr(13, 21, "s: save");
  			mvaddstr(14, 21, "r: reprint");
  		}

*** mille.c.orig	Sun Apr  7 00:52:12 1985
--- mille.c	Thu Jan  2 13:29:34 1986
***************
*** 21,27
  
  	if (strcmp(av[0], "a.out") == 0) {
  		outf = fopen("q", "w");
! 		setbuf(outf, 0);
  		Debug = TRUE;
  	}
  	restore = FALSE;

--- 21,27 -----
  
  	if (strcmp(av[0], "a.out") == 0) {
  		outf = fopen("q", "w");
! 		setbuf(outf, (char *)0);
  		Debug = TRUE;
  	}
  	restore = FALSE;
***************
*** 116,122
   */
  rub() {
  
! 	signal(SIGINT, 1);
  	if (getyn(REALLYPROMPT))
  		die();
  	signal(SIGINT, rub);

--- 116,122 -----
   */
  rub() {
  
! 	signal(SIGINT, SIG_IGN);
  	if (getyn(REALLYPROMPT))
  		die();
  	signal(SIGINT, rub);
***************
*** 127,133
   */
  die() {
  
! 	signal(SIGINT, 1);
  	if (outf)
  		fflush(outf);
  	mvcur(0, COLS - 1, LINES - 1, 0);

--- 127,133 -----
   */
  die() {
  
! 	signal(SIGINT, SIG_IGN);
  	if (outf)
  		fflush(outf);
  	mvcur(0, COLS - 1, LINES - 1, 0);

*** misc.c.orig	Sun Apr  7 00:52:12 1985
--- misc.c	Thu Jan  2 13:31:29 1986
***************
*** 30,36
  CARD
  getcard()
  {
! 	reg char	c, c1;
  
  	for (;;) {
  		while ((c = readch()) == '\n' || c == '\r' || c == ' ')

--- 30,36 -----
  CARD
  getcard()
  {
! 	reg int		c, c1;
  
  	for (;;) {
  		while ((c = readch()) == '\n' || c == '\r' || c == ' ')

*** move.c.orig	Sun Apr  7 00:52:12 1985
--- move.c	Thu Jan  2 13:36:34 1986
***************
*** 323,328
  			goto ret;
  		  case 'O':		/* Order */
  			Order = !Order;
  			Movetype = M_ORDER;
  			goto ret;
  		  case 'Q':		/* Quit */

--- 323,333 -----
  			goto ret;
  		  case 'O':		/* Order */
  			Order = !Order;
+ 			if (!Order)
+ 				mvwaddstr(Score, 12, 21, "o: order hand");
+ 			else
+ 				mvwaddstr(Score, 12, 21, "o: stop ordering");
+ 			wclrtoeol(Score);
  			Movetype = M_ORDER;
  			goto ret;
  		  case 'Q':		/* Quit */
***************
*** 392,398
  					leaveok(Board, TRUE);
  					if ((outf = fopen(buf, "w")) == NULL)
  						perror(buf);
! 					setbuf(outf, 0);
  				}
  				Debug = !Debug;
  				break;

--- 397,403 -----
  					leaveok(Board, TRUE);
  					if ((outf = fopen(buf, "w")) == NULL)
  						perror(buf);
! 					setbuf(outf, (char *)0);
  				}
  				Debug = !Debug;
  				break;
***************
*** 488,494
  reg CARD	*hand;
  {
  	reg CARD	*cp, *tp;
- 	reg int		j;
  	reg CARD	temp;
  
  	cp = hand;

--- 493,498 -----
  reg CARD	*hand;
  {
  	reg CARD	*cp, *tp;
  	reg CARD	temp;
  
  	cp = hand;

*** roll.c.orig	Sun Apr  7 00:52:12 1985
--- roll.c	Thu Jan  2 13:46:00 1986
***************
*** 7,13
  
  # define	reg	register
  
! # ifndef vax
  # define	MAXRAND	32767L
  
  roll(ndie, nsides)

--- 7,13 -----
  
  # define	reg	register
  
! # ifndef BSD
  # define	MAXRAND	32767L
  
  roll(ndie, nsides)
***************
*** 14,20
  int	ndie, nsides; {
  
  	reg long	tot;
! 	reg unsigned	n, r;
  
  	tot = 0;
  	n = ndie;

--- 14,20 -----
  int	ndie, nsides; {
  
  	reg long	tot;
! 	reg unsigned	n;
  
  	tot = 0;
  	n = ndie;

*** save.c.orig	Sun Apr  7 00:52:12 1985
--- save.c	Thu Jan  2 13:48:25 1986
***************
*** 1,7
  #include	"mille.h"
  #include	<sys/types.h>
  #include	<sys/stat.h>
- #include	<sys/time.h>
  #ifndef	unctrl
  #include	"unctrl.h"
  #endif

--- 1,6 -----
  #include	"mille.h"
  #include	<sys/types.h>
  #include	<sys/stat.h>
  #ifndef	unctrl
  #include	"unctrl.h"
  #endif
***************
*** 16,22
   */
  
  typedef	struct stat	STAT;
- typedef	struct tm	TIME;
  
  char	*ctime();
  

--- 15,20 -----
   */
  
  typedef	struct stat	STAT;
  
  char	*ctime();
  
***************
*** 32,38
  
  	reg char	*sp;
  	reg int		outf;
! 	reg TIME	*tp;
  	char		buf[80];
  	TIME		tme;
  	STAT		junk;

--- 30,36 -----
  
  	reg char	*sp;
  	reg int		outf;
! 	reg long	*tp;
  	char		buf[80];
  	long		tme;
  	STAT		junk;
***************
*** 34,40
  	reg int		outf;
  	reg TIME	*tp;
  	char		buf[80];
! 	TIME		tme;
  	STAT		junk;
  
  	tp = &tme;

--- 32,38 -----
  	reg int		outf;
  	reg long	*tp;
  	char		buf[80];
! 	long		tme;
  	STAT		junk;
  
  	tp = &tme;

*** varpush.c.orig	Sun Apr  7 00:52:13 1985
--- varpush.c	Thu Jan  2 13:50:55 1986
***************
*** 16,34
  
  	int	temp;
  
! 	(*func)(file, &Debug, sizeof Debug);
! 	(*func)(file, &Finished, sizeof Finished);
! 	(*func)(file, &Order, sizeof Order);
! 	(*func)(file, &End, sizeof End);
! 	(*func)(file, &On_exit, sizeof On_exit);
! 	(*func)(file, &Handstart, sizeof Handstart);
! 	(*func)(file, &Numgos, sizeof Numgos);
! 	(*func)(file,  Numseen, sizeof Numseen);
! 	(*func)(file, &Play, sizeof Play);
! 	(*func)(file, &Window, sizeof Window);
! 	(*func)(file,  Deck, sizeof Deck);
! 	(*func)(file, &Discard, sizeof Discard);
! 	(*func)(file,  Player, sizeof Player);
  	if (func == read) {
  		read(file, &temp, sizeof temp);
  		Topcard = &Deck[temp];

--- 16,34 -----
  
  	int	temp;
  
! 	(*func)(file, (char *)&Debug, sizeof Debug);
! 	(*func)(file, (char *)&Finished, sizeof Finished);
! 	(*func)(file, (char *)&Order, sizeof Order);
! 	(*func)(file, (char *)&End, sizeof End);
! 	(*func)(file, (char *)&On_exit, sizeof On_exit);
! 	(*func)(file, (char *)&Handstart, sizeof Handstart);
! 	(*func)(file, (char *)&Numgos, sizeof Numgos);
! 	(*func)(file, (char *)Numseen, sizeof Numseen);
! 	(*func)(file, (char *)&Play, sizeof Play);
! 	(*func)(file, (char *)&Window, sizeof Window);
! 	(*func)(file, (char *)Deck, sizeof Deck);
! 	(*func)(file, (char *)&Discard, sizeof Discard);
! 	(*func)(file, (char *)Player, sizeof Player);
  	if (func == read) {
  		read(file, (char *)&temp, sizeof temp);
  		Topcard = &Deck[temp];
***************
*** 30,36
  	(*func)(file, &Discard, sizeof Discard);
  	(*func)(file,  Player, sizeof Player);
  	if (func == read) {
! 		read(file, &temp, sizeof temp);
  		Topcard = &Deck[temp];
  		if (Debug) {
  			char	buf[80];

--- 30,36 -----
  	(*func)(file, (char *)&Discard, sizeof Discard);
  	(*func)(file, (char *)Player, sizeof Player);
  	if (func == read) {
! 		read(file, (char *)&temp, sizeof temp);
  		Topcard = &Deck[temp];
  		if (Debug) {
  			char	buf[80];
***************
*** 42,48
  				goto over;
  			}
  			if (strcmp(buf, "/dev/null") != 0)
! 				setbuf(outf, 0);
  		}
  	}
  	else {

--- 42,48 -----
  				goto over;
  			}
  			if (strcmp(buf, "/dev/null") != 0)
! 				setbuf(outf, (char *)0);
  		}
  	}
  	else {
***************
*** 47,53
  	}
  	else {
  		temp = Topcard - Deck;
! 		write(file, &temp, sizeof temp);
  	}
  }
  

--- 47,53 -----
  	}
  	else {
  		temp = Topcard - Deck;
! 		write(file, (char *)&temp, sizeof temp);
  	}
  }
  

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 16:00:53 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA09773; Mon, 13 Jan 86 16:00:53 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA05754; Mon, 13 Jan 86 16:00:33 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA17902; Mon, 13 Jan 86 14:59:54 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA17893; Mon, 13 Jan 86 14:59:07 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10807; Mon, 13 Jan 86 15:01:23 PST
Date: Mon, 13 Jan 86 15:01:23 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601132301.AA10807@gorodish.sun.uucp>
Subject: "diff" gets confused if one argument is a directory
Index: 	bin/diff/diffreg.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	If you do a "diff" where one file is a binary file, and the other
	file is a directory, it will probably report the files as
	different even if the file in the directory in question being
	compared with the other file is identical to it.

Repeat-By:
	mkdir /tmp/x
	cp <binary file> /tmp/x
	cd /tmp/x
	diff <binary file> .
	
Fix:
	Have "diff" redo the "stat" on the file in the directory in question,
	so that when it compares the sizes of the two files, it compares
	the sizes of the files rather than the size of the file and the size
	of the containing directory.

Here's a "diff -c" listing - your line numbers may differ:

*** diffreg.c.orig	Wed Aug 28 14:44:36 1985
--- diffreg.c	Thu Jan  2 13:56:33 1986
***************
*** 152,158
  		done();
  	}
  	chrtran = (iflag? cup2low : clow2low);
! 	if ((stb1.st_mode & S_IFMT) == S_IFDIR)
  		file1 = splice(file1, file2);
  	else if ((stb2.st_mode & S_IFMT) == S_IFDIR)
  		file2 = splice(file2, file1);

--- 152,158 -----
  		done();
  	}
  	chrtran = (iflag? cup2low : clow2low);
! 	if ((stb1.st_mode & S_IFMT) == S_IFDIR) {
  		file1 = splice(file1, file2);
  		if (stat(file1, &stb1) < 0) {
  			fprintf(stderr, "diff: ");
***************
*** 154,160
  	chrtran = (iflag? cup2low : clow2low);
  	if ((stb1.st_mode & S_IFMT) == S_IFDIR)
  		file1 = splice(file1, file2);
! 	else if ((stb2.st_mode & S_IFMT) == S_IFDIR)
  		file2 = splice(file2, file1);
  	else if (!strcmp(file1, "-")) {
  		if (!strcmp(file2, "-")) {

--- 154,165 -----
  	chrtran = (iflag? cup2low : clow2low);
  	if ((stb1.st_mode & S_IFMT) == S_IFDIR) {
  		file1 = splice(file1, file2);
! 		if (stat(file1, &stb1) < 0) {
! 			fprintf(stderr, "diff: ");
! 			perror(file1);
! 			done();
! 		}
! 	} else if ((stb2.st_mode & S_IFMT) == S_IFDIR) {
  		file2 = splice(file2, file1);
  		if (stat(file2, &stb2) < 0) {
  			fprintf(stderr, "diff: ");
***************
*** 156,162
  		file1 = splice(file1, file2);
  	else if ((stb2.st_mode & S_IFMT) == S_IFDIR)
  		file2 = splice(file2, file1);
! 	else if (!strcmp(file1, "-")) {
  		if (!strcmp(file2, "-")) {
  			fprintf(stderr, "diff: can't specify - -\n");
  			done();

--- 161,172 -----
  		}
  	} else if ((stb2.st_mode & S_IFMT) == S_IFDIR) {
  		file2 = splice(file2, file1);
! 		if (stat(file2, &stb2) < 0) {
! 			fprintf(stderr, "diff: ");
! 			perror(file2);
! 			done();
! 		}
! 	} else if (!strcmp(file1, "-")) {
  		if (!strcmp(file2, "-")) {
  			fprintf(stderr, "diff: can't specify - -\n");
  			done();
***************
*** 162,168
  			done();
  		}
  		file1 = copytemp();
! 	} else if (!strcmp(file2, "-"))
  		file2 = copytemp();
  	if ((f1 = fopen(file1, "r")) == NULL) {
  		fprintf(stderr, "diff: ");

--- 172,183 -----
  			done();
  		}
  		file1 = copytemp();
! 		if (stat(file1, &stb1) < 0) {
! 			fprintf(stderr, "diff: ");
! 			perror(file1);
! 			done();
! 		}
! 	} else if (!strcmp(file2, "-")) {
  		file2 = copytemp();
  		if (stat(file2, &stb2) < 0) {
  			fprintf(stderr, "diff: ");
***************
*** 164,169
  		file1 = copytemp();
  	} else if (!strcmp(file2, "-"))
  		file2 = copytemp();
  	if ((f1 = fopen(file1, "r")) == NULL) {
  		fprintf(stderr, "diff: ");
  		perror(file1);

--- 179,190 -----
  		}
  	} else if (!strcmp(file2, "-")) {
  		file2 = copytemp();
+ 		if (stat(file2, &stb2) < 0) {
+ 			fprintf(stderr, "diff: ");
+ 			perror(file2);
+ 			done();
+ 		}
+ 	}
  	if ((f1 = fopen(file1, "r")) == NULL) {
  		fprintf(stderr, "diff: ");
  		perror(file1);

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 16:02:15 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA09791; Mon, 13 Jan 86 16:02:15 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA05782; Mon, 13 Jan 86 16:01:46 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18308; Mon, 13 Jan 86 15:34:24 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18203; Mon, 13 Jan 86 15:33:39 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA10965; Mon, 13 Jan 86 15:35:57 PST
Date: Mon, 13 Jan 86 15:35:57 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601132335.AA10965@gorodish.sun.uucp>
Subject: Some "lex" cleanups and bug fixes
Index: 	usr.bin/lex/lmain.c usr.bin/lex/sub1.c usr.bin/lex/parser.y 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	1) A couple of bits of code here are really sloppy when it comes
	   to pointers vs. integers.

	2) Some other bits of code are sloppy when it comes to - surprise! -
	   dereferencing NULL pointers.
Repeat-By:
	Try "lex -Q anything.l", or "lex </dev/null" (if "lex" isn't
	given a source file, it reads from standard input) if your
	machine dumps core when dereferencing null pointers.
Fix:
	See following context diffs.

*** /archwizard/4.3beta/usr/src/usr.bin/lex/lmain.c	Thu Feb 21 13:35:28 1985
--- ./lmain.c	Thu Jan  2 14:02:45 1986
***************
*** 128,134
  dp =	dchar = myalloc(DEFCHAR,sizeof(*dchar));
  	sname = (char **) myalloc(STARTSIZE,sizeof(*sname));
  sp = 	schar = myalloc(STARTCHAR,sizeof(*schar));
! 	if(ccl == 0 || def == 0 || subs == 0 || dchar == 0 || sname == 0 || schar == 0)
  		error("Too little core to begin");
  	}
  free1core(){

--- 128,134 -----
  dp =	dchar = myalloc(DEFCHAR,sizeof(*dchar));
  	sname = (char **) myalloc(STARTSIZE,sizeof(*sname));
  sp = 	schar = myalloc(STARTCHAR,sizeof(*schar));
! 	if(ccl == 0 || pchar == 0 || def == 0 || subs == 0 || dchar == 0 || sname == 0 || schar == 0)
  		error("Too little core to begin");
  	}
  free1core(){
***************
*** 194,199
    int a,b; {
  	register char *i;
  	i = calloc(a, b);
  	if(i==0)
  		warning("OOPS - calloc returns a 0");
  	else if(i == (char *)-1){

--- 194,200 -----
    int a,b; {
  	register char *i;
  	i = calloc(a, b);
+ # ifdef DEBUG
  	if(i==0)
  		warning("OOPS - calloc returns a 0");
  # endif
***************
*** 196,204
  	i = calloc(a, b);
  	if(i==0)
  		warning("OOPS - calloc returns a 0");
- 	else if(i == (char *)-1){
- # ifdef DEBUG
- 		warning("calloc returns a -1");
  # endif
  		return(0);
  		}

--- 197,202 -----
  # ifdef DEBUG
  	if(i==0)
  		warning("OOPS - calloc returns a 0");
  # endif
  	return(i);
  	}
***************
*** 200,207
  # ifdef DEBUG
  		warning("calloc returns a -1");
  # endif
- 		return(0);
- 		}
  	return(i);
  	}
  # ifdef DEBUG

--- 198,203 -----
  	if(i==0)
  		warning("OOPS - calloc returns a 0");
  # endif
  	return(i);
  	}
  # ifdef DEBUG
***************
*** 207,213
  # ifdef DEBUG
  buserr(){
  	fflush(errorf);
! 	fflush(fout);
  	fflush(stdout);
  	fprintf(errorf,"Bus error\n");
  	if(report == 1)statistics();

--- 203,210 -----
  # ifdef DEBUG
  buserr(){
  	fflush(errorf);
! 	if(fout != NULL)
! 		fflush(fout);
  	fflush(stdout);
  	fprintf(errorf,"Bus error\n");
  	if(report == 1)statistics();
***************
*** 215,221
  	}
  segviol(){
  	fflush(errorf);
! 	fflush(fout);
  	fflush(stdout);
  	fprintf(errorf,"Segmentation violation\n");
  	if(report == 1)statistics();

--- 212,219 -----
  	}
  segviol(){
  	fflush(errorf);
! 	if(fout != NULL)
! 		fflush(fout);
  	fflush(stdout);
  	fprintf(errorf,"Segmentation violation\n");
  	if(report == 1)statistics();

*** /archwizard/4.3beta/usr/src/usr.bin/lex/sub1.c	Thu Feb 21 13:34:53 1985
--- ./sub1.c	Thu Jan  2 14:05:09 1986
***************
*** 62,68
  	fprintf(errorf,s,p,d);
  	putc('\n',errorf);
  	fflush(errorf);
! 	fflush(fout);
  	fflush(stdout);
  	}
  index(a,s)

--- 62,69 -----
  	fprintf(errorf,s,p,d);
  	putc('\n',errorf);
  	fflush(errorf);
! 	if(fout != NULL)
! 		fflush(fout);
  	fflush(stdout);
  	}
  index(a,s)

*** /archwizard/4.3beta/usr/src/usr.bin/lex/parser.y	Mon Jan 13 15:33:13 1986
--- ./parser.y	Mon Jan 13 15:19:36 1986
***************
*** 216,222
  yylex(){
  	register char *p;
  	register int c, i;
! 	char  *t, *xp;
  	int n, j, k, x;
  	static int sectbegin;
  	static char token[TOKENSIZE];

--- 216,223 -----
  yylex(){
  	register char *p;
  	register int c, i;
! 	char  *t;
! 	register char *xp;
  	int n, j, k, x;
  	static int sectbegin;
  	static char token[TOKENSIZE];
***************
*** 241,248
  						sectbegin = TRUE;
  						i = treesize*(sizeof(*name)+sizeof(*left)+
  							sizeof(*right)+sizeof(*nullstr)+sizeof(*parent))+ALITTLEEXTRA;
! 						c = myalloc(i,1);
! 						if(c == 0)
  							error("Too little core for parse tree");
  						p = c;
  						cfree(p,i,1);

--- 242,249 -----
  						sectbegin = TRUE;
  						i = treesize*(sizeof(*name)+sizeof(*left)+
  							sizeof(*right)+sizeof(*nullstr)+sizeof(*parent))+ALITTLEEXTRA;
! 						xp = myalloc(i,1);
! 						if(xp == 0)
  							error("Too little core for parse tree");
  						cfree((char *)xp,i,1);
  						name = (int *)myalloc(treesize,sizeof(*name));
***************
*** 244,254
  						c = myalloc(i,1);
  						if(c == 0)
  							error("Too little core for parse tree");
! 						p = c;
! 						cfree(p,i,1);
! 						name = myalloc(treesize,sizeof(*name));
! 						left = myalloc(treesize,sizeof(*left));
! 						right = myalloc(treesize,sizeof(*right));
  						nullstr = myalloc(treesize,sizeof(*nullstr));
  						parent = myalloc(treesize,sizeof(*parent));
  						if(name == 0 || left == 0 || right == 0 || parent == 0 || nullstr == 0)

--- 245,254 -----
  						xp = myalloc(i,1);
  						if(xp == 0)
  							error("Too little core for parse tree");
! 						cfree((char *)xp,i,1);
! 						name = (int *)myalloc(treesize,sizeof(*name));
! 						left = (int *)myalloc(treesize,sizeof(*left));
! 						right = (int *)myalloc(treesize,sizeof(*right));
  						nullstr = myalloc(treesize,sizeof(*nullstr));
  						parent = (int *)myalloc(treesize,sizeof(*parent));
  						if(name == 0 || left == 0 || right == 0 || parent == 0 || nullstr == 0)
***************
*** 250,256
  						left = myalloc(treesize,sizeof(*left));
  						right = myalloc(treesize,sizeof(*right));
  						nullstr = myalloc(treesize,sizeof(*nullstr));
! 						parent = myalloc(treesize,sizeof(*parent));
  						if(name == 0 || left == 0 || right == 0 || parent == 0 || nullstr == 0)
  							error("Too little core for parse tree");
  						return(freturn(DELIM));

--- 250,256 -----
  						left = (int *)myalloc(treesize,sizeof(*left));
  						right = (int *)myalloc(treesize,sizeof(*right));
  						nullstr = myalloc(treesize,sizeof(*nullstr));
! 						parent = (int *)myalloc(treesize,sizeof(*parent));
  						if(name == 0 || left == 0 || right == 0 || parent == 0 || nullstr == 0)
  							error("Too little core for parse tree");
  						return(freturn(DELIM));
***************
*** 294,300
  					case 'k': case 'K': /* overriden packed char classes */
  						while (*p && !digit(*p))p++;
  						if (report==2) report=1;
! 						cfree(pchar, pchlen, sizeof(*pchar));
  						pchlen = siconv(p);
  # ifdef DEBUG
  						if (debug) printf( "Size classes (%%k) now %d\n",pchlen);

--- 294,300 -----
  					case 'k': case 'K': /* overriden packed char classes */
  						while (*p && !digit(*p))p++;
  						if (report==2) report=1;
! 						cfree((char *)pchar, pchlen, sizeof(*pchar));
  						pchlen = siconv(p);
  # ifdef DEBUG
  						if (debug) printf( "Size classes (%%k) now %d\n",pchlen);
***************
*** 419,424
  		/* end of section one processing */
  		}
  	else if(sect == RULESECTION){		/* rules and actions */
  		while(!eof){
  			switch(c=gch()){
  			case '\0':

--- 419,430 -----
  		/* end of section one processing */
  		}
  	else if(sect == RULESECTION){		/* rules and actions */
+ 		/*
+ 		 * If it is required that one of the items given above
+ 		 * which causes a call to "lgate" must have been called
+ 		 * by now, this should be an error instead.
+ 		 */
+ 		lgate();
  		while(!eof){
  			switch(c=gch()){
  			case '\0':
***************
*** 678,683
  			}
  		}
  	/* section three */
  	ptail();
  # ifdef DEBUG
  	if(debug)

--- 684,696 -----
  			}
  		}
  	/* section three */
+ 	/*
+ 	 * If it is required that one of the items given above
+ 	 * which causes a call to "lgate" must have been called
+ 	 * by now, this should be an error instead.  (If it hasn't
+ 	 * been done by now, do we have a null "lex" program?)
+ 	 */
+ 	lgate();
  	ptail();
  # ifdef DEBUG
  	if(debug)

From @rand-unix.ARPA:guyton%condor@rand-unix.ARPA  Mon Jan 13 17:09:41 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10230; Mon, 13 Jan 86 17:09:41 PST
Return-Path: <guyton@condor>
Received: from condor.arpa (condor) by rand-unix.ARPA; Mon, 13 Jan 86 17:05:13 pst
Received: from localhost by condor.arpa; Mon, 13 Jan 86 17:04:52 pst
From: Jim Guyton <guyton%condor@rand-unix.ARPA>
Message-Id: <8601140104.AA04771@condor.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: guyton@rand-unix.ARPA, obrien@rand-unix.ARPA, terry@rand-unix.ARPA
Cc: rick@seismo.arpa
Subject: timeout bug in 4.3bsd cntrl.c??
Date: 13 Jan 86 17:04:48 PST (Mon)

Description:

	Suspicious activity in timeout code waiting for final
	CY after storing a file.

        We've had multiple occasions where the wait for the "CY" message
        after a big file transfer [to a slow micro] wasn't long enough.

        This of course, caused the uucico to fail, and the next time
        communications were established, the same file was sent again,
        only to timeout again and loop till human intervention.

        In looking at the code and the LOGFILE, it wasn't clear
        that the PATIENCE code was correct.  Minute-level
        timestamps on the log entries made it hard to debug.

Debugging change:

	In logent.c, I added the "seconds" field [tm_sec] to the timestamp
	printout [in addition to hours/minutes] for all logfile entries.

	I re-ran my test and got this fragment in the logfile
	(this is for a 600K byte file):

ucondor condor (1/13-15:34:55-3071) OK (startup)
guyton condor (1/13-15:34:56-3071) REQUEST (S /tmp/ham /r/guyton/open guyton)
guyton condor (1/13-15:50:56-3071) PATIENCE (17)
guyton condor (1/13-15:52:36-3071) PATIENCE (16)
guyton condor (1/13-15:52:36-3071) PATIENCE (15)
guyton condor (1/13-15:52:36-3071) PATIENCE (14)
guyton condor (1/13-15:52:36-3071) PATIENCE (13)
guyton condor (1/13-15:52:36-3071) PATIENCE (12)
guyton condor (1/13-15:52:36-3071) PATIENCE (11)
guyton condor (1/13-15:52:36-3071) PATIENCE (10)
guyton condor (1/13-15:52:36-3071) PATIENCE (9)
guyton condor (1/13-15:52:36-3071) PATIENCE (8)
guyton condor (1/13-15:52:36-3071) PATIENCE (7)
guyton condor (1/13-15:52:37-3071) PATIENCE (6)
guyton condor (1/13-15:52:37-3071) PATIENCE (5)
guyton condor (1/13-15:52:37-3071) PATIENCE (4)
guyton condor (1/13-15:52:37-3071) PATIENCE (3)
guyton condor (1/13-15:52:37-3071) PATIENCE (2)
guyton condor (1/13-15:52:37-3071) PATIENCE (1)
guyton condor (1/13-15:52:37-3071) BAD READ (expected 'C' got FAIL (2))
guyton condor (1/13-15:52:37-3071) FAILED (conversation complete)



BUG:    Note that patience entries 1 through 16 took only two seconds.


Fix?:
	HAS ANYONE ELSE ALREADY FIXED THIS???

	I'd really rather not track this down, but if I hear that
	nobody else has fixed it yet, I'll try anyway.

	Please let me know; if no response I'll assume someone else
	has/will taken care of it.


thanks,

-- Jim Guyton

From @rand-unix.ARPA:guyton%condor@rand-unix.ARPA  Mon Jan 13 17:20:18 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10328; Mon, 13 Jan 86 17:20:18 PST
Return-Path: <guyton@condor>
Received: from condor.arpa (condor) by rand-unix.ARPA; Mon, 13 Jan 86 17:19:24 pst
Received: from localhost by condor.arpa; Mon, 13 Jan 86 17:19:04 pst
From: Jim Guyton <guyton%condor@rand-unix.ARPA>
Message-Id: <8601140119.AA04810@condor.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: guyton@rand-unix.ARPA, obrien@rand-unix.ARPA, terry@rand-unix.ARPA
Subject: tu78 enhancement: write-erase-gap
Date: 13 Jan 86 17:19:00 PST (Mon)

Description:

	New command added to tape iotcl to allow for user-initiated
	write-erase-gap command.


Requirement:

	Without write-erase-gap, music played on the tu78 has all the
	notes blurred together.  Write-erase-gap is need to provide
	proper note definition and pauses.


Humor-level:

	The only application currently needing this is my hack that
	plays tunes on the tu78.  I'd like to give it away when it's
	done, and having this command in the kernal sure would make
	it easier for others to share in the fun.


Changes:

	Trivial adds to mtio.h and mt.c.  As the tu78 is the only DEC drive
	that I've found capable of playing songs, mt.c is the only driver
	that I bothered to change:


% diff h/Orig/mtio.h h/mtio.h
27a28
> #define MTWERG  8       /* write an erase-gap (tu78 only) */


% diff vaxmba/Orig/mt.c vaxmba/mt.c
840c840
<       {MT_WTM,MT_SFORWF,MT_SREVF,MT_SFORW,MT_SREV,MT_REW,MT_UNLOAD,MT_SENSE};
---
>       {MT_WTM,MT_SFORWF,MT_SREVF,MT_SFORW,MT_SREV,MT_REW,MT_UNLOAD,MT_SENSE,MT_ERASE};
850c850
<               case MTWEOF:
---
>               case MTWEOF: case MTWERG:
876c876
<               if (op == MT_WTM)
---
>               if (op == MT_WTM || op == MT_ERASE)



-- Jim

p.s. I'll send you the play program when I get it tuned up better ...

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:36:11 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10534; Mon, 13 Jan 86 17:36:11 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07650; Mon, 13 Jan 86 17:35:23 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18794; Mon, 13 Jan 86 16:26:26 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18758; Mon, 13 Jan 86 16:25:45 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11553; Mon, 13 Jan 86 16:28:04 PST
Date: Mon, 13 Jan 86 16:28:04 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140028.AA11553@gorodish.sun.uucp>
Subject: Mail doesn't handle RFC822 addresses properly
Index: 	ucb/Mail/aux.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	The routine "skin" does not understand RFC822 addresses (in fact,
	the comment at the front explicitly says it's for RFC733 addresses).
Fix:

*** aux.c.orig	Thu Jan  2 14:10:44 1986
--- aux.c	Thu Jan  2 14:11:05 1986
***************
*** 524,530
  }
  
  /*
!  * Skin an arpa net address according to the RFC 733 interpretation
   * of "host-phrase."
   */
  char *

--- 524,530 -----
  }
  
  /*
!  * Skin an arpa net address according to the RFC 822 interpretation
   * of "host-phrase."
   */
  char *
***************
*** 533,538
  {
  	register int c;
  	register char *cp, *cp2;
  	int gotlt, lastsp;
  	char nbuf[BUFSIZ];
  	int nesting;

--- 533,539 -----
  {
  	register int c;
  	register char *cp, *cp2;
+ 	char *bufend;
  	int gotlt, lastsp;
  	char nbuf[BUFSIZ];
  	int nesting;
***************
*** 544,550
  		return(name);
  	gotlt = 0;
  	lastsp = 0;
! 	for (cp = name, cp2 = nbuf; c = *cp++; ) {
  		switch (c) {
  		case '(':
  			nesting = 1;

--- 545,552 -----
  		return(name);
  	gotlt = 0;
  	lastsp = 0;
! 	bufend = nbuf;
! 	for (cp = name, cp2 = bufend; c = *cp++; ) {
  		switch (c) {
  		case '(':
  			/*
***************
*** 547,552
  	for (cp = name, cp2 = nbuf; c = *cp++; ) {
  		switch (c) {
  		case '(':
  			nesting = 1;
  			while (*cp != '\0') {
  				switch (*cp++) {

--- 549,558 -----
  	for (cp = name, cp2 = bufend; c = *cp++; ) {
  		switch (c) {
  		case '(':
+ 			/*
+ 			 * Start of a "comment".
+ 			 * Ignore it.
+ 			 */
  			nesting = 1;
  			while ((c = *cp) != 0) {
  				cp++;
***************
*** 548,555
  		switch (c) {
  		case '(':
  			nesting = 1;
! 			while (*cp != '\0') {
! 				switch (*cp++) {
  				case '(':
  					nesting++;
  					break;

--- 554,567 -----
  			 * Ignore it.
  			 */
  			nesting = 1;
! 			while ((c = *cp) != 0) {
! 				cp++;
! 				switch (c) {
! 				case '\\':
! 					if (*cp == 0)
! 						goto outcm;
! 					cp++;
! 					break;
  				case '(':
  					nesting++;
  					break;
***************
*** 562,567
  				if (nesting <= 0)
  					break;
  			}
  			lastsp = 0;
  			break;
  

--- 574,580 -----
  				if (nesting <= 0)
  					break;
  			}
+ 		outcm:
  			lastsp = 0;
  			break;
  
***************
*** 565,570
  			lastsp = 0;
  			break;
  
  		case ' ':
  			if (cp[0] == 'a' && cp[1] == 't' && cp[2] == ' ')
  				cp += 3, *cp2++ = '@';

--- 578,605 -----
  			lastsp = 0;
  			break;
  
+ 		case '"':
+ 			/*
+ 			 * Start of a "quoted-string".
+ 			 * Copy it in its entirety.
+ 			 */
+ 			while ((c = *cp) != 0) {
+ 				cp++;
+ 				switch (c) {
+ 				case '\\':
+ 					if ((c = *cp) == 0)
+ 						goto outqs;
+ 					cp++;
+ 					break;
+ 				case '"':
+ 					goto outqs;
+ 				}
+ 				*cp2++ = c;
+ 			}
+ 		outqs:
+ 			lastsp = 0;
+ 			break;
+ 
  		case ' ':
  			if (cp[0] == 'a' && cp[1] == 't' && cp[2] == ' ')
  				cp += 3, *cp2++ = '@';
***************
*** 576,582
  			break;
  
  		case '<':
! 			cp2 = nbuf;
  			gotlt++;
  			lastsp = 0;
  			break;

--- 611,617 -----
  			break;
  
  		case '<':
! 			cp2 = bufend;
  			gotlt++;
  			lastsp = 0;
  			break;
***************
*** 582,589
  			break;
  
  		case '>':
! 			if (gotlt)
! 				goto done;
  
  			/* Fall into . . . */
  

--- 617,633 -----
  			break;
  
  		case '>':
! 			if (gotlt) {
! 				gotlt = 0;
! 				while (*cp != ',' && *cp != 0)
! 					cp++;
! 				if (*cp == 0 )
! 					goto done;
! 				*cp2++ = ',';
! 				*cp2++ = ' ';
! 				bufend = cp2;
! 				break;
! 			}
  
  			/* Fall into . . . */
  

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:38:11 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10566; Mon, 13 Jan 86 17:38:11 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07691; Mon, 13 Jan 86 17:37:16 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18851; Mon, 13 Jan 86 16:33:05 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18809; Mon, 13 Jan 86 16:32:20 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11605; Mon, 13 Jan 86 16:34:35 PST
Date: Mon, 13 Jan 86 16:34:35 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140034.AA11605@gorodish.sun.uucp>
Subject: "xstr" doesn't check for "calloc" or "fclose" failing
Index: 	ucb/xstr.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	"xstr" assumes that "calloc" will never fail to allocate
	storage.  It also assumes that "fclose" will never fail,
	although it checks most other I/O operations.

	"calloc" can fail, even on a 4.2BSD system, if you run out
	of swap space - which happens all too frequently on my
	machine.  "fclose" can fail, since it flushes any buffered
	I/O out to the file, and can get an I/O error doing so.
Repeat-By:
	Inspect the code.
Fix:
	The code to discard unused function return values has also
	been cleaned up.

*** /archwizard/4.3beta/usr/src/ucb/xstr.c	Tue Jun 18 18:39:41 1985
--- ./xstr.c	Thu Jan  2 14:22:20 1986
***************
*** 26,32
   * November, 1978
   */
  
! #define	ignore(a)	Ignore((char *) a)
  
  char	*calloc();
  off_t	tellpt;

--- 26,32 -----
   * November, 1978
   */
  
! #define	ignore(a)	((void) a)
  
  char	*calloc();
  off_t	tellpt;
***************
*** 299,305
  		if (i >= 0)
  			return (hp->hpt + i);
  	}
! 	hp = (struct hash *) calloc(1, sizeof (*hp));
  	hp->hpt = mesgpt;
  	hp->hstr = savestr(str);
  	mesgpt += strlen(hp->hstr) + 1;

--- 299,308 -----
  		if (i >= 0)
  			return (hp->hpt + i);
  	}
! 	if ((hp = (struct hash *) calloc(1, sizeof (*hp))) == NULL) {
! 		perror("xstr");
! 		exit(8);
! 	}
  	hp->hpt = mesgpt;
  	hp->hstr = savestr(str);
  	mesgpt += strlen(hp->hstr) + 1;
***************
*** 337,343
  					perror(strings), exit(4);
  			}
  		}
! 	ignore(fclose(mesgwrit));
  }
  
  found(new, off, str)

--- 340,347 -----
  					perror(strings), exit(4);
  			}
  		}
! 	if (fclose(mesgwrit) == EOF)
! 		perror(strings), exit(4);
  }
  
  found(new, off, str)
***************
*** 409,415
  savestr(cp)
  	register char *cp;
  {
! 	register char *dp = (char *) calloc(1, strlen(cp) + 1);
  
  	return (strcpy(dp, cp));
  }

--- 413,419 -----
  savestr(cp)
  	register char *cp;
  {
! 	register char *dp;
  
  	if ((dp = (char *) calloc(1, strlen(cp) + 1)) == NULL) {
  		perror("xstr");
***************
*** 411,416
  {
  	register char *dp = (char *) calloc(1, strlen(cp) + 1);
  
  	return (strcpy(dp, cp));
  }
  

--- 415,424 -----
  {
  	register char *dp;
  
+ 	if ((dp = (char *) calloc(1, strlen(cp) + 1)) == NULL) {
+ 		perror("xstr");
+ 		exit(8);
+ 	}
  	return (strcpy(dp, cp));
  }
  
***************
*** 414,433
  	return (strcpy(dp, cp));
  }
  
- Ignore(a)
- 	char *a;
- {
- 
- 	a = a;
- }
- 
- ignorf(a)
- 	int (*a)();
- {
- 
- 	a = a;
- }
- 
  lastchr(cp)
  	register char *cp;
  {

--- 422,427 -----
  	return (strcpy(dp, cp));
  }
  
  lastchr(cp)
  	register char *cp;
  {
***************
*** 450,456
  onintr()
  {
  
! 	ignorf(signal(SIGINT, SIG_IGN));
  	if (strings[0] == '/')
  		ignore(unlink(strings));
  	ignore(unlink("x.c"));

--- 444,450 -----
  onintr()
  {
  
! 	ignore(signal(SIGINT, SIG_IGN));
  	if (strings[0] == '/')
  		ignore(unlink(strings));
  	ignore(unlink("x.c"));

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:39:06 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10584; Mon, 13 Jan 86 17:39:06 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07725; Mon, 13 Jan 86 17:38:50 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18891; Mon, 13 Jan 86 16:38:58 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18845; Mon, 13 Jan 86 16:38:17 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11663; Mon, 13 Jan 86 16:40:36 PST
Date: Mon, 13 Jan 86 16:40:36 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140040.AA11663@gorodish.sun.uucp>
Subject: "put *" doesn't work in FTP
Index: 	ucb/ftp/cmds.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	It is an undocumented feature of "ftp" that it does expansion
	of star names in some commands.  Star name expansion in "put"
	is useful if the star name expands to one file.  If you say
	something like "put *.c", however, the target file name will
	be "*.c", not "<whatever>.c".
Repeat-By:
	Try it.
Fix:
	This patch assumes the previous patch to "cmds.c", mentioned in
	an earlier bug report, has been applied.

*** cmds.c	Thu Jan  2 14:26:49 1986
--- cmds.c.new	Wed Jul 31 16:34:12 1985
***************
*** 213,218
  	char *argv[];
  {
  	char *cmd;
  
  	if (argc == 2)
  		argc++, argv[2] = argv[1];

--- 213,219 -----
  	char *argv[];
  {
  	char *cmd;
+ 	char *oldargv1;
  
  	if (argc == 2)
  		argc++, argv[2] = argv[1];
***************
*** 239,244
  	}
  	if (argc < 3) 
  		goto usage;
  	if (!globulize(&argv[1]))
  		return;
  	cmd = (argv[0][0] == 'a') ? "APPE" : "STOR";

--- 240,246 -----
  	}
  	if (argc < 3) 
  		goto usage;
+ 	oldargv1 = argv[1];
  	if (!globulize(&argv[1]))
  		return;
  	/*
***************
*** 241,246
  		goto usage;
  	if (!globulize(&argv[1]))
  		return;
  	cmd = (argv[0][0] == 'a') ? "APPE" : "STOR";
  	sendrequest(cmd, argv[1], argv[2]);
  }

--- 243,254 -----
  	oldargv1 = argv[1];
  	if (!globulize(&argv[1]))
  		return;
+ 	/*
+ 	 * If "globulize" modifies argv[1], and argv[2] is a copy of
+ 	 * the old argv[1], make it a copy of the new argv[1].
+ 	 */
+ 	if (argv[1] != oldargv1 && argv[2] == oldargv1)
+ 		argv[2] = argv[1];
  	cmd = (argv[0][0] == 'a') ? "APPE" : "STOR";
  	sendrequest(cmd, argv[1], argv[2]);
  }

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:40:14 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10597; Mon, 13 Jan 86 17:40:14 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07737; Mon, 13 Jan 86 17:39:34 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18906; Mon, 13 Jan 86 16:41:01 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18865; Mon, 13 Jan 86 16:40:21 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11684; Mon, 13 Jan 86 16:42:39 PST
Date: Mon, 13 Jan 86 16:42:39 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140042.AA11684@gorodish.sun.uucp>
Subject: FTP dereferences null pointers
Index: 	ucb/ftp/main.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	In various circumstances, FTP will dereference null pointers.
Fix:
	This patch assumes the previous patch to "main.c", mentioned in
	an earlier bug report, has been applied.

*** main.c	Mon Jul 15 16:04:05 1985
--- main.c.new	Wed Jul 31 16:32:40 1985
***************
*** 35,40
  int	intr();
  int	lostpeer();
  extern	char *home;
  
  main(argc, argv)
  	char *argv[];

--- 35,41 -----
  int	intr();
  int	lostpeer();
  extern	char *home;
+ char	*getlogin();
  
  main(argc, argv)
  	char *argv[];
***************
*** 41,47
  {
  	register char *cp;
  	int top;
! 	struct passwd *pw;
  	char homedir[MAXPATHLEN];
  
  	sp = getservbyname("ftp", "tcp");

--- 42,48 -----
  {
  	register char *cp;
  	int top;
! 	struct passwd *pw = NULL;
  	char homedir[MAXPATHLEN];
  
  	sp = getservbyname("ftp", "tcp");
***************
*** 103,109
  	/*
  	 * Set up the home directory in case we're globbing.
  	 */
! 	pw = getpwnam(getlogin());
  	if (pw == NULL)
  		pw = getpwuid(getuid());
  	if (pw != NULL) {

--- 104,112 -----
  	/*
  	 * Set up the home directory in case we're globbing.
  	 */
! 	cp = getlogin();
! 	if (cp != NULL)
! 		pw = getpwnam(cp);
  	if (pw == NULL)
  		pw = getpwuid(getuid());
  	if (pw != NULL) {
***************
*** 202,207
  		if (line[0] == 0)
  			break;
  		makeargv();
  		c = getcmd(margv[0]);
  		if (c == (struct cmd *)-1) {
  			printf("?Ambiguous command\n");

--- 205,212 -----
  		if (line[0] == 0)
  			break;
  		makeargv();
+ 		if (margc == 0)
+ 			continue;
  		c = getcmd(margv[0]);
  		if (c == (struct cmd *)-1) {
  			printf("?Ambiguous command\n");
***************
*** 400,406
  		for (i = 0; i < lines; i++) {
  			for (j = 0; j < columns; j++) {
  				c = cmdtab + j * lines + i;
! 				printf("%s", c->c_name);
  				if (c + lines >= &cmdtab[NCMDS]) {
  					printf("\n");
  					break;

--- 405,412 -----
  		for (i = 0; i < lines; i++) {
  			for (j = 0; j < columns; j++) {
  				c = cmdtab + j * lines + i;
! 				if (c->c_name)
! 					printf("%s", c->c_name);
  				if (c + lines >= &cmdtab[NCMDS]) {
  					printf("\n");
  					break;

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:40:36 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10606; Mon, 13 Jan 86 17:40:36 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07749; Mon, 13 Jan 86 17:40:12 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18919; Mon, 13 Jan 86 16:42:48 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18888; Mon, 13 Jan 86 16:42:04 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11704; Mon, 13 Jan 86 16:44:21 PST
Date: Mon, 13 Jan 86 16:44:21 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140044.AA11704@gorodish.sun.uucp>
Subject: Some bugs in the "sccs" command
Index: 	ucb/sccs.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	1) Some commands aren't documented in the comments.

	2) The "prt" command in the PWB/UNIX SCCS was renamed "prs"
	   in later versions; same with the "chghist" and "cdc" commands.

	3) It can dereference a null pointer under some circumstances.

	4) If a process spawned by "sccs" dies from a signal, it won't
	   print an error message indicating this.

	5) It doesn't wait properly for a process it spawns.  It should
	   specifically wait for a process with a given PID to die, but
	   it waits for the first child process to die instead.  Processes
	   inside pipelines started by the Bourne shell often have extra
	   children, so the "wait" would terminate prematurely if any of
	   them exited before the process "sccs" spawned exited.
Repeat-By:
	For 5), try doing something like

	cat <file-with-comments> | sccs delget <file>

	Since "delget" first spawns a "delta" and then a "get", when
	it waits for the "delta" to finish the wait may terminate when
	the "cat" terminates, so it tries to run the "get" before the
	"delta" is finished.
Fix:

*** sccs.c.orig	Thu Jan  2 14:39:31 1986
--- sccs.c	Thu Jan  2 14:39:40 1986
***************
*** 69,75
  **		get,
  **		delta,
  **		rmdel,
! **		chghist,
  **		etc.		Straight out of SCCS; only difference
  **				is that pathnames get modified as
  **				described above.

--- 69,75 -----
  **		get,
  **		delta,
  **		rmdel,
! **		cdc,
  **		etc.		Straight out of SCCS; only difference
  **				is that pathnames get modified as
  **				described above.
***************
*** 73,78
  **		etc.		Straight out of SCCS; only difference
  **				is that pathnames get modified as
  **				described above.
  **		edit		Macro for "get -e".
  **		unedit		Removes a file being edited, knowing
  **				about p-files, etc.

--- 73,80 -----
  **		etc.		Straight out of SCCS; only difference
  **				is that pathnames get modified as
  **				described above.
+ **		enter		Front end doing "sccs admin -i<name> <name>"
+ **		create		Macro for "enter" followed by "get".
  **		edit		Macro for "get -e".
  **		unedit		Removes a file being edited, knowing
  **				about p-files, etc.
***************
*** 78,84
  **				about p-files, etc.
  **		delget		Macro for "delta" followed by "get".
  **		deledit		Macro for "delta" followed by "get -e".
! **		info		Tell what files being edited.
  **		clean		Remove all files that can be
  **				regenerated from SCCS files.
  **		check		Like info, but return exit status, for

--- 80,92 -----
  **				about p-files, etc.
  **		delget		Macro for "delta" followed by "get".
  **		deledit		Macro for "delta" followed by "get -e".
! **		branch		Macro for "get -b -e", followed by "delta
! **				-s -n", followd by "get -e -t -g".
! **		diffs		"diff" the specified version of files
! **				and the checked-out version.
! **		print		Macro for "prs -e" followed by "get -p -m".
! **		tell		List what files are being edited.
! **		info		Print information about files being edited.
  **		clean		Remove all files that can be
  **				regenerated from SCCS files.
  **		check		Like info, but return exit status, for
***************
*** 172,178
  struct sccsprog SccsProg[] =
  {
  	"admin",	PROG,	REALUSER,		PROGPATH(admin),
! 	"chghist",	PROG,	0,			PROGPATH(rmdel),
  	"comb",		PROG,	0,			PROGPATH(comb),
  	"delta",	PROG,	0,			PROGPATH(delta),
  	"get",		PROG,	0,			PROGPATH(get),

--- 180,186 -----
  struct sccsprog SccsProg[] =
  {
  	"admin",	PROG,	REALUSER,		PROGPATH(admin),
! 	"cdc",		PROG,	0,			PROGPATH(rmdel),
  	"comb",		PROG,	0,			PROGPATH(comb),
  	"delta",	PROG,	0,			PROGPATH(delta),
  	"get",		PROG,	0,			PROGPATH(get),
***************
*** 194,200
  	"unedit",	UNEDIT,	NO_SDOT,		NULL,
  	"diffs",	DIFFS,	NO_SDOT|REALUSER,	NULL,
  	"-diff",	DODIFF,	NO_SDOT|REALUSER,	PROGPATH(bdiff),
! 	"print",	CMACRO,	0,			"prt -e/get -p -m -s",
  	"branch",	CMACRO,	NO_SDOT,
  		"get:ixrc -e -b/delta: -s -n -ybranch-place-holder/get:pl -e -t -g",
  	"enter",	ENTER,	NO_SDOT,		NULL,

--- 202,208 -----
  	"unedit",	UNEDIT,	NO_SDOT,		NULL,
  	"diffs",	DIFFS,	NO_SDOT|REALUSER,	NULL,
  	"-diff",	DODIFF,	NO_SDOT|REALUSER,	PROGPATH(bdiff),
! 	"print",	CMACRO,	0,			"prs -e/get -p -m -s",
  	"branch",	CMACRO,	NO_SDOT,
  		"get:ixrc -e -b/delta: -s -n -ybranch-place-holder/get:pl -e -t -g",
  	"enter",	ENTER,	NO_SDOT,		NULL,
***************
*** 229,234
  extern char	*getenv();
  # endif V6
  
  char *gstrcat(), *strcat();
  char *gstrncat(), *strncat();
  char *gstrcpy(), *strcpy();

--- 237,244 -----
  extern char	*getenv();
  # endif V6
  
+ extern char	*sys_siglist[];
+ 
  char *gstrcat(), *strcat();
  char *gstrncat(), *strncat();
  char *gstrcpy(), *strcpy();
***************
*** 482,488
  		break;
  
  	  case FIX:		/* fix a delta */
! 		if (strncmp(ap[1], "-r", 2) != 0)
  		{
  			usrerr("-r flag needed for fix command");
  			rval = EX_USAGE;

--- 492,498 -----
  		break;
  
  	  case FIX:		/* fix a delta */
! 		if (ap[1]==0 || strncmp(ap[1], "-r", 2)!=0)
  		{
  			usrerr("-r flag needed for fix command");
  			rval = EX_USAGE;
***************
*** 654,659
  	bool forkflag;
  {
  	register int i;
  	auto int st;
  
  # ifdef DEBUG

--- 664,670 -----
  	bool forkflag;
  {
  	register int i;
+ 	register int wpid;
  	auto int st;
  	register int sigcode;
  	register int coredumped;
***************
*** 655,660
  {
  	register int i;
  	auto int st;
  
  # ifdef DEBUG
  	if (Debug)

--- 666,675 -----
  	register int i;
  	register int wpid;
  	auto int st;
+ 	register int sigcode;
+ 	register int coredumped;
+ 	register char *sigmsg;
+ 	auto char sigmsgbuf[10+1];	/* "Signal 127" + terminating '\0' */
  
  # ifdef DEBUG
  	if (Debug)
***************
*** 686,693
  		}
  		else if (i > 0)
  		{
! 			wait(&st);
! 			if ((st & 0377) == 0)
  				st = (st >> 8) & 0377;
  			if (OutFile >= 0)
  			{

--- 701,709 -----
  		}
  		else if (i > 0)
  		{
! 			while ((wpid = wait(&st)) != -1 && wpid != i)
! 				;
! 			if ((sigcode = st & 0377) == 0)
  				st = (st >> 8) & 0377;
  			else
  			{
***************
*** 689,694
  			wait(&st);
  			if ((st & 0377) == 0)
  				st = (st >> 8) & 0377;
  			if (OutFile >= 0)
  			{
  				close(OutFile);

--- 705,730 -----
  				;
  			if ((sigcode = st & 0377) == 0)
  				st = (st >> 8) & 0377;
+ 			else
+ 			{
+ 				coredumped = sigcode & 0200;
+ 				sigcode &= 0177;
+ 				if (sigcode != SIGINT && sigcode != SIGPIPE)
+ 				{
+ 					if (sigcode < NSIG)
+ 						sigmsg = sys_siglist[sigcode];
+ 					else
+ 					{
+ 						sprintf(sigmsgbuf, "Signal %d",
+ 						    sigcode);
+ 						sigmsg = sigmsgbuf;
+ 					}
+ 					fprintf(stderr, "sccs: %s: %s%s", argv[0],
+ 					    sigmsg,
+ 					    coredumped ? " - core dumped": "");
+ 				}
+ 				st = EX_SOFTWARE;
+ 			}
  			if (OutFile >= 0)
  			{
  				close(OutFile);

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:41:31 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10624; Mon, 13 Jan 86 17:41:31 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07754; Mon, 13 Jan 86 17:41:16 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18927; Mon, 13 Jan 86 16:43:48 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18897; Mon, 13 Jan 86 16:43:08 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11723; Mon, 13 Jan 86 16:45:27 PST
Date: Mon, 13 Jan 86 16:45:27 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140045.AA11723@gorodish.sun.uucp>
Subject: "setreuid" sets p_uid incorrectly
Index: 	sys/sys/kern_prot.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	The entry p_uid in the process table normally contains the
	process' effective UID.  It is set to this value when
	a process executes a set-UID program.  However, when
	a "setreuid" system call is executed, it is set to the new
	value of the real UID, not the effective UID.

	In several places in the manual, a check against "p_uid" is
	documented as a check against a process' effective UID, so the
	current behavior of "setreuid" is incorrect.

	One may argue that a user should be able to kill a process if
	their UID (which is probably the effective UID of their shell)
	matches the real UID of the process, so that they can kill a
	set-UID process.  However,

	1) the current behavior of "setreuid" does not set "p_uid" to
	   a value other than that of the effective UID, unless the
	   process sets its real UID to one value a value other than
	   the value of the effective UID

and

	2) the proper way to make this possible is to change the permissions
	   checking code in "kill", not to change the meaning of "p_uid"
	   in some, but not all, cases.

	(System V permits you to send a signal to a process if either the
	real or effective UID of the sending process matches either the
	original set-UID UID or the real UID of the target process.  The
	reason why it says "original set-UID UID" is that a set-UID process
	which is not set-UID to 0 can repeatedly change its effective UID
	between its real UID and the UID that it was set-UID to at the last
	time it did an "exec".)
Repeat-By:
	Look at the code.
Fix:

*** /archwizard/4.3beta/sys/sys/kern_prot.c	Sat Jun  8 14:37:09 1985
--- ./kern_prot.c	Thu Jan  2 14:42:07 1986
***************
*** 142,148
  		qstart(getquota(ruid, 0, 0));
  	}
  #endif
! 	u.u_procp->p_uid = ruid;
  	u.u_ruid = ruid;
  	u.u_uid = euid;
  }

--- 142,148 -----
  		qstart(getquota(ruid, 0, 0));
  	}
  #endif
! 	u.u_procp->p_uid = euid;
  	u.u_ruid = ruid;
  	u.u_uid = euid;
  }

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:41:54 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10633; Mon, 13 Jan 86 17:41:54 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07769; Mon, 13 Jan 86 17:41:45 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18933; Mon, 13 Jan 86 16:44:10 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18900; Mon, 13 Jan 86 16:43:31 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11731; Mon, 13 Jan 86 16:45:50 PST
Date: Mon, 13 Jan 86 16:45:50 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140045.AA11731@gorodish.sun.uucp>
Subject: "sed" supports comments, but this is undocumented
Index: 	man/man1/sed.1 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	"sed" supports comments in scripts.  Any line containing an
	option string of white space (blanks or tabs) followed by a
	"#" is a comment and will be ignored by "sed".

	Furthermore, if the *first* comment line is of the form

		#n

	the "sed" script will be executed as if the "-n" flag were
	specified.
Repeat-By:
	Check out "fcomp" in "sed0.c".
Fix:
	Document it.  (S5's "sed" supports the "#n" feature, so it's
	probably been in there since V7; S5 even documents it.)

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:42:44 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10647; Mon, 13 Jan 86 17:42:44 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07781; Mon, 13 Jan 86 17:42:31 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18949; Mon, 13 Jan 86 16:48:47 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18939; Mon, 13 Jan 86 16:47:57 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11769; Mon, 13 Jan 86 16:50:15 PST
Date: Mon, 13 Jan 86 16:50:15 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140050.AA11769@gorodish.sun.uucp>
Subject: Several "ftp" bugs
Index: 	ucb/ftp/ftp.c ucb/ftp/main.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	1) If an FTP transfer fails after the data transfer has been
	started, due to inability to open the file on the local side,
	or is interrupted after it has been started, "ftp" doesn't
	try to pick up the final reply code from the other side
	and gets totally out of sync.  (Thanks to Rob Gingell for
	finding and fixing this one.)

	2) If the file can't be opened on the local side, the error
	messages are sometimes garbled.  (Thanks to Rob for this one,
	too.)

	3) If the transfer is interrupted, you can get a worthless
	transfer time statistics message, because it never got the
	ending time of the transfer.

	4) If your system's "longjmp" works System V-style, where an
	argument of 0 is turned into 1, the "longjmp(toplevel, 0)"
	gets treated as "longjmp(toplevel, 1)" and extra blank lines
	get printed.  (Even if your system *doesn't* work System V-style,
	using "longjmp" in this case is gross overkill.)
Repeat-By:
	1) Try interrupting a data transfer and watch "ftp" get
	totally confused.
Fix:
	This patch assumes the previous patches to "ftp.c" and "main.c",
	mentioned in an earlier bug report, has been applied.

*** ftp.c	Thu Jan  2 14:48:59 1986
--- ftp.c.new	Fri Dec 13 12:57:56 1985
***************
*** 206,211
  	FILE *fin, *dout, *popen();
  	int (*closefunc)(), pclose(), fclose(), (*oldintr)();
  	char buf[BUFSIZ];
  	long bytes = 0, hashbytes = sizeof (buf);
  	register int c, d;
  	struct stat st;

--- 206,212 -----
  	FILE *fin, *dout, *popen();
  	int (*closefunc)(), pclose(), fclose(), (*oldintr)();
  	char buf[BUFSIZ];
+ 	int expectingreply = 0;
  	long bytes = 0, hashbytes = sizeof (buf);
  	register int c, d;
  	struct stat st;
***************
*** 218,224
  	if (strcmp(local, "-") == 0)
  		fin = stdin;
  	else if (*local == '|') {
! 		fin = popen(local + 1, "r");
  		if (fin == NULL) {
  			perror(local + 1);
  			goto bad;

--- 219,231 -----
  	if (strcmp(local, "-") == 0)
  		fin = stdin;
  	else if (*local == '|') {
! 		/*
! 		 * Advance local so further uses just yield file name
! 		 * thus later references for error messages need not check
! 		 * for '|' special case.
! 	 	 */
! 		local += 1;
! 		fin = popen(local, "r");
  		if (fin == NULL) {
  			perror(local);
  			goto bad;
***************
*** 220,226
  	else if (*local == '|') {
  		fin = popen(local + 1, "r");
  		if (fin == NULL) {
! 			perror(local + 1);
  			goto bad;
  		}
  		closefunc = pclose;

--- 227,233 -----
  		local += 1;
  		fin = popen(local, "r");
  		if (fin == NULL) {
! 			perror(local);
  			goto bad;
  		}
  		closefunc = pclose;
***************
*** 245,250
  	} else
  		if (command("%s", cmd) != PRELIM)
  			goto bad;
  	dout = dataconn("w");
  	if (dout == NULL)
  		goto bad;

--- 252,258 -----
  	} else
  		if (command("%s", cmd) != PRELIM)
  			goto bad;
+ 	expectingreply++;	/* got preliminary reply, expecting final reply */
  	dout = dataconn("w");
  	if (dout == NULL)
  		goto bad;
***************
*** 307,313
  	}
  	gettimeofday(&stop, (struct timezone *)0);
  	if (closefunc != NULL)
! 		(*closefunc)(fin);
  	(void) fclose(dout);
  	(void) getreply(0);
  done:

--- 315,321 -----
  	}
  	gettimeofday(&stop, (struct timezone *)0);
  	if (closefunc != NULL)
! 		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
  	if (expectingreply) {
***************
*** 309,315
  	if (closefunc != NULL)
  		(*closefunc)(fin);
  	(void) fclose(dout);
- 	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)

--- 317,322 -----
  	if (closefunc != NULL)
  		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
  	if (expectingreply) {
  		(void) getreply(0);
***************
*** 311,316
  	(void) fclose(dout);
  	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("sent", bytes, &start, &stop);

--- 318,327 -----
  		(*closefunc)(fin), closefunc = NULL;
  	(void) fclose(dout);
  done:
+ 	if (expectingreply) {
+ 		(void) getreply(0);
+ 		expectingreply = 0;
+ 	}
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("sent", bytes, &start, &stop);
***************
*** 319,325
  	if (data >= 0)
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fin != NULL)
! 		(*closefunc)(fin);
  	goto done;
  }
  

--- 330,337 -----
  	if (data >= 0)
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fin != NULL)
! 		(*closefunc)(fin), closefunc = NULL;
! 	bytes = 0;	/* so we don't print a message if the transfer was aborted */
  	goto done;
  }
  
***************
*** 337,342
  	FILE *fout, *din, *popen();
  	int (*closefunc)(), pclose(), fclose(), (*oldintr)();
  	char buf[BUFSIZ];
  	long bytes = 0, hashbytes = sizeof (buf);
  	register int c, d;
  	struct timeval start, stop;

--- 349,355 -----
  	FILE *fout, *din, *popen();
  	int (*closefunc)(), pclose(), fclose(), (*oldintr)();
  	char buf[BUFSIZ];
+ 	int expectingreply = 0;
  	long bytes = 0, hashbytes = sizeof (buf);
  	register int c, d;
  	struct timeval start, stop;
***************
*** 372,377
  	} else
  		if (command("%s", cmd) != PRELIM)
  			goto bad;
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {

--- 385,391 -----
  	} else
  		if (command("%s", cmd) != PRELIM)
  			goto bad;
+ 	expectingreply++;	/* got preliminary reply, expecting final reply */
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {
***************
*** 375,381
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {
! 		fout = popen(local + 1, "w");
  		closefunc = pclose;
  	} else {
  		fout = fopen(local, mode);

--- 389,400 -----
  	if (strcmp(local, "-") == 0)
  		fout = stdout;
  	else if (*local == '|') {
! 		/*
! 		 * Advance local over '|' so don't need to check for
! 		 * '|' special case any further.
! 		 */
! 		local += 1;
! 		fout = popen(local, "w");
  		closefunc = pclose;
  	} else {
  		fout = fopen(local, mode);
***************
*** 382,388
  		closefunc = fclose;
  	}
  	if (fout == NULL) {
! 		perror(local + 1);
  		goto bad;
  	}
  	din = dataconn("r");

--- 401,407 -----
  		closefunc = fclose;
  	}
  	if (fout == NULL) {
! 		perror(local);
  		goto bad;
  	}
  	din = dataconn("r");
***************
*** 450,457
  	gettimeofday(&stop, (struct timezone *)0);
  	(void) fclose(din);
  	if (closefunc != NULL)
! 		(*closefunc)(fout);
! 	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)

--- 469,475 -----
  	gettimeofday(&stop, (struct timezone *)0);
  	(void) fclose(din);
  	if (closefunc != NULL)
! 		(*closefunc)(fout), closefunc = NULL;
  done:
  	if (expectingreply) {
  		(void) getreply(0);
***************
*** 453,458
  		(*closefunc)(fout);
  	(void) getreply(0);
  done:
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("received", bytes, &start, &stop);

--- 471,480 -----
  	if (closefunc != NULL)
  		(*closefunc)(fout), closefunc = NULL;
  done:
+ 	if (expectingreply) {
+ 		(void) getreply(0);
+ 		expectingreply = 0;
+ 	}
  	signal(SIGINT, oldintr);
  	if (bytes > 0 && verbose)
  		ptransfer("received", bytes, &start, &stop);
***************
*** 462,467
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fout != NULL)
  		(*closefunc)(fout);
  	goto done;
  }
  

--- 484,490 -----
  		(void) close(data), data = -1;
  	if (closefunc != NULL && fout != NULL)
  		(*closefunc)(fout);
+ 	bytes = 0;	/* so we don't print a message if the transfer was aborted */
  	goto done;
  }
  
*** main.c	Wed Jul 31 16:32:40 1985
--- main.c.new	Fri Dec 13 12:33:57 1985
***************
*** 226,232
  		if (c->c_handler != help)
  			break;
  	}
- 	longjmp(toplevel, 0);
  }
  
  struct cmd *

--- 226,231 -----
  		if (c->c_handler != help)
  			break;
  	}
  }
  
  struct cmd *

From sun!gorodish!guy@ucbvax.berkeley.edu  Mon Jan 13 17:43:19 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA10658; Mon, 13 Jan 86 17:43:19 PST
Received: by ucbvax.berkeley.edu (5.39/1.7)
	id AA07789; Mon, 13 Jan 86 17:43:03 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18959; Mon, 13 Jan 86 16:49:12 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA18948; Mon, 13 Jan 86 16:48:22 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA11777; Mon, 13 Jan 86 16:50:40 PST
Date: Mon, 13 Jan 86 16:50:40 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601140050.AA11777@gorodish.sun.uucp>
Subject: The "ftp" manual page needs work
Index: 	man/man1/ftp.1c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	The manual page "ftp.1c" is far from a good description of the
	functionality of the "ftp" command.  (Or, at least, that command
	with all the bug fixes dropped in.)
Repeat-By:
	Read the code, try the program, then read the documentation.
Fix:
	Here's a better one:

.\" Copyright (c) 1983 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\"	@(#)ftp.1c	6.1 (Berkeley) 4/29/85
.\"
.TH FTP 1C "December 13, 1985"
.UC 5
.SH NAME
ftp \- ARPANET file transfer program
.SH SYNOPSIS
.B ftp
[ 
.B \-v
] [
.B \-d
] [
.B \-i
] [
.B \-n
] [
.B \-g
] [
.B \-t
] [
.I host
]
.SH DESCRIPTION
.I Ftp
is the user interface to the ARPANET standard File Transfer Protocol.
\fIFtp\fP transfers files to and from a remote network site.
.LP
The client host with which 
.I ftp
is to communicate may be specified on the command line.
If this is done,
.I ftp
immediately attempts to establish a connection to an FTP server on that host;
otherwise, \fIftp\fP enters its command interpreter and awaits instructions
from the user.  When \fIftp\fP is awaiting commands from the user, it
displays the prompt \*(lqftp>\*(rq.  The following commands are recognized
by
.IR ftp :
.TP
\fB\&! \fR[ \fIcommand \fR]
Run
.I command
as a shell command on the local machine.
If no 
.I command
is given, invoke an interactive shell.
.TP
\fBappend\fP \fIlocal-file\fP [ \fIremote-file\fP ]
Append a local file to a file on the remote machine.  If
.I remote-file
is left unspecified, the local file name is used in naming the
remote file.  File transfer uses the current settings for
\*(lqrepresentation type\*(rq, \*(lqfile structure\*(rq,
and \*(lqtransfer mode\*(rq.
.TP
.B ascii
Set the \*(lqrepresentation type\*(rq
to \*(lqnetwork ASCII\*(rq.  This is the default type.
.TP
.B bell
Arrange that a bell be sounded after each file transfer
command is completed.
.TP
.B binary
Set the \*(lqrepresentation type\*(rq to \*(lqimage\*(rq.
.TP
.B bye
Terminate the FTP session with the remote server
and exit
.IR ftp .
.TP
.BI cd " remote-directory"
Change the working directory on the remote machine
to 
.IR remote-directory .
.TP
.B close
Terminate the FTP session with the remote server, and
return to the command interpreter.
.TP
.BI delete " remote-file"
Delete the file
.I remote-file
on the remote machine.
.TP
\fBdebug\fP [ \fIdebug-value\fP ]
Toggle debugging mode.  If an optional
.I debug-value
is specified it is used to set the debugging level.
When debugging is on,
.I ftp
prints each command sent to the remote machine, preceded
by the string \*(lq-->\*(rq.
.TP
\fBdir\fP [ \fIremote-directory\fP ] [ \fIlocal-file\fP ]
Print a listing of the directory contents in the
directory,
.IR remote-directory ,
and, optionally, placing the output in
.IR local-file .
If no directory is specified, the current working
directory on the remote machine is used.  If no local
file is specified, or \fIlocal-file\fP is \fB\-\fP,
output comes to the terminal.
.TP
\fBform\fP [ \fIformat-name\fP ]
Set the carriage control format subtype of the
\*(lqrepresentation type\*(rq to
.IR format-name .
The only valid
.I format-name
is
.BR non-print ,
which corresponds to the default \*(lqnon-print\*(rq subtype.
.TP
\fBget\fP \fIremote-file\fP [ \fIlocal-file\fP ]
Retrieve the 
.I remote-file
and store it on the local machine.  If the local
file name is not specified, it is given the same
name it has on the remote machine.
The current settings for \*(lqrepresentation type\*(rq,
\*(lqfile structure\*(rq, and \*(lqtransfer mode\*(rq
are used while transferring the file.
.TP
\fBglob\fR
Toggle filename expansion, or "globbing",  
for \fBmdelete\fP, \fBmget\fP and \fBmput\fP.
If globbing is turned off, filenames are taken literally.
.IP
Globbing for \fBmput\fP is done as in \fIcsh\fP\|(1).
For \fBmdelete\fP and \fBmget\fP, each remote file name is
expanded separately on the remote machine, and the lists are not merged.
.IP
Expansion of a directory name is likely to be radically
different from expansion of the name of an ordinary file:
the exact result depends on the remote operating system and
FTP server,
and can be previewed by doing `\fBmls\fP\ \fIremote-files\fP\ \fB\-\fP'.
.IP
\fBmget\fP and \fBmput\fP are not meant to transfer
entire directory subtrees of files.  You can do this by
transferring a \fItar\fP\|(1) archive of the subtree (using a
\*(lqrepresentation type\*(rq of \*(lqimage\*(rq as set by the
.B binary
command).
.TP
\fBhash\fP
Toggle hash-sign (``#'') printing for each data block
transferred.  The size of a data block is 1024 bytes.
.TP
\fBhelp\fP [ \fIcommand\fP ]
Print an informative message about the meaning of
.IR command .
If no argument is given, 
.I ftp
prints a list of the known commands.
.TP
\fBlcd\fP [ \fIdirectory\fP ]
Change the working directory on the local machine.  If
no 
.I directory
is specified, the user's home directory is used.
.TP
\fBls\fP [ \fIremote-directory\fP ] [ \fIlocal-file\fP ]
Print an abbreviated listing of the contents of a
directory on the remote machine.  If
.I remote-directory
is left unspecified, the current working directory
is used.  If no local file is specified, 
or if \fIlocal-file\fR is \fB\-\fR,
the output is sent to the terminal.
.TP
\fBmdelete\fP [ \fIremote-files\fP ]
Delete the \fIremote-files\fP on the remote machine.
.TP
\fBmdir\fP \fIremote-files\fP \fIlocal-file\fP
Like \fBdir\fP, except multiple remote files may be specified.
.TP
\fBmget\fP \fIremote-files\fP
Expand the \fIremote-files\fP on the remote machine
and do a \fBget\fP for each file name thus produced.
See \fBglob\fR for details on the filename expansion.
Files are transferred into the local working directory,
which can be changed with `\fBlcd\fP\ \fIdirectory\fP';
new local directories can be created with
`\fB!\fP\ \fBmkdir\fP\ \fIdirectory\fP'.
.TP
\fBmkdir\fP \fIdirectory-name\fP
Make a directory on the remote machine.
.TP
\fBmls\fP \fIremote-files\fP \fIlocal-file\fP
Like \fBls\fP, except multiple remote files may be specified.
.TP
\fBmode\fP [ \fImode-name\fP ]
Set the \*(lqtransfer mode\*(rq to
.IR mode-name .
The only valid
.I mode-name
is
.BR stream ,
which corresponds to the default \*(lqstream\*(rq mode.
.TP
\fBmput\fP \fIlocal-files\fP
Expand wild cards in the list of local files given as arguments
and do a \fBput\fR for each file in the resulting list.
See \fBglob\fP for details of filename expansion.
.TP
\fBopen\fP \fIhost\fP [ \fIport\fP ]
Establish a connection to the specified
.I host
FTP server.  An optional port number may be supplied,
in which case, 
.I ftp
will attempt to contact an FTP server at that port.
If the 
.I auto-login
option is on (default), 
.I ftp
will also attempt to automatically log the user in to
the FTP server (see below).
.TP
.B prompt
Toggle interactive prompting.  Interactive prompting
occurs during multiple file transfers to allow the
user to selectively retrieve or store files.
By default, prompting is turned on.
If prompting is turned off, any \fBmget\fP or \fBmput\fP
will transfer all files, and any \fBmdelete\fP will delete all files.
.TP
\fBput\fP \fIlocal-file\fP [ \fIremote-file\fP ]
Store a local file on the remote machine.  If 
.I remote-file
is left unspecified, the local file name is used
in naming the remote file.  File transfer uses the
current settings for \*(lqrepresentation type\*(rq,
\*(lqfile structure\*(rq, and \*(lqtransfer mode\*(rq.
.TP
.B pwd
Print the name of the current working directory on the remote
machine.
.TP
.B quit
A synonym for \fBbye\fP.
.TP
\fBquote\fP \fIarg1\fP \fIarg2\fP ...
Send the arguments specified, verbatim, to the remote FTP
server.  A single FTP reply code is expected in return.
.TP
\fBrecv\fP \fIremote-file\fP [ \fIlocal-file\fP ]
A synonym for \fBget\fP.
.TP
\fBremotehelp\fP [ \fIcommand-name\fP ]
Request help from the remote FTP server.  If a 
.I command-name
is specified it is supplied to the server as well.
.TP
\fBrename\fP \fIfrom\fP \fIto\fP
Rename the file
.I from
on the remote machine to have the name
.IR to .
.TP
.BI rmdir " directory-name"
Delete a directory on the remote machine.
.TP
\fBsend\fP \fIlocal-file\fP [ \fIremote-file\fP ]
A synonym for \fBput\fP.
.TP
.B sendport
Toggle the use of PORT commands.  By default, 
.I ftp
will attempt to use a PORT command when establishing
a connection for each data transfer.  If the PORT
command fails, 
.I ftp
will use the default data port.  When the use of PORT
commands is disabled, no attempt will be made to use
PORT commands for each data transfer.  This is useful
for certain FTP implementations which ignore PORT
commands but incorrectly indicate they've been accepted.
.TP
.B status
Show the current status of
.IR ftp .
.TP
\fBstruct\fP [ \fIstruct-name\fP ]
Set the \*(lqfile structure\*(rq to
.IR struct-name .
The only valid
.I struct-name
is
.BR file ,
which corresponds to the default \*(lqfile\*(rq structure.
.TP
.B tenex
Set the \*(lqrepresentation type\*(rq to that needed to
talk to TENEX machines.
.TP
.B trace
Toggle packet tracing (unimplemented).
.TP
\fBtype\fP [ \fItype-name\fP ]
Set the \*(lqrepresentation type\*(rq to
.IR type-name .
The valid
.IR type-name s
are
.B ascii
for \*(lqnetwork ASCII\*(rq,
.B binary
or
.B image
for \*(lqimage\*(rq,
and
.B tenex
for \*(lqlocal byte size\*(rq with a byte size of 8 (used to talk to
TENEX machines).
If no type is specified, the current type
is printed.  The default type is \*(lqnetwork ASCII\*(rq.
.TP
\fBuser\fP \fIuser-name\fP [ \fIpassword\fP ] [ \fIaccount\fP ]
Identify yourself to the remote FTP server.  If the
password is not specified and the server requires it,
.I ftp
will prompt the user for it (after disabling local echo).
If an account field is not specified, and the FTP server
requires it, the user will be prompted for it.  Unless
.I ftp
is invoked with \*(lqauto-login\*(rq disabled, this
process is done automatically on initial connection to
the FTP server.
.TP
.B verbose
Toggle verbose mode.  In verbose mode, all responses from
the FTP server are displayed to the user.  In addition,
if verbose mode is on, when a file transfer completes, statistics
regarding the efficiency of the transfer are reported.  By default,
verbose mode is on if
.IR ftp 's
commands are coming from a terminal, and off otherwise.
.TP
\fB?\fP [ \fIcommand\fP ]
A synonym for \fBhelp\fP.
.LP
Command arguments which have embedded spaces may be quoted with
quote (") marks.
.LP
If any command argument which is not indicated as being optional is
not specified,
.I ftp
will prompt for that argument.
.SH "FILE NAMING CONVENTIONS"
Local files specified as arguments to
.I ftp
commands are processed according to the following rules.
.TP
1)
If the file name \*(lq-\*(rq is specified, the
standard input (for reading) or standard output
(for writing) is used.
.TP
2)
If the first character of the file name is \*(lq|\*(rq, the
remainder of the argument is interpreted as a shell command.
.I ftp
then forks a shell, using 
.IR popen (3S)
with the argument supplied, and reads (writes) from the standard output
(standard input) of that shell.  If the shell command includes spaces,
the argument
must be quoted; e.g. \*(lq"| ls -lt"\*(rq.  A particularly
useful example of this mechanism is: \*(lqdir |more\*(rq.
.TP
3)
Failing the above checks, if ``globbing'' is enabled,
local file names are expanded
according to the rules used in the 
.IR csh (1);
c.f. the
.I glob
command.
.LP
Note that remote file names are not processed, but are passed just as they
are typed, except for the \fBmdelete\fP, \fBmdir\fP, \fBmget\fP,
and \fBmls\fP commands, where they are expanded according to the rules of
the remote host's operating system, if any.
.SH "FILE TRANSFER PARAMETERS"
The FTP specification specifies many parameters which may
affect a file transfer.
.LP
The \*(lqrepresentation type\*(rq
may be one of \*(lqnetwork ASCII\*(rq, \*(lqEBCDIC\*(rq, \*(lqimage\*(rq,
or \*(lqlocal byte size\*(rq with a specified byte size (for PDP-10's
and PDP-20's mostly).  The \*(lqnetwork ASCII\*(rq and \*(lqEBCDIC\*(rq
types have a further subtype which specifies whether vertical format control
(newlines, form feeds, etc.) are to be passed through (\*(lqnon-print\*(rq),
provided in TELNET format (\*(lqTELNET format controls\*(rq),
or provided in ASA (FORTRAN) (\*(lqcarriage control (ASA)\*(rq) format.
.I ftp
supports the \*(lqnetwork ASCII\*(rq (subtype \*(lqnon-print\*(rq only)
and \*(lqimage\*(rq types, plus \*(lqlocal byte size\*(rq
with a byte size of 8 for communicating with TENEX machines.
.LP
The \*(lqfile structure\*(rq may be one of \*(lqfile\*(rq
(no record structure), \*(lqrecord\*(rq, or \*(lqpage\*(rq.
.I ftp
supports only the default value, which is \*(lqfile\*(rq.
.LP
The \*(lqtransfer mode\*(rq may be one of \*(lqstream\*(rq,
\*(lqblock\*(rq, or \*(lqcompressed\*(rq.
.I ftp
supports only the default value, which is \*(lqstream\*(rq.
.SH OPTIONS
Options may be specified at the command line, or to the 
command interpreter.
.TP
.B \-v
show all responses from the remote server, as well
as report on data transfer statistics.  This is turned on by
default if
.I ftp
is running interactively with its input coming from the user's terminal.
.TP
.B \-n
do not attempt \*(lqauto-login\*(rq upon initial connection.
If auto-login is enabled, 
.I ftp
checks the
.BI . netrc
file in the user's home directory for an entry describing
an account on the remote machine.  If no entry exists,
.I ftp
uses the login name on the local machine as the user
identity on the remote machine, and prompts for a password
and, optionally, an account with which to login.
.TP
.B \-i
turn off interactive prompting during multiple file transfers.
.TP
.B \-g
disable filename "globbing."
.TP
.B \-d
enable debugging.
.TP
.B \-t
enable packet tracing (unimplemented).
.SH "SEE ALSO"
rcp(1), ftpd(8c)
.SH BUGS
Many FTP server implementations do not support experimental
operations such as print working directory.

From entropy!hubert@uw-beaver.arpa  Mon Jan 13 18:26:37 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA00480; Mon, 13 Jan 86 18:26:37 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA05486; Mon, 13 Jan 86 14:01:10 PST
Return-Path: <entropy!hubert>
Received: by entropy.UUCP (5.31/1.0.Entropy)
	id AA22108; Mon, 13 Jan 86 13:58:42 PST
Date: Mon, 13 Jan 86 13:58:42 PST
From: Steve Hubert <entropy!hubert@uw-beaver.arpa>
Posted-Date: Mon, 13 Jan 86 13:58:42 PST
Message-Id: <8601132158.AA22108@entropy.UUCP>
To: uw-beaver!beta43_bugs@monet.berkeley.edu
Subject: question

I am hoping you have come across this bug and have a fix.  I have
not tried to figure out what is wrong.

On a 785 I have gotten 2 or 3 panic("blkdev")'s.  Have you seen
this problem?  Thanks

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 {decvax,ihnp4,ucbvax!lbl-csam}!uw-beaver!entropy!hubert
 hubert%entropy@uw-beaver.arpa

From dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA  Sat Jan 18 23:45:50 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA17823; Sat, 18 Jan 86 23:45:50 PST
Received: from tektronix by csnet-relay.csnet id a016636; 19 Jan 86 2:43 EST
From: dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA
To: beta43_bugs%monet.berkeley.edu@CSNET-RELAY.ARPA
Received: from lumiere by tektronix with smtp ; 18 Jan 86 08:30:08 PST
Comment: Message received over unauthenticated port at tektronix
Received: by lumiere (5.31/5.14),	id AA23296; Sat, 18 Jan 86 08:30:55 PST
Message-Id: <8601181630.AA23296@lumiere>
Subject: ranlib does not work on lirge libraries
Date: 18 Jan 86 08:30:51 PST (Sat)

Index:	usr.bin/ranlib 4.3BSD

Description:
	Several problems were encountered (all of which existed
	under 4.2 also).

	1. Ranlib does not dynamically allocate its string or
	   symbol table.  The linker and the archiver are able
	   to handle larger libraries than ranlib.
	2. The check for overrunning the string table boundary
	   is insufficient.
	3. The string table index is not reinitialized between
	   successive library arguments.  Later arguments get
	   a concatenation of the current and all previous string
	   tables.

Repeat-By:
	1. Try running ranlib on a very large library with
	   many symbols.
	2. Run ranlib on a library that will overrun the string
	   table.  Ranlib will write one character beyond the end
	   of the string table which just happens to be where the
	   index into the string table is kept.  Strings start
	   getting stuck all over the place..
	3. Try the following.

	   Script started on Fri Jan 17 22:55:42 1986
	   $ cp /lib/libc.a .
	   $ ar x libc.a __.SYMDEF
	   $ mv __.SYMDEF save.SYMDEF
	   $ /usr/bin/ranlib libc.a libc.a
	   $ ar x libc.a __.SYMDEF
	   $ ls -s *SYMDEF
	     10 __.SYMDEF		   7 save.SYMDEF
	   $ ^D
	   script done on Fri Jan 17 22:58:01 1986

	   __.SYMDEF is larger because it contains two copies 
	   of the string table.

Fix:
	Because of the number of changes, I have included
	the entire source file.

	The symbol and string tables are now dynamically allocated
	and the other bugs are fixed.

>>>>>>>>>>>>>>>>>>>>>>>>> CUT HERE <<<<<<<<<<<<<<<<<<<<<<<<<<
/*
 * Copyright (c) 1980 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
char copyright[] =
"@(#) Copyright (c) 1980 Regents of the University of California.\n\
 All rights reserved.\n";
#endif not lint

#ifndef lint
static char sccsid[] = "@(#)ranlib.c	5.2 (Berkeley) 9/5/85";
#endif not lint

/*
 * ranlib - create table of contents for archive; string table version
 */
#include <sys/types.h>
#include <ar.h>
#include <ranlib.h>
#include <a.out.h>
#include <stdio.h>

struct	ar_hdr	archdr;
#define	OARMAG 0177545
long	arsize;
struct	exec	exp;
FILE	*fi, *fo;
long	off, oldoff;
long	atol(), ftell();
#define TABSZ	3000
int	tnum;
#define	STRTABSZ	30000
int	tssiz;
char	*strtab;
int	ssiz;
int	new;
char	tempnm[] = "__.SYMDEF";
char	firstname[17];
void	stash();
char *malloc(), *calloc();

/*
 * table segment definitions
 */
char	*segalloc();
void	segclean();
struct	tabsegment {
	struct tabsegment	*pnext;
	unsigned		nelem;
	struct ranlib		tab[TABSZ];
} tabbase, *ptabseg;
struct	strsegment {
	struct strsegment	*pnext;
	unsigned		nelem;
	char			stab[STRTABSZ];
} strbase, *pstrseg;

main(argc, argv)
char **argv;
{
	char cmdbuf[BUFSIZ];
	/* magbuf must be an int array so it is aligned on an int-ish
	   boundary, so that we may access its first word as an int! */
	int magbuf[(SARMAG+sizeof(int))/sizeof(int)];
	register int just_touch = 0;
	register struct tabsegment *ptab;
	register struct strsegment *pstr;

	/* check for the "-t" flag" */
	if (argc > 1 && strcmp(argv[1], "-t") == 0) {
		just_touch++;
		argc--;
		argv++;
	}

	--argc;
	while(argc--) {
		fi = fopen(*++argv,"r");
		if (fi == NULL) {
			fprintf(stderr, "ranlib: cannot open %s\n", *argv);
			continue;
		}
		off = SARMAG;
		fread((char *)magbuf, 1, SARMAG, fi);
		if (strncmp((char *)magbuf, ARMAG, SARMAG)) {
			if (magbuf[0] == OARMAG)
				fprintf(stderr, "old format ");
			else
				fprintf(stderr, "not an ");
			fprintf(stderr, "archive: %s\n", *argv);
			continue;
		}
		if (just_touch) {
			register int	len;

			fseek(fi, (long) SARMAG, 0);
			if (fread(cmdbuf, sizeof archdr.ar_name, 1, fi) != 1) {
				fprintf(stderr, "malformed archive: %s\n",
					*argv);
				continue;
			}
			len = strlen(tempnm);
			if (bcmp(cmdbuf, tempnm, len) != 0 ||
			    cmdbuf[len] != ' ') {
				fprintf(stderr, "no symbol table: %s\n", *argv);
				continue;
			}
			fclose(fi);
			fixdate(*argv);
			continue;
		}
		fseek(fi, 0L, 0);
		new = tssiz = tnum = 0;
		segclean();
		if (nextel(fi) == 0) {
			fclose(fi);
			continue;
		}
		do {
			long o;
			register n;
			struct nlist sym;

			fread((char *)&exp, 1, sizeof(struct exec), fi);
			if (N_BADMAG(exp))
				continue;
			if (!strncmp(tempnm, archdr.ar_name, sizeof(archdr.ar_name)))
				continue;
			if (exp.a_syms == 0) {
				fprintf(stderr, "ranlib: warning: %s(%s): no symbol table\n", *argv, archdr.ar_name);
				continue;
			}
			o = N_STROFF(exp) - sizeof (struct exec);
			if (ftell(fi)+o+sizeof(ssiz) >= off) {
				fprintf(stderr, "ranlib: warning: %s(%s): old format .o file\n", *argv, archdr.ar_name);
				continue;
			}
			fseek(fi, o, 1);
			fread((char *)&ssiz, 1, sizeof (ssiz), fi);
			if (ssiz < sizeof ssiz){
				/* sanity check */
				fprintf(stderr, "ranlib: warning: %s(%s): mangled string table\n", *argv, archdr.ar_name);
				continue;
			}
			strtab = (char *)calloc(1, ssiz);
			if (strtab == 0) {
				fprintf(stderr, "ranlib: ran out of memory\n");
				exit(1);
			}
			fread(strtab+sizeof(ssiz), ssiz - sizeof(ssiz), 1, fi);
			fseek(fi, -(exp.a_syms+ssiz), 1);
			n = exp.a_syms / sizeof(struct nlist);
			while (--n >= 0) {
				fread((char *)&sym, 1, sizeof(sym), fi);
				if (sym.n_un.n_strx == 0)
					continue;
				sym.n_un.n_name = strtab + sym.n_un.n_strx;
				if ((sym.n_type&N_EXT)==0)
					continue;
				switch (sym.n_type&N_TYPE) {

				case N_UNDF:
					if (sym.n_value!=0)
						stash(&sym);
					continue;

				default:
					stash(&sym);
					continue;
				}
			}
			free(strtab);
		} while(nextel(fi));
		new = fixsize();
		fclose(fi);
		fo = fopen(tempnm, "w");
		if(fo == NULL) {
			fprintf(stderr, "can't create temporary\n");
			exit(1);
		}
		tnum *= sizeof (struct ranlib);
		fwrite(&tnum, 1, sizeof (tnum), fo);
		tnum /= sizeof (struct ranlib);
		ptab = &tabbase;
		do {
			fwrite((char *)ptab->tab, ptab->nelem,
			    sizeof(struct ranlib), fo);
		} while (ptab = ptab->pnext);
		fwrite(&tssiz, 1, sizeof (tssiz), fo);
		pstr = &strbase;
		do {
			fwrite(pstr->stab, pstr->nelem, 1, fo);
			tssiz -= pstr->nelem;
		} while (pstr = pstr->pnext);
		/* pad with nulls */
		while (tssiz--) putc('\0', fo);
		fclose(fo);
		if(new)
			sprintf(cmdbuf, "ar rlb %s %s %s\n", firstname, *argv, tempnm);
		else
			sprintf(cmdbuf, "ar rl %s %s\n", *argv, tempnm);
		if(system(cmdbuf))
			fprintf(stderr, "ranlib: ``%s'' failed\n", cmdbuf);
		else
			fixdate(*argv);
		unlink(tempnm);
	}
	exit(0);
}

nextel(af)
FILE *af;
{
	register r;
	register char *cp;

	oldoff = off;
	fseek(af, off, 0);
	r = fread((char *)&archdr, 1, sizeof(struct ar_hdr), af);
	if (r != sizeof(struct ar_hdr))
		return(0);
	for (cp=archdr.ar_name; cp < & archdr.ar_name[sizeof(archdr.ar_name)]; cp++)
		if (*cp == ' ')
			*cp = '\0';
	arsize = atol(archdr.ar_size);
	if (arsize & 1)
		arsize++;
	off = ftell(af) + arsize;
	return(1);
}

void
stash(s)
	struct nlist *s;
{
	register char *cp;
	register char *strtab;
	register strsiz;
	register struct ranlib *tab;
	register tabsiz;

	if (ptabseg->nelem >= TABSZ) {
		/* allocate a new symbol table segment */
		ptabseg = ptabseg->pnext =
		    (struct tabsegment *) segalloc(sizeof(struct tabsegment));
		ptabseg->pnext = NULL;
		ptabseg->nelem = 0;
	}
	tabsiz = ptabseg->nelem;
	tab = ptabseg->tab;

	if (pstrseg->nelem >= STRTABSZ) {
		/* allocate a new string table segment */
		pstrseg = pstrseg->pnext =
		    (struct strsegment *) segalloc(sizeof(struct strsegment));
		pstrseg->pnext = NULL;
		pstrseg->nelem = 0;
	}
	strsiz = pstrseg->nelem;
	strtab = pstrseg->stab;

	tab[tabsiz].ran_un.ran_strx = tssiz;
	tab[tabsiz].ran_off = oldoff;
redo:
	for (cp = s->n_un.n_name; strtab[strsiz++] = *cp++;)
		if (strsiz >= STRTABSZ) {
			/* allocate a new string table segment */
			pstrseg = pstrseg->pnext =
			    (struct strsegment *) segalloc(sizeof(struct strsegment));
			pstrseg->pnext = NULL;
			strsiz = pstrseg->nelem = 0;
			strtab = pstrseg->stab;
			goto redo;
		}

	tssiz += strsiz - pstrseg->nelem; /* length of the string */
	pstrseg->nelem = strsiz;
	tnum++;
	ptabseg->nelem++;
}

/* allocate a zero filled segment of size bytes */
char *
segalloc(size)
unsigned size;
{
	char *pseg = NULL;

	pseg = malloc(size);
	if (pseg == NULL) {
		fprintf(stderr, "ranlib: ran out of memeory\n");
		exit(1);
	}
	return(pseg);
}

/* free segments */
void
segclean()
{
	register struct tabsegment *ptab;
	register struct strsegment *pstr;

	/*
	 * symbol table
	 *
	 * The first entry is static.
	 */
	ptabseg = &tabbase;
	ptab = ptabseg->pnext;
	while (ptabseg = ptab) {
		ptab = ptabseg->pnext;
		free((char *)ptabseg);
	}
	ptabseg = &tabbase;
	ptabseg->pnext = NULL;
	ptabseg->nelem = 0;

	/*
	 * string table
	 *
	 * The first entry is static.
	 */
	pstrseg = &strbase;
	pstr = pstrseg->pnext;
	while (pstrseg = pstr) {
		pstr = pstrseg->pnext;
		free((char *)pstrseg);
	}
	pstrseg = &strbase;
	pstrseg->pnext = NULL;
	pstrseg->nelem = 0;
}

fixsize()
{
	int i;
	off_t offdelta;
	register struct tabsegment *ptab;

	if (tssiz&1)
		tssiz++;
	offdelta = sizeof(archdr) + sizeof (tnum) + tnum * sizeof(struct ranlib) +
	    sizeof (tssiz) + tssiz;
	off = SARMAG;
	nextel(fi);
	if(strncmp(archdr.ar_name, tempnm, sizeof (archdr.ar_name)) == 0) {
		new = 0;
		offdelta -= sizeof(archdr) + arsize;
	} else {
		new = 1;
		strncpy(firstname, archdr.ar_name, sizeof(archdr.ar_name));
	}
	ptab = &tabbase;
	do {
		for (i = 0; i < ptab->nelem; i++)
			ptab->tab[i].ran_off += offdelta;
	} while (ptab = ptab->pnext);
	return(new);
}

/* patch time */
fixdate(s)
	char *s;
{
	long time();
	char buf[24];
	int fd;

	fd = open(s, 1);
	if(fd < 0) {
		fprintf(stderr, "ranlib: can't reopen %s\n", s);
		return;
	}
	sprintf(buf, "%-*ld", sizeof(archdr.ar_date), time((long *)NULL)+5);
	lseek(fd, (long)SARMAG + ((char *)archdr.ar_date-(char *)&archdr), 0);
	write(fd, buf, sizeof(archdr.ar_date));
	close(fd);
}

------- End of Forwarded Message

From nsc!chongo@decwrl.DEC.COM  Tue Jan 21 05:08:00 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA00662; Tue, 21 Jan 86 05:08:00 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA13582; Tue, 21 Jan 86 05:08:05 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA01176; Tue, 21 Jan 86 03:32:28 pst
Date: Tue, 21 Jan 86 03:32:28 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Tue, 21 Jan 86 03:32:28 pst
Message-Id: <8601211132.AA01176@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: arp problems

/etc/arp -a always reports:

? (3.4.3.3) at (incomplete) temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary
? (3.3.3.3) at 3:3:3:3:3:3 temporary

regardles of previous arp actions.

chongo <> /\oo/\

From whm%arizona.csnet@CSNET-RELAY.ARPA  Wed Jan 22 01:57:06 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA05659; Wed, 22 Jan 86 01:57:06 PST
Received: from arizona by csnet-relay.csnet id ag26774; 22 Jan 86 4:39 EST
Received: by arizona.uucp (5.15/3.14)
	id AA03186; Wed, 22 Jan 86 00:44:19 MST
Received: by megaron.arizona.uucp (5.15/3.14)
	id AA20084; Wed, 22 Jan 86 00:44:17 MST
Date: Wed, 22 Jan 86 00:44:17 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8601220744.AA20084@megaron.arizona.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: /usr/games/adventure

The binary doesn't work; it just sits there and takes input.  Recompiling
from source fixes it right up.

From chris@gyre.umd.edu  Wed Jan 22 13:23:54 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA07583; Wed, 22 Jan 86 13:23:54 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA25130; Wed, 22 Jan 86 16:23:58 EST
Date: Wed, 22 Jan 86 16:23:58 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601222123.AA25130@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: expreserve sends bogus mail

Index: /usr/src/ucb/ex/expreserve.c 4.3Beta Fix

Description:
	If an ex or vi session ends unexpectedly while no name has
	yet been assigned to the file being edited, incorrect mail
	is sent to the user.

Repeat-By:
	Run vi and use the `a' command to add some text, then suspend
	the editor and send it a hangup signal.  Note the contents of
	the letter you receive:

	...
	An easy way to do this is to give the command "vi -r ".
	...

	This line should read `vi -r LOST'.

Fix:
	(from elsie!ado)
RCS file: RCS/expreserve.c,v
retrieving revision 1.1
diff -c2 -r1.1 expreserve.c
*** /tmp/,RCSt1025108	Wed Jan 22 16:20:30 1986
--- expreserve.c	Wed Jan 22 16:20:08 1986
***************
*** 356,359 ****
--- 356,360 ----
  		fprintf(mf,
  "Since the file had no name, it has been named \"LOST\".\n");
+ 		fname = "LOST";
  	} else {
  		fprintf(mf,

From chris@gyre.umd.edu  Wed Jan 22 13:36:08 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA07698; Wed, 22 Jan 86 13:36:08 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA25243; Wed, 22 Jan 86 16:35:56 EST
Date: Wed, 22 Jan 86 16:35:56 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601222135.AA25243@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: vi Makefile install entries missing `-o root'

Index: /usr/src/ucb/ex/Makefile 4.3Beta Fix

Description:
	The install entries for expreserve and exrecover do not
	specify `-o root' (I know, *you* do not care . . . .)

Repeat-By:
	Inspection

Fix:
RCS file: RCS/Makefile,v
retrieving revision 1.1
diff -c2 -r1.1 Makefile
*** /tmp/,RCSt1025226	Wed Jan 22 16:34:24 1986
--- Makefile	Wed Jan 22 16:34:11 1986
***************
*** 139,144 ****
  	ln ${DESTDIR}/${BINDIR}/ex ${DESTDIR}/usr/bin/ex
  	chmod 1755 ${DESTDIR}/${BINDIR}/ex
! 	install -s -m 4755 exrecover ${DESTDIR}/${LIBDIR}/ex${VERSION}recover
! 	install -s -m 4755 expreserve ${DESTDIR}/${LIBDIR}/ex${VERSION}preserve
  # The following line normally fails.  This is OK.
  	-mkdir ${DESTDIR}/usr/preserve
--- 139,144 ----
  	ln ${DESTDIR}/${BINDIR}/ex ${DESTDIR}/usr/bin/ex
  	chmod 1755 ${DESTDIR}/${BINDIR}/ex
! 	install -s -o root -m 4755 exrecover ${DESTDIR}/${LIBDIR}/ex${VERSION}recover
! 	install -s -o root -m 4755 expreserve ${DESTDIR}/${LIBDIR}/ex${VERSION}preserve
  # The following line normally fails.  This is OK.
  	-mkdir ${DESTDIR}/usr/preserve

From sun!gorodish!guy@ucbvax.berkeley.edu  Thu Jan 23 03:52:28 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA11626; Thu, 23 Jan 86 03:52:28 PST
Received: by ucbvax.berkeley.edu (5.44/1.7)
	id AA24436; Thu, 23 Jan 86 03:51:46 PST
Received: from snail.sun.uucp by sun.uucp (3.0-/SMI-2.0)
	id AA18422; Thu, 23 Jan 86 00:52:52 PST
Received: from gorodish.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA12810; Thu, 23 Jan 86 00:52:58 PST
Received: by gorodish.sun.uucp (3.0/SMI-3.0DEV3)
	id AA14081; Thu, 23 Jan 86 00:54:55 PST
Date: Thu, 23 Jan 86 00:54:55 PST
From: sun!gorodish!guy@ucbvax.berkeley.edu (Guy Harris)
Message-Id: <8601230854.AA14081@gorodish.sun.uucp>
Subject: "leave" accepts illegal times and dereferences null pointers
Index: 	ucb/leave.c 4.3BSD
To: beta43_bugs@monet.berkeley.edu

Description:
	You can say something like "leave 12:30", instead of the
	correct "leave 1230", and it will accept it and set the
	time to an invalid value.

	"leave" will also dereference a null pointer if "getlogin"
	returns a null pointer; for instance, if you leave an
	alarm running and log out.
Repeat-By:
	1) Try "leave 12:30".

	2) Try "leave <anything>" and then log out on a machine like
	a Sun which does not look indulgently on dereferencing
	null pointers.
Fix:

*** /archwizard/4.3beta/usr/src/ucb/leave.c	Fri May 31 09:19:03 1985
--- leave.c.new	Thu Jan 23 00:49:30 1986
***************
*** 15,20
  #endif not lint
  
  #include <stdio.h>
  #include <signal.h>
  /*
   * leave [[+]hhmm]

--- 15,21 -----
  #endif not lint
  
  #include <stdio.h>
+ #include <ctype.h>
  #include <signal.h>
  /*
   * leave [[+]hhmm]
***************
*** 32,38
  main(argc, argv)
  char **argv;
  {
! 	long when, tod, now, diff, hours, minutes;
  	char *cp;
  	int *nv;
  	int atoi();

--- 33,39 -----
  main(argc, argv)
  char **argv;
  {
! 	long when, now, diff, hours, minutes;
  	char *cp;
  	int *nv;
  	int gethm();
***************
*** 35,41
  	long when, tod, now, diff, hours, minutes;
  	char *cp;
  	int *nv;
! 	int atoi();
  	int *localtime();
  
  	strcpy(origlogin, getlogin());

--- 36,42 -----
  	long when, now, diff, hours, minutes;
  	char *cp;
  	int *nv;
! 	int gethm();
  	int *localtime();
  
  	if ((cp = getlogin()) == NULL) {
***************
*** 38,44
  	int atoi();
  	int *localtime();
  
! 	strcpy(origlogin, getlogin());
  	if (argc < 2) {
  		printf("When do you have to leave? ");
  		fflush(stdout);

--- 39,49 -----
  	int gethm();
  	int *localtime();
  
! 	if ((cp = getlogin()) == NULL) {
! 		fprintf(stderr, "leave: You are not logged in\n");
! 		exit(1);
! 	}
! 	strcpy(origlogin, cp);
  	if (argc < 2) {
  		printf("When do you have to leave? ");
  		fflush(stdout);
***************
*** 50,56
  		exit(0);
  	if (*cp == '+') {
  		cp++;
! 		if (*cp < '0' || *cp > '9')
  			usage();
  		tod = atoi(cp);
  		hours = tod / 100;

--- 55,61 -----
  		exit(0);
  	if (*cp == '+') {
  		cp++;
! 		if (!gethm(cp, &hours, &minutes))
  			usage();
  		if (minutes < 0 || minutes > 59)
  			usage();
***************
*** 52,60
  		cp++;
  		if (*cp < '0' || *cp > '9')
  			usage();
- 		tod = atoi(cp);
- 		hours = tod / 100;
- 		minutes = tod % 100;
  		if (minutes < 0 || minutes > 59)
  			usage();
  		diff = 60*hours+minutes;

--- 57,62 -----
  		cp++;
  		if (!gethm(cp, &hours, &minutes))
  			usage();
  		if (minutes < 0 || minutes > 59)
  			usage();
  		diff = 60*hours+minutes;
***************
*** 61,67
  		doalarm(diff);
  		exit(0);
  	}
! 	if (*cp < '0' || *cp > '9')
  		usage();
  	tod = atoi(cp);
  	hours = tod / 100;

--- 63,69 -----
  		doalarm(diff);
  		exit(0);
  	}
! 	if (!gethm(cp, &hours, &minutes))
  		usage();
  	if (hours > 12)
  		hours -= 12;
***************
*** 63,70
  	}
  	if (*cp < '0' || *cp > '9')
  		usage();
- 	tod = atoi(cp);
- 	hours = tod / 100;
  	if (hours > 12)
  		hours -= 12;
  	if (hours == 12)

--- 65,70 -----
  	}
  	if (!gethm(cp, &hours, &minutes))
  		usage();
  	if (hours > 12)
  		hours -= 12;
  	if (hours == 12)
***************
*** 69,75
  		hours -= 12;
  	if (hours == 12)
  		hours = 0;
- 	minutes = tod % 100;
  
  	if (hours < 0 || hours > 12 || minutes < 0 || minutes > 59)
  		usage();

--- 69,74 -----
  		hours -= 12;
  	if (hours == 12)
  		hours = 0;
  
  	if (hours < 0 || hours > 12 || minutes < 0 || minutes > 59)
  		usage();
***************
*** 84,90
  	while (diff < 0)
  		diff += 12*60;
  	if (diff > 11*60) {
! 		printf("That time has already passed!\n");
  		exit(1);
  	}
  	doalarm(diff);

--- 83,89 -----
  	while (diff < 0)
  		diff += 12*60;
  	if (diff > 11*60) {
! 		fprintf(stderr, "That time has already passed!\n");
  		exit(1);
  	}
  	doalarm(diff);
***************
*** 93,99
  
  usage()
  {
! 	printf("usage: leave [[+]hhmm]\n");
  	exit(1);
  }
  

--- 92,98 -----
  
  usage()
  {
! 	fprintf(stderr, "usage: leave [[+]hhmm]\n");
  	exit(1);
  }
  
***************
*** 97,102
  	exit(1);
  }
  
  doalarm(nmins)
  long nmins;
  {

--- 96,120 -----
  	exit(1);
  }
  
+ int
+ gethm(cp, hp, mp)
+ register char *cp;
+ int *hp, *mp;
+ {
+ 	register char c;
+ 	register int tod;
+ 
+ 	tod = 0;
+ 	while ((c = *cp++) != '\0') {
+ 		if (!isdigit(c))
+ 			return(0);
+ 		tod = tod * 10 + (c - '0');
+ 	}
+ 	*hp = tod / 100;
+ 	*mp = tod % 100;
+ 	return(1);
+ }
+ 
  doalarm(nmins)
  long nmins;
  {
***************
*** 172,177
  int secs;
  {
  	int n;
  
  	while (secs > 0) {
  		n = 100;

--- 190,196 -----
  int secs;
  {
  	int n;
+ 	register char *l;
  
  	while (secs > 0) {
  		n = 100;
***************
*** 180,186
  		secs -= n;
  		if (n > 0)
  			sleep(n);
! 		if (strcmp(origlogin, getlogin()))
  			exit(0);
  	}
  }

--- 199,208 -----
  		secs -= n;
  		if (n > 0)
  			sleep(n);
! 		l = getlogin();
! 		if (l == NULL)
! 			exit(0);
! 		if (strcmp(origlogin, l) != 0)
  			exit(0);
  	}
  }

From dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA  Thu Jan 23 15:55:35 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA14896; Thu, 23 Jan 86 15:55:35 PST
Received: from tektronix by csnet-relay.csnet id ab14742; 23 Jan 86 18:45 EST
From: dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA
To: beta43_bugs%monet.berkeley.edu@CSNET-RELAY.ARPA
Received: from lumiere by tektronix with smtp ; 23 Jan 86 10:31:10 PST
Comment: Message received over unauthenticated port at tektronix
Received: by lumiere (5.31/5.14),	id AA14921; Thu, 23 Jan 86 10:31:33 PST
Message-Id: <8601231831.AA14921@lumiere>
Subject: MAKEDEV bug and fix
Date: 23 Jan 86 10:31:29 PST (Thu)

Description:
	When a site has two tape drives of different device types,
	one cannot use MAKEDEV to create device names for them if
	they are both device 0.  This is due to the fact that
	although there are many tape device types they all resolve
	to /dev/*mt*.  There were also a couple of additional bugs.
Repeat-By:
	% mkdir test; cd test; cp /dev/MAKEDEV .
	% su
	# ./MAKEDEV ts0 tm0

	mknod will complain because MAKEDEV is trying to make
	/dev/{mt0, mt4, mt8, mt12 ...} a second time for a tm0
	but it has already created these files once for the ts0.
Fix:
	Thanks go to Richard Doty <rdoty@tektronix> for the bulk of
	this fix.  The fix is to pass more information to MAKEDEV
	to tell it how to name an mt.  With the fix below, one would
	use:

	# ./MAKEDEV ts0 tm0.1

	... with the second form used to tell MAKEDEV to name tm0
	as if it were dev 1 (ie, it will create /dev/{mt1, mt5, mt9,
	mt13, ...}).

	Also fixed: The nameing scheme in mtio(4) implies that one
	can only have four drives called "mt".  The fifth one would
	be called /dev/{mt4, mt8, mt12, mt16 ...}, which conflicts
	with the names of mt0.  Thus, only mt0-3 are allowed.  Also,
	an error clause was wrong.  Diffs follow.


*** /tmp/,RCSt1017787	Wed Jan 22 15:15:42 1986
- --- MAKEDEV	Wed Jan 22 15:15:24 1986
***************
*** 71,78
  	mt*) blk=7; chr=19;;
  	ut*) blk=10; chr=17;;
  	esac
! 	case $unit in
! 	0|1|2|3|4|5|6|7)
  		four=`expr $unit + 4` ; eight=`expr $unit + 8`
  		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
  		/etc/mknod mt$unit	b $blk $unit

- --- 74,94 -----
  	mt*) blk=7; chr=19;;
  	ut*) blk=10; chr=17;;
  	esac
! #
! # permit {devicename}{unitnumber}.{devname}
! # 	ts0.2 means that you want ts unit 0 to be named
! #	as if it were mt2 (ie, /dev/{mt2, mt6, mt10, mt14...} )
! #
! 	case $i in
! 	*.*)	unit=`expr $i : '..\([^\.]*\)'`
! 		Unit=`expr $i : '^.*\.\(.*\)'`
! 		;;
! 	*)	unit=`expr $i : '..\(.*\)'`
! 		Unit=$unit
! 		;;
! 	esac
! 	case $Unit in
! 	0|1|2|3)
  		four=`expr $unit + 4` ; eight=`expr $unit + 8`
  		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
  		Four=`expr $Unit + 4` ; Eight=`expr $Unit + 8`
***************
*** 75,92
  	0|1|2|3|4|5|6|7)
  		four=`expr $unit + 4` ; eight=`expr $unit + 8`
  		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
! 		/etc/mknod mt$unit	b $blk $unit
! 		/etc/mknod mt$four	b $blk $four
! 		/etc/mknod mt$eight	b $blk $eight
! 		/etc/mknod mt$twelve	b $blk $twelve
! 		/etc/mknod nmt$unit	b $blk $four ;: sanity w/pdp11 v7
! 		/etc/mknod nmt$eight	b $blk $twelve ;: ditto
! 		/etc/mknod nrmt$unit	c $chr $four ;: sanity w/pdp11 v7
! 		/etc/mknod nrmt$eight	c $chr $twelve ;: ditto
! 		/etc/mknod rmt$unit	c $chr $unit
! 		/etc/mknod rmt$four	c $chr $four
! 		/etc/mknod rmt$eight	c $chr $eight
! 		/etc/mknod rmt$twelve	c $chr $twelve
  		if [ $i = ut ] 
  		then
  			/etc/mknod mt$twenty	b $blk $twenty

- --- 91,110 -----
  	0|1|2|3)
  		four=`expr $unit + 4` ; eight=`expr $unit + 8`
  		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
! 		Four=`expr $Unit + 4` ; Eight=`expr $Unit + 8`
! 		Twelve=`expr $Unit + 12`; Twenty=`expr $Unit + 20`
! 		/etc/mknod mt$Unit	b $blk $unit
! 		/etc/mknod mt$Four	b $blk $four
! 		/etc/mknod mt$Eight	b $blk $eight
! 		/etc/mknod mt$Twelve	b $blk $twelve
! 		/etc/mknod nmt$Unit	b $blk $four ;: sanity w/pdp11 v7
! 		/etc/mknod nmt$Eight	b $blk $twelve ;: ditto
! 		/etc/mknod nrmt$Unit	c $chr $four ;: sanity w/pdp11 v7
! 		/etc/mknod nrmt$Eight	c $chr $twelve ;: ditto
! 		/etc/mknod rmt$Unit	c $chr $unit
! 		/etc/mknod rmt$Four	c $chr $four
! 		/etc/mknod rmt$Eight	c $chr $eight
! 		/etc/mknod rmt$Twelve	c $chr $twelve
  		if [ $i = ut ] 
  		then
  			/etc/mknod mt$Twenty	b $blk $twenty
***************
*** 89,96
  		/etc/mknod rmt$twelve	c $chr $twelve
  		if [ $i = ut ] 
  		then
! 			/etc/mknod mt$twenty	b $blk $twenty
! 			/etc/mknod rmt$twenty	c $chr $twenty
  		fi
  		;;
  	*)

- --- 107,114 -----
  		/etc/mknod rmt$Twelve	c $chr $twelve
  		if [ $i = ut ] 
  		then
! 			/etc/mknod mt$Twenty	b $blk $twenty
! 			/etc/mknod rmt$Twenty	c $chr $twenty
  		fi
  		;;
  	*)
***************
*** 94,100
  		fi
  		;;
  	*)
! 		echo bad unit for tape in: $1
  		;;
  	esac
  	umask 77

- --- 112,118 -----
  		fi
  		;;
  	*)
! 		echo bad unit for tape in: $i
  		;;
  	esac
  	umask 77

From dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA  Thu Jan 23 16:16:36 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA14986; Thu, 23 Jan 86 16:16:36 PST
Received: from tektronix by csnet-relay.csnet id am14742; 23 Jan 86 18:52 EST
From: dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA
To: beta43_bugs%monet.berkeley.edu@CSNET-RELAY.ARPA
Received: from lumiere by tektronix with smtp ; 23 Jan 86 13:25:20 PST
Comment: Message received over unauthenticated port at tektronix
Received: by lumiere (5.31/5.14),	id AA16323; Thu, 23 Jan 86 13:26:08 PST
Message-Id: <8601232126.AA16323@lumiere>
Subject: libc (fputs)
Date: 23 Jan 86 13:26:05 PST (Thu)

Subject: fputs() fails if a buffer IS allocated and the stream is opened for
	R/W.

Index:	/usr/src/lib/libc/vax/stdio/fputs.c

Description:
	 Under 4.2 and 4.3alpha, fputs() is a C program that repetatively 
	 calls putc(), which in turn calls _flsbuf() to empty the contents 
	 of a string to a stream.  _flsbuf() allocates a buffer and checks 
	 if the _IORW flag is set and if it is, sets the _IOWRT flag.

	 Under 4.3beta, fputs() was rewritten in assy lang. for optimization.
	 Unfortunately, it is now broken because it only calls _flsbuf() if 
	 there is NO buffer allocated.  The _IOWRT flag is never set if there 
	 IS a buffer allocated to the stream.  If a buffer is allocated, 
	 fputs() calls fflush().  Fflush() checks to see if the _IOWRT 
	 is set.  If it is not, it just returns without writing the buffer.
	
Repeat-By:
	#include <stdio.h>
	char *fname = "fputs.test";
	main()
	{
		char buf[BUFSIZ];
		FILE *fp, *fopen();
	
		/* open for writing at end of file, create if necessary */
		if( (fp = fopen(fname,"a")) == NULL)  {
			perror("fopen");
			exit(1);
		} else /* reopen for r/w and position at start of file */
			freopen(fname, "r+", fp); 
	
		/* read contents of file if any */
		while( fgets( buf, sizeof(buf), fp) )
			printf(buf);
	
		/* get input and and append to file */
		printf("Enter text:\n");
		while( fgets(buf, sizeof(buf), stdin) )
			fputs(buf, fp);
	
		fclose(fp); 
	}
	The file fputs.test will be zero length.

Fix:
	Need to test if the R/W flag is set.  If so, set the WRT flag and
	clear the READ and EOF.  Diffs follow:
	*** /usr/src/lib/libc/vax/stdio/fputs.c	Fri Aug 23 19:10:42 1985
	--- /tmp/fputs.c	Thu Jan 23 13:06:18 1986
	***************
	*** 24,29 ****
	--- 24,32 ----
	  
	  #define		NBF	04
	  #define		LBF	0200
	+ #define		WRT	02
	+ #define		EOF_READ 021	/* (_IOREAD | _IOEOF ) */
	+ #define		RW	0400
	  
	  #define		NL	012
	  
	***************
	*** 74,79 ****
	--- 77,91 ----
	  	incl	_CNT(IOP)		/* Unput the char we sent */
	  	decl	_PTR(IOP)
	  2:
	+ 
	+ 	/*
	+ 	 * Test if the R/W flag is set, if so, set the WRT flag and
	+ 	 * clear the READ and EOF flags.
	+ 	 */
	+ 	bitw	$RW,_FLAG(IOP)
	+ 	jeql 	Lloop			/* if not set, jmp */
	+ 	bisw2	$WRT,_FLAG(IOP)		/* set _IOWRT */
	+ 	bicw2	$EOF_READ,_FLAG(IOP)	/* clear _IOREAD and _IOEOF */
	  
	  	/*
	  	 * Search for the terminating null.


From dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA  Sun Jan 26 20:06:07 1986
Received: by monet.berkeley.edu (5.44/1.7)
	id AA28860; Sun, 26 Jan 86 20:06:07 PST
Received: from tektronix by csnet-relay.csnet id ae19560; 26 Jan 86 22:50 EST
From: dlu%lumiere%tektronix.csnet@CSNET-RELAY.ARPA
To: beta43_bugs%monet.berkeley.edu@CSNET-RELAY.ARPA
Received: from lumiere by tektronix with smtp ; 26 Jan 86 18:33:13 PST
Comment: Message received over unauthenticated port at tektronix
Received: by lumiere (5.31/5.14),	id AA02297; Sun, 26 Jan 86 14:34:57 PST
Message-Id: <8601262234.AA02297@lumiere>
Date: 26 Jan 86 14:34:51 PST (Sun)

------- Forwarded Message

>From: tektronix!sutton <Carl D. Sutton>
Subject: Disposing dynamic files clobbers standard files too.
Index:	usr.lib/libpc/DFDISPOSE.c 4.3BSD

Description:
	When dispose() is called, library routine DFDISPOSE walks
	the file list, and starting with the first iorec having 
	an address >= &p, calls PFCLOSE.c for each iorec having 
	a numerically lesser address than the ending address of p.
	Unfortunately, this results in all of the standard files 
	being closed, since their iorecs have lesser addresses.
	The next time "output" is accessed, a core dump occurs.
Repeat-By:
	Try compiling and running (or interpreting using pix)
	the following program:

	program p(output);
	type fileptr = ^text;
	var p: fileptr;
	begin
		new(p);
		rewrite(p^);
		dispose(p);
		writeln(output, 'test worked');
	end.

	It will dump core!
Fix:
	Code diffs follow:

RCS file: RCS/DFDISPOSE.c,v
retrieving revision 1.0
retrieving revision 1.1
diff -c -r1.0 -r1.1
*** /tmp/,RCSt1014756	Sun Jan 26 13:24:48 1986
- --- /tmp/,RCSt2014756	Sun Jan 26 13:24:49 1986
***************
*** 28,34
  		prev = next;
  		next = next->fchain;
  	}
! 	while(next != FILNIL && next < end)
  		next = PFCLOSE(next, TRUE);
  	prev->fchain = next;
  	DISPOSE(var, size);

- --- 28,34 -----
  		prev = next;
  		next = next->fchain;
  	}
! 	while(next != FILNIL && start <= next && next < end)
  		next = PFCLOSE(next, TRUE);
  	prev->fchain = next;
  	DISPOSE(var, size);

------- End of Forwarded Message

From lepreau  Tue Jan 28 06:13:20 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA05009; Tue, 28 Jan 86 06:13:20 PST
Date: Tue, 28 Jan 86 06:13:20 PST
From: lepreau (Jay Lepreau)
Message-Id: <8601281413.AA05009@monet.berkeley.edu>
To: beta43_bugs
Subject: Missing man pages

tftp.1 and sccs.1 are completely absent (I sent mail to eric about the
latter awhile ago).  Note that tftpd.8c does exist.

Unless you intentionally don't want to document them (do you?)
need .so's for f, u, and view.

From j@utah-cs.ARPA  Wed Jan 29 14:07:52 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA01141; Wed, 29 Jan 86 14:07:52 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA15135; Wed, 29 Jan 86 15:08:00 MST
Date: Wed, 29 Jan 86 15:08:00 MST
From: j@utah-cs.arpa (J Lepreau)
Message-Id: <8601292208.AA15135@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: etc/telnetd.c needs to setpgrp in parent

A telnet'ed user whose shell is /bin/sh will be abruptly looged out as
soon as he first hits a ^C, for telnetd gets it and dies, fast.

What I don't understand is that this is not a problem in 4.2 or 4.3
alpha, even though telnetd didn't do a setpgrp then, either.  Some
kernel or sh change?

***************
*** 188,193 ****
--- 188,194 ----
  	ioctl(p, FIONBIO, &on);
  	signal(SIGTSTP, SIG_IGN);
  	signal(SIGCHLD, cleanup);
+ 	setpgrp(0, 0);
  
  	/*
  	 * Request to do remote echo.


From hilbert!hubert@uw-beaver.arpa  Thu Jan 30 20:42:22 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA06272; Thu, 30 Jan 86 20:42:22 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA14964; Thu, 30 Jan 86 20:45:56 PST
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA04551; Thu, 30 Jan 86 17:52:52 PST
Date: Thu, 30 Jan 86 17:52:52 PST
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Thu, 30 Jan 86 17:52:52 PST
Message-Id: <8601310152.AA04551@hilbert.UUCP>
To: beta43_sites@monet.berkeley.edu
Subject: 4.3 panic("blkdev")'s
Cc: bob@uw-bluechip, burr@uw-ward, uw-beaver!sanislo, uw-beaver!yenbut

I have run out of ideas on this problem.  If anyone can think of anything
please drop me a line.  Thanks.

I am getting panic(blkdev)'s about every other day or so.
Configuration is 4.3beta on a 11/785, 3 ra81's on a single uda50, some
dmf's and a dz, FPA, Interlan ethernet.  I have spent quite a bit of
time looking through the code and through core dumps.  I have not tried
adding any sort of debugging code to the kernel.  If anyone has time to
look through this stuff that would be greatly appreciated.

Steve Hubert
 Univ. of Wash., Seattle
 {decvax,ihnp4,ucbvax!lbl-csam}!uw-beaver!entropy!hubert
 entropy!hubert@uw-beaver
 hubert@uw-june.arpa


Here is what is happening.  A bad 'dev' is getting passed to getblk()
from bread() from rwip().  Here is some of the key code from sys_inode.c.

	--- sys_inode.c 6.13  8/4/85 ---

rwip(ip, uio, rw)
	register struct inode *ip;
	register struct uio *uio;
	enum uio_rw rw;
{
	dev_t dev = (dev_t)ip->i_rdev;		<=== local var dev = c636
	struct buf *bp;
	struct fs *fs;
	daddr_t lbn, bn;
	register int n, on, type;
	int size;
	long bsize;
	extern int mem_no;
	int error = 0;
	:
	:
	:
	type = ip->i_mode&IFMT;			<=== type = IFREG
	:
	:
	:
	if (type != IFBLK) {
		dev = ip->i_dev;		<=== this seems to be skipped
		fs = ip->i_fs;			<=== this is executed
		bsize = fs->fs_bsize;		<=== this is executed
	} else
		bsize = BLKDEV_IOSIZE;
	do {
		:
		:
		:
		if (rw == UIO_READ) {
			:
			:
			:
				bp = breada(dev, bn, size, rablock, rasize);
			else
				bp = bread(dev, bn, size);
			ip->i_lastr = lbn;
		} else {
		:
		:
		:
The value of dev pushed for bread (or sometimes for breada) is the original
value that was in ip->i_rdev rather than the value it should be which
is in ip->i_dev.  The stack below shows that the local variable dev ( -2(fp) )
is still set to c636 which is the value in ip->i_rdev rather than 0905
(or some other minor with major 9) which is the value in ip->i_dev.
The symptoms are exactly as if the crucial instruction (dev = ip->i_dev)
is skipped.  Any ideas?


======
_HIL # adb -k vmunix.2 vmcore.2

sbr e068 slr 3970
p0br 4e00 p0lr 9b6 p1br	7600 p1lr fff0
panic: blkdev

*(scb-4)/$c

_boot()	from _boot+f3
_boot(0,0) from	_panic+3a
_panic(8003e140) from _getblk+f0
_getblk(-39ca,38c6c,400) from _bread+25
_bread(-39ca,38c6c,400)	from 8001045f
_rwip(8006020c,7fffff60,0) from	_ino_rw+7c
_ino_rw(80066520,0,7fffff60) from _rwuio+da
_rwuio(7fffff60,0) from	_read+2b
_read()	from 8002653f
_syscall() from	_Xsyscall+c
_Xsyscall(3,7fffe544,1ff) from e2f6a
_Syssize(10d748) from e26b0
_Syssize(10d748) from 1844
?(7fffe864) from 923b
_Syssize(134188,7fffe864,7fffe86c,1) from 9464
_Syssize(134188,10e7ac,15ac,10d738,10e7a4,1) from 127f
?(10e7ac,10de2c,10e2f4,10e7a4) from a6f5
_Syssize(7fffe90c) from	9aab
_Syssize(1,7fffe93c,7fffe944) from 37
?() from e2ad4
_Syssize() from	54414e49
_Syssize()
address	out of segment

*(scb-4)/X
7ffffd90:	0

.,(8000000-.)/X

7ffffd90:	0		Frame
7ffffd94:	21010000
7ffffd98:	7ffffddc	AP
7ffffd9c:	7ffffdb8	FP
7ffffda0:	80025cc3	PC
		9		R0
		0		R8
		0		---- no args to doadump()
7ffffdb0:	0		:: local var in boot (devtype)
		6		:: local var in boot (howto=RB_NOSYNC|RB_SINGLE)
		0		Frame
		2f000000
7ffffdc0:	7ffffe30	AP
		7ffffdec	FP
		8000f314	PC
		0		R7
7ffffdd0:	97		R8
		8004747c	R9
		8004747c	R10
		2		----
7ffffde0:	0		---- args to boot() boot(RB_PANIC,bootopt)
		0		----
		0		:: local var in panic (bootopt=RB_AUTOBOOT)
		0		Frame
7ffffdf0:	2fff0000
		7ffffe5c	AP
		7ffffe40	FP
		80015916	PC
7ffffe00:	c6		R0
		38c6		R1
		0		R2
		7fffeca8	R3
7ffffe10:	0		R4
		0		R5
		8006b154	R6
		8000		R7   = saved R7 from rwip = type = IFREG
7ffffe20:	0		R8
		97		R9
		8004747c	R10
		8004747c	R11
7ffffe30:	1		---- 
		8003e140	---- arg to panic() = address of panicstr
		2fc00000
		7ffffea4
7ffffe40:	0		Frame
		2c000000
		7ffffe84	AP
		7ffffe6c	FP
7ffffe50:	800154dd	PC
		7fffff60	R10
		8006020c	R11
		3		---- args to getblk()
7ffffe60:	-39ca		---- dev              <=== This causes panic ==
		38c6c		---- blkno
		400		---- size
		0		Frame
7ffffe70:	28000000
		7ffffee8	AP
		7ffffec0	FP
		8001045f	PC
7ffffe80:	8006020c	R11
		3		---- args to bread()
		-39ca		---- dev              <=== This causes panic ==
		38c6c		---- blkno
7ffffe90:	400		---- size
		7fffff08
		8001824d
		97
7ffffea0:	0
		1000		:: local rwip var (bsize)
		400		:: local rwip var (size)
		38c6c		:: local rwip var (bn)
7ffffeb0:	0		:: local rwip var (lbn)
		801ca200	:: local rwip var (fs)
		8004ad2c	:: local rwip var (bp)
		c6360445	:: local rwip var (dev = -2(fp))
		^^^^    <---     This is dev, (note -39ca = c636 sign extended)
7ffffec0:	0		Frame
		2f800000
		7fffff14	AP
		7ffffefc	FP
7ffffed0:	80010104	PC
		5a6c		R7
		8003d040	R8
		7fffff60	R9
7ffffee0:	80066520	R10
		8006020c	R11
		3		---- args to rwip()
		8006020c	---- ip
7ffffef0:	7fffff60	---- uio
		0		---- rw
		0
		0
7fffff00:	28000000
		7fffff4c
		7fffff2c
		8000fa76
7fffff10:	7fffff60
		3
		80066520
		0
7fffff20:	7fffff60
		1ff
		1
		0
7fffff30:	2e000000
		7fffff8c
		7fffff74
		8000f8bf
7fffff40:	c
		7fffe538
		7fffec9c
		2
7fffff50:	7fffff60
		0
		7fffe544
		1ff
7fffff60:	7fffff58
		1
		0
		0
7fffff70:	1ff
		0
		28000000
		7fffffe8
7fffff80:	7fffffa4
		8002653f
		80000000
		0
7fffff90:	180000
		0
		0
		5f370
7fffffa0:	10cd06
		0
		2fff0000
		7fffe534
7fffffb0:	7fffe520
		80000f7c
		0
		134194
7fffffc0:	0
		1341ac
		0
		0
7fffffd0:	8006b154
		5a6c
		7fffe93c
		7fffe944
7fffffe0:	7fffe938
		1243c8
		0
		7fffe520
7ffffff0:	5
		3
		10cd08
		3c00000

From muller@nprdc.arpa  Fri Jan 31 02:19:50 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA07275; Fri, 31 Jan 86 02:19:50 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA11857; Fri, 31 Jan 86 02:10:13 pst
Date: Fri, 31 Jan 86 02:10:13 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8601311010.AA11857@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu

Subject: overlay function in curses displays garbage and is SLOW!
Index:	usr.lib/libcurses/overlay.c 4.3BSD

Description:
	The overlay funtion in curses is extremely slow and when it
	does finally run it displays garbage on the screen. It also
	messes up the the other windows.
Repeat-By:
	Run the very simply program below. With the stock 4.3 curses
	the program takes 56 CPU seconds and then dies. 

#include <curses.h>

#define YPOSBOX		 0
#define XPOSBOX		 0
#define YBOX		20
#define XBOX	        80

#define YPOSSBOX	 2
#define XPOSSBOX	10
#define YSBOX	        17
#define XSBOX	        66

WINDOW *boxing,*sub_box;
main()
{
	boxing = newwin(YBOX,XBOX,YPOSBOX,XPOSBOX);
	sub_box = subwin(boxing,YSBOX,XSBOX,YPOSSBOX,XPOSSBOX);
	initscr();
	box(boxing,'|','-');
	wrefresh(boxing);
	box(sub_box,'.','.');
	overlay(sub_box,boxing);/* overlays sub_box on top of boxing */
	wrefresh(sub_box);
	mvcur(0,COLS-1,LINES-1,0);	/* move to bottom of screen */
	endwin();
}

Fix:
	A quick check with profile shows the following:
granularity: each sample hit covers 4 byte(s) for 0.02% of 56.41 seconds

                8.10       46.52       1/1           _main [2]
[3]     96.8    8.10       46.52       1         _overlay [3]
               46.47        0.00  288686/288686      _waddch [4]

	This seemed a bit excessive for calls to waddch. On inspection
	alone there was at least one typo (a call to waddch had an
	incorrect arg count). Furthur investigation showed that the loop
	that was spending all the time was also creating the garbage output.
	Several of the subscripts used in the arrays were pointing
	to areas outside of the arrays. Here is the working solution
	(the program now takes 0.5 cpu seconds).

	Keith Muller
	University of California
	muller@nprdc

RCS file: RCS/overlay.c,v
retrieving revision 1.1
diff -c -r1.1 overlay.c
*** /tmp/,RCSt1015540	Fri Jan 31 02:03:45 1986
--- overlay.c	Fri Jan 31 02:02:44 1986
***************
*** 23,28
  
  	reg char	*sp, *end;
  	reg int		x, y, endy, endx, starty, startx;
  
  # ifdef DEBUG
  	fprintf(outf, "OVERLAY(%0.2o, %0.2o);\n", win1, win2);

--- 23,29 -----
  
  	reg char	*sp, *end;
  	reg int		x, y, endy, endx, starty, startx;
+ 	reg int 	y1,y2;
  
  # ifdef DEBUG
  	fprintf(outf, "OVERLAY(%0.2o, %0.2o);\n", win1, win2);
***************
*** 42,49
  		      &win2->_y[y - win2->_begy][startx - win2->_begx], x);
  		touchline(win2, y, startx - win2->_begx, endx - win2->_begx);
  	}
! 	for (y = starty; y < endy; y++) {
! 		end = &win1->_y[y - win1->_begy][endx - win1->_begx];
  		x = startx - win2->_begx;
  		for (sp = &win1->_y[y][startx - win1->_begx]; sp < end; sp++) {
  			if (!isspace(*sp)) {

--- 43,52 -----
  		      &win2->_y[y - win2->_begy][startx - win2->_begx], x);
  		touchline(win2, y, startx - win2->_begx, endx - win2->_begx);
  	}
! 	y1 = starty - win1->_begy;
! 	y2 = starty - win2->_begy;
! 	for (y = starty; y < endy; y++, y1++, y2++) {
! 		end = &win1->_y[y1][endx - win1->_begx];
  		x = startx - win2->_begx;
  		for (sp = &win1->_y[y1][startx - win1->_begx]; sp < end; sp++) {
  			if (!isspace(*sp))
***************
*** 45,55
  	for (y = starty; y < endy; y++) {
  		end = &win1->_y[y - win1->_begy][endx - win1->_begx];
  		x = startx - win2->_begx;
! 		for (sp = &win1->_y[y][startx - win1->_begx]; sp < end; sp++) {
! 			if (!isspace(*sp)) {
! 				waddch(win2, y - win2->_begy, x);
! 				waddch(win2, *sp);
! 			}
  			x++;
  		}
  	}

--- 48,56 -----
  	for (y = starty; y < endy; y++, y1++, y2++) {
  		end = &win1->_y[y1][endx - win1->_begx];
  		x = startx - win2->_begx;
! 		for (sp = &win1->_y[y1][startx - win1->_begx]; sp < end; sp++) {
! 			if (!isspace(*sp))
! 				mvwaddch(win2, y2, x, *sp);
  			x++;
  		}
  	}

From muller@sdcsvax.ucsd.edu  Fri Jan 31 02:17:40 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA07272; Fri, 31 Jan 86 02:17:40 PST
Received: by sdcsvax.ucsd.edu (5.31/4.41)
	id AA04761; Fri, 31 Jan 86 02:17:46 PST hops=0
Date: Fri, 31 Jan 86 02:17:46 PST
From: muller@sdcsvax.UCSD.EDU (Keith Muller)
Message-Id: <8601311017.AA04761@sdcsvax.ucsd.edu>
To: beta43_bugs@monet.berkeley.edu

Subject: overlay function in curses displays garbage and is SLOW!
Index:	usr.lib/libcurses/overlay.c 4.3BSD

Description:
	The overlay funtion in curses is extremely slow and when it
	does finally run it displays garbage on the screen. It also
	messes up the the other windows.
Repeat-By:
	Run the very simply program below. With the stock 4.3 curses
	the program takes 56 CPU seconds and then dies. 

#include <curses.h>

#define YPOSBOX		 0
#define XPOSBOX		 0
#define YBOX		20
#define XBOX	        80

#define YPOSSBOX	 2
#define XPOSSBOX	10
#define YSBOX	        17
#define XSBOX	        66

WINDOW *boxing,*sub_box;
main()
{
	boxing = newwin(YBOX,XBOX,YPOSBOX,XPOSBOX);
	sub_box = subwin(boxing,YSBOX,XSBOX,YPOSSBOX,XPOSSBOX);
	initscr();
	box(boxing,'|','-');
	wrefresh(boxing);
	box(sub_box,'.','.');
	overlay(sub_box,boxing);/* overlays sub_box on top of boxing */
	wrefresh(sub_box);
	mvcur(0,COLS-1,LINES-1,0);	/* move to bottom of screen */
	endwin();
}

Fix:
	A quick check with profile shows the following:
granularity: each sample hit covers 4 byte(s) for 0.02% of 56.41 seconds

                8.10       46.52       1/1           _main [2]
[3]     96.8    8.10       46.52       1         _overlay [3]
               46.47        0.00  288686/288686      _waddch [4]

	This seemed a bit excessive for calls to waddch. On inspection
	alone there was at least one typo (a call to waddch had an
	incorrect arg count). Furthur investigation showed that the loop
	that was spending all the time was also creating the garbage output.
	Several of the subscripts used in the arrays were pointing
	to areas outside of the arrays. Here is the working solution
	(the program now takes 0.5 cpu seconds).

	Keith Muller
	University of California
	muller@nprdc

RCS file: RCS/overlay.c,v
retrieving revision 1.1
diff -c -r1.1 overlay.c
*** /tmp/,RCSt1015540	Fri Jan 31 02:03:45 1986
--- overlay.c	Fri Jan 31 02:02:44 1986
***************
*** 23,28
  
  	reg char	*sp, *end;
  	reg int		x, y, endy, endx, starty, startx;
  
  # ifdef DEBUG
  	fprintf(outf, "OVERLAY(%0.2o, %0.2o);\n", win1, win2);

--- 23,29 -----
  
  	reg char	*sp, *end;
  	reg int		x, y, endy, endx, starty, startx;
+ 	reg int 	y1,y2;
  
  # ifdef DEBUG
  	fprintf(outf, "OVERLAY(%0.2o, %0.2o);\n", win1, win2);
***************
*** 42,49
  		      &win2->_y[y - win2->_begy][startx - win2->_begx], x);
  		touchline(win2, y, startx - win2->_begx, endx - win2->_begx);
  	}
! 	for (y = starty; y < endy; y++) {
! 		end = &win1->_y[y - win1->_begy][endx - win1->_begx];
  		x = startx - win2->_begx;
  		for (sp = &win1->_y[y][startx - win1->_begx]; sp < end; sp++) {
  			if (!isspace(*sp)) {

--- 43,52 -----
  		      &win2->_y[y - win2->_begy][startx - win2->_begx], x);
  		touchline(win2, y, startx - win2->_begx, endx - win2->_begx);
  	}
! 	y1 = starty - win1->_begy;
! 	y2 = starty - win2->_begy;
! 	for (y = starty; y < endy; y++, y1++, y2++) {
! 		end = &win1->_y[y1][endx - win1->_begx];
  		x = startx - win2->_begx;
  		for (sp = &win1->_y[y1][startx - win1->_begx]; sp < end; sp++) {
  			if (!isspace(*sp))
***************
*** 45,55
  	for (y = starty; y < endy; y++) {
  		end = &win1->_y[y - win1->_begy][endx - win1->_begx];
  		x = startx - win2->_begx;
! 		for (sp = &win1->_y[y][startx - win1->_begx]; sp < end; sp++) {
! 			if (!isspace(*sp)) {
! 				waddch(win2, y - win2->_begy, x);
! 				waddch(win2, *sp);
! 			}
  			x++;
  		}
  	}

--- 48,56 -----
  	for (y = starty; y < endy; y++, y1++, y2++) {
  		end = &win1->_y[y1][endx - win1->_begx];
  		x = startx - win2->_begx;
! 		for (sp = &win1->_y[y1][startx - win1->_begx]; sp < end; sp++) {
! 			if (!isspace(*sp))
! 				mvwaddch(win2, y2, x, *sp);
  			x++;
  		}
  	}

From chris@gyre.umd.edu  Fri Jan 31 04:20:59 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA07621; Fri, 31 Jan 86 04:20:59 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA00666; Fri, 31 Jan 86 07:19:13 EST
Date: Fri, 31 Jan 86 07:19:13 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8601311219.AA00666@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Nasty little find bug

Index: /usr/src/usr.bin/find/find.c 4.3Beta Fix

Description:
	`find' does not properly implement matching of character class
	ranges (`[a-z]').  This appears to be due to a coding error
	which was masked by a compiler (bug|feature) until recently.

Repeat-By:
	% mkdir xxx; cd xxx; touch emacs-macros
	% find . -name 'emacs[0-9]*' -print
	% cd ..; rm -r xxx

	This will print `emacs-macros' (it should not).

Fix:
	Below.

Chris

RCS file: RCS/find.c,v
retrieving revision 1.1
diff -c2 -r1.1 find.c
*** /tmp/,RCSt1000659	Fri Jan 31 07:15:16 1986
--- find.c	Fri Jan 31 07:14:53 1986
***************
*** 714,718 ****
  
  			case '-':
! 				k |= lc <= scc && scc <= (cc=p[1]);
  			}
  			if (scc==(lc=cc)) k++;
--- 714,719 ----
  
  			case '-':
! 				cc = p[1];
! 				k |= lc <= scc && scc <= cc;
  			}
  			if (scc==(lc=cc)) k++;

From torek  Sat Feb  1 09:13:47 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA13004; Sat, 1 Feb 86 09:13:47 PST
Date: Sat, 1 Feb 86 09:13:47 PST
From: torek (Chris Torek)
Message-Id: <8602011713.AA13004@monet.berkeley.edu>
To: beta43_bugs
Subject: pcc/INDEX is wrong

/usr/src/lib/pcc/INDEX claims the C compiler is for a PDP-11....

Chris

From comay  Sun Feb  2 21:06:13 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25407; Sun, 2 Feb 86 21:06:13 PST
Date: Sun, 2 Feb 86 21:06:13 PST
From: comay (David S. Comay)
Message-Id: <8602030506.AA25407@monet.berkeley.edu>
To: beta43_bugs
Subject: soft carrier only works with the first dmz
Index: 	sys/vaxuba/dmz.c 4.3BSD

Description:
	When soft carrier is enabled on any port on any dmz other than
	the first one, processes will hang in dmzopen when trying to
	open that port.
Repeat-By:
	Turn on soft carrier and start a getty on one of the ports on
	the second dmz
Fix:
	The mask used to check the soft carrier bit should be created
	by shifting a one the minor number modulo 24, rather than just
	the minor number

	*** dmz.c.orig	Mon Dec 16 03:05:49 1985
	--- dmz.c	Mon Dec 16 03:06:06 1985
	***************
	*** 219,225 ****
	--- 219,225 ----
	  
	  	/* Wait for carrier, then process line discipline specific open */
	  	if((dmzmctl(device,DMZ_ON,DMSET) & (DMZ_CAR << 8)) ||
	!<	   (dmzsoftCAR[controller] & ( 1 << unit)))
	  		tp->t_state |= TS_CARR_ON;
	  	priority=spl5();	
	  	while ((tp->t_state & TS_CARR_ON) == 0){
	---------------
	  
	  	/* Wait for carrier, then process line discipline specific open */
	  	if((dmzmctl(device,DMZ_ON,DMSET) & (DMZ_CAR << 8)) ||
	!>	   (dmzsoftCAR[controller] & ( 1 << (unit % 24))))
	  		tp->t_state |= TS_CARR_ON;
	  	priority=spl5();	
	  	while ((tp->t_state & TS_CARR_ON) == 0){

From comay  Sun Feb  2 21:08:36 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25429; Sun, 2 Feb 86 21:08:36 PST
Date: Sun, 2 Feb 86 21:08:36 PST
From: comay (David S. Comay)
Message-Id: <8602030508.AA25429@monet.berkeley.edu>
To: beta43_bugs
Subject: maybe a better way of creating /etc/motd in /etc/rc.local
Index: 	/etc/rc.local 4.3BSD

Description:
	The distributed version of /etc/rc.local creates /etc/motd by
	finding the version string in the kernel and then it tries to
	add the remainder of the current /etc/motd by adding all the
	lines of the current one except those containing the string
	`UNIX'.  It is possible that a valid line in /etc/motd will be
	lost with this procedure.
Repeat-By:
	% echo Welcome to the UNIX system. >> /etc/motd

	The next time the system comes up multiuser, the lines just
	added to /etc/motd will be missing.
Fix:
	Use `tail +2' rather than `grep -v UNIX' to filter out the
	version line.

	*** rc.local.orig	Mon Dec 16 04:12:28 1985
	--- rc.local	Mon Dec 16 04:13:40 1985
	***************
	*** 9,15 ****
	--- 9,15 ----
	  /etc/ifconfig lo0 localhost
	  
	  /usr/ucb/strings /vmunix | grep UNIX >/tmp/t1
	!<grep -v UNIX /etc/motd >>/tmp/t1
	  mv /tmp/t1 /etc/motd
	  chmod 666 /etc/motd
	  
	---------------
	  /etc/ifconfig lo0 localhost
	  
	  /usr/ucb/strings /vmunix | grep UNIX >/tmp/t1
	!>/usr/ucb/tail +2 /etc/motd >>/tmp/t1
	  mv /tmp/t1 /etc/motd
	  chmod 666 /etc/motd
	  

From comay  Sun Feb  2 21:07:57 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25423; Sun, 2 Feb 86 21:07:57 PST
Date: Sun, 2 Feb 86 21:07:57 PST
From: comay (David S. Comay)
Message-Id: <8602030507.AA25423@monet.berkeley.edu>
To: beta43_bugs, eric, miriam
Subject: incorrect sccs header included
Index: 	usr.lib/sendmail/src/alias.c 4.3BSD

Description:
	The wrong sccs header is included when sendmail is compiled.
	Not a big problem, although one can get fooled if one uses
	`what' to look at sccs headers.
Repeat-By:
	what /usr/lib/sendmail | egrep alias\\.c

	Notice that even though sendmail was compiled with DBM turned
	on, the sccs header says otherwise.
Fix:
	Simply move the definition of the sccs header after the
	inclusion of sendmail.h, which includes conf.h which defines
	`DBM'.

	*** alias.c.orig	Fri Oct 25 16:38:08 1985
	--- alias.c	Mon Dec 16 03:11:06 1985
	***************
	*** 8,21 ****
	--- 8,13 ----
	  **  specifies the terms and conditions for redistribution.
	  */
	  
	-<#ifndef lint
	-<# ifdef DBM
	-<static char	SccsId[] = "@(#)alias.c	5.6 (Berkeley) 10/24/85	(with DBM)";
	-<# else DBM
	-<static char	SccsId[] = "@(#)alias.c	5.6 (Berkeley) 10/24/85	(without DBM)";
	-<# endif DBM
	-<#endif not lint
	-<
	  # include <pwd.h>
	  # include <sys/types.h>
	  # include <sys/stat.h>
	---------------
	  # include <pwd.h>
	  # include <sys/types.h>
	  # include <sys/stat.h>
	***************
	*** 25,30 ****
	--- 17,30 ----
	---------------
	  # ifdef FLOCK
	  # include <sys/file.h>
	  # endif FLOCK
	+>
	+>#ifndef lint
	+># ifdef DBM
	+>static char	SccsId[] = "@(#)alias.c	5.6 (Berkeley) 10/24/85	(with DBM)";
	+># else DBM
	+>static char	SccsId[] = "@(#)alias.c	5.6 (Berkeley) 10/24/85	(without DBM)";
	+># endif DBM
	+>#endif not lint
	  
	  
	  /*

From comay  Sun Feb  2 21:09:03 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25439; Sun, 2 Feb 86 21:09:03 PST
Date: Sun, 2 Feb 86 21:09:03 PST
From: comay (David S. Comay)
Message-Id: <8602030509.AA25439@monet.berkeley.edu>
To: beta43_bugs
Subject: LOCAL should be local in setup documentation
Index: 	/usr/doc/setup/4.t

Description:
	In section 4.3.2 (Devices and device drivers), the user is
	given an example of of creating some special files.  In the
	example, MAKEDEV is called with an argument LOCAL.  This should
	really be local (how picky of me.)
Repeat-By:
	Look through the MAKEDEV and notice that case for `local',
	rather than `LOCAL'.
Fix:
	Change LOCAL to local in /usr/doc/setup/4.t.

From comay  Sun Feb  2 21:09:18 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25446; Sun, 2 Feb 86 21:09:18 PST
Date: Sun, 2 Feb 86 21:09:18 PST
From: comay (David S. Comay)
Message-Id: <8602030509.AA25446@monet.berkeley.edu>
To: beta43_bugs
Subject: misplaced files?
Index: 	/usr/ucb/bugformat
	/usr/adm/newsyslog
	/usr/spool/mqueue/newsyslog

Description:
	The above three files either don't exist, or they seem to exist in the
	wrong place on the distribution tape.
Repeat-By:
	Check location of these files.
Fix:
	Since bugformat is not a binary, it should probably exist in
	/usr/lib.  If one looks at the distributed /usr/lib/crontab,
	one sees the following two lines

		10 0 * * 7	root	sh /usr/adm/newsyslog
		20 0 * * *	root	sh /usr/spool/mqueue/newsyslog

	It seems according to this, that what it distributed as
	/usr/adm/newsyslog should really exist in
	/usr/spool/mqueue/newsyslog (this newsyslog rotates the mail
	logs around.) The `real' /usr/adm/newsyslog (which trims
	/usr/adm/messages) did not exist on our tape.

From comay  Sun Feb  2 21:07:44 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25420; Sun, 2 Feb 86 21:07:44 PST
Date: Sun, 2 Feb 86 21:07:44 PST
From: comay (David S. Comay)
Message-Id: <8602030507.AA25420@monet.berkeley.edu>
To: beta43_bugs, eric, miriam
Subject: arguments to smtp helo & help commands are incorrect
Index: 	usr.lib/sendmail/srvrsmtp.c 4.3BSD

Description:
	Since the code that deals with the smtp helo and help commands
	do not ignore the white space following these commands,
	sendmail incorrect deals with the command's arguments.
Repeat-By:
	% /usr/lib/sendmail -bs
	220 tektools Sendmail 5.31/5.14 ready at Mon, 16 Dec 85 06:52:50 PST
	help
	214-Commands:
	214-	HELO	MAIL	RCPT	DATA	RSET
	214-	NOOP	QUIT	HELP	VRFY	EXPN
	214-For more info use "HELP <topic>".
	214-To report bugs in the implementation contact eric@Berkeley.ARPA
	214-or eric@UCB-ARPA.ARPA.
	214-For local information contact postmaster at this site.
	214 End of HELP info
	help rset
	504 HELP topic unknown
	help mail
	504 HELP topic unknown
	helo myname
	250 tektools Hello  myname, pleased to meet you
	helo tektools
	250 tektools Hello  tektools, pleased to meet you
	quit
	221 tektools closing connection
	%

	Notice that the `helo tektools' should have resulted in the
	error `I refuse to talk with myself'.
Fix:
	*** srvrsmtp.c.orig	Sun Feb  2 19:27:20 1986
	--- srvrsmtp.c	Sun Feb  2 19:28:34 1986
	***************
	*** 172,178 ****
	  		/* break off command */
	  		for (p = inp; isspace(*p); p++)
	  			continue;
	- 		cmd = p;
	  		for (cmd = cmdbuf; *p != '\0' && !isspace(*p); )
	  			*cmd++ = *p++;
	  		*cmd = '\0';
	--- 172,177 ----
	***************
	*** 183,188 ****
	--- 182,190 ----
	  			if (sameword(c->cmdname, cmdbuf))
	  				break;
	  		}
	+ 
	+ 		while(isspace(*p))
	+ 			++p;
	  
	  		/* process command */
	  		switch (c->cmdcode)

From comay  Sun Feb  2 21:09:37 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25461; Sun, 2 Feb 86 21:09:37 PST
Date: Sun, 2 Feb 86 21:09:37 PST
From: comay (David S. Comay)
Message-Id: <8602030509.AA25461@monet.berkeley.edu>
To: beta43_bugs, eric
Subject: facility code `daemon' does not exist
Index: 	etc/syslogd.c 4.3BSD
	ucb/logger.c 4.3BSD

Description:
	There is no facility `daemon' defined in syslogd, even though
	there is one defined in <sys/syslog.h>.  `daemon' is referenced
	as well in the distributed syslog.conf.
Repeat-By:
	Start up syslogd and watch the console output.
Fix:
	Add a line for `daemon' to the FacNames array in both syslogd.c
	as well as logger.c.

*** syslogd.c.orig	Mon Jan 20 10:43:16 1986
--- syslogd.c	Mon Jan 20 10:42:32 1986
***************
*** 928,933 ****
--- 928,934 ----
  	"kern",		LOG_KERN,
  	"user",		LOG_USER,
  	"mail",		LOG_MAIL,
+ 	"daemon",	LOG_DAEMON,
  	"auth",		LOG_AUTH,
  	"security",	LOG_AUTH,
  	"local0",	LOG_LOCAL0,

*** logger.c.orig	Mon Jan 20 10:47:09 1986
--- logger.c	Mon Jan 20 10:48:27 1986
***************
*** 144,149 ****
--- 144,150 ----
  	"kern",		LOG_KERN,
  	"user",		LOG_USER,
  	"mail",		LOG_MAIL,
+ 	"daemon",	LOG_DAEMON,
  	"auth",		LOG_AUTH,
  	"security",	LOG_AUTH,
  	"local0",	LOG_LOCAL0,

From comay  Sun Feb  2 21:08:18 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25426; Sun, 2 Feb 86 21:08:18 PST
Date: Sun, 2 Feb 86 21:08:18 PST
From: comay (David S. Comay)
Message-Id: <8602030508.AA25426@monet.berkeley.edu>
To: beta43_bugs, eric, miriam
Subject: uucp mail with a single dot in the body results in truncated mail
Index: 	bin/rmail.c 4.3BSD

Description:
	When uucp mail normally arrives, rmail is executed and it pipes
	the message to sendmail.  Sendmail normally sees a single dot
	on a line as a message terminator, so if the letter in question
	has a single dot on a line, all subsequent lines will be
	discarded.
Repeat-By:
	Have a letter sent to the local site via uucp and include a
	single dot by itself somewhere in the middle of the letter.
	The text following the dot will be discarded.
Fix:
	Sendmail should be invoked with the `-i' option so that it will
	not interpret a single dot as a message terminator.

	*** rmail.c.orig	Mon Dec 16 03:59:08 1985
	--- rmail.c	Mon Dec 16 03:59:44 1985
	***************
	*** 100,106 ****
	--- 100,106 ----
	  	}
	  	(void) strcat(from, uf);
	  
	!<	(void) sprintf(cmd, "%s -ee -f%s", MAILER, from);
	  	while (*++argv != NULL)
	  	{
	  		(void) strcat(cmd, " '");
	---------------
	  	}
	  	(void) strcat(from, uf);
	  
	!>	(void) sprintf(cmd, "%s -ee -f%s -i", MAILER, from);
	  	while (*++argv != NULL)
	  	{
	  		(void) strcat(cmd, " '");

From comay  Sun Feb  2 21:10:12 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25475; Sun, 2 Feb 86 21:10:12 PST
Date: Sun, 2 Feb 86 21:10:12 PST
From: comay (David S. Comay)
Message-Id: <8602030510.AA25475@monet.berkeley.edu>
To: beta43_bugs
Subject: typing eof during rcs operations with multiple files causes problems
Index: 	new/rcs/src/ci.c 4.3BSD
	new/rcs/src/co.c 4.3BSD
	new/rcs/src/rcs.c 4.3BSD
	new/rcs/src/rcsgen.c 4.3BSD

Description:
	When more than one file is being used with a rcs command, and
	if the rcs command prompts for user input (for example,
	prompting for a comment when checking in a revision), all
	furthur input receives eofs as well.
Repeat-By:
	Check in more than one file, and when `ci' prompts for input
	when checking in the first file, type eof.  When `ci' checks in
	the second file, it will print out a prompt but it actually
	will not allow furthur input.
Fix:
	Some appropriately placed clearerrs solve te problem.

	*** /tmp/,RCSt1020758	Sat Feb  1 21:12:47 1986
	--- ci.c	Mon Oct 14 08:46:36 1985
	***************
	*** 723,728
	                  fputs("checkin anyway? [ny](n): ",stdout);
	                  response=c=getchar();
	                  while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
	                  result=(response=='y'||response=='Y');
	          }
	          if (result==false) {
	
	--- 726,733 -----
	                  fputs("checkin anyway? [ny](n): ",stdout);
	                  response=c=getchar();
	                  while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
	+ 		if ( c == EOF )
	+ 		    clearerr(stdin);
	                  result=(response=='y'||response=='Y');
	          }
	          if (result==false) {
	***************
	*** 777,782
	                  cin=getchar();
	  		response=cin;
	                  while (!(cin==EOF || cin=='\n')) cin=getchar();/*skip to end of line*/
	                  if (response=='\n'||response=='y'||response=='Y')
	                          return logmsg;
	                  else
	
	--- 782,789 -----
	                  cin=getchar();
	  		response=cin;
	                  while (!(cin==EOF || cin=='\n')) cin=getchar();/*skip to end of line*/
	+ 		if (c == EOF)
	+ 			clearerr(stdin);
	                  if (response=='\n'||response=='y'||response=='Y')
	                          return logmsg;
	                  else
	***************
	*** 790,796
	          for (;;) {
	                  cin=getchar();
	                  if (cin==EOF) {
	!                         if(isatty(fileno(stdin))) putc('\n',stdout);
	                          if (*(tp-1) != '\n') *tp++ = '\n'; /* append newline */
	                          *tp = '\0'; /*terminate*/
	                          break;
	
	--- 797,803 -----
	          for (;;) {
	                  cin=getchar();
	                  if (cin==EOF) {
	!                         if(isatty(fileno(stdin))) putc('\n',stdout), clearerr(stdin);
	                          if (*(tp-1) != '\n') *tp++ = '\n'; /* append newline */
	                          *tp = '\0'; /*terminate*/
	                          break;
	*** /tmp/,RCSt1020758	Sat Feb  1 21:12:58 1986
	--- co.c	Mon Oct 14 08:46:39 1985
	***************
	*** 337,342
	                  /* must be stderr in case of IO redirect */
	                  c=response=getchar();
	                  while (!(c==EOF || c=='\n')) c=getchar(); /*skip rest*/
	                  if (!(response=='y'||response=='Y')) {
	                          warn("checkout aborted.");
	                          return false;
	
	--- 340,347 -----
	                  /* must be stderr in case of IO redirect */
	                  c=response=getchar();
	                  while (!(c==EOF || c=='\n')) c=getchar(); /*skip rest*/
	+ 		if ( c == EOF )
	+ 			clearerr(stdin);
	                  if (!(response=='y'||response=='Y')) {
	                          warn("checkout aborted.");
	                          return false;
	*** /tmp/,RCSt1020758	Sat Feb  1 21:13:07 1986
	--- rcs.c	Mon Oct 14 08:46:52 1985
	***************
	*** 928,933
	          fprintf(stdout, "Do you want to break the lock? [ny](n): ");
	          response=c=getchar();
	          while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
	          if (response=='\n'||response=='n'||response=='N') return false;
	  
	          /* go ahead with breaking  */
	
	--- 931,938 -----
	          fprintf(stdout, "Do you want to break the lock? [ny](n): ");
	          response=c=getchar();
	          while (!(c==EOF || c=='\n')) c=getchar();/*skip to end of line*/
	+ 	if ( c == EOF )
	+ 	    clearerr(stdin);
	          if (response=='\n'||response=='n'||response=='N') return false;
	  
	          /* go ahead with breaking  */
	***************
	*** 948,953
	              if ( c == EOF ) {
	                  putc('\n',stdout);
	                  fprintf(mailmess, "%c\n", old1);
	                  break;
	              }
	              else if ( c == '\n' && old1 == '.' && old2 == '\n')
	
	--- 953,959 -----
	              if ( c == EOF ) {
	                  putc('\n',stdout);
	                  fprintf(mailmess, "%c\n", old1);
	+ 		clearerr(stdin);
	                  break;
	              }
	              else if ( c == '\n' && old1 == '.' && old2 == '\n')
	***************
	*** 1397,1402
	                  fprintf(stderr,"Do you really want to delete all revisions ?[ny](n): ");
	  		c = response = getchar();
	  		while( c != EOF && c != '\n') c = getchar();
	                  if ( response != 'y' && response != 'Y') {
	                      diagnose("No revision deleted");
	  		    Delta = delstrt;
	
	--- 1403,1410 -----
	                  fprintf(stderr,"Do you really want to delete all revisions ?[ny](n): ");
	  		c = response = getchar();
	  		while( c != EOF && c != '\n') c = getchar();
	+ 		if ( c == EOF )
	+ 			clearerr(stdin);
	                  if ( response != 'y' && response != 'Y') {
	                      diagnose("No revision deleted");
	  		    Delta = delstrt;
	*** /tmp/,RCSt1020758	Sat Feb  1 21:13:25 1986
	--- rcsgen.c	Mon Oct 14 08:47:13 1985
	***************
	*** 234,241
	                  }
	                  c = '\0'; old2= '\n';
	                  if ((old1=getchar())==EOF && isatty(fileno(stdin)))
	!                      putc('\n',stdout);
	!                 else for (;;) {
	                              c=getchar();
	                              if (c==EOF) {
	                                      if (isatty(fileno(stdin))) putc('\n',stdout);
	
	--- 240,247 -----
	                  }
	                  c = '\0'; old2= '\n';
	                  if ((old1=getchar())==EOF && isatty(fileno(stdin)))
	!                      putc('\n',stdout), clearerr(stdin);
	!                 else if (old1!=EOF) for (;;) {
	                              c=getchar();
	                              if (c==EOF) {
	                                      if (isatty(fileno(stdin))) putc('\n',stdout), clearerr(stdin);
	***************
	*** 238,244
	                  else for (;;) {
	                              c=getchar();
	                              if (c==EOF) {
	!                                     if (isatty(fileno(stdin))) putc('\n',stdout);
	                                      putc(old1,frewrite);
	                                      if (old1!='\n') putc('\n',frewrite);
	                                      break;
	
	--- 244,250 -----
	                  else if (old1!=EOF) for (;;) {
	                              c=getchar();
	                              if (c==EOF) {
	!                                     if (isatty(fileno(stdin))) putc('\n',stdout), clearerr(stdin);
	                                      putc(old1,frewrite);
	                                      if (old1!='\n') putc('\n',frewrite);
	                                      break;

From comay  Sun Feb  2 21:11:14 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25497; Sun, 2 Feb 86 21:11:14 PST
Date: Sun, 2 Feb 86 21:11:14 PST
From: comay (David S. Comay)
Message-Id: <8602030511.AA25497@monet.berkeley.edu>
To: beta43_bugs
Subject: error when making `tags' in lib/libc
Index: 	lib/libc/Makefile 4.3BSD

Description:
	Due to a misplaced `done' statement, a `make tags' causes a
	syntax error.
Repeat-By:
	Either from /usr/src, or from /usr/src/lib/libc, make tags.
Fix:
	*** /tmp/,RCSt1013573	Sun Feb  2 16:19:56 1986
	--- Makefile	Sun Feb  2 16:10:27 1986
	***************
	*** 78,83
	  tags:
	  	for i in ${ALL}; do \
	  		(cd $$i; make ${MFLAGS} TAGSFILE=../${TAGSFILE} tags); \
	  	cd net/${HOSTLOOKUP}; \
	  		make ${MFLAGS} TAGSFILE=../../${TAGSFILE} tags
	  	done
	
	--- 81,87 -----
	  tags:
	  	for i in ${ALL}; do \
	  		(cd $$i; make ${MFLAGS} TAGSFILE=../${TAGSFILE} tags); \
	+ 	done
	  	cd net/${HOSTLOOKUP}; \
	  		make ${MFLAGS} TAGSFILE=../../${TAGSFILE} tags
	  
	***************
	*** 80,86
	  		(cd $$i; make ${MFLAGS} TAGSFILE=../${TAGSFILE} tags); \
	  	cd net/${HOSTLOOKUP}; \
	  		make ${MFLAGS} TAGSFILE=../../${TAGSFILE} tags
	- 	done
	  
	  clean:
	  	for i in ${MACHINE}/csu ${ALL} net/hosttable net/named; \
	
	--- 84,89 -----
	  	done
	  	cd net/${HOSTLOOKUP}; \
	  		make ${MFLAGS} TAGSFILE=../../${TAGSFILE} tags
	  
	  clean:
	  	for i in ${MACHINE}/csu ${ALL} net/hosttable net/named; \

From comay  Sun Feb  2 21:11:25 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA25504; Sun, 2 Feb 86 21:11:25 PST
Date: Sun, 2 Feb 86 21:11:25 PST
From: comay (David S. Comay)
Message-Id: <8602030511.AA25504@monet.berkeley.edu>
To: beta43_bugs
Subject: rcs commands do not work well under bourne shell
Index: 	new/rcs/src/rcsutil.c 4.3BSD

Description:
	While running the bourne shell, put in the background a rcs
	command and then type interrupt.  The rcs command itself will
	be interrupted.
Repeat-By:
	$ ci test.c < /dev/null > errs &
	$ ^C

	as this point, the rcs command will interrupt and print
	something like `RCS: cleaning up'.

Fix:
	The following fix came from one of our heavy rcs users,
	Steve Summit:

	*** /tmp/,RCSt1020758	Sat Feb  1 21:13:31 1986
	--- rcsutil.c	Mon Oct 14 08:47:25 1985
	***************
	*** 182,187
	          exit(1);
	  }
	  
	  void catchints()
	  {
	          signal(SIGINT,catchsig); signal(SIGHUP,catchsig);
	
	--- 186,222 -----
	          exit(1);
	  }
	  
	+ /*
	+  *  Catching signals is tricky.  If a signal was being ignored
	+  *  before RCS even started, it must not be caught.  (The shell
	+  *  sets SIGINT and SIGQUIT to SIG_IGN for background processes. 
	+  *  If RCS turned around and caught them, control-C's in the
	+  *  foreground would kill background RCS processes.)
	+  *
	+  *  intstat, etc. keep track of whether or not it's okay to catch
	+  *  a signal.  If intstat is SIG_DUNNO, we don't know yet if it's
	+  *  safe to catch them.  We temporarily set the signal to
	+  *  SIG_IGN, and if the return value (the previous state of the
	+  *  signal) is something other than SIG_IGN, it's okay to catch
	+  *  this signal, so we set intstat to SIG_OK.  If the return value
	+  *  is SIG_IGN, we shouldn't catch this signal, and intstat is
	+  *  set to SIG_NOCATCH.  (We have just redundantly set the signal
	+  *  to SIG_IGN, but that doesn't matter.)
	+  *
	+  *  Only if intstat (or whatever) ends up being SIG_OK do we turn
	+  *  around and catch the signal again.
	+  *
	+  *						scs 9/20/84
	+  */
	+ 
	+ #define SIG_DUNNO	0
	+ #define SIG_OK		1
	+ #define SIG_NOCATCH	2
	+ 
	+ static int intstat = SIG_DUNNO;
	+ static int hupstat = SIG_DUNNO;
	+ static int quitstat = SIG_DUNNO;
	+ 
	  void catchints()
	  {
	  	if(intstat == SIG_DUNNO)
	***************
	*** 184,191
	  
	  void catchints()
	  {
	!         signal(SIGINT,catchsig); signal(SIGHUP,catchsig);
	!         signal(SIGQUIT,catchsig); signal(SIGPIPE,catchsig);
	  	signal(SIGTERM,catchsig);
	  }
	  
	
	--- 219,243 -----
	  
	  void catchints()
	  {
	! 	if(intstat == SIG_DUNNO)
	! 		intstat = signal(SIGINT, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	if(intstat == SIG_OK)
	! 		signal(SIGINT, catchsig);
	! 
	! 	if(hupstat == SIG_DUNNO)
	! 		hupstat = signal(SIGHUP, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	if(hupstat == SIG_OK)
	! 		signal(SIGHUP, catchsig);
	! 
	! 	if(quitstat == SIG_DUNNO)
	! 		quitstat = signal(SIGQUIT, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	if(quitstat == SIG_OK)
	! 		signal(SIGQUIT, catchsig);
	! 
	! 	signal(SIGPIPE,catchsig);
	  	signal(SIGTERM,catchsig);
	  }
	  
	***************
	*** 189,194
	  	signal(SIGTERM,catchsig);
	  }
	  
	  void ignoreints()
	  {
	          signal(SIGINT,SIG_IGN); signal(SIGHUP,SIG_IGN);
	
	--- 241,260 -----
	  	signal(SIGTERM,catchsig);
	  }
	  
	+ /*
	+  *  In case ignoreints gets called first (I don't think it does;
	+  *  this is known as robust programming) we'd better check
	+  *  intstat et al here as well.  If the status was unknown,
	+  *  better set it.  If it was known and it was SIG_OK, signals
	+  *  might be caught now so we'd better ignore them.  Otherwise,
	+  *  (the status is known and it's SIG_NOCATCH) signals are now
	+  *  being ignored (it was a signal to SIG_IGN that caused the
	+  *  status to be set to SIG_NOCATCH in the first place) and we
	+  *  don't have to bother.
	+  *
	+  *						scs 9/20/84
	+  */
	+ 
	  void ignoreints()
	  {
	  	if(intstat == SIG_DUNNO)
	***************
	*** 191,198
	  
	  void ignoreints()
	  {
	!         signal(SIGINT,SIG_IGN); signal(SIGHUP,SIG_IGN);
	!         signal(SIGQUIT,SIG_IGN); signal(SIGPIPE,SIG_IGN);
	  	signal(SIGTERM,SIG_IGN);
	  }
	  
	
	--- 257,281 -----
	  
	  void ignoreints()
	  {
	! 	if(intstat == SIG_DUNNO)
	! 		intstat = signal(SIGINT, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	else if(intstat == SIG_OK)
	! 		signal(SIGINT, SIG_IGN);
	! 
	! 	if(hupstat == SIG_DUNNO)
	! 		hupstat = signal(SIGHUP, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	else if(hupstat == SIG_OK)
	! 		signal(SIGHUP, SIG_IGN);
	! 
	! 	if(quitstat == SIG_DUNNO)
	! 		quitstat = signal(SIGQUIT, SIG_IGN) != SIG_IGN ?
	! 						SIG_OK : SIG_NOCATCH;
	! 	else if(quitstat == SIG_OK)
	! 		signal(SIGQUIT, SIG_IGN);
	! 
	! 	signal(SIGPIPE,SIG_IGN);
	  	signal(SIGTERM,SIG_IGN);
	  }
	  

From glenn%ivrel@sun.arpa  Mon Feb  3 17:13:11 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA00327; Mon, 3 Feb 86 17:13:11 PST
Received: by ucbvax.berkeley.edu (5.44/1.9)
	id AA03290; Mon, 3 Feb 86 15:40:29 PST
Received: from snail.sun.uucp by sun.arpa (3.0-/SMI-3.0)
	id AA04923; Mon, 3 Feb 86 15:07:21 PST
Received: from ivrel.sun.uucp by snail.sun.uucp (3.0-/SMI-3.0DEV4)
	id AA02706; Mon, 3 Feb 86 15:07:08 PST
Received: by ivrel.sun.uucp (1.1/SMI-3.0DEV3)
	id AA00324; Mon, 3 Feb 86 15:12:51 PST
Date: Mon, 3 Feb 86 15:12:51 PST
From: glenn%ivrel@sun.arpa (Glenn C. Skinner)
Message-Id: <8602032312.AA00324@ivrel.sun.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: MSG_PEEK/rights bug in sys/uipc_socket.c
Cc: glenn@ivrel

Subject: MSG_PEEK bug in soreceive
Index:	/sys/sys/uipc_socket.c 4.3BSD Fix

Description:
	The code in soreceive to handle address and rights information in
	incoming messages fails to advance past this information when the
	receiver has specified MSG_PEEK in the flags field and has asked
	for this information to be returned.

	The code also fails to handle address or rights information that
	spans more than one mbuf, but I don't have a fix handy for this
	problem.
Repeat-By:
	Set up a pair of unix domain datagram sockets and pass access rights
	from one to the other.  Have the recipient peek instead of consuming
	the message.  Observe incorrect behavior.  (Caveat: I haven't actually
	tried this test, but have only examined the code.)
Fix:
	The following context diff illustrates the cure, which consists
	simply of removing an else clause that incorrectly restricts
	advancing past the address or rights information to the case
	where nobody wants a copy of it.

	Line numbers will undoubtedly differ from those of your version.

		-- Glenn Skinner, SMI <glenn@sun> (415) 960-7523

*** /4.3beta/sys/sys/uipc_socket.c	Mon Sep 16 20:53:58 1985
--- uipc_socket.c	Tue Jan 28 19:22:48 1986
***************
*** 468,480 ****
  		if (flags & MSG_PEEK) {
  			if (aname)
  				*aname = m_copy(m, 0, m->m_len);
! 			else
! 				m = m->m_act;
  		} else {
  			if (aname) {
  				*aname = m;
  				sbfree(&so->so_rcv, m);
! if(m->m_next) panic("receive 1b");
  				so->so_rcv.sb_mb = m = m->m_act;
  			} else
  				m = sbdroprecord(&so->so_rcv);
--- 483,495 ----
  		if (flags & MSG_PEEK) {
  			if (aname)
  				*aname = m_copy(m, 0, m->m_len);
! 			m = m->m_act;
  		} else {
  			if (aname) {
  				*aname = m;
  				sbfree(&so->so_rcv, m);
! 				if(m->m_next)
! 					panic("receive 1b");
  				so->so_rcv.sb_mb = m = m->m_act;
  			} else
  				m = sbdroprecord(&so->so_rcv);
***************
*** 486,498 ****
  		if (flags & MSG_PEEK) {
  			if (rightsp)
  				*rightsp = m_copy(m, 0, m->m_len);
! 			else
! 				m = m->m_act;
  		} else {
  			if (rightsp) {
  				*rightsp = m;
  				sbfree(&so->so_rcv, m);
! if(m->m_next) panic("receive 2b");
  				so->so_rcv.sb_mb = m = m->m_act;
  			} else
  				m = sbdroprecord(&so->so_rcv);
--- 501,513 ----
  		if (flags & MSG_PEEK) {
  			if (rightsp)
  				*rightsp = m_copy(m, 0, m->m_len);
! 			m = m->m_act;
  		} else {
  			if (rightsp) {
  				*rightsp = m;
  				sbfree(&so->so_rcv, m);
! 				if(m->m_next)
! 					panic("receive 2b");
  				so->so_rcv.sb_mb = m = m->m_act;
  			} else
  				m = sbdroprecord(&so->so_rcv);
***************

From nsc!chongo@decwrl.DEC.COM  Wed Feb  5 21:15:13 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA15927; Wed, 5 Feb 86 21:15:13 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA25017; Wed, 5 Feb 86 21:13:35 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA19125; Wed, 5 Feb 86 21:03:15 pst
Date: Wed, 5 Feb 86 21:03:15 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Wed, 5 Feb 86 21:03:15 pst
Message-Id: <8602060503.AA19125@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: vaxuba/dmz.c

files.vax has the line:

	vaxuba/dmz.c		optional dmz device-driver

yet such file exists on the 4.3Beta tape.

chongo <> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Wed Feb  5 23:16:06 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA16431; Wed, 5 Feb 86 23:16:06 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA25011; Wed, 5 Feb 86 21:13:25 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA19063; Wed, 5 Feb 86 20:55:34 pst
Date: Wed, 5 Feb 86 20:55:34 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Wed, 5 Feb 86 20:55:34 pst
Message-Id: <8602060455.AA19063@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: kernel file missing

files.vax has the line:

	vaxif/if_vv.c		optional vv device-driver

but no such file was on the Beta release tape.

chongo <> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Thu Feb  6 23:13:23 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA03986; Thu, 6 Feb 86 23:13:23 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA17924; Thu, 6 Feb 86 23:12:00 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA11216; Thu, 6 Feb 86 22:53:16 pst
Date: Thu, 6 Feb 86 22:53:16 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Thu, 6 Feb 86 22:53:16 pst
Message-Id: <8602070653.AA11216@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: FYI: missing kernel files

The directory /usr/src/sys/netpup was missing from the 4.3beta tape.
We don't use (or need) them, but I thought you might like to know in
case someone else does.

chongo <pup-pup> /\pp/\

From nsc!chongo@decwrl.DEC.COM  Fri Feb  7 06:08:42 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA04897; Fri, 7 Feb 86 06:08:42 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA23308; Fri, 7 Feb 86 06:06:48 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA16492; Fri, 7 Feb 86 02:25:11 pst
Date: Fri, 7 Feb 86 02:25:11 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Fri, 7 Feb 86 02:25:11 pst
Message-Id: <8602071025.AA16492@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: Syntax errors in kernel sources

Both vaxif/if_ub.c and vaxif/if_hdh.c give the wrong number of arguments
to the macro:  if_rubaget.

chongo <> /\oo/\

From nsc!chongo@decwrl.DEC.COM  Fri Feb  7 06:09:17 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA04907; Fri, 7 Feb 86 06:09:17 PST
Received: by decwrl.DEC.COM (4.22.01/4.7.34)
	id AA23323; Fri, 7 Feb 86 06:07:23 pst
Received: by nsc.NSC (4.12/6.0.GT)
	id AA16878; Fri, 7 Feb 86 02:44:14 pst
Date: Fri, 7 Feb 86 02:44:14 pst
From: Landon Noll <nsc!nsc!chongo@decwrl.DEC.COM>
Posted-Date: Fri, 7 Feb 86 02:44:14 pst
Message-Id: <8602071044.AA16878@nsc.NSC>
To: 43bugs@decwrl.DEC.COM
Subject: minor error in vaxuba/lpa.c

vaxuba/lpa.c includes ioctl.h which in turn includes ttydev.h which in turn
defines the symbol  DONE  to be the value 0200.  Yet vaxuba/lpa.c later
defines  DONE  to be the value 0100000 causing a 'redefinied symbol' warning
to be generated.

chongo <> /\oo/\

From whm%arizona.csnet@CSNET-RELAY.ARPA  Sat Feb  8 17:47:12 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA11988; Sat, 8 Feb 86 17:47:12 PST
Received: from arizona by csnet-relay.csnet id ae02847; 8 Feb 86 20:39 EST
Received: by arizona.uucp (5.31/3.14)
	id AA19440; Fri, 7 Feb 86 18:36:02 MST
Received: by megaron.arizona.uucp (5.31/3.14)
	id AA10464; Fri, 7 Feb 86 18:36:00 MST
Date: Fri, 7 Feb 86 18:36:00 MST
From: whm@arizona (Bill Mitchell)
Message-Id: <8602080136.AA10464@megaron.arizona.uucp>
To: beta43_sites@monet.berkeley.edu
Subject: Copying an 8600's RL02

I've been trying to make a copy of our RL02 boot pack but I haven't
been having much luck.  The 4.3 I&O document says that the pack can
be copied using dd, and I tried this:

	dd if=/dev/crl of=rl02 ibs=512 obs=512
	[Mounted new RL02]
	dd if=rl02 of=/dev/crl ibs=512 obs=512

"arff tvmf /dev/crl" works just fine and I even went so far as to
extract all the files on both the original RL02 and the copy and
diff them and there were no differences.  I can boot ok from the new
pack, but when I try to a complete power-up sequence, it gets as
far as the console printing "Initializing CPU" and then I get
an MCP error, "no response packet received from CSM".  It then
prints the lines:

	FKCSM020.BPN
	?DP_STAK underflow

repeatedly until interrupted with a control-P.  It's also been known to
print FKCSM017.BPN rather than 020.

It seems that something has been corrupted, but what?  If you believe
arff and diff, the pack that works is identical to the pack that
doesn't work.

I forgot to mention that on the copy from the original pack to the disk,
dd gets an "I/O error", but I supposed that this was due to some sort
of bug in detecting EOF since arff and diff didn't turn up any differences.

Any ideas?  I suppose my basic question is whether the pair of dd's shown
above should get the job done.

					Thanks,
					Bill Mitchell
p.s.
There's some rewriting wierdness at the CSNET relay, so don't reply to
whm@arizona.edu.  Use whm%arizona@csnet-relay or whm%arizona@relay.cs.net.


From bloom  Mon Feb 10 12:26:24 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA01623; Mon, 10 Feb 86 12:26:24 PST
From: bloom (Jim Bloom)
Message-Id: <8602102026.AA01623@monet.berkeley.edu>
To: whm%arizona@relay.cs.net (Bill Mitchell)
Cc: beta43_sites@monet.berkeley.edu
Subject: Re: Copying an 8600's RL02
In-Reply-To: Your message of Fri, 7 Feb 86 18:36:00 MST.
	     <8602080136.AA10464@megaron.arizona.uucp>
Date: 10 Feb 86 12:26:20 PST (Mon)

The error on the first dd is expect after 20480 blocks.  It is a problem
of not detecting the end of the disk and returning the EOF instead of
an error.

The only thing I can think of that you didn't look at on the pack is
the first 6 blocks.  They are not in the filesystem on the rl02.  The
second block is non-critical and may differ without too much of a problem.

Pay particularly close attention to those error printouts.  There may
be a problem in csm020.bpn or csm017.bpn.  You might also talk to DEC
about what the errors mean.

					Jim Bloom

From bloom  Mon Feb 10 12:57:41 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA01623; Mon, 10 Feb 86 12:26:24 PST
From: bloom (Jim Bloom)
Message-Id: <8602102026.AA01623@monet.berkeley.edu>
To: whm%arizona@relay.cs.net (Bill Mitchell)
Cc: beta43_sites@monet.berkeley.edu
Subject: Re: Copying an 8600's RL02
In-Reply-To: Your message of Fri, 7 Feb 86 18:36:00 MST.
	     <8602080136.AA10464@megaron.arizona.uucp>
Date: 10 Feb 86 12:26:20 PST (Mon)

The error on the first dd is expect after 20480 blocks.  It is a problem
of not detecting the end of the disk and returning the EOF instead of
an error.

The only thing I can think of that you didn't look at on the pack is
the first 6 blocks.  They are not in the filesystem on the rl02.  The
second block is non-critical and may differ without too much of a problem.

Pay particularly close attention to those error printouts.  There may
be a problem in csm020.bpn or csm017.bpn.  You might also talk to DEC
about what the errors mean.

					Jim Bloom

From muller@nprdc.arpa  Wed Feb 12 00:46:07 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA10649; Wed, 12 Feb 86 00:46:07 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA21508; Wed, 12 Feb 86 00:45:58 pst
Date: Wed, 12 Feb 86 00:45:58 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8602120845.AA21508@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: nroff bug

Subject: nroff terminal tables broken and incomplete
Index:	usr.bin/nroff/term/code.300 4.3BSD

Description:
	This bug report applies to all nroff terminal tables
	built from code.300, i.e. the -T450 table
	for Diablo Hyterm printers and several others.

	The tables are broken:
		Xi character yields "\b/".
	Several characters which should be printed have null
	definitions, viz:
		square root
		terminal sigma
		root en
		approximates
		down arrow
		cap (intersection)
		subset of
		superset of
		improper subset
		improper superset
		proportional to
		empty set
		member of
	Other characters are not recognizable; they
	do not resemble their typeset image.

Repeat-By:
	Print the distributed character test file, chartst.
	
		nroff -T450 /usr/src/usr.bin/nroff/term/chartest

Fix:
	Revise code.300 as shown by attached contextual diff.
	Remake nroff term tables which depend on code.300.

*** /usr/src/usr.bin/nroff/term/code.300 (4.3bsd) Fri Aug  5 13:36:05 1983
--- code.300	Thu Jan 16 06:58:42 1986 (fixed)
***************
*** 110,117 ****
  "\203ffi",	 /*ffi*/
  "\203ffl",	 /*ffl*/
  "\001\344o\304",	 /*degree*/
! "\001|\b-",	 /*dagger*/
! "\001l\bo",	/* section*/
  "\001'",	 /*foot mark*/
  "\001'",	 /*acute accent*/
  "\001`",	 /*grave accent*/
--- 110,117 ----
  "\203ffi",	 /*ffi*/
  "\203ffl",	 /*ffl*/
  "\001\344o\304",	 /*degree*/
! "\001\342-\302|",	 /*dagger*/
! "\001\342s\302s",	 /*section*/
  "\001'",	 /*foot mark*/
  "\001'",	 /*acute accent*/
  "\001`",	 /*grave accent*/
***************
*** 147,153 ****
  "\001\242/\303-\204-\343\\\242", /*Delta*/
  "\001O\b=", /*Theta*/
  "\001\242/\204\\\242", /*Lambda*/
! "\001\\b/",	 /*Xi*/
  "\001\242[]\204[]\242\343-\303", /*Pi*/
  "\001\200>\302-\345-\303", /*Sigma*/
  "\000\0",	 /**/
--- 147,153 ----
  "\001\242/\303-\204-\343\\\242", /*Delta*/
  "\001O\b=", /*Theta*/
  "\001\242/\204\\\242", /*Lambda*/
! "\001\341_\346_\307-",	/*Xi*/
  "\001\242[]\204[]\242\343-\303", /*Pi*/
  "\001\200>\302-\345-\303", /*Sigma*/
  "\000\0",	 /**/
***************
*** 155,202 ****
  "\001o\b[\b]", /*Phi*/
  "\001\200[]-\302\202'\244`\202\342", /*Psi*/
  "\001\200O\302\241-\202-\241\342", /*Omega*/
! "\000\0",	 /*square root*/
! "\000\0",	 /*terminal sigma*/
! "\000\0",	 /*root en*/
  "\001>\b_",	 /*>=*/
  "\001<\b_",	 /*<=*/
  "\001=\b_",	 /*identically equal*/
  "\001-",	 /*equation minus*/
  "\001=\b~",	 /*approx =*/
! "\000\0",	 /*approximates*/
  "\001=\b/",	 /*not equal*/
! "\002->",	 /*right arrow*/
! "\002<-",	 /*left arrow*/
  "\001|\b^",	 /*up arrow*/
! "\000\0",	 /*down arrow*/
  "\001=",	 /*equation equal*/
  "\001x",	 /*multiply*/
! "\001/",	 /*divide*/
  "\001+\b_",	 /*plus-minus*/
  "\001U",	 /*cup (union)*/
! "\000\0",	 /*cap (intersection)*/
! "\000\0",	 /*subset of*/
! "\000\0",	 /*superset of*/
! "\000\0",	 /*improper subset*/
! "\000\0",	 /* improper superset*/
! "\002oo",	 /*infinity*/
  "\001\200o\201\301`\241\341`\241\341`\201\301", /*partial derivative*/
  "\001\242\\\343-\204-\303/\242", /*gradient*/
  "\001\200-\202\341,\301\242", /*not*/
  "\001\200|'\202`\243\306'\241`\202\346",	/*integral sign*/
! "\000\0",	 /*proportional to*/
! "\000\0",	 /*empty set*/
! "\000\0",	 /*member of*/
  "\001+",	 /*equation plus*/
! "\001r\bO",	 /*registered*/
! "\001c\bO",	 /*copyright*/
  "\001|",	 /*box rule */
  "\001c\b/",	 /*cent sign*/
! "\001|\b=",	 /*dbl dagger*/
! "\002=>",	 /*right hand*/
! "\002<=",	 /*left hand*/
  "\001*",	 /*math * */
! "\000\0",	 /*bell system sign*/
  "\001|",	 /*or (was star)*/
  "\001O",	 /*circle*/
  "\001|",	 /*left top (of big curly)*/
--- 155,202 ----
  "\001o\b[\b]", /*Phi*/
  "\001\200[]-\302\202'\244`\202\342", /*Psi*/
  "\001\200O\302\241-\202-\241\342", /*Omega*/
! "\002-\242\304`\202\344/",	 /*square root*/
! "\001\341s\301\203`\243",	 /*terminal sigma*/
! "\001\343-\303",	 /*root en*/
  "\001>\b_",	 /*>=*/
  "\001<\b_",	 /*<=*/
  "\001=\b_",	 /*identically equal*/
  "\001-",	 /*equation minus*/
  "\001=\b~",	 /*approx =*/
! "\001\301~\341",   /*approximates*/
  "\001=\b/",	 /*not equal*/
! "\002 \245-\204->\201",	 /*right arrow*/
! "\002 \245<-\204-\201",	 /*left arrow*/
  "\001|\b^",	 /*up arrow*/
! "\001\301v\341|",	 /*down arrow*/
  "\001=",	 /*equation equal*/
  "\001x",	 /*multiply*/
! "\001\200.\341-\343.\304",	 /*divide*/
  "\001+\b_",	 /*plus-minus*/
  "\001U",	 /*cup (union)*/
! "\001\242|\202^\202|\242",	 /*cap (intersection)*/
! "\002 \242\245(\341\204_\346_\203\307",	/*subset of*/
! "\002 \243\341_\346_\307\204)\241",	/*superset of*/
! "\002 \242\245(\341\204_\346_\307_\203",	/*improper subset of*/
! "\002 \243_\341_\346_\307\204)\241",	/*improper superset of*/
! "\002o\242o\202",	 /*infinity*/
  "\001\200o\201\301`\241\341`\241\341`\201\301", /*partial derivative*/
  "\001\242\\\343-\204-\303/\242", /*gradient*/
  "\001\200-\202\341,\301\242", /*not*/
  "\001\200|'\202`\243\306'\241`\202\346",	/*integral sign*/
! "\002o\242c\202",	 /*proportional to*/
! "\0010\b/",	 /*empty set*/
! "\001\200(\201\341-\301\241",	 /*member of*/
  "\001+",	 /*equation plus*/
! "\003(r)",	 /*registered*/
! "\003(c)",	 /*copyright*/
  "\001|",	 /*box rule */
  "\001c\b/",	 /*cent sign*/
! "\001\341=\301|",	 /*dbl dagger*/
! "\002*>",	 /*right hand*/
! "\002<*",	 /*left hand*/
  "\001*",	 /*math * */
! "\003(b)",	 /*bell system sign*/
  "\001|",	 /*or (was star)*/
  "\001O",	 /*circle*/
  "\001|",	 /*left top (of big curly)*/


From muller@nprdc.arpa  Wed Feb 12 00:46:51 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA10660; Wed, 12 Feb 86 00:46:51 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA21512; Wed, 12 Feb 86 00:46:35 pst
Date: Wed, 12 Feb 86 00:46:35 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8602120846.AA21512@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: another nroff bug

Subject: nroff table for NEC 7725/5525
Index:	usr.bin/nroff/term/tabnecmath.c 4.3BSD

Description:
	The nec-t nroff terminal table for NEC printers does not work
	for the NEC 7725/5525 models.  These printers employ Diablo
	escape sequences (NEC refers to the printers as "Diablo
	replacements").  A special table (attached) is required for the
	7725/5525 models when using the "Times Roman/Technical Math"
	print thimble.

	We have refered to this table locally as -Tnecmath
	a name more consistent with other table names
	might be (-Tnec25-t?).

Repeat-By:
	Run nroff with input requiring half-line motion on
	a model NEC model 7725 using -Tnec-t; the escape
	sequences print as garbage.

		echo "\u2\d" | nroff -Tnec-t
	
Fix:
	Use the following terminal table in place of tabnec-t.c:

----------------------- cut here ------------------------------
#define INCH 240
/*
NEC Spinwriter 7725 and 5525 (Diablo replacements)
with Technical Math/Times Roman thimble
12 chars/inch, 6 lines/inch
nroff driving tables
width and code tables
*/

struct {
	int bset;
	int breset;
	int Hor;
	int Vert;
	int Newline;
	int Char;
	int Em;
	int Halfline;
	int Adj;
	char *twinit;
	char *twrest;
	char *twnl;
	char *hlr;
	char *hlf;
	char *flr;
	char *bdon;
	char *bdoff;
	char *ploton;
	char *plotoff;
	char *up;
	char *down;
	char *right;
	char *left;
	char *codetab[256-32];
	int zzz;
	} t = {
/*bset*/	0,
/*breset*/	0177420,
/*Hor*/		INCH/60,
/*Vert*/	INCH/48,
/*Newline*/	INCH/6,
/*Char*/	INCH/12,
/*Em*/		INCH/12,
/*Halfline*/	INCH/12,
/*Adj*/		INCH/12,
/*twinit*/	"\0334\033\037\013",
/*twrest*/	"\0334\033\037\015",
/*twnl*/	"\015\n",
/*hlr*/		"\033D",
/*hlf*/		"\033U",
/*flr*/		"\033\n",
/*bdon*/	"",
/*bdoff*/	"",
/*ploton*/	"\0333",
/*plotoff*/	"\0334",
/*up*/		"\033\n",
/*down*/	"\n",
/*right*/	" ",
/*left*/	"\b",
/*codetab*/
"\001 ",	/*space*/
"\001!",	/*!*/
"\002\200\047\202\047",	/*"*/
"\001#",	/*#*/
"\001\200|\341S\301",	/*$*/
"\001%",	/*%*/
"\000",	/*&*/
"\001'",	/*' close*/
"\001(",	/*(*/
"\001)",	/*)*/
"\001*",	/***/
"\001+",	/*+*/
"\001,",	/*,*/
"\001-",	/*- hyphen*/
"\001.",	/*.*/
"\001/",	/*/*/
"\2010",	/*0*/
"\2011",	/*1*/
"\2012",	/*2*/
"\2013",	/*3*/
"\2014",	/*4*/
"\2015",	/*5*/
"\2016",	/*6*/
"\2017",	/*7*/
"\2018",	/*8*/
"\2019",	/*9*/
"\001:",	/*:*/
"\001:\b,",	/*;*/
"\001<",	/*<*/
"\001=",	/*=*/
"\001>",	/*>*/
"\001?",	/*?*/
"\001@",	/*@*/
"\201A",	/*A*/
"\201B",	/*B*/
"\201C",	/*C*/
"\201D",	/*D*/
"\201E",	/*E*/
"\201F",	/*F*/
"\201G",	/*G*/
"\201H",	/*H*/
"\201I",	/*I*/
"\201J",	/*J*/
"\201K",	/*K*/
"\201L",	/*L*/
"\201M",	/*M*/
"\201N",	/*N*/
"\201O",	/*O*/
"\201P",	/*P*/
"\201Q",	/*Q*/
"\201R",	/*R*/
"\201S",	/*S*/
"\201T",	/*T*/
"\201U",	/*U*/
"\201V",	/*V*/
"\201W",	/*W*/
"\201X",	/*X*/
"\201Y",	/*Y*/
"\201Z",	/*Z*/
"\001[",	/*[*/
"\001\016\112\017",	/*\*/
"\001]",	/*]*/
"\001\344.\201\341.\201\301.\242\304",	/*^*/
"\001_",	/*_ dash*/
"\001'",	/*` open*/
"\201a",	/*a*/
"\201b",	/*b*/
"\201c",	/*c*/
"\201d",	/*d*/
"\201e",	/*e*/
"\201f",	/*f*/
"\201g",	/*g*/
"\201h",	/*h*/
"\201i",	/*i*/
"\201j",	/*j*/
"\201k",	/*k*/
"\201l",	/*l*/
"\201m",	/*m*/
"\201n",	/*n*/
"\201o",	/*o*/
"\201p",	/*p*/
"\201q",	/*q*/
"\201r",	/*r*/
"\201s",	/*s*/
"\201t",	/*t*/
"\201u",	/*u*/
"\201v",	/*v*/
"\201w",	/*w*/
"\201x",	/*x*/
"\201y",	/*y*/
"\201z",	/*z*/
"\001{",	/*{*/
"\001|",	/*|*/
"\001}",	/*}*/
"\001\343\016\074\017\303",	/*~*/
"\000\0",	/*narrow sp*/
"\001-",	/*hyphen*/
"\001O\b+",	/*bullet*/
"\002\[]",	/*square*/
"\001-",	/*3/4 em*/
"\001_",	/*rule*/
"\2031/4",	/*1/4*/
"\2031/2",	/*1/2*/
"\2033/4",	/*3/4*/
"\001-",	/*minus*/
"\202fi",	/*fi*/
"\202fl",	/*fl*/
"\202ff",	/*ff*/
"\203ffi",	/*ffi*/
"\203ffl",	/*ffl*/
"\001\343o\303",	/*degree*/
"\001\342-\302|",	/*dagger*/
"\001\342s\302s",	/*section*/
"\001'",	/*foot mark*/
"\001'",	/*acute accent*/
"\001\345.\201\301.\201\304",	/*grave accent*/
"\001_",	/*underrule*/
"\001/",	/*slash (longer)*/
"\000\0",	/*half narrow space*/
"\001 ",	/*unpaddable space*/
"\001\016\123\017",	/*alpha*/
"\001\046",	/*beta*/
"\001\016\107\017",	/*gamma*/
"\001\016\113\017",	/*delta*/
"\001\016\116\017",	/*epsilon*/
"\001\200c\201\301,\241\343<\302",	/*zeta*/
"\001\016\114\017",	/*eta*/
"\001O\b-",	/*theta*/
"\001i",	/*iota*/
"\001k",	/*kappa*/
"\001\016\102\017",	/*lambda*/
"\001\073",	/*mu*/
"\001\241(\203/\242",	/*nu*/
"\001\016\104\017",	/*xi*/
"\001o",	/*omicron*/
"\001\042",	/*pi*/
"\001\016\106\017",	/*rho*/
"\001\016\126\017",	/*sigma*/
"\001\016\103\017",	/*tau*/
"\001v",	/*upsilon*/
"\001o\b/",	/*phi*/
"\001x",	/*chi*/
"\001\200/-\301\202'\244'\202\341",	/*psi*/
"\001\016\130\017",	/*omega*/
"\001\242|\202\344-\304\342\202'\242\302",	/*Gamma*/
"\001\016\101\017",	/*Delta*/
"\001O\b=",	/*Theta*/
"\002/\242\016\112\017\202",	/*Lambda*/
"\001\341_\346_\307\341-\301",	/*Xi*/
"\001\242[]\204[]\242\343-\303",	/*Pi*/
"\001\341>\301\302-\346-\304\241",	/*Sigma*/
"\000\0",	/**/
"\001Y",	/*Upsilon*/
"\001o\b[\b]",	/*Phi*/
"\001\200[]-\301\202'\244'\202\341",	/*Psi*/
"\001\134",	/*Omega*/
"\001\301-\341\202\303'\202\343/\244",	/*square root*/
"\001\341s\301\202'\242",	/*terminal sigma*/
"\001\343-\303",	/*root en*/
"\001>\b_",	/*>=*/
"\001<\b_",	/*<=*/
"\001=\b_",	/*identically equal*/
"\001-",	/*equation minus*/
"\001=\b\344\016\074\017\304",	/*approx =*/
"\001\016\074\017",	/*approximates*/
"\001=\b/",	/*not equal*/
"\002 \245-\204->\201",	/*right arrow*/
"\002 \245<-\204-\201",	/*left arrow*/
"\001\016\132\017",	/*up arrow*/
"\001\016\136\017",	/*down arrow*/
"\001=",	/*equation equal*/
"\001x",	/*multiply*/
"\001\200.-\345.\305",	/*divide*/
"\001+\b_",	/*plus-minus*/
"\001U",	/*cup (union)*/
"\001\343\140\203\136\243\303",	/*cap (intersection)*/
"\002 \242\245\341(\301\341\204_\346_\203\307",	/*subset of*/
"\002 \243\341_\346_\307\204\341)\301\241",	/*superset of*/
"\002 \242\245\341(\301\341\204_\346_\307_\203",	/*improper subset of*/
"\002 \243_\341_\346_\307\341\204)\301\241",	/*improper superset of*/
"\001\016\137\017",	/*infinity*/
"\001\016\115\017",	/*partial derivative*/
"\001\200\016\112\017\203/\243\344\201-\201-\304\242",	/*gradient*/
"\001\200-\202\343,\303\242",	/*not*/
"\001\044",	/*integral sign*/
"\001\016\135\017",	/*proportional to*/
"\0010\b/",	/*empty set*/
"\001\200(\201-\241",	/*member of*/
"\001+",	/*equation plus*/
"\003(r)",	/*registered*/
"\003(c)",	/*copyright*/
"\001|",	/*box rule */
"\001c\b/",	/*cent sign*/
"\001\341=\301|",	/*dbl dagger*/
"\002*>",	/*right hand*/
"\002<*",	/*left hand*/
"\001*",	/*math * */
"\003(b)",	/*bell system sign*/
"\001|",	/*or (was star)*/
"\001O",	/*circle*/
"\001|",	/*left top (of big curly)*/
"\001|",	/*left bottom*/
"\001|",	/*right top*/
"\001|",	/*right bot*/
"\001|",	/*left center of big curly bracket*/
"\001|",	/*right center of big curly bracket*/
"\001|",	/*bold vertical*/
"\001\201\016\076\017\241",	/*left floor (left bot of big sq bract)*/
"\001\241\016\100\017\201",	/*right floor (right bot ")*/
"\001\201\140\241",	/*left ceiling (lt of ")*/
"\001\241\136\201"};	/*right ceiling (rt of ")*/

From joel@isi-venera.arpa  Wed Feb 12 08:33:25 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA12892; Wed, 12 Feb 86 08:33:25 PST
Received: by isi-venera.arpa (5.31/1.2)
	id AA02935; Wed, 12 Feb 86 08:34:50 PST
Date: Wed 12 Feb 86 08:34:49-PST
From: "Joel Goldberger" <JOEL@isi-venera.arpa>
Subject: TCP connections in FIN_WAIT_2
To: beta43_bugs@monet.berkeley.edu
Cc: Joel@isi-venera.arpa
Message-Id: <VAX-MM(171)+TOPSLIB(113) 12-Feb-86 08:34:49.ISI-VENERA.ARPA>

We are running 4.3 Beta on our 8600 connected only to 10MBit Ether and
get a number of TCP connections that stay in FIN_WAIT_2 forever.  Is there
a fix for this ?

- Joel Goldberger -
-------

From chris@mimsy.umd.edu  Thu Feb 13 20:25:59 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA07732; Thu, 13 Feb 86 20:25:59 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA24384; Thu, 13 Feb 86 23:25:29 EST
Date: Thu, 13 Feb 86 23:25:29 EST
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8602140425.AA24384@mimsy.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: quiz Middle-Earth capital does not accept a correct answer

Index: /usr/games/quiz 4.3Beta

Description:
	The quiz database does not accept `Minas Anor' as the capital
	of Gondor.  Minas Anor was the name of Minas Tirith before
	the fall of Minas Ithil (later Minas Morgul).

Repeat-By:
	% quiz Middle-Earth capital
	...

Incidentally, there is a proper name for the City of the Corsairs
as well; I cannot remember it, but I can probably find it later.

Chris

From chris@gyre.umd.edu  Fri Feb 14 01:22:03 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA08408; Fri, 14 Feb 86 01:22:03 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA00328; Fri, 14 Feb 86 04:20:34 EST
Date: Fri, 14 Feb 86 04:20:34 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602140920.AA00328@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: rcmd could use some rewriting
Cc: chris@gyre.umd.edu

I got to thinking about the rlogin timing problem (which, by the
way, does seem to hit occasionally, even on Vaxen) and I decided
that the best way to fix it would be to fiddle with rcmd().  The
thing to do, I think, is to add a routine in the same file that
looks like this:

	char *
	remcmd(s, ahost, rport, locuser, remuser, cmd, serr)
		int s;
		char *ahost;
		int rport;
		char *locuser, *remuser, *cmd;
		int *serr;

where s and *serr are the sockets for the connection and for stderr,
respectively, already bound to local addresses (via rresvport);
serr may be NULL to indicate that no error socket is desired.  The
return value of the function is the error message, or NULL for
none.  rcmd() then becomes:

int
rcmd(ahost, rport, locuser, remuser, cmd, fd2p)
	char **ahost;
	int rport;
	char *locuser, *remuser, *cmd;
	int *fd2p;
{
	int s, lport = IPPORT_RESERVED - 1;
	char *err;

	if ((s = rresvport(&lport)) < 0) {
		if (errno == EAGAIN)
			fprintf(stderr, "socket: All ports in use\n");
		else
			perror("rcmd: socket");
		return (-1);
	}
	if (fd2p != NULL) {
		lport--;
		if ((*fd2p = rresvport(&lport)) < 0) {
			(void) close(s);
			return (-1);
		}
	}
	err = remcmd(s, ahost, rport, locuser, remuser, cmd, fd2p);
	if (err) {
		(void) close(s);
		if (fdp2)
			(void) close(*fd2p);
		fprintf(stderr, "%s\n", err);
		return (-1);
	}
}

That leaves remcmd() the task of creating error messages, of course;
but it does make the interface for servers that use one of a set
of hosts much nicer: they no longer produce error messages for
hosts that are down.  The code for remcmd() itself is obvious,
given the existing rcmd().

Incidentally, I do not understand what `retry' is doing in the
current rcmd()---the socket `s' should be safe from EADDRINUSE
errors since it is neither listening nor SO_REUSEADDR'ed.  rconnect()
as above does not do anything sensible if that error really does
occur.  The timeout retry makes a certain amount of sense, but
is buggy (it fails to close the socket `s'), and probably does
not belong in that routine.

----

The other option that I see is to define a new rcmd() (call it
remcmd() or whatever you like) that again takes one more argument,
but this time a pointer to a function.  The function would be called
for each socket before connect()ing, and would allow the caller to
set options and pgroups and whatnot.  I suppose the function should
get two arguments, one the socket itself and the other true iff
the first is the stderr socket.  Again, the implementation for
rcmd() is obvious (but this time the darn printf()s are still in
there---perhaps yet another option to get rid of them?!?).

(Somehow I keep suspecting that I am overlooking something simple....)

Chris

From chris@gyre.umd.edu  Fri Feb 14 01:38:56 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA08519; Fri, 14 Feb 86 01:38:56 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA00380; Fri, 14 Feb 86 04:38:57 EST
Date: Fri, 14 Feb 86 04:38:57 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602140938.AA00380@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Speaking of rcmd()...

Index: /usr/src/lib/libc/net/rcmd.c 4.3Beta++ Fix

Description:
	_checkhost is not portable.

Repeat-By:
	Inspection (or try it on a PR1ME, if you can find one).

Fix:
	What is this (char *)1 business anyway?  It hardly seems
	worthwhile.  quotaon and quotaoff have the same strangeness,
	assuming (char *)NULL + 1 == (char *)1 and all.

Chris

*** rcmd.c.bak	Fri Feb 14 04:31:04 1986
--- rcmd.c	Fri Feb 14 04:35:48 1986
***************
*** 232,260 ****
  {
  	static char ldomain[MAXHOSTNAMELEN + 1];
! 	static char *domainp = NULL;
  	register char *cp;
  
  	if (len == -1)
! 		return(!strcmp(rhost, lhost));
  	if (strncmp(rhost, lhost, len))
! 		return(0);
  	if (!strcmp(rhost, lhost))
! 		return(1);
  	if (*(lhost + len) != '\0')
! 		return(0);
! 	if (!domainp) {
  		if (gethostname(ldomain, sizeof(ldomain)) == -1) {
! 			domainp = (char *)1;
! 			return(0);
  		}
  		ldomain[MAXHOSTNAMELEN] = NULL;
! 		if ((domainp = index(ldomain, '.') + 1) == (char *)1)
! 			return(0);
! 		cp = domainp;
  		while (*cp)
  			*cp++ = isupper(*cp) ? tolower(*cp) : *cp;
  	}
! 	if (domainp == (char *)1)
! 		return(0);
! 	return(!strcmp(domainp, rhost + len +1));
  }
--- 232,264 ----
  {
  	static char ldomain[MAXHOSTNAMELEN + 1];
! 	static char *domainp;
! 	static int nodomain;
  	register char *cp;
  
  	if (len == -1)
! 		return (!strcmp(rhost, lhost));
  	if (strncmp(rhost, lhost, len))
! 		return (0);
  	if (!strcmp(rhost, lhost))
! 		return (1);
  	if (*(lhost + len) != '\0')
! 		return (0);
! 	if (nodomain)
! 		return (0);
! 	if (domainp == 0) {
  		if (gethostname(ldomain, sizeof(ldomain)) == -1) {
! 			nodomain++;
! 			return (0);
  		}
  		ldomain[MAXHOSTNAMELEN] = NULL;
! 		if ((cp = index(ldomain, '.')) == 0) {
! 			nodomain++;
! 			return (0);
! 		}
! 		cp++;
! 		domainp = cp;
  		while (*cp)
  			*cp++ = isupper(*cp) ? tolower(*cp) : *cp;
  	}
! 	return (!strcmp(domainp, rhost + len + 1));
  }

From mcvax!dpk@seismo.CSS.GOV  Fri Feb 14 10:29:28 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA10278; Fri, 14 Feb 86 10:29:28 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Fri, 14 Feb 86 12:40:26 EST
Received: from gigue.cwi.nl (gigue.uucp) by mcvax.uucp; Fri, 14 Feb 86 13:35:40 +0100 (MET)
Date:     Fri, 14 Feb 86 13:29:05 MET
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.berkeley.edu
Cc: karels@monet.berkeley.edu
Subject:  ifconfig -down doesn't always work
Message-Id:  <8602141329.a016927@gigue.mcvax.UUCP>

ifconfig -down does not seem to suceed in stopping usage of the
device if you are the Superuser.  Specifically, if you ifconfig
the interface down than then try to use ping, ping will succeed.

Thoughts?

-Doug-

From chris@gyre.umd.edu  Fri Feb 14 21:40:22 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA13882; Fri, 14 Feb 86 21:40:22 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03579; Sat, 15 Feb 86 00:39:02 EST
Date: Sat, 15 Feb 86 00:39:02 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602150539.AA03579@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: adb can get blown away by a reserved operand fault

Index: /usr/src/bin/adb/format.c 4.3Beta fix

Description:
	A reserved operand float value will crash adb when printed.

Repeat-By:
	Compile the following program:

		int x,x2[2];main(){x=0x8000;x2[0]=0x8000;abort();}

	Run it with adb `:r', then type `x/f' or `x2/F'.  Blammo.

Fix:
	(From watmath!arwhite, edited to match adb style) below.
	This includes another change that keeps repeat counts that
	evaluate to zero from doing some harm (just what I do not
	know, and he did not remember).

Chris

RCS file: RCS/format.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1003520	Sat Feb 15 00:31:37 1986
--- /tmp/,RCSt2003520	Sat Feb 15 00:31:39 1986
***************
*** 61,64 ****
--- 61,65 ----
  			OD
  			fp--;
+ 			IF fcount==0 THEN fcount = 1; FI
  		ELSE fcount = 1;
  		FI
***************
*** 217,221 ****
  			fw = 0;
  			fw.sa = wx;
! 			printf("%-16.9f", fw);
  			dotinc=4; break;
  
--- 218,225 ----
  			fw = 0;
  			fw.sa = wx;
! 			IF (wx & ~0xFFFF00FF) == 0x8000
! 			THEN printf("(reserved oprnd)");
! 			ELSE printf("%-16.9f", fw);
! 			FI
  			dotinc=4; break;
  
***************
*** 222,226 ****
  		    case 'F':
  			fw.sa = wx;
! 			printf("%-32.18F", fw);
  			dotinc=8; break;
  
--- 226,233 ----
  		    case 'F':
  			fw.sa = wx;
! 			IF (wx & ~0xFFFF00FF) == 0x8000
! 			THEN printf("%-32s", "(reserved oprnd)");
! 			ELSE printf("%-32.18F", fw);
! 			FI
  			dotinc=8; break;
  

From chris@gyre.umd.edu  Fri Feb 14 21:47:41 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA13903; Fri, 14 Feb 86 21:47:41 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03598; Sat, 15 Feb 86 00:46:03 EST
Date: Sat, 15 Feb 86 00:46:03 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602150546.AA03598@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: adb `$C' and `$c' do the same thing

Index: /usr/src/bin/adb/print.c 4.3Beta Fix

Description:
	Since adb no longer knows about local symbols, $C prints no
	locals.  This is a pain, especially when debugging kernels.

Repeat-By:
	Run adb.

Fix:
	(Again from watmath!arwhite.  I have been going through
	some of my `to do' stuff.  This dates from March 1984....
	Again, I have edited it to try to preserve the `Bourne
	style', much as I dislike that.)

	The change given below makes adb print registers and some
	local variables (it will not print all of a large array, or
	many locals, though).  While not ideal, it does provide
	some of the functionality now missing.

	I will follow up with a change to adb.1 to reflect the $C
	format.

Chris

RCS file: RCS/print.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1003520	Sat Feb 15 00:31:45 1986
--- /tmp/,RCSt2003520	Sat Feb 15 00:31:49 1986
***************
*** 254,258 ****
  		return;
  
! 	    case 'c': case 'C':
  		IF adrflg
  		THEN	frame=adrval;
--- 254,268 ----
  		return;
  
! 	    case 'c': case 'C': {
! 		L_INT regs[12], *q;
! 		REGPTR p;
! 		ADDR stackp, a;
! 		int i, j, k, l;
! 
! 		/* get current registers */
! 		q = &regs[12];
! 		FOR p = &reglist[12]; p < &reglist[24]; p++
! 		DO *--q = kcore ? *p->rkern : *(ADDR *)(((ADDR)&u)+p->roffs);
! 		OD
  		IF adrflg
  		THEN	frame=adrval;
***************
*** 271,274 ****
--- 281,285 ----
  			FI
  			callpc=get(frame+16,DSP);
+ 			stackp=argp;	/* don't know */
  		ELIF kcore
  		THEN	argp = pcb.pcb_ap;
***************
*** 275,281 ****
--- 286,294 ----
  			frame = pcb.pcb_fp;
  			callpc = pcb.pcb_pc;
+ 			stackp = pcb.pcb_ksp;
  		ELSE	argp= *(ADDR *)(((ADDR)&u)+AP);
  			frame= *(ADDR *)(((ADDR)&u)+FP);
  			callpc= *(ADDR *)(((ADDR)&u)+PC);
+ 			stackp= *(ADDR *)(((ADDR)&u)+USP);
  		FI
  		lastframe=0;
***************
*** 326,329 ****
--- 339,383 ----
  					FI
  				OD
+ 				printf("fp: %X%15tap: %X%30tsp:  %X\n",
+ 				    frame, argp, stackp);
+ 				/* print current registers */
+ 			    printf("r0: %X%15tr1: %X%30tr2:  %X%45tr3:  %X\n",
+ 				regs[0], regs[1], regs[2], regs[3]);
+ 			    printf("r4: %X%15tr5: %X%30tr6:  %X%45tr7:  %X\n",
+ 				regs[4], regs[5], regs[6], regs[7]);
+ 			    printf("r8: %X%15tr9: %X%30tr10: %X%45tr11: %X\n",
+ 				regs[8], regs[9], regs[10], regs[11]);
+ 				/* get next frame's registers */
+ 				i = get(frame+4, DSP);
+ 				i >>= 16; i &= 0xfff;/* register mask */
+ 				FOR j=1,k=0,l=0; (j&0x1000)==0; j<<=1,k++
+ 				DO	IF i&j
+ 					THEN regs[k]=get(frame+20+l++*4, DSP);
+ 					FI
+ 				OD
+ 				/* print the current frame's auto variables */
+ 				/* i.e., -4(sp) -> (sp) */
+ #define MAXPRINT 30		/* max # of auto words to print */
+ 				a = stackp;
+ 				IF frame - MAXPRINT*4 > stackp
+ 				THEN stackp = frame - MAXPRINT * 4;
+ 				FI
+ 				FOR i = frame-4; i > stackp; i -= 4
+ 				DO	printf("%X: %X(fp):%20t%X\n",
+ 					    i, i-frame, get(i, DSP));
+ 				OD
+ 				IF a != stackp
+ 				THEN	printf("%X: %X(fp) .. %X: %X(fp) %s\n",
+ 					    i, i-frame, a, a-frame,
+ 					    "not displayed");
+ 				FI
+ 				/* calculate the previous frame's sp */
+ 				/* 5 <=> 0, psw, ap, fp, pc; plus saved regs */
+ 				stackp = frame + (5+l)*4;
+ 				i = get(frame+4, DSP);
+ 				stackp += (i >> 30) & 3;/* stack alignment */
+ 				IF i & (1<<29)/* 'calls', add on arg space */
+ 				THEN stackp+=(get(frame+20+l*4, DSP)&0xff)*4;
+ 				FI
  			FI
  
***************
*** 339,342 ****
--- 393,397 ----
  		OD
  		break;
+ 	    }
  
  	    /*print externals*/

From chris@gyre.umd.edu  Fri Feb 14 22:07:50 1986
Received: by monet.berkeley.edu (5.44/1.8)
	id AA13937; Fri, 14 Feb 86 22:07:50 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03749; Sat, 15 Feb 86 01:05:56 EST
Date: Sat, 15 Feb 86 01:05:56 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602150605.AA03749@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: After installing $C, man adb is wrong

Index: /usr/man/man1/adb.1 4.3Beta+last_change Fix

Description:
	Of course, when updating the program one must update the
	manuals....

Repeat-By:
	man adb

Fix:
	Below

Chris

RCS file: RCS/adb.1,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1003733	Sat Feb 15 01:04:59 1986
--- /tmp/,RCSt2003733	Sat Feb 15 01:05:04 1986
***************
*** 601,606 ****
  .B C 
  is used then the names and (32 bit) values of all automatic
! and static variables are printed for each active function. (broken
! on the VAX).  If
  .I count
  is given then only the first
--- 601,607 ----
  .B C 
  is used then the names and (32 bit) values of all automatic
! and static variables are printed for each active function.  (On the
! VAX, this is broken; instead, all the registers and the
! first 32 stack values are printed.)  If
  .I count
  is given then only the first

From karels  Mon Feb 17 19:12:03 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA07133; Mon, 17 Feb 86 19:12:03 PST
From: karels (Mike Karels)
Message-Id: <8602180312.AA07133@monet.berkeley.edu>
To: beta43_sites
Cc: allmanagers@ucbvax
Cc: ferrari@ernie, graham@arpa
Subject: changes since 4.3 beta release
Date: Mon, 17 Feb 86 19:11:58 -0800

Hello.  As indicated earlier, I am sending out an update list with information
about changes of various types made here since the 4.3BSD beta release.
Some of you have already updated your systems to reflect many of these
changes (especially the Berkeley sites receiving sources from calder!).
This message is an invitation to all interested beta sites to acquire
and install these changes for testing during the last few weeks before
the final release.  As you have varying degrees of access to Berkeley
and/or to the Internet, I will wait to see if any of you who plan
to install and test this have problems getting to it.  If it helps,
I can leave stuff out for anonymous ftp; uucp is more problematical.
It would be helpful if you would send me a status update as you upgrade
and test these changes.  Also, I would like to know which drivers
each site has tested.

Obviously, this list is incomplete and some of the categories overlap.
Several of the changes depend on others, especially on kernel or library
changes.  If you have problems installing something, look for related
areas on the list.

Changes in the network since the beta release

There have been numerous but small changes in the networking code
since the beta test began.  Most of these changes address particular
problems or observations made by the beta sites, and a few are small
fixes that didn't make the cutoff for the beta tape.
As many of these affect the same files, I'll list the files together
at the end.

TCP: code was added to maintain estimates of the peer's send and receive
    buffer sizes.  The former is not yet used, but is desired for a new
    delayed-acknowledgement scheme that has not yet been tested.  However,
    it was discussed with Bob Walsh in July, and we concluded that it was
    worth testing.  The peer's receive buffer size had to be estimated
    in order to avoid performance problems when that size was very small
    (e.g., the peer is a TAC or an IBM PC).  The sender silly-window syndrome
    avoidance code had been improved in 4.3, but worked poorly if the window
    was never as much as 512.  The send policy will now send if the offered
    window is at least one-half of the receiver's buffer, as well as when
    the window is at least a full-sized segment or it can send all of the
    data that has been queued.  One other change also needed to be made
    for the TAC.  The TAC doesn't fill in the window field on its initial
    packet (SYN), and the apparent window is random.  There is some question
    as to the validity of the window field if the packet does not have ACK
    set, and therefore TCP was changed to ignore the window information
    on those packets.

    Other changes to the send policy: the Nagle algorithm of small-
    packet avoidance for telnet-like connections caused problems
    for the X window system, which sends mouse-tracking information
    in small packets.  As there is no echo or response, this interacts
    badly with the delayed acknowledgement (only one packet will be
    sent each 200 milliseconds).  An option was added to suppress
    the small-packet avoidance on a connection.  Also, a fix was made
    to the Nagle algorithm code to send all of the data if it amounts
    to one or more full packets plus a small remainder.  This is desirable
    to avoid slowing down mail, etc., which exhibit this behavior
    but are not the small-packet offenders that are targetted.

    Minor fixes:  The initial sequence number prototype for TCP is now
    being incremented much more quickly, which exposed two bugs.
    Both the window-update receiving code and the urgent data receiving
    code compared sequence numbers to 0 the first time they were called
    on a connection.  This fails if the initial sequence number has
    wrapped around to negative numbers.  Both were initialized
    when the connection was set up.  This still remains a problem
    in compatibility with 4.2 systems, which have both problems.
    Therefore, I added an #ifdef COMPAT_42 to restart sequence numbers
    from 0 when they reach 2^31.

    A bug in handling TCP packets received with both data and options
    (which are not supposed to be used) has been corrected.  The advertised
    window is never allowed to shrink, in correspondence with the earlier
    change in the input handler.  The retransmit code was changed to
    check for shrinking windows, updating the connection state rather
    than timing out waiting for acknowledgement.  The input handler
    was modified to know when it needed to call the output side,
    reducing unnecessary tests for acknowlegement-only packets
    and, with other fixes above, breaking a loop that occasionally
    occurred in a connection through the loopback interface.
    Routing failures due to out-of-date routes created by redirects
    cause the old routes to be deleted before retrying.
    Finally, the retransmission code has been tuned, using a faster
    backoff after the first retransmission.  On an initial connection
    request where there is no round-trip time estimate, a much more
    conservative policy is used.
files: /sys/netinet/tcp_{input,output,timer,usrreq,subr}.c
     /sys/netinet/tcp{,_var,_timer,_seq}.h

IP: IP has been changed to recognize and accept network broadcasts
    as well as subnet broadcasts when subnets are enabled.  Such broadcasts
    normally originate from hosts that do not know about subnets.
    IP also accepts old-style (4.2) broadcasts using a host part of all
    zeros, either as network or subnet broadcast.  An address of all ones
    is recognized as "broadcast on this network," and an address of all
    zeros is accepted as well.  The latter two are sometimes used in
    broadcast information requests or network mask requests in the course
    of starting a diskless workstation.  Raw IP sockets may now use IP
    options, including source routing.
files: /sys/netinet/{in_var.h,in_proto.c,ip_input.c,raw_ip.c}
    /sys/net/{raw_cb.h,raw_cb.c,raw_usrreq.c}

general Internet changes:
    Route cache management has been moved from the upper level protocols
    (UDP, raw) to IP, and use of DONTROUTE on raw IP sockets was fixed.
    Ports greater than IPPORT_USERRESERVED (5000) are reserved for
    servers, which need not be privileged.
files: /sys/netinet/{in.h,in_pcb.c,ip_output.c,upd_usrreq.c,raw_ip.c}
    
ICMP:
    ICMP code to reverse source routes was fixed and simplified.
files: /sys/netinet/ip_icmp.c

UDP:
    The UDP time-to-live was reduced from 255 to 15, and the definition
    was placed in the header file.  The #ifdef COMPAT_42 used by TCP
    also disables UDP checksum checking, for use during conversion
    of a network from 4.2 to 4.3, as vanilla 4.2 calculated UDP
    checksums incorrectly.
files: /sys/netinet/{udp_var.h,udp_usrreq.c}

ARP: The address resolution protocol has been generalized a bit.
    It was specific for IP on 10 Mb/s Ethernet; it now handles multiple
    protocols on 10 Mb/s Ethernet and could easily be adapted to other
    hardware as well.  This change was made while adding ARP resolution
    of trailer protocol addresses.  Hosts desiring to receive trailer
    encapsulations must now indicate that by the use of ARP, and allows
    trailers to operate between cooperating 4.3 machines while using
    non-trailer encapsulations with other hosts.  The negotiation need
    not be symmetrical: a Vax may request trailers, for example,
    and a SUN may note this and send trailer packets to the Vax without
    itself requesting trailers.  Arp now uses the most recent address
    translation heard, so that caches may be invalidated without timing
    out, and arp rejects the ethernet broadcast address as legitimate
    host address.
files: /sys/netinet/if_ether.[ch] /sys/net/if_arp.h
	/usr/src/etc/arp.c
    
Unix domain and socket layer:
    The datagram queuing routines and access rights code have
    been modified to link all of the buffers from one packet
    onto one chain rather than three.  This makes it faster
    to find the end of a queue, and makes it possible to distinguish
    access rights and data sent in two separate datagrams
    from two sent at once.  In order to test one previously unused
    routine, the Unix domain stream connections were modified
    to support the passage of access rights.  Problems with access-rights
    garbage collection were also noted and fixed, and a count is kept
    of rights outstanding so that garbage collection is done only when
    needed.  Garbage collection is triggered by socket shutdown now
    rather than file close, as it was previously run prematurely.

    The binding and connection of Unix domain sockets has
    been cleaned up so that "recvfrom" and "accept" get the address 
    of the peer if bound rather than their own.

    Socket buffers ("sockbufs") have been modified to use unsigned short
    rather than short integers for character counts and mbuf counts.
    This increases the maximum buffer size to 64K-1.  These fields
    should really be unsigned longs, but a socket would no longer fit
    in an mbuf.  Next time...

    The connect routine will now try to disconnect a connected socket
    before reconnecting.  This is only allowed if the protocol itself
    is not connection oriented.  Datagram sockets may connect to specify
    a default destination, then later connect to another destination
    or to a null destination to disconnect.  Also, a failed attempt
    to connect returns the error once only, so that additional
    connect calls may be attempted.

    Both the pipe and socketpair system calls could lose network buffers
    if the user had run out of file descriptors.  Both have been corrected
    to free the partially set up socket properly after failure.

    A "getsockopt" call has been added to determine the type of a socket
    (eg, SOCK_STREAM, SOCK_DGRAM), and to collect any outstanding error
    status.  Select on a socket for reading or writing returns true
    if there is error status pending.
files: /sys/h/{socket.h,socketvar.h,unpcb.h}, /sys/sys/kern_descrip.c,
    /sys/sys/uipc_{domain.c,proto.c,socket*.c,syscalls.c,usrreq.c}

routing:
    The interface to the rtinit routine was changed to allow
    deletion of routes to hosts, so that when changing the address of
    a point-to-point interface, the old route can be deleted.
files: /sys/net/route.d /sys/netinet/in.c, /sys/netns/ns.c

Xerox NS:
    Numerous changes and fixes: route caching, retransmit and oob bugs
    fixed, tracing, more good stuff.
files: /sys/netns/*

Interface layer:
    There is now a metric per interface in the ifnet structure.
    Ioctl's were added to set and get this metric.  It is unused
    by the kernel, but is used by routed as its metric.  As its
    metric is simply hop counts, with 0 the normal for an attached
    interface, this makes it possible to weight interfaces differently,
    in particular to mark paths as "secondary" to favor other routes.
    A flag has been added to distinguish the software loopback interface.
files: /sys/net/{if.h,if.c,if_loop.c},
    /usr/src/etc/{ifconfig/ifconfig.c,routed/startup.c}

network drivers:
    The acc driver was fixed to round up the size of the receive buffer,
    fixing a longstanding bug.  A typo in the css driver was corrected.
    The il, ex and de drivers were taught how to reprogram the hardware
    Ethernet address for Xerox NS.  The Unibus support routines were
    changed to allow reading from a transmit buffer, even if the
    transmit buffer was remapped.  This fixes the problem seen with the
    DEUNA driver, gradually corrupting its buffers if trailers are
    enabled and broadcasts use trailers.  10Mb/s Ethernet drivers print
    their hardware addresses during autoconfiguration; they also reset
    the hardware upon an "ifconfig -down" and reinitialize upon
    "ifconfig -up".  A driver has been added for the Interlan NP100 (as
    a "dumb" Ethernet interface).  The Proteon if_vv driver was
    missing, and it has been replaced and updated.  The hdh driver was
    updated for 4.3.  The Ungerman- Bass driver if_ub.c was deleted as
    useless.  The 3Mb/s Ethernet driver was coerced into undersatnding
    Xerox NS packets.
files: /sys/vaxif/if_{uba.[ch],acc.c,css.c,en.c,ex.c,de.c,il.c,ec.c,hdh.c,vv.c}
    /sys/vaxif/if_ix.[ch] /sys/vaxuba/np{.c,reg.h}
    /usr/src/new/np100/*


Changes in the other parts of the kernel

header files, misc:
    User and group id's have been changed from short to uid_t and gid_t
    (both unsigned short) where ever possible.  All structures including
    these now use the typedefs.  The calls accepting single uid's or gid's
    ore returning them have also been specified in terms of these typedefs.
    Getgroups and setgroups still use arrays of integers, however,
    for compatibility.  The BSD definitions in param.h were modified
    somewhat: BSD4_3 is defined as 1, so that #if works, and BSD
    was redefined as 43 rather than 4.3, so that arithmetic
    comparisons work.  Certain signal and errno definitions were
    added for SysV compatibility. Macros were added to syslog.h
    for masks as used by setlogmask.  Setreuid was changed to maintain
    the effective uid in p_uid, making it consistent with other usage.
    Select was changed to not modify the masks if interrupted or other
    errors occur, but always otherwise.  A reserved range of system
    calls for vendors was added, and syscalls.c was brought into sync
    with init_sysent.c.  Syscall 63 is no longer used internally.
files: /sys/h/{types,acct,inode,prod,stat,user}.h
    /sys/h/{ioctl.h,param.h,signal.h} /sys/sys/{kern_prot.c,sys_generic.c}
    /sys/sys/{init_sysent.c,syscalls.c} /sys/vax/trap.c

filesystem:
    A bug in the interaction of the filesystem with the virtual memory
    system was fixed.  Although the high-level write code was careful
    to flush modified pages from the virtual-memory text page cache,
    a page might be moved in reallocating a fragment, implicitly
    modifying the pages in earlier fragments in the block.
    It is no longer necessary to log out and in again after reducing
    ones block allocation below the soft limit before being able
    to allocate space again.
files: /sys/sys/{ufs_alloc.c,ufs_bmap.c,quota_ufs.c}

text table:
    The text table is now managed differently.  Unused entries are treated
    as a cache, similar to the usage of the inode table.  Entries with
    reference counts aof 0 are placed in an LRU cache for potential reuse.
    In effect, all texts are "sticky".  The sticky bit works actually works
    as before, preventing entries from being freed and in effect locking
    files into the cache.  The code to prevent modification of running
    texts was cleaned up by keeping a pointer to any text entry in the
    inode, allowing texts to be freed when unlinking files without linear
    searches.
files: /sys/h/{inode,text}.h
    /sys/sys/{vm_text.c,init_main.c,kern_exec.c,sys_process.c}
    /usr/src/ucb/vmstat.c

Virtual memory:
    Configuration parameters and other segment size limits were
    converted from pages to bytes.  Also, the swap code was changed
    to handle errors a bit better (swapout doesn't do swkill's, just
    reflects errors to the caller for action there).  At process exit,
    interrupts are blocked for less time due to freeing the pages
    of the user structure (cf. XXX hack memory interlock).
files: /sys/sys/{kern_resource,vm_swap,vm_page,vm_pt,vm_sched}.c
    /sys/vax/{vmparam.h,vm_machdep.c}

Terminal and pseudo-terminal changes:
    I got tired of modifying terminal drivers to make the modem control
    code do the same things, and also needed to fix cleanup problems
    in the pty code when the controller closed.  For these reasons,
    the tty modem control code was removed from the tty drivers and placed
    in the tty common code, accessed using the previously unused l_modem
    entry in the linesw.  Also, the line-discipline close routines
    and ttyclose (called at final close) have been separated.
    This avoids problems with closedown of berknet or bulk-data type
    line disciplines that overlay the clist queues.  The pty driver,
    which must make assumptions about the queues, has been changed to
    disallow non-standard line disciplines for now.  In a related
    change, an entry in the tty code was added to allow the tty
    highwater mark to be checked, preventing uprintf and tprintf from
    consuming all of the clists when errors recur; uprint now sleeps,
    and tprintf only logs the message.

    Selecting for exceptional conditions now works on pty's in funny
    modes (PKT, REMOTE, UPKT).  The autoconfiguration of dmf's has
    been corrected; there a few outstanding problems with the DMF driver
    which are unresolved.  The (originally missing) dmz driver has been
    cleaned up a bit more, but will probably be replaced with the Ultrix
    version or merged with the dmf driver.  The serial-line IP discipline
    (from Rick Adams, via Chris Torek) has been added.  (anyone have a man
    page for this?)  It should have the performance changes from Kirk Smith
    added; I have this outlined on paper, and will probably install them
    later.  The two tablet disciplines were merged and their ioctls were
    moved to a new include file.
files: /sys/sys/{init_main.c,tty.c,tty_pty.c,tty_conf.c}
    /sys/vaxuba/{dh,dhu,dz,dmf,dmz}.c
    /sys/h/{ioctl.h,tablet.h},/sys/sys/tty_tb.c
    /sys/net/if_sl.c /sys/dist/MAKEDEV /sys/conf/files /sys/conf/files.vax
    /usr/src/etc/slattach.c /usr/man/man8/slattach.8c

timestamps:
    The microtime routine was updated and enabled, and is now used
    in gettimeofday and ip_time to previde microsecond- (millisecond-)
    resolution timestamps.  Adjtime was corrected to prevent oscillation
    around zero if an adjustment was not a multiple of tickadj.
files: /sys/vax/machdep.c,/sys/sys/kern_time.c,/sys/netinet/ip_icmp.c

massbus disks:
    The massbus routines were changed to avoid a problem when restarting
    a tranfer after an error: the mba common code hadn't been modified
    to know that the transfer was being started from the middle.
files: /sys/vaxmba/{mbavar.h,mba.c,hp.c}

misc. driver changes:
    The ECC code in the idc driver for the 730 was fixed.  The kgclock
    probe routine was missing its return value.  A new PS2 driver was
    installed.  The tape drivers return more intelligent error codes
    when opens fail, especially if already in use.  The partition
    sizes in the uda driver were brought into line with the other disk
    drivers, and 4.2 compatible partitions were made optional.
    Bugs in buffered-data-path handling in the uda driver have been
    exterminated, and a patchable variable was added to control
    its DMA burst size.  (Now, if I only knew what to set it to!)
    Diskpart and disktab were taught which drives use bad-sector forwarding.
    An inconsistency between the ts-11 driver and the uba buffered-data-path
    handling was corrected; it behaved wrong when using an odd memory
    address and a buffered data path.  Several drivers omitted the
    null termination for the list of standard addresses: dhu.c, dh.c, dn.c,
    lp.c, uu.c.
files: /sys/vaxuba/{idc.c,kgclock.c,ps.c,tm.c,ut.c,ts.c,uda.c}
    /sys/vaxuba/{dhu.c,dh.c,dn.c,lp.c,uu.c
     /sys/vaxmba/{ht,mt}.c
     /sys/dist/disktab, /usr/include/disktab.h, /usr/src/lib/libc/gen/disktab.c,
     /usr/src/etc/diskpart.c

    A TU81 driver was received from DEC for release:
files: /sys/vaxuba/{tmscpreg.h,tmscp.c} /sys/vax/{cond.c,tmscp.h}
    /sys/h/mtio.h /sys/conf/files.vax

Autoconfiguration:
    A bug in coniguration of 2 SBI's on an 8600 was fixed.  (Still haven't
    tested configuration of adaptors on the second SBI.)
files: /sys/vax/autoconf.c

Changes in standalone programs and drivers:
    The skip-sector handling in the formatter was discovered to be
    totally nonfunctional and has been fixed.  The formatter was modified
    to allow formatting ranges of tracks rather than just entire disks.
    The standalone drivers were cleaned up a bit, allowing more flexible
    use by the formatter.  The hp bootstrap was discovered to be too
    large, and unneeded routines were removed for the second-stage
    bootstraps.  The read routine was changed to do direct DMA for block-
    sized reads rather than copying one character per subroutine call.
    The makefile now checks dependencies.  Changes to the block 0
    and second stage bootstraps to allow 750's to boot from units other
    than 0 may soon be installed.
files:/sys/stand/{format.c,boot.c,sys.c,hp.c,hp.old.c,hpmaptype.c,up.c}
    /sys/stand/{bootxx.c,saio.h,savax.h,srt0.c,Makefile}


Changes in user programs:

This section is skeletal at best.  There have been a large number of small
fixes, most of which are not listed here.  I have attempted only to list
the more important or useful changes, or those which I would like to have
others test.

C library:
    Stdio has been changed to be a bit more friendly to programs that want
    to do their own memory management.  It does not make calls on malloc
    until the first twenty files have been opened, and a new entry point
    has been provided (f_prealloc()) to preallocate all of the memory
    that might ever be needed for file structures and internal data
    structures.  Puts and fputs were changed to be compatible with
    files opened for reading and writing.  Malloc has several bug fixes.
    Two standard address translation routines were added for NS.
    The "longjmp botch" handling was moved to a separate file so that
    it may be trapped.
files: /usr/src/lib/libc/stdio/{findiop.c,filbuf.c,puts.c,fputs.c}
    /usr/src/lib/libc/gen/malloc.c
    /usr/src/lib/libc/vax/gen/{setjmp.s,_setjmp.s,setjmperr.c}

network utilities:
    Netstat has been cleaned up to format more nicely and correspond
    with reality.  The route command works better with the nameserver:
    it tries multiple addresses before failing, and tries not to depend
    on the nameserver unnecessarily (so it will work before starting
    the nameserver if numeric addresses are given).  Major work
    was done on ftp, including making aborts work, adding passive mode,
    etc.  A new version of tftp was installed from guyton@rand-unix.
    Routed was fixed to handle out-of-range address families more
    gracefully, without depending on the kernel's AF_MAX.
files: /usr/src/ucb/netstat/{route.c,if.c,unix.c,Makefile,host.c}
    /usr/src/etc/{route.c,ifconfig/ifconfig.c}
    /usr/src/etc/ftp/{ftpd.c,Makefile,ftpcmd.y} /usr/src/ucb/ftp/*
    /usr/src/etc/tftpd/{Makefile,tftpd.c} /usr/src/ucb/tftp/*
    /usr/man/{man1/ftp.1c,man8/ftpd.8c}
    /usr/src/etc/routed/{startup.c,af.h,af.c,if.c,main.c,tables.c,
       interface.h,timer.h,Makefile,tools/query.c,tools/trace.c}
compiler fixes:
	/usr/src/lib/cpp/cpp.c
	/usr/src/lib/pcc/{table.c,order.c,local2.c}
	/usr/src/lib/mip/{trees.c,pftn.c,optim.c,allo.c}
	/usr/src/lib/c2/c21.c
	/usr/src/usr.bin/lint/{macdefs.h,lint.c}
	/usr/src/usr.bin/f77/f77.c
	/usr/src/usr.bin/f77/src/f77pass1/{defs.h,gram.dcl,gram.expr,gram.exec,
		proc.c,stab.c,regalloc.c,misc.c,lex.c,io.c,expr.c,exec.c}

various programs use /etc/shells as list of acceptable shells:
    /usr/src/lib/libc/gen/getusershell.c,/usr/src/bin/passwd.c,
various minor modifications and bug fixes:

getty: /usr/src/etc/getty/{init.c,gettytab.h,subr.c,main.c,gettytab}
	/usr/man/man5/gettytab.5
named: numerous changes; recently released to BIND mailing list members
XNSrouted: /usr/src/etc/XNSrouted/*.[ch]
arff: works on 8600 RL02's: /usr/src/etc/arff.c
dmesg: bug fixes: /usr/src/etc/dmesg.c
syslogd.c: bug fixes: /usr/src/etc/syslogd.c
dump: speedups: /usr/src/etc/dump/{dumpmain.c,dumptraverse.c,dumprmt.c}
	/usr/src/etc/rmt.c
config: fixes: /usr/src/etc/config/{main.c,Makefile,mkmakefile.c}
telnetd: fixes, try multiple addresses: /usr/src/{etc/telnetd.c,ucb/telnet.c}
rwhod: performance: /usr/src/etc/rwhod.c
rlogin: notify about flushes faster, don't flush if not necessary:
	/usr/src/etc/rlogind.c,/usr/src/ucb/rlogin.c
bad144: fixes: /usr/src/etc/bad144.c
ex: fixes: /usr/src/ucb/ex/{ex_tagio.c,ex_unix.c,expreserve.c,Makefile}
dbx: /usr/src/ucb/dbx/{check.c,fortran.c,runtime.c,Makefile}
	/usr/man/man1/dbx.1
compress: fix: /usr/src/etc/compress/compress.c
Mail: fixes:
	/usr/src/ucb/Mail/{aux.c,names.c,list.c,lex.c,def.h,optim.c,Makefile}
tn3270: new version: /usr/src/ucb/tn3270/*
finger: bug fixes: /usr/src/ucb/finger.c
diff: fixes: /usr/src/bin/diff/{diffreg.c,diffh.c}
sh: fix # as comment only from script, security: /usr/src/bin/sh/{name.c,word.c}
csh: changes to filename completion ("nobeep"), nice made relative:
	/usr/src/bin/csh/{sh.file.c,sh.time.c,sh.sem.c,sh.proc.c}
	/usr/src/bin/nice.c
make: fixes: /usr/src/bin/make/{main.c,files.c,misc.c,defs}
write: fixes: /usr/src/bin/write.c
chgrp: fix security botch with -R: /usr/src/bin/chgrp.c
stty: "stty size": /usr/src/bin/stty.c
login: various fixes: /usr/src/bin/login.c
rm: no errors from rm -f, use MAXPATHLEN: /usr/src/bin/rm.c
ld: minor fixes: /usr/src/bin/ld.c
date: cleanup, don't complain if network not on: /usr/src/bin/date.c
timed: fixes: /usr/src/etc/timed/*
termcap: various additions and corrections: /usr/src/etc/termcap/tercap.src
inetd: allow "stream wait" type, handle more sockets: /usr/src/etc/inetd.c
-me, -man macros: troff and ditroff versions merged:
	/usr/lib/tmac/tmac.{e,an.new}
curses: bug fixes: /usr/src/usr.lib/libcurses/{overlay.c,curses.c,cr_tty.c,
	getch.c,clrtobot.c,move.c}
uucp: version of the week: /usr/src/usr.bin/uucp/*
tip: new commands, ability to unlock without world-writable uucp dir:
	/usr/src/usr.bin/tip/{tip.h,tip.c,cu.c,cmds.c,remote.c,hunt.c,
	    uucplock.c,cmdtab.c,acu.c,Makefile}
sendmail: final version of experimental version of beta tape:
	/usr/src/usr.lib/sendmail/* (from monet /nbsd only!!!)
lpr: updated logging, fixes: /usr/src/usr.lib/lpr/{Makefile,recvjob.c,
    printjob.c,lprm.c,lpr.c,lpq.c,lpd.c,lpc.c,displayq.c,pac.c,filters/vplotf.c}
imagen plot stuff: /usr/src/usr.lib/plot/{imagen/*,Makefile,driver.c}
	/usr/man/man1/plot.1g
mh: We are testing mh6.2 with major performance work now; mh6.3 is on its way.
	/usr/src/new/mh

From glenn%ivrel@SUN.ARPA  Wed Feb 19 16:16:43 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA01897; Wed, 19 Feb 86 16:16:43 PST
Received: from snail.sun.uucp by sun.arpa (3.2-/SMI-3.0)
	id AA03163; Wed, 19 Feb 86 16:14:24 PST
Received: from ivrel.sun.uucp by snail.sun.uucp (3.2-/SMI-3.0DEV4)
	id AA12297; Wed, 19 Feb 86 16:13:07 PST
Received: by ivrel.sun.uucp (1.1/SMI-3.0DEV3)
	id AA01570; Wed, 19 Feb 86 16:16:37 PST
Date: Wed, 19 Feb 86 16:16:37 PST
From: glenn%ivrel@SUN.ARPA (Glenn C. Skinner)
Message-Id: <8602200016.AA01570@ivrel.sun.uucp>
Subject: argument missing to sodisconnect call in soconnect
Index: 	/sys/sys/uipc_socket.c 4.3BSD FIX
Cc: glenn@ivrel

Description:
	Sodisconnect takes two arguments, but the call to it on line 229
	of uipc_socket.c (in soconnect()) supplies only one.
Repeat-By:
	N.A.
Fix:
	Change the line in question from:

  	if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
  	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
- 	    (error = sodisconnect(so))))
  		error = EISCONN;
  	else

	to:

  	if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
  	    ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
+ 	    (error = sodisconnect(so, nam))))
  		error = EISCONN;
  	else


From whm%arizona.csnet@CSNET-RELAY.ARPA  Thu Feb 20 01:44:04 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA04744; Thu, 20 Feb 86 01:44:04 PST
Received: from arizona by csnet-relay.csnet id a008065; 20 Feb 86 4:39 EST
Received: by arizona.arizona; Thu, 20 Feb 86 01:08:08 MST
Date: Thu, 20 Feb 86 01:08:04 MST
From: Bill Mitchell <whm%arizona.csnet@CSNET-RELAY.ARPA>
Message-Id: <8602200808.AA05854@megaron.arizona>
Received: by megaron.arizona; Thu, 20 Feb 86 01:08:04 MST
To: beta43_bugs@monet.berkeley.edu
Subject: Bugs in dmesg.c and chgrp.c; Q's about csh

monet:/usr/src/etc/dmesg.c won't compile.  The variable omsgbuf is undeclared.
The apparent fix is s/omsgbuf/omesg/ or vice-versa.

In chgrp.c, the format %s in:

	default:
		fatal(255, "unknown option: %s", *cp);

should be %c as *cp is a char, not a char *.  (Try chgrp -r.)

I note that 4.3 csh has filename completion, but it doesn't seem to work
on the command name as the csh mods distributed on net in the days of 4.1.
Also, "nobeep" is handy, but it would be nice if it used a visual bell if
available.


From lepreau  Mon Feb 24 05:01:31 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA12671; Mon, 24 Feb 86 05:01:31 PST
Date: Mon, 24 Feb 86 05:01:31 PST
From: lepreau (Jay Lepreau)
Message-Id: <8602241301.AA12671@monet.berkeley.edu>
To: beta43_bugs
Subject: getuid() et al and uid_t/gid_t

Was changing all the system and library calls to take and return uid_t
and gid_t instead of int a good idea?  It sure causes a lot of lint
complaints in zillions of programs.  Couldn't just change the typedef in
types.h for the u struct and leave the calls alone?  Also, right now
getpwuid and getgrgid still take int's.

From joel@isi-venera.arpa  Mon Feb 24 09:17:39 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA14086; Mon, 24 Feb 86 09:17:39 PST
Received: by isi-venera.arpa (5.31/1.2)
	id AA19050; Mon, 24 Feb 86 09:19:14 PST
Date: Mon 24 Feb 86 09:19:13-PST
From: "Joel Goldberger" <JOEL@isi-venera.arpa>
Subject: Getting changed files for 4.3
To: Karels@monet.berkeley.edu, beta43_bugs@monet.berkeley.edu
Cc: Joel@isi-venera.arpa
Message-Id: <VAX-MM(171)+TOPSLIB(113) 24-Feb-86 09:19:13.ISI-VENERA.ARPA>

Mike (et al),

How can I get the changed files for 4.3 Beta over the Internet ?

I couldn't find them on UCBARPA where we have a guest account.

Thanks,
Joel Goldberger
-------

From salkind@nyu.arpa  Tue Feb 25 06:26:26 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA21999; Tue, 25 Feb 86 06:26:26 PST
Date: Tue, 25 Feb 86 09:28:03 est
From: salkind@nyu.arpa (Lou Salkind)
Message-Id: <8602251428.AA16773@nyu.arpa>
Received: by nyu.arpa; Tue, 25 Feb 86 09:28:03 est
To: beta43_bugs@monet.berkeley.edu
Subject: minor bug in hosttable/Makefile

In /usr/src/lib/libc/net/hosttable/Makefile, change
	@echo "building normal netlib"
to
	@echo "building normal hostlib"

-- Lou

PS:  Did you get my note about notes?

From comay  Wed Feb 26 08:10:23 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA07283; Wed, 26 Feb 86 08:10:23 PST
Date: Wed, 26 Feb 86 08:10:23 PST
From: comay (David S. Comay)
Message-Id: <8602261610.AA07283@monet.berkeley.edu>
Subject: tip hayes driver doesn't work with some so-called hayes-compatibles
Index: 	usr.bin/tip/aculib/hayes.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	on at least one so-called hayes compatible modem (a robotics),
	the hayes driver fails to work because

		1. the command to turn off verbose status reports
		(ATv0) does not work (the appropriate command for the
		robotics is ATV0.) apparently the robotics wants the
		whole command capitalized.

		2. the driver assumes the modem is in echo mode (this
		is documented in the driver), however the robotics
		always starts out in no-echo mode.  normally this is
		switch selectable, but there is no such switch on the
		robotics.
Repeat-By:
	after adding an appropriate entry in /etc/remote, try using the
	command `tip <phonenumber>'.  eventually, the driver will time
	out.
Fix:
	since the hayes does not care what case the command is in (with
	the exception of the AT prefix), we can fix (1) my simply
	capitalizing the command character.  i don't know whether
	other so-called hayes compatibles care about the case of the
	command character.  if they do, perhaps a driver for just the
	robotics should be made from the hayes driver.

	the fix to (2) is to first send an `ATE1' command to turn on
	echo.  since we do not know what state we started in, we don't
	know what the response will be so we sleep a second and then
	throwaway whatever response we received.  we then proceed with
	turning off verbose mode just like the original driver.

	finally, while i was capitalizing all the AT commands, i
	noticed when tip is closing a connection, it turns verbose mode
	back on with ATV1.  probably a better choice would be to sent
	ATZ, which resets the modem into whatever state is specified by
	the switch setting.

*** /tmp/,RCSt1026081	Wed Feb 26 07:15:30 1986
--- /tmp/,RCSt2026081	Wed Feb 26 07:15:32 1986
***************
*** 61,66
  #ifdef ACULOG
  	char line[80];
  #endif
  	if (hay_sync() == 0)		/* make sure we can talk to the modem */
  		return(0);
  	if (boolean(value(VERBOSE)))

--- 61,67 -----
  #ifdef ACULOG
  	char line[80];
  #endif
+ 	int len;
  	if (hay_sync() == 0)		/* make sure we can talk to the modem */
  		return(0);
  	if (boolean(value(VERBOSE)))
***************
*** 68,74
  	fflush(stdout);
  	ioctl(FD, TIOCHPCL, 0);
  	ioctl(FD, TIOCFLUSH, 0);	/* get rid of garbage */
! 	write(FD, "ATv0\r", 5);	/* tell modem to use short status codes */
  	gobble("\r");
  	gobble("\r");
  	write(FD, "ATTD", 4);	/* send dial command */

--- 69,79 -----
  	fflush(stdout);
  	ioctl(FD, TIOCHPCL, 0);
  	ioctl(FD, TIOCFLUSH, 0);	/* get rid of garbage */
! 	write(FD, "ATE1\r", 5);
! 	sleep(1);
! 	ioctl(FD, FIONREAD, &len);
! 	(void) read(FD, dumbuf, min(len, DUMBUFLEN));
! 	write(FD, "ATV0\r", 5);	/* tell modem to use short status codes */
  	gobble("\r");
  	gobble("\r");
  	write(FD, "ATTD", 4);	/* send dial command */
***************
*** 238,244
  		dumbuf[rlen] = '\0';
  		printf("read (%d): %s\r\n", rlen, dumbuf);
  #endif
! 		write(FD, "ATv1\r", 5);
  		sleep(1);
  #ifdef DEBUG
  		ioctl(FD, FIONREAD, &len);

--- 243,249 -----
  		dumbuf[rlen] = '\0';
  		printf("read (%d): %s\r\n", rlen, dumbuf);
  #endif
! 		write(FD, "ATZ\r", 5);
  		sleep(1);
  #ifdef DEBUG
  		ioctl(FD, FIONREAD, &len);

From karels  Wed Feb 26 14:50:11 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA08360; Wed, 26 Feb 86 12:52:41 PST
From: karels (Mike Karels)
Message-Id: <8602262052.AA08360@monet.berkeley.edu>
To: beta43_sites
Cc: allmanagers@ucbvax
Subject: more changes
Date: Wed, 26 Feb 86 12:52:37 PST

Here's the message for which several of you have been waiting.
As promised, I have created a tar file containing the files listed in
my set of changes.  It also includes the things mentioned below.
A compressed copy of the tar image is available by anonymous ftp from
ucbarpa.berkeley.edu from the file /pub/4.3/update/tar.Z.2.
Note that the directories leading to this file are unreadable,
but the file is readable.  The compressed file is 3.8 Mb.  As it is large,
perhaps we can coordinate copying, with some sites redistributing it
to other nearby sites (e.g. ISI and Rand, MIT, BRL and other east
coast sites, etc.).  The tar image after decompression is 9.4Mb.
The complete list of files is attached here, courtesy of Jordan Hubbard.


A few additions to last Monday's list, of rather recent origin:

The code to share unibus allocations among the various terminal multiplexors
didn't handle Unibus resets properly.  This was fixed last week.
files: /sys/vaxuba/{dh.c,dhu.c,dmf.c,dmz.c}

The ubaerror routine was confused by having time set backwards,
and would reset a unibus adaptor unnecessarily.  Unsigned arithmetic
to the rescue.
files: /sys/vaxuba/{ubavar.h,uba.c}

The previous changes to ARP eliminated the need to place the local
address in the ARP tables.  The prevents Ethernet interfaces from
sending IP packets to themselves (which only happens when the loopback
is not enabled).  For what it's worth, this has been corrected.
file: /sys/netinet/if_ether.c

New bug: if a mount is attempted of an already-mounted filesystem,
the device close was called and any buffers in the the buffer cache
were invalidated.  If the filesystem had been modified, it would
be left in an inconsistent state.  This has been fixed.
file: /sys/sys/ufs_mount.c

While changing if_sl to use mbuf clusters for buffers, I realized that
there was no way to free mbuf clusters except when associated with an mbuf.
As I was never fond of having the internal details of this visible,
I changed the MCLGET macro to take a single argument, an mbuf to which
a cluster should be added.  This is similar to Sun's mclget() routine
except that the macro implementation prevents the use of a return value.
Of course, all of the MCLGET users have been modifed accordingly.
files: /sys/h/mbuf.h, /sys/sys/uipc_socket.c, /sys/vaxif/if_{uba.c,ec.c}
	/sys/net/if_sl.c

Config now constructs a separate file containing magic definitions
used in counting and naming device interrupts.
files: /usr/src/etc/config/{Makefile,mkglue.c,mkmakefile.c},
	/sys/vax/{locore.s,scb.s}, /sys/conf/Makefile.vax

Autoconfiguration has been generalized significantly.  The percpu and
old persbi structures are now different, and the structure is sufficiently
general to handle everything from the 8600 to the uVax II.  (No, there's
no support for the latter yet.)
files: /sys/vax/{cpu.h,ioa.h,autoconfig.c,cpudata.c}

Lint.  Recent type changes generated lots; it's been delinted.

		Mike


Complete list of files:

sys/cassette/Makefile
sys/conf/LINT
sys/conf/Makefile.vax
sys/conf/files
sys/conf/files.vax
sys/conf/newvers.sh
sys/conf/param.c
sys/dist/MAKEDEV
sys/dist/disktab
sys/dist/rc.local
sys/floppy/Makefile
sys/h/acct.h
sys/h/buf.h
sys/h/errno.h
sys/h/inode.h
sys/h/ioctl.h
sys/h/mbuf.h
sys/h/mtio.h
sys/h/namei.h
sys/h/param.h
sys/h/proc.h
sys/h/protosw.h
sys/h/signal.h
sys/h/socket.h
sys/h/socketvar.h
sys/h/stat.h
sys/h/syslog.h
sys/h/systm.h
sys/h/tablet.h
sys/h/text.h
sys/h/types.h
sys/h/uio.h
sys/h/unpcb.h
sys/h/user.h
sys/net/if.c
sys/net/if.h
sys/net/if_arp.h
sys/net/if_loop.c
sys/net/if_sl.c
sys/net/raw_cb.c
sys/net/raw_cb.h
sys/net/raw_usrreq.c
sys/net/route.c
sys/netimp/if_imp.c
sys/netinet/if_ether.c
sys/netinet/if_ether.h
sys/netinet/in.c
sys/netinet/in.h
sys/netinet/in_pcb.c
sys/netinet/in_proto.c
sys/netinet/in_var.h
sys/netinet/ip_icmp.c
sys/netinet/ip_input.c
sys/netinet/ip_output.c
sys/netinet/raw_ip.c
sys/netinet/tcp.h
sys/netinet/tcp_input.c
sys/netinet/tcp_output.c
sys/netinet/tcp_seq.h
sys/netinet/tcp_subr.c
sys/netinet/tcp_timer.c
sys/netinet/tcp_timer.h
sys/netinet/tcp_usrreq.c
sys/netinet/tcp_var.h
sys/netinet/udp_usrreq.c
sys/netinet/udp_var.h
sys/netns
sys/netns/idp.h
sys/netns/idp_usrreq.c
sys/netns/idp_var.h
sys/netns/ns.c
sys/netns/ns.h
sys/netns/ns_error.c
sys/netns/ns_error.h
sys/netns/ns_if.h
sys/netns/ns_input.c
sys/netns/ns_output.c
sys/netns/ns_pcb.c
sys/netns/ns_pcb.h
sys/netns/ns_proto.c
sys/netns/sp.h
sys/netns/spidp.h
sys/netns/spp_debug.c
sys/netns/spp_debug.h
sys/netns/spp_var.h
sys/stand/Makefile
sys/stand/boot.c
sys/stand/bootxx.c
sys/stand/format.c
sys/stand/hp.c
sys/stand/hpmaptype.c
sys/stand/saio.h
sys/stand/savax.h
sys/stand/srt0.c
sys/stand/sys.c
sys/stand/up.c
sys/sys/init_main.c
sys/sys/init_sysent.c
sys/sys/kern_acct.c
sys/sys/kern_clock.c
sys/sys/kern_descrip.c
sys/sys/kern_exec.c
sys/sys/kern_exit.c
sys/sys/kern_fork.c
sys/sys/kern_mman.c
sys/sys/kern_prot.c
sys/sys/kern_resource.c
sys/sys/kern_sig.c
sys/sys/kern_time.c
sys/sys/kern_xxx.c
sys/sys/quota_kern.c
sys/sys/quota_sys.c
sys/sys/quota_ufs.c
sys/sys/subr_log.c
sys/sys/subr_prf.c
sys/sys/subr_xxx.c
sys/sys/sys_generic.c
sys/sys/sys_inode.c
sys/sys/sys_process.c
sys/sys/syscalls.c
sys/sys/tags
sys/sys/tty.c
sys/sys/tty_conf.c
sys/sys/tty_pty.c
sys/sys/tty_subr.c
sys/sys/tty_tb.c
sys/sys/ufs_alloc.c
sys/sys/ufs_bio.c
sys/sys/ufs_bmap.c
sys/sys/ufs_inode.c
sys/sys/ufs_mount.c
sys/sys/ufs_namei.c
sys/sys/ufs_subr.c
sys/sys/ufs_syscalls.c
sys/sys/uipc_domain.c
sys/sys/uipc_proto.c
sys/sys/uipc_socket.c
sys/sys/uipc_socket2.c
sys/sys/uipc_syscalls.c
sys/sys/uipc_usrreq.c
sys/sys/vm_drum.c
sys/sys/vm_mem.c
sys/sys/vm_page.c
sys/sys/vm_proc.c
sys/sys/vm_pt.c
sys/sys/vm_sched.c
sys/sys/vm_swap.c
sys/sys/vm_swp.c
sys/sys/vm_text.c
sys/vax/Locore.c
sys/vax/autoconf.c
sys/vax/conf.c
sys/vax/cpu.h
sys/vax/cpudata.c
sys/vax/crl.c
sys/vax/inline/langpats.c
sys/vax/ioa.h
sys/vax/locore.s
sys/vax/machdep.c
sys/vax/mem.c
sys/vax/ns_cksum.c
sys/vax/scb.s
sys/vax/tmscp.h
sys/vax/trap.c
sys/vax/tu.c
sys/vax/vm_machdep.c
sys/vax/vmparam.h
sys/vaxif/if_acc.c
sys/vaxif/if_css.c
sys/vaxif/if_ddn.c
sys/vaxif/if_de.c
sys/vaxif/if_dmc.c
sys/vaxif/if_ec.c
sys/vaxif/if_en.c
sys/vaxif/if_ex.c
sys/vaxif/if_hdh.c
sys/vaxif/if_hdhreg.h
sys/vaxif/if_hy.c
sys/vaxif/if_il.c
sys/vaxif/if_ix.c
sys/vaxif/if_ix.h
sys/vaxif/if_pcl.c
sys/vaxif/if_uba.c
sys/vaxif/if_uba.h
sys/vaxif/if_vv.c
sys/vaxif/raw_hy.c
sys/vaxmba/hp.c
sys/vaxmba/ht.c
sys/vaxmba/mba.c
sys/vaxmba/mbavar.h
sys/vaxmba/mt.c
sys/vaxuba/dh.c
sys/vaxuba/dhu.c
sys/vaxuba/dmf.c
sys/vaxuba/dmz.c
sys/vaxuba/dn.c
sys/vaxuba/dz.c
sys/vaxuba/idc.c
sys/vaxuba/kgclock.c
sys/vaxuba/lp.c
sys/vaxuba/lpa.c
sys/vaxuba/np.c
sys/vaxuba/npreg.h
sys/vaxuba/ps.c
sys/vaxuba/rl.c
sys/vaxuba/tm.c
sys/vaxuba/tmscp.c
sys/vaxuba/tmscpreg.h
sys/vaxuba/ts.c
sys/vaxuba/uba.c
sys/vaxuba/ubavar.h
sys/vaxuba/uda.c
sys/vaxuba/up.c
sys/vaxuba/ut.c
sys/vaxuba/uu.c
sys/vaxuba/vp.c
usr/include/disktab.h
usr/lib/tmac/tmac.an.new
usr/lib/tmac/tmac.e
usr/man/man1/dbx.1
usr/man/man1/ftp.1c
usr/man/man1/plot.1g
usr/man/man5/gettytab.5
usr/man/man8/ftpd.8c
usr/man/man8/slattach.8c
usr/src/bin/chgrp.c
usr/src/bin/csh/sh.file.c
usr/src/bin/csh/sh.proc.c
usr/src/bin/csh/sh.sem.c
usr/src/bin/csh/sh.time.c
usr/src/bin/date.c
usr/src/bin/diff/diffh.c
usr/src/bin/diff/diffreg.c
usr/src/bin/ld.c
usr/src/bin/login.c
usr/src/bin/make/defs
usr/src/bin/make/files.c
usr/src/bin/make/main.c
usr/src/bin/make/misc.c
usr/src/bin/nice.c
usr/src/bin/passwd.c
usr/src/bin/rm.c
usr/src/bin/sh/name.c
usr/src/bin/sh/word.c
usr/src/bin/stty.c
usr/src/bin/write.c
usr/src/etc/XNSrouted/af.c
usr/src/etc/XNSrouted/af.h
usr/src/etc/XNSrouted/defs.h
usr/src/etc/XNSrouted/if.c
usr/src/etc/XNSrouted/input.c
usr/src/etc/XNSrouted/interface.h
usr/src/etc/XNSrouted/main.c
usr/src/etc/XNSrouted/output.c
usr/src/etc/XNSrouted/protocol.h
usr/src/etc/XNSrouted/startup.c
usr/src/etc/XNSrouted/table.h
usr/src/etc/XNSrouted/tables.c
usr/src/etc/XNSrouted/timer.c
usr/src/etc/XNSrouted/trace.c
usr/src/etc/XNSrouted/trace.h
usr/src/etc/arff.c
usr/src/etc/arp.c
usr/src/etc/bad144.c
usr/src/etc/config/Makefile
usr/src/etc/config/main.c
usr/src/etc/config/mkglue.c
usr/src/etc/config/mkmakefile.c
usr/src/etc/diskpart.c
usr/src/etc/dmesg.c
usr/src/etc/dump/dumpmain.c
usr/src/etc/dump/dumprmt.c
usr/src/etc/dump/dumptraverse.c
usr/src/etc/ftpd/Makefile
usr/src/etc/ftpd/ftpcmd.y
usr/src/etc/ftpd/ftpd.c
usr/src/etc/getty/gettytab
usr/src/etc/getty/gettytab.h
usr/src/etc/getty/init.c
usr/src/etc/getty/main.c
usr/src/etc/getty/subr.c
usr/src/etc/ifconfig/ifconfig.c
usr/src/etc/inetd.c
usr/src/etc/rlogind.c
usr/src/etc/rmt.c
usr/src/etc/route.c
usr/src/etc/routed/Makefile
usr/src/etc/routed/af.c
usr/src/etc/routed/af.h
usr/src/etc/routed/if.c
usr/src/etc/routed/interface.h
usr/src/etc/routed/main.c
usr/src/etc/routed/startup.c
usr/src/etc/routed/tables.c
usr/src/etc/routed/timer.c
usr/src/etc/routed/tools/query.c
usr/src/etc/routed/tools/trace.c
usr/src/etc/rwhod.c
usr/src/etc/slattach.c
usr/src/etc/syslogd.c
usr/src/etc/telnetd.c
usr/src/etc/termcap/termcap.src
usr/src/etc/tftpd/Makefile
usr/src/etc/tftpd/tftpd.c
usr/src/etc/timed/Makefile
usr/src/etc/timed/acksend.c
usr/src/etc/timed/byteorder.c
usr/src/etc/timed/candidate.c
usr/src/etc/timed/cmds.c
usr/src/etc/timed/cmdtab.c
usr/src/etc/timed/correct.c
usr/src/etc/timed/globals.h
usr/src/etc/timed/master.c
usr/src/etc/timed/measure.c
usr/src/etc/timed/networkdelta.c
usr/src/etc/timed/readmsg.c
usr/src/etc/timed/slave.c
usr/src/etc/timed/timed.c
usr/src/etc/timed/timedc.c
usr/src/etc/timed/timedc.h
usr/src/lib/c2/c21.c
usr/src/lib/cpp/cpp.c
usr/src/lib/libc/gen/getusershell.c
usr/src/lib/libc/gen/malloc.c
usr/src/lib/libc/stdio/filbuf.c
usr/src/lib/libc/stdio/findiop.c
usr/src/lib/libc/stdio/fputs.c
usr/src/lib/libc/stdio/puts.c
usr/src/lib/libc/vax/gen/_setjmp.s
usr/src/lib/libc/vax/gen/disktab.c
usr/src/lib/libc/vax/gen/setjmp.s
usr/src/lib/libc/vax/gen/setjmperr.c
usr/src/lib/mip/allo.c
usr/src/lib/mip/optim.c
usr/src/lib/mip/pftn.c
usr/src/lib/mip/trees.c
usr/src/lib/pcc/local2.c
usr/src/lib/pcc/order.c
usr/src/lib/pcc/table.c
usr/src/new/np100
usr/src/ucb/Mail/Makefile
usr/src/ucb/Mail/aux.c
usr/src/ucb/Mail/def.h
usr/src/ucb/Mail/lex.c
usr/src/ucb/Mail/list.c
usr/src/ucb/Mail/names.c
usr/src/ucb/Mail/optim.c
usr/src/ucb/compress/compress.c
usr/src/ucb/dbx/Makefile
usr/src/ucb/dbx/check.c
usr/src/ucb/dbx/fortran.c
usr/src/ucb/dbx/runtime.c
usr/src/ucb/ex/Makefile
usr/src/ucb/ex/ex_tagio.c
usr/src/ucb/ex/ex_unix.c
usr/src/ucb/ex/expreserve.c
usr/src/ucb/finger.c
usr/src/ucb/ftp
usr/src/ucb/netstat/Makefile
usr/src/ucb/netstat/host.c
usr/src/ucb/netstat/if.c
usr/src/ucb/netstat/route.c
usr/src/ucb/netstat/unix.c
usr/src/ucb/rlogin.c
usr/src/ucb/telnet.c
usr/src/ucb/tftp
usr/src/ucb/tn3270
usr/src/ucb/vmstat.c
usr/src/usr.bin/f77/src/f77/f77.c
usr/src/usr.bin/f77/src/f77pass1/defs.h
usr/src/usr.bin/f77/src/f77pass1/exec.c
usr/src/usr.bin/f77/src/f77pass1/expr.c
usr/src/usr.bin/f77/src/f77pass1/gram.dcl
usr/src/usr.bin/f77/src/f77pass1/gram.exec
usr/src/usr.bin/f77/src/f77pass1/gram.expr
usr/src/usr.bin/f77/src/f77pass1/io.c
usr/src/usr.bin/f77/src/f77pass1/lex.c
usr/src/usr.bin/f77/src/f77pass1/misc.c
usr/src/usr.bin/f77/src/f77pass1/proc.c
usr/src/usr.bin/f77/src/f77pass1/regalloc.c
usr/src/usr.bin/f77/src/f77pass1/stab.c
usr/src/usr.bin/lint/lint.c
usr/src/usr.bin/lint/macdefs.h
usr/src/usr.bin/plot/driver.c
usr/src/usr.bin/tip/Makefile
usr/src/usr.bin/tip/acu.c
usr/src/usr.bin/tip/cmds.c
usr/src/usr.bin/tip/cmdtab.c
usr/src/usr.bin/tip/cu.c
usr/src/usr.bin/tip/hunt.c
usr/src/usr.bin/tip/remote.c
usr/src/usr.bin/tip/tip.c
usr/src/usr.bin/tip/tip.h
usr/src/usr.bin/tip/uucplock.c
usr/src/usr.bin/uucp
usr/src/usr.lib/libcurses/clrtobot.c
usr/src/usr.lib/libcurses/cr_tty.c
usr/src/usr.lib/libcurses/curses.c
usr/src/usr.lib/libcurses/getch.c
usr/src/usr.lib/libcurses/move.c
usr/src/usr.lib/libcurses/overlay.c
usr/src/usr.lib/libplot/Makefile
usr/src/usr.lib/libplot/imagen/Makefile
usr/src/usr.lib/libplot/imagen/SCCS
usr/src/usr.lib/libplot/imagen/arc.c
usr/src/usr.lib/libplot/imagen/box.c
usr/src/usr.lib/libplot/imagen/charset.c
usr/src/usr.lib/libplot/imagen/circle.c
usr/src/usr.lib/libplot/imagen/close.c
usr/src/usr.lib/libplot/imagen/cont.c
usr/src/usr.lib/libplot/imagen/dot.c
usr/src/usr.lib/libplot/imagen/erase.c
usr/src/usr.lib/libplot/imagen/imPcodes.h
usr/src/usr.lib/libplot/imagen/imp.h
usr/src/usr.lib/libplot/imagen/label.c
usr/src/usr.lib/libplot/imagen/line.c
usr/src/usr.lib/libplot/imagen/linemod.c
usr/src/usr.lib/libplot/imagen/move.c
usr/src/usr.lib/libplot/imagen/open.c
usr/src/usr.lib/libplot/imagen/point.c
usr/src/usr.lib/libplot/imagen/scale.c
usr/src/usr.lib/libplot/imagen/space.c
usr/src/usr.lib/lpr/Makefile
usr/src/usr.lib/lpr/displayq.c
usr/src/usr.lib/lpr/filters/vplotf.c
usr/src/usr.lib/lpr/lpc.c
usr/src/usr.lib/lpr/lpd.c
usr/src/usr.lib/lpr/lpq.c
usr/src/usr.lib/lpr/lpr.c
usr/src/usr.lib/lpr/lprm.c
usr/src/usr.lib/lpr/pac.c
usr/src/usr.lib/lpr/printjob.c
usr/src/usr.lib/lpr/recvjob.c
-C /nbsd/
usr/src/usr.lib/sendmail/doc/op.me
usr/src/usr.lib/sendmail/cf/Makefile
usr/src/usr.lib/sendmail/cf/kim.mc
usr/src/usr.lib/sendmail/cf/tcpm.m4
usr/src/usr.lib/sendmail/cf/arpaproto.mc
usr/src/usr.lib/sendmail/cf/csbase.m4
usr/src/usr.lib/sendmail/cf/base.m4
usr/src/usr.lib/sendmail/cf/KEY
usr/src/usr.lib/sendmail/cf/arpa.mc
usr/src/usr.lib/sendmail/cf/uucpproto.mc
usr/src/usr.lib/sendmail/cf/ether.m4
usr/src/usr.lib/sendmail/cf/ucbvax.mc
usr/src/usr.lib/sendmail/cf/berkhosts.m4
usr/src/usr.lib/sendmail/cf/version.m4
usr/src/usr.lib/sendmail/cf/suucpm.m4
usr/src/usr.lib/sendmail/cf/ccbase.m4
usr/src/usr.lib/sendmail/cf/lanroot.mc
usr/src/usr.lib/sendmail/cf/lanleaf.mc
usr/src/usr.lib/sendmail/cf/ji.mc
usr/src/usr.lib/sendmail/src/conf.h
usr/src/usr.lib/sendmail/src/sendmail.h
usr/src/usr.lib/sendmail/src/Makefile.ns
usr/src/usr.lib/sendmail/src/trace.h
usr/src/usr.lib/sendmail/src/Makefile.m4
usr/src/usr.lib/sendmail/src/conf.c
usr/src/usr.lib/sendmail/src/arpadate.c
usr/src/usr.lib/sendmail/src/bcopy.c
usr/src/usr.lib/sendmail/src/clock.c
usr/src/usr.lib/sendmail/src/collect.c
usr/src/usr.lib/sendmail/src/queue.c
usr/src/usr.lib/sendmail/src/convtime.c
usr/src/usr.lib/sendmail/src/bmove.11.s
usr/src/usr.lib/sendmail/src/bmove.vax.s
usr/src/usr.lib/sendmail/src/daemon.c
usr/src/usr.lib/sendmail/src/deliver.c
usr/src/usr.lib/sendmail/src/envelope.c
usr/src/usr.lib/sendmail/src/err.c
usr/src/usr.lib/sendmail/src/headers.c
usr/src/usr.lib/sendmail/src/macro.c
usr/src/usr.lib/sendmail/src/main.c
usr/src/usr.lib/sendmail/src/parseaddr.c
usr/src/usr.lib/sendmail/src/stats.c
usr/src/usr.lib/sendmail/src/readcf.c
usr/src/usr.lib/sendmail/src/alias.c
usr/src/usr.lib/sendmail/src/savemail.c
usr/src/usr.lib/sendmail/src/version.c
usr/src/usr.lib/sendmail/src/stab.c
usr/src/usr.lib/sendmail/src/sysexits.c
usr/src/usr.lib/sendmail/src/trace.c
usr/src/usr.lib/sendmail/src/usersmtp.c
usr/src/usr.lib/sendmail/src/util.c
usr/src/usr.lib/sendmail/src/recipient.c
usr/src/usr.lib/sendmail/src/Version.c
usr/src/usr.lib/sendmail/src/srvrsmtp.c
usr/src/usr.lib/sendmail/aux/Makefile
usr/src/usr.lib/sendmail/aux/newaliases.c
usr/src/usr.lib/sendmail/aux/mconnect.c
usr/src/usr.lib/sendmail/nscf/kim.mc
usr/src/usr.lib/sendmail/nscf/nstcpldm.m4
usr/src/usr.lib/sendmail/nscf/berkm.m4
usr/src/usr.lib/sendmail/nscf/nicregistered.m4
usr/src/usr.lib/sendmail/nscf/cchosts.m4
usr/src/usr.lib/sendmail/nscf/nstcpm.m4
usr/src/usr.lib/sendmail/nscf/version.m4
usr/src/usr.lib/sendmail/nscf/postwriterule.m4
usr/src/usr.lib/sendmail/nscf/rule0.m4
usr/src/usr.lib/sendmail/nscf/berkhosts.m4
usr/src/usr.lib/sendmail/nscf/monet.mc
usr/src/usr.lib/sendmail/nscf/rule3.m4
usr/src/usr.lib/sendmail/nscf/arpa.mc
usr/src/usr.lib/sendmail/nscf/uucpm.m4
usr/src/usr.lib/sendmail/nscf/rule5.m4
usr/src/usr.lib/sendmail/nscf/ucbvax.mc
usr/src/usr.lib/sendmail/nscf/Makefile
usr/src/usr.lib/sendmail/nscf/ucbtcp.mc
usr/src/usr.lib/sendmail/nscf/euucpm.m4
usr/src/usr.lib/sendmail/nscf/arpa.ed
usr/src/usr.lib/sendmail/nscf/uucphosts.m4
usr/src/usr.lib/sendmail/README_FOR_NAME_SERVER
usr/src/usr.lib/sendmail/Makefile
usr/src/usr.lib/sendmail/FILES

From chris@gyre.umd.edu  Thu Feb 27 15:46:46 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA05021; Thu, 27 Feb 86 15:46:46 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05444; Thu, 27 Feb 86 18:03:02 EST
Date: Thu, 27 Feb 86 18:03:02 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8602272303.AA05444@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: rwhod has lint fluff, does excessive work

Index: /usr/src/etc/rwhod.c 4.3Beta Fix

Description:
	Try `lint' on rwhod.  Observe fluff.  Look at source.  Observe
	extraneous chdir("/dev"), and lack of chdir(RWHODIR), and lots
	of namei() exercise.

Repeat-By:
	I think I just wrote that above...

Fix:
	Below

Chris

RCS file: RCS/rwhod.c,v
retrieving revision 1.1
diff -c2 -r1.1 rwhod.c
*** /tmp/,RCSt1005339	Thu Feb 27 17:58:12 1986
--- rwhod.c	Thu Feb 27 17:57:03 1986
***************
*** 77,82 ****
  
  int	onalrm();
! char	*strcpy(), *sprintf(), *malloc();
! long	lseek();
  int	getkmem();
  struct	in_addr inet_makeaddr();
--- 77,82 ----
  
  int	onalrm();
! char	*strcpy(), *strncpy(), *sprintf(), *malloc(), *realloc();
! off_t	lseek();
  int	getkmem();
  struct	in_addr inet_makeaddr();
***************
*** 86,90 ****
  	struct sockaddr_in from;
  	char path[64];
! 	int addr, on = 1;
  	struct hostent *hp;
  	char *cp;
--- 86,90 ----
  	struct sockaddr_in from;
  	char path[64];
! 	int on = 1;
  	struct hostent *hp;
  	char *cp;
***************
*** 111,115 ****
  	  s = open("/dev/tty", 2);
  	  if (s >= 0) {
! 		ioctl(s, TIOCNOTTY, 0);
  		(void) close(s);
  	  }
--- 111,115 ----
  	  s = open("/dev/tty", 2);
  	  if (s >= 0) {
! 		(void) ioctl(s, TIOCNOTTY, 0);
  		(void) close(s);
  	  }
***************
*** 116,120 ****
  	}
  #endif
- 	(void) chdir("/dev");
  	(void) signal(SIGHUP, getkmem);
  	openlog("rwhod", LOG_PID, LOG_DAEMON);
--- 116,119 ----
***************
*** 128,132 ****
  	if ((cp = index(myname, '.')) != NULL)
  		*cp = '\0';
! 	strncpy(mywd.wd_hostname, myname, sizeof (myname) - 1);
  	utmpf = open("/etc/utmp", O_RDONLY);
  	if (utmpf < 0) {
--- 127,135 ----
  	if ((cp = index(myname, '.')) != NULL)
  		*cp = '\0';
! 	(void) strncpy(mywd.wd_hostname, myname, sizeof (myname) - 1);
! 	if (chdir(RWHODIR)) {
! 		syslog(LOG_ERR, "chdir(%s): %m", RWHODIR);
! 		exit(1);
! 	}
  	utmpf = open("/etc/utmp", O_RDONLY);
  	if (utmpf < 0) {
***************
*** 143,147 ****
  		exit(1);
  	}
! 	if (setsockopt(s, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0) {
  		syslog(LOG_ERR, "setsockopt SO_BROADCAST: %m");
  		exit(1);
--- 146,151 ----
  		exit(1);
  	}
! 	if (setsockopt(s, SOL_SOCKET, SO_BROADCAST,
! 	    (char *)&on, sizeof (on)) < 0) {
  		syslog(LOG_ERR, "setsockopt SO_BROADCAST: %m");
  		exit(1);
***************
*** 160,164 ****
  	if (!configure(s))
  		exit(1);
! 	signal(SIGALRM, onalrm);
  	onalrm();
  	for (;;) {
--- 164,168 ----
  	if (!configure(s))
  		exit(1);
! 	(void) signal(SIGALRM, onalrm);
  	onalrm();
  	for (;;) {
***************
*** 194,201 ****
  			continue;
  		}
! 		(void) sprintf(path, "%s/whod.%s", RWHODIR, wd.wd_hostname);
  		whod = creat(path, 0666);
  		if (whod < 0) {
! 			syslog(LOG_WARNING, "%s: %m", path);
  			continue;
  		}
--- 198,205 ----
  			continue;
  		}
! 		(void) sprintf(path, "whod.%s", wd.wd_hostname);
  		whod = creat(path, 0666);
  		if (whod < 0) {
! 			syslog(LOG_WARNING, "%s/%s: %m", RWHODIR, path);
  			continue;
  		}
***************
*** 206,218 ****
  
  			/* undo header byte swapping before writing to file */
! 			wd.wd_sendtime = ntohl(wd.wd_sendtime);
  			for (i = 0; i < 3; i++)
! 				wd.wd_loadav[i] = ntohl(wd.wd_loadav[i]);
! 			wd.wd_boottime = ntohl(wd.wd_boottime);
  			we = wd.wd_we;
  			for (i = 0; i < n; i++) {
! 				we->we_idle = ntohl(we->we_idle);
  				we->we_utmp.out_time =
! 				    ntohl(we->we_utmp.out_time);
  				we++;
  			}
--- 210,222 ----
  
  			/* undo header byte swapping before writing to file */
! 			wd.wd_sendtime = ntohl((long)wd.wd_sendtime);
  			for (i = 0; i < 3; i++)
! 				wd.wd_loadav[i] = ntohl((long)wd.wd_loadav[i]);
! 			wd.wd_boottime = ntohl((long)wd.wd_boottime);
  			we = wd.wd_we;
  			for (i = 0; i < n; i++) {
! 				we->we_idle = ntohl((long)we->we_idle);
  				we->we_utmp.out_time =
! 				    ntohl((long)we->we_utmp.out_time);
  				we++;
  			}
***************
*** 256,260 ****
  	int cc;
  	double avenrun[3];
! 	time_t now = time(0);
  	register struct neighbor *np;
  
--- 260,264 ----
  	int cc;
  	double avenrun[3];
! 	time_t now = time((time_t *)0);
  	register struct neighbor *np;
  
***************
*** 268,275 ****
  			utmpsize = stb.st_size + 10 * sizeof(struct utmp);
  			if (utmp)
! 				utmp = (struct utmp *)realloc(utmp, utmpsize);
  			else
! 				utmp = (struct utmp *)malloc(utmpsize);
! 			if (! utmp) {
  				fprintf(stderr, "rwhod: malloc failed\n");
  				utmpsize = 0;
--- 272,281 ----
  			utmpsize = stb.st_size + 10 * sizeof(struct utmp);
  			if (utmp)
! 				utmp = (struct utmp *)
! 				    realloc((char *)utmp, (unsigned)utmpsize);
  			else
! 				utmp = (struct utmp *)
! 				    malloc((unsigned)utmpsize);
! 			if (utmp == NULL) {
  				fprintf(stderr, "rwhod: malloc failed\n");
  				utmpsize = 0;
***************
*** 277,281 ****
  			}
  		}
! 		(void) lseek(utmpf, (long)0, L_SET);
  		cc = read(utmpf, (char *)utmp, stb.st_size);
  		if (cc < 0) {
--- 283,287 ----
  			}
  		}
! 		(void) lseek(utmpf, (off_t)0, L_SET);
  		cc = read(utmpf, (char *)utmp, stb.st_size);
  		if (cc < 0) {
***************
*** 301,313 ****
  	for (i = 0; i < utmpent; i++) {
  		if (stat(we->we_utmp.out_line, &stb) >= 0)
! 			we->we_idle = htonl(now - stb.st_atime);
  		we++;
  	}
! 	(void) lseek(kmemf, (long)nl[NL_AVENRUN].n_value, L_SET);
  	(void) read(kmemf, (char *)avenrun, sizeof (avenrun));
  	for (i = 0; i < 3; i++)
! 		mywd.wd_loadav[i] = htonl((u_long)(avenrun[i] * 100));
  	cc = (char *)we - (char *)&mywd;
! 	mywd.wd_sendtime = htonl(time(0));
  	mywd.wd_vers = WHODVERSION;
  	mywd.wd_type = WHODTYPE_STATUS;
--- 307,319 ----
  	for (i = 0; i < utmpent; i++) {
  		if (stat(we->we_utmp.out_line, &stb) >= 0)
! 			we->we_idle = htonl((long)(now - stb.st_atime));
  		we++;
  	}
! 	(void) lseek(kmemf, (off_t)nl[NL_AVENRUN].n_value, L_SET);
  	(void) read(kmemf, (char *)avenrun, sizeof (avenrun));
  	for (i = 0; i < 3; i++)
! 		mywd.wd_loadav[i] = htonl((long)(avenrun[i] * 100));
  	cc = (char *)we - (char *)&mywd;
! 	mywd.wd_sendtime = htonl((long)time((time_t *)0));
  	mywd.wd_vers = WHODVERSION;
  	mywd.wd_type = WHODTYPE_STATUS;
***************
*** 314,318 ****
  	for (np = neighbors; np != NULL; np = np->n_next)
  		(void) sendto(s, (char *)&mywd, cc, 0,
! 			np->n_addr, np->n_addrlen);
  done:
  	(void) alarm(AL_INTERVAL);
--- 320,324 ----
  	for (np = neighbors; np != NULL; np = np->n_next)
  		(void) sendto(s, (char *)&mywd, cc, 0,
! 			(struct sockaddr *)np->n_addr, np->n_addrlen);
  done:
  	(void) alarm(AL_INTERVAL);
***************
*** 321,325 ****
  getkmem()
  {
- 	struct nlist *nlp;
  	static ino_t vmunixino;
  	static time_t vmunixctime;
--- 327,330 ----
***************
*** 348,355 ****
  		exit(1);
  	}
! 	(void) lseek(kmemf, (long)nl[NL_BOOTTIME].n_value, L_SET);
  	(void) read(kmemf, (char *)&mywd.wd_boottime,
  	    sizeof (mywd.wd_boottime));
! 	mywd.wd_boottime = htonl(mywd.wd_boottime);
  }
  
--- 353,360 ----
  		exit(1);
  	}
! 	(void) lseek(kmemf, (off_t)nl[NL_BOOTTIME].n_value, L_SET);
  	(void) read(kmemf, (char *)&mywd.wd_boottime,
  	    sizeof (mywd.wd_boottime));
! 	mywd.wd_boottime = htonl((long)mywd.wd_boottime);
  }
  
***************
*** 386,390 ****
  		if (np == NULL)
  			continue;
! 		np->n_name = malloc(strlen(ifr->ifr_name) + 1);
  		if (np->n_name == NULL) {
  			free((char *)np);
--- 391,395 ----
  		if (np == NULL)
  			continue;
! 		np->n_name = malloc((unsigned)(strlen(ifr->ifr_name) + 1));
  		if (np->n_name == NULL) {
  			free((char *)np);
***************
*** 391,397 ****
  			continue;
  		}
! 		strcpy(np->n_name, ifr->ifr_name);
  		np->n_addrlen = sizeof (ifr->ifr_addr);
! 		np->n_addr = malloc(np->n_addrlen);
  		if (np->n_addr == NULL) {
  			free(np->n_name);
--- 396,402 ----
  			continue;
  		}
! 		(void) strcpy(np->n_name, ifr->ifr_name);
  		np->n_addrlen = sizeof (ifr->ifr_addr);
! 		np->n_addr = malloc((unsigned)np->n_addrlen);
  		if (np->n_addr == NULL) {
  			free(np->n_name);

From satz@su-mojave.arpa  Thu Feb 27 17:24:52 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA05323; Thu, 27 Feb 86 17:24:52 PST
Message-Id: <8602280124.AA05323@monet.berkeley.edu>
Received: by su-mojave.arpa with TCP; Thu, 27 Feb 86 17:22:01 pst
Date: Thu, 27 Feb 86 17:22:01 pst
From: Greg Satz <satz@su-mojave.arpa>
Subject: lib/libc/gen/regex.c bug +FIX
To: beta43_bugs@monet.berkeley.edu

I ran into this problem with rdist. The except_pat command
turned up the fact that /etc/rc* was really matching /etc/r*.
Here is the fix I used:

*** /tmp/,RCSt1009765	Thu Feb 27 17:19:02 1986
--- regex.c	Tue Feb  4 21:00:30 1986
***************
*** 345,353 ****
  
  		case CCHR|CSTAR:
  			curlp = lp;
! 			while (*lp++ == *ep)
! 				;
! 			ep++;
  			goto star;
  
  		case CCL|CSTAR:
--- 345,352 ----
  
  		case CCHR|CSTAR:
  			curlp = lp;
! 			if (*lp++ != *ep++)
! 				return(0);
  			goto star;
  
  		case CCL|CSTAR:

From SATZ@SU-SIERRA.ARPA  Fri Feb 28 17:24:58 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA10554; Fri, 28 Feb 86 17:24:58 PST
Message-Id: <8603010124.AA10554@monet.berkeley.edu>
Date: Fri 28 Feb 86 17:22:01-PST
From: Greg Satz <SATZ@SU-SIERRA.ARPA>
Subject: tar.Z.2 problems
To: beta43_bugs@monet.berkeley.edu
Phone: (415) 497-1004

Thanks for the update. Just wanted to let you know about the following:

You included the library getusershell, but you didn't include the man page.

In lib/libc/stdio, fputs.c and puts.c were the exact same files as what
was on the latest beta tape. Were these what you intended to send?
-------

From j@utah-cs.ARPA  Sat Mar  1 15:19:23 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA13795; Sat, 1 Mar 86 15:19:23 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA12406; Sat, 1 Mar 86 16:20:39 MST
Date: Sat, 1 Mar 86 16:20:39 MST
From: j@utah-cs.arpa (J Lepreau)
Message-Id: <8603012320.AA12406@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: inetd(8) and inetd.c disagree about "trival" service support

The man page says it supports some "trivial" services internally,
but the code seems to have no evidence of this, and they don't work.

From guyton%condor@rand-unix.ARPA  Sat Mar  1 16:35:14 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA14193; Sat, 1 Mar 86 16:35:14 PST
Received: from condor.arpa (condor) by rand-unix.ARPA; Sat, 1 Mar 86 16:24:24 pst
Received: from localhost by condor.arpa; Sat, 1 Mar 86 16:02:40 pst
From: Jim Guyton <guyton%condor@rand-unix.ARPA>
Message-Id: <8603020002.AA00256@condor.arpa>
To: beta43_bugs@monet.berkeley.edu
Cc: James_Guyton <guyton@rand-unix.ARPA>, obrien@rand-unix.ARPA,
        terry@rand-unix.ARPA
Subject: protection of ttys
Date: Sat, 01 Mar 86 16:02:35 PST

I was somewhat surprised to see that under 4.3BSD tty devices
are still protected 0622 (i.e. write by anyone).

I assume you know that this allows trivial violation
of system security if "intellegent" terminals are
being used (via the terminal's "send-back" ability).
This is in addition to little things like anyone
being able to log anyone else out:

	% stty 0 > /dev/ttyh0

Solution:

     1) Create a new group (we called it "write")
     2) In login (et al), make the tty device owned by user,
	but group "write".
     3) Make legitimate programs setgid "write"  (for example,
	the "write" program).
     4) Change above pgms to convert control characters to ^X
	syntax.
     5) Slight changes to mesg and finger to set/examine the
	group bit (instead of group+world).

We ran with these changes for about a year under 4.1BSD, but
never got around to fixing our 4.2BSD system.  If there is any
chance of getting the mods included in 4.3, let me know and
I'll apply the fixes and let you know how it all works out.

-- Jim Guyton

From chris@gyre.umd.edu  Sun Mar  2 15:33:56 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA19561; Sun, 2 Mar 86 15:33:56 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA20704; Sun, 2 Mar 86 18:33:55 EST
Date: Sun, 2 Mar 86 18:33:55 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8603022333.AA20704@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: termcap `install' entry does not reinstall tabset files

Index: /usr/src/etc/termcap/Makefile 4.3Beta Fix

Description:
	The Makefile does not install the tabset files, since the
	directory is always `up to date'.

Repeat-by:
	cd /usr/src/etc/termcap; make install

	Note that the tabset directory was not installed.

Fix:
	Below

Chris

RCS file: RCS/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1020692	Sun Mar  2 18:32:11 1986
--- /tmp/,RCSt2020692	Sun Mar  2 18:32:12 1986
***************
*** 18,22 ****
  	install -m 444 termcap ${DESTDIR}/etc/termcap
  
! tabset:
  	rm -fr ${DESTDIR}/usr/lib/tabset
  	mkdir ${DESTDIR}/usr/lib/tabset
--- 18,22 ----
  	install -m 444 termcap ${DESTDIR}/etc/termcap
  
! tabset: FRC
  	rm -fr ${DESTDIR}/usr/lib/tabset
  	mkdir ${DESTDIR}/usr/lib/tabset
***************
*** 25,28 ****
--- 25,30 ----
  clean:
  	rm -f termcap
+ 
+ FRC:
  
  installall:

From medin@orion.arpa  Sun Mar  2 18:14:29 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA19866; Sun, 2 Mar 86 18:14:29 PST
Received: by orion.arpa (5.28/1.5)
	id AA24694; Sun, 2 Mar 86 18:13:59 PST
Message-Id: <8603030213.AA24694@orion.arpa>
To: karels@monet.berkeley.edu (Mike Karels)
Cc: beta43_sites@monet.berkeley.edu, allmanagers@ucbvax.berkeley.edu
Subject: Re: more changes
In-Reply-To: Your message of Wed, 26 Feb 86 12:52:37 PST.
	     <8602262052.AA08360@monet.berkeley.edu>
Date: 02 Mar 86 18:13:56 PST (Sun)
From: Milo S. Medin (NASA ARC Code ED) <medin@orion.arpa>


For those of you MILNET sites who haven't gotten it yet, its now available
for public ftp in pub/43update/tar.Z.2 on host orion.arpa (or orion.arc.nasa.gov if you're into that sort of thing).


					Milo

From muller@nprdc.arpa  Mon Mar  3 01:43:32 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA21127; Mon, 3 Mar 86 01:43:32 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA04494; Mon, 3 Mar 86 01:44:13 pst
Date: Mon, 3 Mar 86 01:44:13 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603030944.AA04494@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: refer bug

Subject: 'refer' fails to detect duplicate citations in some cases
Index:	src/usr.bin/refer/glue1.c 4.3BSD

Description:
	When references are printed as a sorted endlist (-s option)
	refer normally collapses duplicate citations so that only
	one instance of each reference appears in the endlist.
	It certain cases involving the use multiple databases,
	in and out of the current directory, refer fails to detect
	duplicate citations with the result that multiple identical
	references appear in the reference list.

Repeat-By:
	
	1) Unpack the attached shar archive.

	2) Run indxbib to create an index for ref.local.
	This is necessary, if the ref.local database is not
	indexed the error does not occur.

		indxbib ref.local

	3) Note that in doc there are three citations.  The first
	and third are duplicates citing "ref1" which is in the 
	refer database "ref.local" in the current directory.
	The second citation "kernighan cherry" is to a reference
	in the distributed refer database in /usr/dict/papers.

	4) Run refer:

		refer -s -p ref.local doc

	5) Note that in the refer output the "ref1" reference which
	is cited twice, appears in the reference list twice.
	It should appear only once.  Also the signals (superscripts)
	placed in the text are wrong, they should be (1,2,1)
	since the third citation is a duplicate of the first, instead
	they are (1,3,2).

	For comparison the correct and incorrect refer output files
	have been provided in referout.correct and referout.wrong.

Fix:

*** /usr/src/usr.bin/refer/glue1.c	Wed Jan  9 15:52:36 1985 4.3bsd
--- refer-test/glue1.c	Fri Feb 28 14:12:30 1986 (fixed)
***************
*** 252,257 ****
--- 252,259 ----
  char *t;
  {
  	char *s;
+ 
+ 	usedir[0] = 0;
  	s=t;
  	while (*s) s++;
  	while (s>=t && *s != '/') s--;
----------cut here -------
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	doc
#	ref.local
#	referout.correct
#	referout.wrong
# This archive created: Mon Mar  3 01:36:57 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'doc'" '(124 characters)'
if test -f 'doc'
then
	echo shar: will not over-write existing file "'doc'"
else
sed 's/^	X//' << \SHAR_EOF > 'doc'
	XRegular text.
	X.[
	Xref1
	X.]
	XRegular text.
	X.[
	Xkernighan cherry typesetting mathematics
	X.]
	X.[
	Xref1
	X.]
	XRegular text.
	X.[
	X$LIST$
	X.]
SHAR_EOF
if test 124 -ne "`wc -c < 'doc'`"
then
	echo shar: error transmitting "'doc'" '(should have been 124 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'ref.local'" '(17 characters)'
if test -f 'ref.local'
then
	echo shar: will not over-write existing file "'ref.local'"
else
sed 's/^	X//' << \SHAR_EOF > 'ref.local'
	X%T ref1
	X
	X%T ref2
SHAR_EOF
if test 17 -ne "`wc -c < 'ref.local'`"
then
	echo shar: error transmitting "'ref.local'" '(should have been 17 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'referout.correct'" '(575 characters)'
if test -f 'referout.correct'
then
	echo shar: will not over-write existing file "'referout.correct'"
else
sed 's/^	X//' << \SHAR_EOF > 'referout.correct'
	XRegular text.\*([.1\*(.]
	XRegular text.\*([.2,\|1\*(.]
	XRegular text.
	X.]<
	X.\"1
	X.ds [F 1
	X.]-
	X.ds [T ref1
	X.nr [T 0
	X.nr [A 0
	X.nr [O 0
	X.][ 0 other
	X.\"Kernighan.B.W.-1975-2
	X.ds [F 2
	X.]-
	X.ds [r 17
	X.ds [K cstr
	X.ds [R Comp. Sci. Tech. Rep. No. 17
	X.ds [I Bell Laboratories
	X.ds [C Murray Hill, New Jersey
	X.ds [A B. W. Kernighan
	X.as [A " and L. L. Cherry
	X.ds [T A System for Typesetting Mathematics
	X.ds [d May 1974, revised April 1977
	X.ds [J Comm. Assoc. Comp. Mach.
	X.ds [K acm cacm
	X.ds [V 18
	X.ds [P 151-157
	X.nr [P 1
	X.ds [D March 1975
	X.nr [T 0
	X.nr [A 0
	X.nr [O 0
	X.][ 1 journal-article
	X.]>
SHAR_EOF
if test 575 -ne "`wc -c < 'referout.correct'`"
then
	echo shar: error transmitting "'referout.correct'" '(should have been 575 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'referout.wrong'" '(644 characters)'
if test -f 'referout.wrong'
then
	echo shar: will not over-write existing file "'referout.wrong'"
else
sed 's/^	X//' << \SHAR_EOF > 'referout.wrong'
	XRegular text.\*([.1\*(.]
	XRegular text.\*([.3,\|2\*(.]
	XRegular text.
	X.]<
	X.\"1
	X.ds [F 1
	X.]-
	X.ds [T ref1
	X.nr [T 0
	X.nr [A 0
	X.nr [O 0
	X.][ 0 other
	X.\"2
	X.ds [F 2
	X.]-
	X.ds [T ref1
	X.nr [T 0
	X.nr [A 0
	X.nr [O 0
	X.][ 0 other
	X.\"Kernighan.B.W.-1975-3
	X.ds [F 3
	X.]-
	X.ds [r 17
	X.ds [K cstr
	X.ds [R Comp. Sci. Tech. Rep. No. 17
	X.ds [I Bell Laboratories
	X.ds [C Murray Hill, New Jersey
	X.ds [A B. W. Kernighan
	X.as [A " and L. L. Cherry
	X.ds [T A System for Typesetting Mathematics
	X.ds [d May 1974, revised April 1977
	X.ds [J Comm. Assoc. Comp. Mach.
	X.ds [K acm cacm
	X.ds [V 18
	X.ds [P 151-157
	X.nr [P 1
	X.ds [D March 1975
	X.nr [T 0
	X.nr [A 0
	X.nr [O 0
	X.][ 1 journal-article
	X.]>
SHAR_EOF
if test 644 -ne "`wc -c < 'referout.wrong'`"
then
	echo shar: error transmitting "'referout.wrong'" '(should have been 644 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

From muller@nprdc.arpa  Mon Mar  3 01:47:52 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA21154; Mon, 3 Mar 86 01:47:52 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA04504; Mon, 3 Mar 86 01:48:32 pst
Date: Mon, 3 Mar 86 01:48:32 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603030948.AA04504@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: maybe a fopen bug?

Subject: fopen in "a" mode does not assure writes will append to file
Index:	src/lib/libc/stdio/fopen.c 4.3BSD

Description:
	If two or more processes open a file in the "a" or "a+" mode
	and write to the file, the output is not appended to the file
	but placed at the position that was the end of the file at the
	time the fopen completed.

	Whether this is a bug or not depends on the interpretation of
	what the "a" mode means. Does it mean append (as open() means
	append), or is it simply a fopen() and a fseek to the end of
	the file operation?

Repeat-By:
	Have two programs fopen the same empty file in "a" mode BEFORE either
	one writes to it. Then have each program fprintf to the file. for
	example:
		program a fprintf: hello
		program b fprintf: HELLO
	The contents of the file after both programs complete will be
	either HELLO or hello, not both lines:
		hello
		HELLO
Fix:

*** /usr/src/lib/libc/stdio/fopen.c	Thu May 30 14:28:20 1985
--- fopen.c	Mon Mar  3 00:38:55 1986
***************
*** 29,35 ****
  
  	switch (*mode) {
  	case 'a':
! 		oflags = O_CREAT | (rw ? O_RDWR : O_WRONLY);
  		break;
  	case 'r':
  		oflags = rw ? O_RDWR : O_RDONLY;
--- 29,35 ----
  
  	switch (*mode) {
  	case 'a':
! 		oflags = O_CREAT | O_APPEND | (rw ? O_RDWR : O_WRONLY);
  		break;
  	case 'r':
  		oflags = rw ? O_RDWR : O_RDONLY;
***************
*** 45,51 ****
  	if (f < 0)
  		return (NULL);
  
! 	if (*mode == 'a')
  		lseek(f, (off_t)0, L_XTND);
  
  	iop->_cnt = 0;
--- 45,51 ----
  	if (f < 0)
  		return (NULL);
  
! 	if ((*mode == 'a') && rw)
  		lseek(f, (off_t)0, L_XTND);
  
  	iop->_cnt = 0;

From muller@nprdc.arpa  Tue Mar  4 01:35:29 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA25698; Tue, 4 Mar 86 01:35:29 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA15845; Tue, 4 Mar 86 01:36:02 pst
Date: Tue, 4 Mar 86 01:36:02 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603040936.AA15845@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: another refer bug

Subject: /usr/lib/refer/inv can core dump from writes on a bad stream
Index:	usr.bin/refer/inv1.c 4.3BSD

Description:
	In some cases inv attempts to write to a stream which has not
	been initialized.  This results in an execution error.
	In inv1.c the stream fd is declared as an automatic variable in
	function main:
		FILE *fd;
	Later in the code the intialization of fd is skipped unless the
	"keepkey" flag is true. The keepkey flag is set only by the -d
	option of inv:
		if (keepkey)
			fd = keepkey ? fopen(nmd, "w") : 0;

	Later the variable fd is passed to newkeys() which checks if fd
	is 0; If fd in not 0, then newkeys() attempts to perform a fputs on
	the stream fd. If the -d flag is not specified it is possible for
	fd to have some random non-zero value resulting in a core dump.

Repeat-By:
	The problem cannot be repeated reliably because
	it depends on the garbage value picked up in fd.

Fix:
	Force the initialization of fd in all cases.

	Keith Muller
	University of california, San Diego

*** /usr/src/usr.bin/refer/inv1.c	Sun May  8 14:34:16 1983
--- inv1.c	Tue Mar  4 01:16:07 1986
***************
*** 120,127 ****
  			appflg=0;
  	}
  	fc = fopen(nmc,  appflg ? "a" : "w");
! 	if (keepkey)
! 		fd = keepkey ? fopen(nmd, "w") : 0;
  	docs = newkeys(fta, stdin, fc, nhash, fd, &iflong);
  	fclose(stdin);
  	if (remove != NULL)
--- 120,126 ----
  			appflg=0;
  	}
  	fc = fopen(nmc,  appflg ? "a" : "w");
! 	fd = keepkey ? fopen(nmd, "w") : 0;
  	docs = newkeys(fta, stdin, fc, nhash, fd, &iflong);
  	fclose(stdin);
  	if (remove != NULL)

From lepreau@utah-cs.ARPA  Tue Mar  4 17:16:41 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA00347; Tue, 4 Mar 86 17:16:41 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA11347; Tue, 4 Mar 86 18:18:00 MST
Date: Tue, 4 Mar 86 18:18:00 MST
From: lepreau@utah-cs.arpa (Jay Lepreau)
Message-Id: <8603050118.AA11347@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: inetd bug?

Biff/comsat frequently stop working for us, and it appears always to
follow a kill -1 of inetd, issued in order to re-configure it.  However,
it is not always reproducible.  lastcomm shows that comsat is never
forked;  I have not noticed any other anomalous services.  I haven't tried
to track it down beyond that, but if you want more data let me know what
you want and I'll get it the next time it happens.

From lepreau@utah-cs.ARPA  Wed Mar  5 03:48:13 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA01854; Wed, 5 Mar 86 03:48:13 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA21995; Wed, 5 Mar 86 04:51:06 MST
Date: Wed, 5 Mar 86 04:51:06 MST
From: lepreau@utah-cs.arpa (Jay Lepreau)
Message-Id: <8603051151.AA21995@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: Nasty fsck bug and fix

Summary: it can take more than one fsck run to clean up a filesystem.
Maybe other ill effects too.

This turned up on our root filesys:
Pass 1 found an inode with "unknown file type" which got cleared, but
pass2 didn't pick up the unallocated dir entry.  The next time fsck ran
(after immediate reboot), pass 2 found the unallocated dir entry.  This
of course has horrible consequences on normal filesystems which don't
get the luxury of being fsck'ed twice.

In monet:~lepreau/fsck is a script to demonstrate the error and a log
of a run at Utah.

Fix:
The "statemap" table apparently is supposed to default to USTATE
(unallocated) and get filled in as inodes turn up.  It is calloc'ed and
never initialized otherwise (it can be huge), but in rev 3.3 of fsck.h
(Feb 85) USTATE changed from 0 to 01, and 0 is now unused.  The switch
statement in pass2check() doesn't have a default case, so it
didn't show up there.  I just changed USTATE back to 0.

p.s. Presumably this explains many of our "freeing free inode" panics.
But could it cause a "freeing free frag" panic?  This happened after
the fix to ufs_mount.c was in.

From lepreau@utah-cs.ARPA  Wed Mar  5 04:06:31 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA01874; Wed, 5 Mar 86 04:06:31 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA22261; Wed, 5 Mar 86 05:09:23 MST
Date: Wed, 5 Mar 86 05:09:23 MST
From: lepreau@utah-cs.arpa (Jay Lepreau)
Message-Id: <8603051209.AA22261@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: Fsck correction

Think my analysis was too pessimistic; it looks like a sufficient fix is to add
		statemap[inumber] = USTATE;
in the UNKNOWN FILE TYPE clause in pass1.c.  But then a good idea to
add a firewall default case in the pass2.c switch statement.

From chris@gyre.umd.edu  Wed Mar  5 04:32:53 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA01992; Wed, 5 Mar 86 04:32:53 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA23746; Wed, 5 Mar 86 07:03:03 EST
Date: Wed, 5 Mar 86 07:03:03 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8603051203.AA23746@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: Oops, the last set of changes to rwhod were bogus

Add these on top of those and things should get better.  (I *was*
worried about not finding any open()s that depended on being in
/dev; I forgot about stat().)

Chris

RCS file: RCS/rwhod.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -c2 -r1.2 -r1.3
*** /tmp/,RCSt1023676	Wed Mar  5 07:01:21 1986
--- /tmp/,RCSt2023676	Wed Mar  5 07:01:24 1986
***************
*** 304,307 ****
--- 304,317 ----
  		utmpent = we - mywd.wd_we;
  	}
+ 
+ 	/*
+ 	 * The test on utmpent looks silly---after all, if no one is
+ 	 * logged on, why worry about efficiency?---but is useful on
+ 	 * (e.g.) compute servers.
+ 	 */
+ 	if (utmpent && chdir("/dev")) {
+ 		syslog(LOG_ERR, "chdir(/dev): %m");
+ 		exit(1);
+ 	}
  	we = mywd.wd_we;
  	for (i = 0; i < utmpent; i++) {
***************
*** 321,324 ****
--- 331,338 ----
  		(void) sendto(s, (char *)&mywd, cc, 0,
  			(struct sockaddr *)np->n_addr, np->n_addrlen);
+ 	if (utmpent && chdir(RWHODIR)) {
+ 		syslog(LOG_ERR, "chdir(%s): %m", RWHODIR);
+ 		exit(1);
+ 	}
  done:
  	(void) alarm(AL_INTERVAL);

From joel@ucbarpa.berkeley.edu  Fri Mar  7 09:09:52 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA13649; Fri, 7 Mar 86 09:09:52 PST
Received: by ucbarpa.berkeley.edu (5.45/1.9)
	id AA14846; Fri, 7 Mar 86 09:09:46 PST
Date: Fri, 7 Mar 86 09:09:46 PST
From: joel@ucbarpa.berkeley.edu (Joel Goldberger)
Message-Id: <8603071709.AA14846@ucbarpa.berkeley.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: DMZ Driver

When trying to build a kernel with the updated sources I got the following
errors.  It looks like the merge of the dmz & dmf drivers is in progress.
Please advise.

Thanks,
Joel Goldberger

cc -c -S -I. -I../h -DVENERA -DVAX780 -DVAX8600 -DBUFPAGES="3200" -DMAXDSIZ="64000000" -DNSIP -DNS -DINET -DQUOTA -DKERNEL ../vaxuba/dmz.c
../vaxuba/dmreg.h: 21: DM_CTS redefined
"../vaxuba/dmz.c", line 415: IR_RMSTSC undefined
"../vaxuba/dmz.c", line 416: octet_rmstsc undefined
"../vaxuba/dmz.c", line 416: member of structure or union required
"../vaxuba/dmz.c", line 416: operands of & have incompatible types
"../vaxuba/dmz.c", line 727: IR_RMSTSC undefined
"../vaxuba/dmz.c", line 728: octet_rmstsc undefined
"../vaxuba/dmz.c", line 728: member of structure or union required
"../vaxuba/dmz.c", line 728: operands of & have incompatible types
"../vaxuba/dmz.c", line 770: DMF_ST undefined
"../vaxuba/dmz.c", line 771: DML_USR undefined
"../vaxuba/dmz.c", line 772: DMZ_USRW undefined
"../vaxuba/dmz.c", line 785: DMF_SR undefined
"../vaxuba/dmz.c", line 786: DMZ_USRR undefined
"../vaxuba/dmz.c", line 789: DMF_ST undefined
*** Exit 1

From muller@nprdc.arpa  Sat Mar  8 03:03:25 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA20336; Sat, 8 Mar 86 03:03:25 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA29779; Sat, 8 Mar 86 03:05:42 pst
Date: Sat, 8 Mar 86 03:05:42 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603081105.AA29779@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: more refer bugs

Subject: 'refer' data structures too small
Index:	usr.bin/refer/refer5.c 4.3BSD

Description:

	When multiple citations are made back-to-back and the -b option
	is NOT in effect, refer accumulates the signals (i.e. reference
	numbers or labels) in the array sig.  Currently no checks are
	made for overflows of sig which frequently occur when the -l
	option is used.  Undetected overflows mangle adjacent data and
	in some cases cause core dumps.

	The array sig should be larger than 100 bytes; 200 bytes is a
	better size.  Checks should be made for overflows.

	Note that, in the existing refer5.c, sig is declared:

		static char sig[NLABC];

	but NLABC (the maximum number of references in the entire
	document when -l option is used) is unrelated to the purpose of
	array sig.  Maybe a new constant MXSIG=200 for the size of sig.

	In the function putsig, the content of sig plus additional data
	is copied to the array t1, t1 should be at least as large as
	sig.  Hence t1[MXSIG].  It also should be checked for overflows.

	The capacity of refer to support the -k and -l options 
	is greatly improved at small cost by enlarging certain arrays
	in refer5.c.

	The -l option replaces reference numbers by labels composed of
	the senior author's last name, the date, and a disambiguating
	character (e.g. Kernighan1975a).  When the -l option is used,
	refer stores all labels in array bflab which has size
	NFLAB=2000 bytes.  This size has been exceeded in normal 
	practice; have found NFLAB=3000 to be at least a more 
	satisfactory value.

	When the -l or -k options are used, the maximum number of
	references in a document is limited by NLABC=100.  This is too
	small; NLABC=1000 is recommended.
	
Repeat-By:

	The core dump error due to exceeding the size of arrays sig and
	t1 can be reproduced by by running refer with the -l option on
	a test document "doc1" provided in the attached shar archive.

		refer -l doc1

	To demonstrate the problem where the size of bflab[NFLAB]
	is exceeded, create a second test document by executing
	the provided cshell script "makedoc2":

		/bin/csh makedoc2 > doc2

	This test document, doc2, exacerbates the problem with the
	limited size of bflab[NFLAB] by using long author names.  Run
	refer with the -l option on doc2:

		refer -l doc2

	To demonstrate the restriction imposed by NLABC=100, run refer
	with the -l3,2 option on doc2.  The -l3,2 option reduces the
	size of the labels formed to five bytes (e.g. Ker75) thus
	avoiding the overflow of bflab[NFLAB] demonstrated above.
	Refer will halt at the 100th citation.

		refer -l3,2 doc2

Fix:
	Note that, after making these modifications, the first test
	"refer -l doc1" will report "sig overflow (200)" instead of
	core dumping.  The second test "refer -l doc2" will halt with
	"bflab overflow (3000)" but is will be 50% farther through the
	document.  The third test "refer -l3,2 doc2" runs to
	completion.

*** /usr/src/usr.bin/refer/refer5.c	Mon Aug 26 19:14:26 1985
--- refer5.c	Wed Mar  5 15:26:00 1986
***************
*** 4,13 ****
  
  #include "refer..c"
  #define SAME 0
! #define NFLAB 2000
! #define NLABC 100
  
! static char sig[NLABC];
  static char bflab[NFLAB];
  static char *labtab[NLABC];
  static char *lbp = bflab;
--- 4,14 ----
  
  #include "refer..c"
  #define SAME 0
! #define NFLAB 3000		/* number of bytes to record all labels */
! #define NLABC 1000		/* max number of labels */
! #define MXSIG 200		/* max bytes in aggregate signal */
  
! static char sig[MXSIG];
  static char bflab[NFLAB];
  static char *labtab[NLABC];
  static char *lbp = bflab;
***************
*** 18,24 ****
  putsig (nf, flds, nref, nstline, endline, toindex)   /* choose signal style */
  char *flds[], *nstline, *endline;
  {
! 	char t[100], t1[100], t2[100], format[10], *sd, *stline;
  	int addon, another = 0;
  	static FILE *fhide = 0;
  	int i;
--- 19,25 ----
  putsig (nf, flds, nref, nstline, endline, toindex)   /* choose signal style */
  char *flds[], *nstline, *endline;
  {
! 	char t[100], t1[MXSIG], t2[100], format[10], *sd, *stline;
  	int addon, another = 0;
  	static FILE *fhide = 0;
  	int i;
***************
*** 81,86 ****
--- 82,89 ----
  	if (another && (strcmp(".[\n", sd) != SAME))
  		fprintf(stderr, "File %s line %d: punctuation ignored from: %s",
  			Ifile, Iline, sd);
+ 	if ((strlen(sig) + strlen(t)) > MXSIG)
+ 		err("sig overflow (%d)", MXSIG);
  	strcat(sig, t);
  #if EBUG
  	fprintf(stderr, "sig is now %s leng %d\n",sig,strlen(sig));
***************
*** 107,112 ****
--- 110,117 ----
  	if (bare == 0) {
  		if (!another) {
  			sprintf(t1, "%s%s\%s\n", stline, sig, endline);
+ 			if (strlen(t1) > MXSIG)
+ 				err("t1 overflow (%d)", MXSIG);
  			append(t1);
  			flout();
  			sig[0] = 0;
***************
*** 244,250 ****
  	if (nref > NLABC)
  		err("nref in labc overflow (%d)", NLABC);
  #if EBUG
! 	fprintf(stderr, "lbp up to %d of 2000\n", lbp-bflab);
  #endif
  	return(labc[nref] = x+1);
  }
--- 249,255 ----
  	if (nref > NLABC)
  		err("nref in labc overflow (%d)", NLABC);
  #if EBUG
! 	fprintf(stderr, "lbp up to %d of %d\n", lbp-bflab, NFLAB);
  #endif
  	return(labc[nref] = x+1);
  }
----------------------cut here--------------------------------

#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	doc1
#	makedoc2
# This archive created: Sat Mar  8 01:59:27 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'doc1'" '(560 characters)'
if test -f 'doc1'
then
	echo shar: will not over-write existing file "'doc1'"
else
sed 's/^	X//' << \SHAR_EOF > 'doc1'
	XText.
	X.[
	X%A R. Alooralooalarum
	X%T a0
	X%D 1900
	X.]
	X.[
	X%A R. Bloomtoomtoomterry
	X%T b0
	X%D 1900
	X.]
	X.[
	X%A R. Clanktankerous
	X%T c0
	X%D 1900
	X.]
	X.[
	X%A R. Alooralooalarum
	X%T a1
	X%D 1901
	X.]
	X.[
	X%A R. Bloomtoomtoomterry
	X%T b1
	X%D 1901
	X.]
	X.[
	X%A R. Clanktankerous
	X%T c1
	X%D 1901
	X.]
	X.[
	X%A R. Alooralooalarum
	X%T a2
	X%D 1902
	X.]
	X.[
	X%A R. Bloomtoomtoomterry
	X%T b2
	X%D 1902
	X.]
	X.[
	X%A R. Clanktankerous
	X%T c2
	X%D 1902
	X.]
	X.[
	X%A R. Alooralooalarum
	X%T a3
	X%D 1903
	X.]
	X.[
	X%A R. Bloomtoomtoomterry
	X%T b3
	X%D 1903
	X.]
	X.[
	X%A R. Clanktankerous
	X%T c3
	X%D 1903
	X.]
	X.[
	X%A R. Alooralooalarum
	X%T a4
	X%D 1904
	X.]
SHAR_EOF
if test 560 -ne "`wc -c < 'doc1'`"
then
	echo shar: error transmitting "'doc1'" '(should have been 560 characters)'
fi
fi # end of overwriting check
echo shar: extracting "'makedoc2'" '(412 characters)'
if test -f 'makedoc2'
then
	echo shar: will not over-write existing file "'makedoc2'"
else
sed 's/^	X//' << \SHAR_EOF > 'makedoc2'
	X#! /bin/csh -f 
	X#
	X#	t1:	create refer input to test bflab[] size
	X#
	X#	usage:	t1 | refer -l
	X
	Xecho Text.
	X@ i = 0
	Xwhile ( $i < 100 )
	X	@ year = 1900 + $i
	X	echo More text.
	X	echo '.['
	X	echo %A R. Alooralooalarum
	X	echo %T a$i
	X	echo %D $year
	X	echo '.]'
	X	echo '.['
	X	echo %A R. Bloomtoomtoomterry
	X	echo %T b$i
	X	echo %D $year
	X	echo '.]'
	X	echo '.['
	X	echo %A R. Clanktankerous
	X	echo %T c$i
	X	echo %D $year
	X	echo '.]'
	X	@ i++
	Xend
SHAR_EOF
if test 412 -ne "`wc -c < 'makedoc2'`"
then
	echo shar: error transmitting "'makedoc2'" '(should have been 412 characters)'
fi
chmod +x 'makedoc2'
fi # end of overwriting check
#	End of shell archive
exit 0

From muller@nprdc.arpa  Sat Mar  8 03:04:38 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA20343; Sat, 8 Mar 86 03:04:38 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA29790; Sat, 8 Mar 86 03:06:58 pst
Date: Sat, 8 Mar 86 03:06:58 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603081106.AA29790@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: yet another refer bug

Subject: 'refer' does not fold upper/lowercase when sorting
Index:	usr.bin/refer/refer7.c 4.3BSD

Description:

	Refer should call sort with the -f option so that sorting is
	not case sensitive.  This helps when sorting names such as "von
	Dusseldorf" which should appear with the V's and not after the Z's.

Repeat-By:

	Run refer with the -s option on the test document "doc"
	provided in the attached shar archive.

		refer -s doc

	Refer will sort the citations by senior author's last name.
	With the existing refer, "von\0Dusseldorf" is placed after
	"Zed".  It should be placed between "Adams" and "Zed".  [Note,
	the \0 in "von\0Dussedorf" allows refer to handle the two part
	name as a unit.]

Fix:
*** /usr/src/usr.bin/refer/refer7.c	Thu Feb 16 01:06:27 1984
--- refer7.c	Fri Mar  7 15:29:01 1986
***************
*** 36,42 ****
  	fo = NULL;
  	if (sort) {
  		char comm[100];
! 		sprintf(comm, "sort %s -o %s", tfile, tfile);
  		system(comm);
  	}
  	fi = fopen(tfile, "r");
--- 36,42 ----
  	fo = NULL;
  	if (sort) {
  		char comm[100];
! 		sprintf(comm, "sort -f %s -o %s", tfile, tfile);
  		system(comm);
  	}
  	fi = fopen(tfile, "r");
---------------------cut here----------------------------
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	doc
# This archive created: Sat Mar  8 02:04:36 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'doc'" '(122 characters)'
if test -f 'doc'
then
	echo shar: will not over-write existing file "'doc'"
else
sed 's/^	X//' << \SHAR_EOF > 'doc'
	X.[
	X%A R. Zed
	X%T An Autobiography
	X.]
	X.[
	X%A R. von\0Dusseldorf
	X%T An Autobiography
	X.]
	X.[
	X%A R. Adams
	X%T An Autobiography
	X.]
SHAR_EOF
if test 122 -ne "`wc -c < 'doc'`"
then
	echo shar: error transmitting "'doc'" '(should have been 122 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0

From comay  Tue Mar 11 07:04:44 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA01393; Tue, 11 Mar 86 07:04:44 PST
Date: Tue, 11 Mar 86 07:04:44 PST
From: comay (David S. Comay)
Message-Id: <8603111504.AA01393@monet.berkeley.edu>
Subject: /usr/lib/eign was missing on our copy of beta tape
Apparently-To: beta43_bugs

Description:
	see above
Repeat-By:
	try running `ptx'

From jim%spruce.UUCP@mouton.ARPA  Thu Mar 13 11:53:22 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA11862; Thu, 13 Mar 86 11:53:22 PST
Received: from bellcore.UUCP by mouton.ARPA (4.12/4.7)
	id AA23288; Thu, 13 Mar 86 14:57:45 est
Date: Thu, 13 Mar 86 14:57:44 est
From: jim%spruce.UUCP@mouton.ARPA
Message-Id: <8603131957.AA23288@mouton.ARPA>
To: beta43_bugs@monet.berkeley.edu

help!

i've been installing stuff from the update 'tar', and the new
/bin/sh keeps saying 'no space' when i try to run scripts such
as install. any quick ideas where the problem is?

a few minor things:

1) /usr/src/lib/libc/gen/Makefile ddoesn't know about getusershell.c.
2) /usr/src/lib/libc/vax/gen/Makefile doesn't know about setjmperror.c.
3) /usr/src/bin/awk/tokenscript mistakenly believes 'e' is linked to 'ex'
   instead of 'ed'.
4) /usr/src/etc/Makefile doesn't know that tftpd.c has moved to its own
   subdirectory.

i haven't looked at updating the kernel yet.

--jim

From entropy!hubert@uw-beaver.arpa  Thu Mar 13 14:23:42 1986
Received: by monet.berkeley.edu (5.44/1.9)
	id AA12362; Thu, 13 Mar 86 14:23:42 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA15432; Thu, 13 Mar 86 13:58:19 PST
Return-Path: <entropy!hubert>
Received: by entropy.UUCP (5.31/1.0.Entropy)
	id AA10388; Thu, 13 Mar 86 13:50:12 PST
Date: Thu, 13 Mar 86 13:50:12 PST
From: Steve Hubert <entropy!hubert@uw-beaver.arpa>
Posted-Date: Thu, 13 Mar 86 13:50:12 PST
Message-Id: <8603132150.AA10388@entropy.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: 4.3 Bug Report
Cc: uw-june!bob, burr@uw-ward, lundberg@uw-ward, uw-beaver!oystr,
        uw-beaver!yenbut

I don't have a fix for this report.  I don't know if the bug is in
dump or restore.  Here are the symptoms.

1.) A user had a file called volc.
2.) We did a level 0 dump.
3.) The user removed the file and created a directory with the same name.
4.) We did a level 1 dump.
5.) We had disk problems and had to do a full restore.  We did a restore r
    with the level 0 and a restore r with the level 1 on top of that.

    He ended up with a directory called RSTTMP... in place of the volc
    directory.  The files in it had the right names but contained
    incorrect data (and incorrect permissions and owners).  I didn't
    try to figure out what the problem was.  Could be that things
    didn't happen in the correct order, I suppose.

    We then tried to do a restore x on the level 0 and on the level 1.
    The restore x on the level 0 tape created the file volc and the
    restore x with the level 1 tape wasn't able to create any of the
    files because volc wasn't a directory.

    I'm not sure if this kind of level 0 followed by level 1 restore x
    is even supposed to work so that may or may not be a bug.  But
    certainly the restore r level 0 followed by level 1 problem is a bug.

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 hubert%entropy@uw-beaver.arpa

From allegra!jpl@ucbvax.berkeley.edu  Sun Mar 16 22:13:40 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA09689; Sun, 16 Mar 86 22:13:40 PST
Received: by ucbvax.berkeley.edu (5.45/1.10)
	id AA04104; Sun, 16 Mar 86 22:13:02 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8603170613.AA04104@ucbvax.berkeley.edu>
Date: Sun, 16 Mar 86 16:18:31 EST
To: dvw@ucbvax.berkeley.edu, karn@ucbvax.berkeley.edu,
        ucbvax!monet!beta43_bugs
Subject: syslogd

There are a couple problems with the sample /etc/syslog.conf as delivered.
mail.* is an invalid priority name, and should be mail.info.  There is
also a bug in syslogd.c that causes dameon to be an invalid facility name.
The fix is quite obvious:
    RCS file: syslogd.c,v
    retrieving revision 1.1
    diff  -r1.1 syslogd.c
    930a931
    > 	"daemon",	LOG_DAEMON,

From karels  Mon Mar 17 21:29:05 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA15827; Mon, 17 Mar 86 21:29:05 PST
From: karels (Mike Karels)
Message-Id: <8603180529.AA15827@monet.berkeley.edu>
To: beta43_sites
Cc: allmanagers@ucbvax
Subject: more updates
Date: Mon, 17 Mar 86 21:29:01 PST

I have another handful of updates.  Most of these are things that got left
off last time and were noticed by some of you.  The list of files
and the reasons for their inclusion is below.  The files are in
~ftp/pub/4.3/update/tar.3; the tar file is 174000 bytes.

One other correction: the list of files in the last update was compiled
by Jordan Hayes.

		Mike


The hosttable version of gethostnamadr.c should have been included,
as should <netdb.h>.  Without these, the new versions of route and arp
would not compile.
files: /usr/src/include/netdb.h, /usr/src/lib/libc/net/hosttable/gethostnamadr.c

The dmz driver would not compile without the updated dmzreg.h file.
file: /sys/vaxuba/dmzreg.h

There was a race in soreceive that was discovered here and elsewhere
just after the last update.  The fix is simple.
file: /sys/sys/uipc_socket.c

A few more fixes in tcp: refix transmit if window shrinks (old fix
was too far down); persist isn't cleared if we ack somethine (eg, a FIN);
the input routine needed to call output if all data was acked.
files: /sys/netinet/tcp_{input,output,subr}.c

The bootstrap modifications to allow booting from units other than 0
on 750's have been installed.  In addition, the encoding of unit number,
partition, adaptor and type in r10 to specify the drive partition
to the bootstrap have been changed.  The fields now occupy one byte
each; they are (from most significant to least significant)
adaptor number, unit number, partition, drive type.  Boot scripts
on 780/785's or 8600's that boot from something other than drive 0
will have to be changed when the new bootstrap is installed.
Unix now uses the boot device as root filesystem;
there is a new boot flag (0x20, RB_DFLTROOT) to suppress this.
The new block-0 boots have been tested on hp, hk and ra only.
files: /sys/h/reboot.h /sys/stand/{boot.c,bootxx.c}
	/sys/vax/{locore.s,autoconf.c}
	/sys/mdec/{hp,up,rl,hk,ra}boot.s

From torek  Tue Mar 18 18:36:17 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24135; Tue, 18 Mar 86 18:36:17 PST
Date: Tue, 18 Mar 86 18:36:17 PST
From: torek (Chris Torek)
Message-Id: <8603190236.AA24135@monet.berkeley.edu>
To: beta43_bugs
Subject: inline MAXLINELEN is too small

Index: /sys/vax/inline/inline.h 4.3Beta Fix

Description:
	inline's idea of the maximum input line
	length is far too optomistic.

Repeat-By:
	Difficult to give a short example.  The problem occurs
	with the Pascal compiler, which generates ridiculously long
	identifiers.  I can send you a sample bug generator,
	but it is nearly 60 kbytes.

Quick fix:
	in inline.h, change MAXLINELEN to 1024 or so.
	This may still be too small.

	A better fix might be to have
	inline start with small buffers and allocate.  You could
	also get rid of some multiplies by making it char *line[QUEUESIZE], at
	the same time.

Chris

From chris@gyre.umd.edu  Tue Mar 18 18:44:58 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24172; Tue, 18 Mar 86 18:44:58 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05637; Tue, 18 Mar 86 21:45:01 EST
Date: Tue, 18 Mar 86 21:45:01 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8603190245.AA05637@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: pc2 makefile installs pc2 unstripped

Index: /usr/src/ucb/pascal/pc2/Makefile 4.3Beta Fix

Description:
	A few K of binary, big deal.

Repeat-By:
	inspection

Fix:
	Below.

Chris

RCS file: RCS/Makefile,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1005582	Tue Mar 18 21:43:32 1986
--- /tmp/,RCSt2005582	Tue Mar 18 21:43:33 1986
***************
*** 41,45 ****
  
  install: ${PROG}
! 	install ${PROG} ${DESTDIR}/usr/lib/${PROG}
  
  clean:
--- 41,45 ----
  
  install: ${PROG}
! 	install -s ${PROG} ${DESTDIR}/usr/lib/${PROG}
  
  clean:

From allegra!jpl@ucbvax.berkeley.edu  Tue Mar 18 22:28:41 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24916; Tue, 18 Mar 86 22:28:41 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA16923; Tue, 18 Mar 86 22:28:15 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8603190628.AA16923@ucbvax.berkeley.edu>
Date: Tue, 18 Mar 86 06:53:32 est
To: ucbvax!monet!beta43_bugs
Subject: tty_pty flow control

Near the end of tty_pty.c (line 531)
			pti->pt_send &= TIOCPKT_NOSTOP;
			pti->pt_send |= TIOCPKT_DOSTOP;
should instead be,
			pti->pt_send &= ~TIOCPKT_NOSTOP;
			pti->pt_send |= TIOCPKT_DOSTOP;

John P. Linderman  allegra!jpl

From allegra!jpl@ucbvax.berkeley.edu  Tue Mar 18 22:34:57 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24934; Tue, 18 Mar 86 22:34:57 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA17032; Tue, 18 Mar 86 22:34:33 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8603190634.AA17032@ucbvax.berkeley.edu>
Date: Tue, 18 Mar 86 09:42:31 est
To: ucbvax!monet!beta43_bugs
Subject: sendmail

    From mp@presto Tue Mar 18 09:36:18 1986
    Date: Tue, 18 Mar 86 09:35:46 est
    To: mdpl@vivace
    Subject: Re:  msgs on bebop
    Cc: jpl
    
	From mdpl@vivace Tue Mar 18 08:14:15 1986
	Date: Tue, 18 Mar 86 08:15:22 est
	To: help
	Subject: msgs on bebop
	Status: RO
	
	The mail I sent to "msgs" just got bounced back from bebop
	with the message:
	
	    From MAILER-DAEMON@bebop Tue Mar 18 08:11:41 1986
	    Date: Tue, 18 Mar 86 08:10:33 est
	    Subject: Returned mail: Internal error
	    To: <mdpl@vivace>
	    
	       ----- Transcript of session follows -----
	    451 endmailer sh: wait: No children
	    554 "|/usr/ucb/msgs -s"... Internal error
    
	    <followed by a copy of the message>
	
	Is this a temporary problem? permanent problem? non-problem? feature?
									Mary
	
	[I told her I'd take a quick look.  There was a new sendmail tacked onto
	the end of the release tape.  I didn't find out about it until I had
	already installed everything else.  Thinks it's worth extracting and
	trying, Mark?]
	    
    I fixed the "No children" error.  In the part of the code that forks
    off a sendmail for each new network connection, they do a
    signal(SIGCHLD, reapchild).  But they never reset the signal
    disposition back to the default, which means wait() is ALWAYS going to
    claim there are no children....
    
	Mark

From allegra!jpl@ucbvax.berkeley.edu  Tue Mar 18 22:35:18 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24941; Tue, 18 Mar 86 22:35:18 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA17042; Tue, 18 Mar 86 22:34:58 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8603190634.AA17042@ucbvax.berkeley.edu>
Date: Tue, 18 Mar 86 10:58:53 EST
To: ucbvax!monet!beta43_bugs
Subject: vaxuba

There are several devices (dhu,dn,lp,uu) whose standard address lists
are not null terminated.  Just
  cd /sys/vaxuba; grep std *.c
for a complete list.

From allegra!jpl@ucbvax.berkeley.edu  Tue Mar 18 22:36:53 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA24952; Tue, 18 Mar 86 22:36:53 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA17081; Tue, 18 Mar 86 22:36:32 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8603190636.AA17081@ucbvax.berkeley.edu>
Date: Tue, 18 Mar 86 16:00:32 EST
To: ucbvax!monet!beta43_bugs
Subject: find

Your -newer option is busted, just like System V's.  If you try to use
more than 1 -newer, like
    \( -name \*.c -newer base.c \) -o \( -name \*.h -newer base.h \)
all of them will use the same file time.  I fixed that (and tried to sneak
in a bunch of new options, like -newerca, to compare the argument's inode
change time to the file's access time), but even if you don't like the new
operations, at least use the Newer array stuff.

I see my CROSSFS=no idea got in as -xdev.  You can pretend it's not a
global option, by making it an operation, but the fact is, the effect is
global as implemented.  For example
    find /mounted /dir -name /mounted/\* -xdev ...
turns off descent under /dir just as it does under /mounted.  Oh well,
better as -xdev than not at all.

30,32c30
< #define	NNEW	50
< int	Nnewer;
< time_t	Newer[NNEW];
---
> long	Newer;
232,234c230
< 	else if(strncmp(a, "-newer", 6) == 0) {
< 		char *p =        a + 6;
< 		time_t *t1p, *t2p;
---
> 	else if(EQ(a, "-newer")) {
239,278c235,236
< 		if(Nnewer >= NNEW) {
< 			fprintf(stderr, "find: too many -newer constructs\n");
< 			exit(1);
< 		}
< 		t1p = t2p = &(Statb.st_mtime);
< 		switch (*p) {
< 		case 'm':
< 		    p++;
< 		    break;
< 		case '\0':
< 		    break;
< 		case 'a':
< 		    t1p = &(Statb.st_atime);
< 		    p++;
< 		    break;
< 		case 'c':
< 		    t1p = &(Statb.st_ctime);
< 		    p++;
< 		    break;
< 		}
< 		switch (*p) {
< 		case 'm':
< 		    p++;
< 		    break;
< 		case '\0':
< 		    break;
< 		case 'a':
< 		    t2p = &(Statb.st_atime);
< 		    p++;
< 		    break;
< 		case 'c':
< 		    t2p = &(Statb.st_ctime);
< 		    p++;
< 		    break;
< 		}
< 		if (*p == '\0') {
< 		    Newer[Nnewer] = *t2p;
< 		    return mk(newer, (struct anode *)t1p,
< 				     (struct anode *)(&Newer[Nnewer++]));
< 		}
---
> 		Newer = Statb.st_mtime;
> 		return mk(newer, (struct anode *)0, (struct anode *)0);
470,471c428
< newer(p)
< register struct { int f; time_t *t1, *t2; } *p;
---
> newer()
473c430
< 	return *(p->t1) > *(p->t2);
---
> 	return Statb.st_mtime > Newer;

From shannon%datsun@SUN.ARPA  Wed Mar 19 09:39:15 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA26405; Wed, 19 Mar 86 09:39:15 PST
Received: from snail.sun.uucp (snail-ptp) by sun.arpa (3.2-/SMI-3.0)
	id AA18229; Wed, 19 Mar 86 09:36:01 PST
Received: from datsun.sun.uucp by snail.sun.uucp (3.2-/SMI-3.0DEV4)
	id AA11801; Wed, 19 Mar 86 01:12:11 PST
Received: by datsun.sun.uucp (3.0/SMI-3.0DEV3)
	id AA00291; Wed, 19 Mar 86 01:13:38 PST
Date: Wed, 19 Mar 86 01:13:38 PST
From: shannon%datsun@SUN.ARPA (Bill Shannon)
Message-Id: <8603190913.AA00291@datsun.sun.uucp>
To: beta43_bugs@monet.berkeley.edu
Subject: at, atq, atrm bugs

From dss@fatkid Tue Mar 18 15:15:53 1986
To: shannon@datsun
Subject: 4.3 at

		    BUGS IN BERKELEY 4.3 AT/ATQ/ATRM

	/usr/bin/at
1: If no file name is specified, at just exits. The man pages specify that
   it will prompt at the terminal for command input.

2: If the time is given with the keyword 'week', it is not parsed correctly
   unless a day or month&day is specified.  The example in the man page:
	at -s -m 1200n week [file]
   prints the message: 'week: no such file or directory'

3: The man page states that 'time' is 1 to 4 digits, with an optional 'A',
   'P', 'N', or 'M'.  In fact, 0 digits are also parsed legally, with 'A'
   or 'M' converting to midnight and 'P' or 'N' converting to noon.  If
   'N' or 'M' are specified, the rest of the digits are ignored, even if
   out of range, e.g.:
	at 9999n file
    schedules 'file' to run at noon.

4: The new at command has a syntax for allowing -c or -s to specify /bin/csh
   or /bin/sh.  If neither are present, the shell is taken from the SHELL
   environment variable.  The man page should explicitly state that leading
   #!/bin/sh -type specifiers are always ignored.


	/usr/bin/atq
1: If atq is setuid, owned by root, and executed by root with the command:
	#atq
   it dumps core.  If it is owned by daemon, it does not.

2: The command atq with no arguments should print the entire queue.  Instead,
   it prints nothing (i.e., the user-name is not optional).

3: The atq man page should specify that the -c flag causes atq to sort the
   list backwards (most recent entered command first).


	/usr/bin/atrm
1: If atrm is setuid, owned by root, and executed by root with the command:
	#atrm -
   it dumps core.  If it is owned by daemon, it does not.

2: The command 'atrm -' never removes anything from the queue (i.e., the
   user-name and/or job id must be specified).

3: There is no syntax for the super-user to remove all jobs from the queue,
   regardless of owner.  In conjunction with the -i (interactive) option,
   this could be useful.

4: If the command:
	atrm 123 456 user
   is given, and 'user' owns any of the specified job numbers, an error
   message is printed when atrm tries to remove entries twice.


From karels@monet.berkeley.edu  Wed Mar 19 13:47:41 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA27287; Wed, 19 Mar 86 13:47:41 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA05677; Wed, 19 Mar 86 13:47:14 PST
Received: by monet.berkeley.edu (5.44/1.11)
	id AA27281; Wed, 19 Mar 86 13:47:05 PST
From: karels@monet.berkeley.edu (Mike Karels)
Message-Id: <8603192147.AA27281@monet.berkeley.edu>
To: allegra!jpl@ucbvax.berkeley.edu
Cc: ucbvax!monet!beta43_bugs
Subject: Re: sendmail 
In-Reply-To: Your message of Tue, 18 Mar 86 09:42:31 EST.
Date: Wed, 19 Mar 86 13:47:03 PST

You should talk to Jim McKie about getting the updates to the beta tape.
All of the bugs that you reported have been fixed some time ago
except the find bug.  Perhaps Jim has an archive of the mail that
has been sent to the beta sites as well.

		Mike

From whm@arizona.edu  Fri Mar 21 15:38:30 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA10988; Fri, 21 Mar 86 15:38:30 PST
Received: by arizona.arizona.edu; Fri, 21 Mar 86 16:29:16 MST
Date: Fri, 21 Mar 86 16:29:14 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8603212329.AA11931@megaron.arizona.edu>
Received: by megaron.arizona.edu; Fri, 21 Mar 86 16:29:14 MST
To: beta43_sites@monet.berkeley.edu
Subject: Anybody running Stanford's V under 4.3?

Has anybody got Stanford's V running under 4.3?  (I checked with Stanford
and they didn't know of anyone.)  They say it should be "a snap", but then
they say that they don't know how 4.3 might affect things.

They went on to say that were expecting that their "enet" packet filter
would be in 4.3.  Mike et al.: Do you expect this to be done?  (I checked
monet:/sys and didn't see any evidence of it.)

					Thanks,
					Bill Mitchell

From chris@gyre.umd.edu  Fri Mar 21 19:11:01 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA15397; Fri, 21 Mar 86 19:11:01 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA00354; Fri, 21 Mar 86 22:11:10 EST
Date: Fri, 21 Mar 86 22:11:10 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8603220311.AA00354@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: pc's handling of write(var:size) is inconsistent

Index: /usr/src/ucb/pascal/src/proc.c 4.3Beta

Description:
	pc -C produces runtime checks for field widths that are
	not consistent with the compile time checks.

Repeat-By:
	Compile the following:

		program bug(output);
		var i : integer;
		begin writeln(47 : 0);
		   i := 0;
		   writeln(47 : i)
		end.

	with `pc -C' and run the executable.  It prints

		47

		Non-positive format width: 0
		Trace/BTP trap (core dumped)

	It should let the 0 go by unless the `s' option were specified.
	(It does this with constant format widths.)

(So I guess it should have two different runtime checks, or maybe
just outlaw 0 widths completely...)

From chris@gyre.umd.edu  Sat Mar 22 10:29:41 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA18917; Sat, 22 Mar 86 10:29:41 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA02725; Sat, 22 Mar 86 13:30:18 EST
Date: Sat, 22 Mar 86 13:30:18 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8603221830.AA02725@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: kernacc() is too trusting

Index: /sys/vax/locore.s 4.3Beta Fix

Description:
	kernacc() is not paranoid enough about its parameters.
	If you feed it a request that crosses P1/SYSTEM space,
	it can look at some strange pte's.

Repeat-By:
	Inspection (the crasher that appeared in net.bugs.4bsd
	does not crash on my kernel, at any rate).

Fix: (untested)
	Seems as though something that crosses P1 and SYS space
	should just probe the regions separately, but no current
	program tries to do this, so the following should suffice:

	After the movl 4(ap),r0 line, add the lines

		bicl3	$0x3fffffff,r0,r1
		addl3	8(ap),r0,r2	# ending virtual address
		bicl2	$0x3fffffff,r2
		cmpl	r1,r2		# same region?
		bneq	kacerr		# no, disallow it

	Alternatively, you could stick a check in the section
	that has detected P1 space, since any other crossover
	is bound to hit an invalid page eventually.

Chris

From allegra!mp@ucbvax.berkeley.edu  Sat Mar 22 22:15:41 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA20753; Sat, 22 Mar 86 22:15:41 PST
Received: by ucbvax.berkeley.edu (5.45/1.11)
	id AA10554; Sat, 22 Mar 86 22:15:21 PST
From: allegra!mp@ucbvax.berkeley.edu
Message-Id: <8603230615.AA10554@ucbvax.berkeley.edu>
Date: Sat, 22 Mar 86 14:27:33 est
To: ucbvax!monet!beta43_bugs
Subject: /usr/doc/sendmail

the files in that directory seem to be about 50% to 90% NULs.
/usr/src/usr.lib/sendmail/doc/* seem to be OK.

From chris@mimsy.umd.edu  Mon Mar 24 19:01:26 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA00697; Mon, 24 Mar 86 19:01:26 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA15465; Mon, 24 Mar 86 22:01:46 EST
Date: Mon, 24 Mar 86 22:01:46 EST
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8603250301.AA15465@mimsy.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: select does not guard against negative uap->nd

Index: /sys/sys/sys_generic.c 4.3Beta Fix

Description:
	A negative first argument to select could conceivably
	cause a crash.

Repeat-By:
	I am not sure I could craft a program on the fly that
	would do anything drastic, but the idea is to get

		(unsigned)(ni * sizeof(fd_mask))

	to be a large positive number, so that copyin() will
	copy a few pages over top of the stack before running
	into an inaccessible address.

	Hm, sizeof(fd_mask) is 4, so NFDBITS is 32, so since
	ni = (uap->nd+31)/32, say I use -32: I get ni = -1,
	which gives ((unsigned) -4) to copyin. Try

		#include <sys/types.h>
		char space[10000];
		main(){(void)select(-32,space,0,0,0);}

	on for size....

	No, that will not do it, since copyin does not like `negative'
	lengths.  Well, ok, I guess it cannot be crashed this way
	(the most negative value for ni is -67108864, which turns
	into -268435456 to copyin, which is still negative).  Still,
	it seems worth touching up to me.

Fix:
	Change select's struct uap to

		unsigned nd;
		fd_set	*in, *ou, *ex;
		struct	timeval *tv;

	or handle uap->nd < 0 early.

	Incidentally, it might save some time (though it would be
	more than just `slightly' wrong) to limit uap->nd at
	u.u_lastfile.

Chris

From bin%coutet@mouton.ARPA  Tue Mar 25 15:18:25 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA01318; Tue, 25 Mar 86 15:18:25 PST
Received: from coutet.UUCP (chuck) by mouton.ARPA (4.12/4.7)
	id AA02995; Tue, 25 Mar 86 18:21:34 est
Received: by coutet.UUCP (5.28/4.7)
	id AA02122; Tue, 25 Mar 86 18:12:25 EST
Date: Tue, 25 Mar 86 18:12:25 EST
From: bin%coutet@mouton.ARPA (The Garbage Collector)
Message-Id: <8603252312.AA02122@coutet.UUCP>
Apparently-To: beta43_bugs@monet.berkeley.edu

either you forgot to send it in the latets updates, but
/sys/stand/hp.old.c should have the 'hptypes' definition
replaced by

extern short hptypes[];

--jim

From muller@nprdc.arpa  Tue Mar 25 21:33:49 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA03599; Tue, 25 Mar 86 21:33:49 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06006; Tue, 25 Mar 86 21:10:15 pst
Date: Tue, 25 Mar 86 21:10:15 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8603260510.AA06006@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: bug report update

I was looking over copies of some bug reports mailed in last month and
spotted a case where I was vague in one report. The report (which I
include below) involved failures by nroff to handle 7725 series of NEC
printers. I included a driver table and said it "replaced" the
tabnec-t.c driver. What I should have said was "that it replaced the tabnec-t.c
table for the 7725".  There is nothing wrong with the 77?0 driver (NEC CODE).
This is a new driver for the DIABLO version of the SAME hardware. We have
almost 60 of these diablo versions at UCSD and I understand there are almost
400 of them in the UC system.

------------------------------------------------------------------------------
Subject: nroff table for NEC 7725/5525
Index:	usr.bin/nroff/term 4.3BSD

Description:
	NEC makes a series of printers (77?0/55?0) which use NEC's own escape
	sequences, and they make another series of printers (7725/5525) which
	use Diablo escape sequences. The distributed NEC related nroff tables,
	tabnec, tabnec-12, and tabnec-t, are all for 77?0/55?0 series and they
	do not work for the NEC 7725/5525 models.

	A special table (attached) is required for the 7725/5525 models when
	using the "Times Roman/Technical Math" print thimble. The combination
	of the Diablo escape sequences and the "Times Roman/Technical Math"
	print thimble that makes a special nroff table necessary. The normal
	nroff tables for diablos do not work as they do not descibe the
	NEC "Times Roman/Technical Math" thimble.

Repeat-By:
	Run nroff with input requiring half-line motion on
	a model NEC model 7725 using -Tnec-t; the escape
	sequences print as garbage.

		echo "\u2\d" | nroff -Tnec-t
	
Fix:
	Add the NEW special nroff driving table to 
	src/usr.bin/nroff/term/tabnec25-t.c and modify the makefile.
	Document the change in src/usr.bin/nroff/term/README

RCS file: RCS/README,v
retrieving revision 1.1
diff -c -r1.1 README
*** /tmp/,RCSt1018146	Tue Mar 25 20:48:43 1986
--- README	Tue Mar 25 20:47:27 1986
***************
*** 20,25
  nec		NEC 55?0 or NEC 77?0 Spinwriter
  nec12		NEC 55?0 or NEC 77?0 Spinwriter, 12 pitch
  nec-t		NEC 55?0/77?0 Spinwriter, Tech-Math/Times-Roman thimble
  qume		Qume Sprint 5 or 9
  qume12		Qume Sprint 5 or 9, 12 pitch
  xerox		Xerox 17?0 or Diablo 16?0

--- 20,26 -----
  nec		NEC 55?0 or NEC 77?0 Spinwriter
  nec12		NEC 55?0 or NEC 77?0 Spinwriter, 12 pitch
  nec-t		NEC 55?0/77?0 Spinwriter, Tech-Math/Times-Roman thimble
+ nec25-t		NEC 5525/7725 Spinwriter, Tech-Math/Times-Roman thimble
  qume		Qume Sprint 5 or 9
  qume12		Qume Sprint 5 or 9, 12 pitch
  xerox		Xerox 17?0 or Diablo 16?0

RCS file: RCS/Makefile,v
retrieving revision 1.1
diff -c -r1.1 Makefile
*** /tmp/,RCSt1016918	Tue Mar 25 13:17:33 1986
--- Makefile	Tue Mar 25 13:01:58 1986
***************
*** 7,13
  #	make links	make links for ease of documentation
  #	make clean	remove tab*.o files lying around
  ALL=	37 lpr 300 300-12 302 302-12 382 382-12 450 450-12 833 833-12 \
! 	epson itoh itoh12 nec nec12 nec-t qume qume12 xerox xerox12 \
  	x-ecs x-ecs12
  DESTDIR=
  DEST=	${DESTDIR}/usr/lib/term

--- 7,13 -----
  #	make links	make links for ease of documentation
  #	make clean	remove tab*.o files lying around
  ALL=	37 lpr 300 300-12 302 302-12 382 382-12 450 450-12 833 833-12 \
! 	epson itoh itoh12 nec nec12 nec-t nec25-t qume qume12 xerox xerox12 \
  	x-ecs x-ecs12
  DESTDIR=
  DEST=	${DESTDIR}/usr/lib/term
***************
*** 32,37
  nec:	tabnec.o code.nec
  nec12:	tabnec12.o code.nec
  nec-t:	tabnec-t.o
  qume:	tabqume.o
  qume12:	tabqume12.o
  xerox:	tabxerox.o code.xerox

--- 32,38 -----
  nec:	tabnec.o code.nec
  nec12:	tabnec12.o code.nec
  nec-t:	tabnec-t.o
+ nec25-t:tabnec25-t.o
  qume:	tabqume.o
  qume12:	tabqume12.o
  xerox:	tabxerox.o code.xerox
----------------------- cut here (start of tabnec25-t.c) ---------------------
#define INCH 240
/*
NEC Spinwriter 7725 and 5525 (Diablo replacements)
with Technical Math/Times Roman thimble
12 chars/inch, 6 lines/inch
nroff driving tables
width and code tables
*/

struct {
	int bset;
	int breset;
	int Hor;
	int Vert;
	int Newline;
	int Char;
	int Em;
	int Halfline;
	int Adj;
	char *twinit;
	char *twrest;
	char *twnl;
	char *hlr;
	char *hlf;
	char *flr;
	char *bdon;
	char *bdoff;
	char *ploton;
	char *plotoff;
	char *up;
	char *down;
	char *right;
	char *left;
	char *codetab[256-32];
	int zzz;
	} t = {
/*bset*/	0,
/*breset*/	0177420,
/*Hor*/		INCH/60,
/*Vert*/	INCH/48,
/*Newline*/	INCH/6,
/*Char*/	INCH/12,
/*Em*/		INCH/12,
/*Halfline*/	INCH/12,
/*Adj*/		INCH/12,
/*twinit*/	"\0334\033\037\013",
/*twrest*/	"\0334\033\037\015",
/*twnl*/	"\015\n",
/*hlr*/		"\033D",
/*hlf*/		"\033U",
/*flr*/		"\033\n",
/*bdon*/	"",
/*bdoff*/	"",
/*ploton*/	"\0333",
/*plotoff*/	"\0334",
/*up*/		"\033\n",
/*down*/	"\n",
/*right*/	" ",
/*left*/	"\b",
/*codetab*/
"\001 ",	/*space*/
"\001!",	/*!*/
"\002\200\047\202\047",	/*"*/
"\001#",	/*#*/
"\001\200|\341S\301",	/*$*/
"\001%",	/*%*/
"\000",	/*&*/
"\001'",	/*' close*/
"\001(",	/*(*/
"\001)",	/*)*/
"\001*",	/***/
"\001+",	/*+*/
"\001,",	/*,*/
"\001-",	/*- hyphen*/
"\001.",	/*.*/
"\001/",	/*/*/
"\2010",	/*0*/
"\2011",	/*1*/
"\2012",	/*2*/
"\2013",	/*3*/
"\2014",	/*4*/
"\2015",	/*5*/
"\2016",	/*6*/
"\2017",	/*7*/
"\2018",	/*8*/
"\2019",	/*9*/
"\001:",	/*:*/
"\001:\b,",	/*;*/
"\001<",	/*<*/
"\001=",	/*=*/
"\001>",	/*>*/
"\001?",	/*?*/
"\001@",	/*@*/
"\201A",	/*A*/
"\201B",	/*B*/
"\201C",	/*C*/
"\201D",	/*D*/
"\201E",	/*E*/
"\201F",	/*F*/
"\201G",	/*G*/
"\201H",	/*H*/
"\201I",	/*I*/
"\201J",	/*J*/
"\201K",	/*K*/
"\201L",	/*L*/
"\201M",	/*M*/
"\201N",	/*N*/
"\201O",	/*O*/
"\201P",	/*P*/
"\201Q",	/*Q*/
"\201R",	/*R*/
"\201S",	/*S*/
"\201T",	/*T*/
"\201U",	/*U*/
"\201V",	/*V*/
"\201W",	/*W*/
"\201X",	/*X*/
"\201Y",	/*Y*/
"\201Z",	/*Z*/
"\001[",	/*[*/
"\001\016\112\017",	/*\*/
"\001]",	/*]*/
"\001\344.\201\341.\201\301.\242\304",	/*^*/
"\001_",	/*_ dash*/
"\001'",	/*` open*/
"\201a",	/*a*/
"\201b",	/*b*/
"\201c",	/*c*/
"\201d",	/*d*/
"\201e",	/*e*/
"\201f",	/*f*/
"\201g",	/*g*/
"\201h",	/*h*/
"\201i",	/*i*/
"\201j",	/*j*/
"\201k",	/*k*/
"\201l",	/*l*/
"\201m",	/*m*/
"\201n",	/*n*/
"\201o",	/*o*/
"\201p",	/*p*/
"\201q",	/*q*/
"\201r",	/*r*/
"\201s",	/*s*/
"\201t",	/*t*/
"\201u",	/*u*/
"\201v",	/*v*/
"\201w",	/*w*/
"\201x",	/*x*/
"\201y",	/*y*/
"\201z",	/*z*/
"\001{",	/*{*/
"\001|",	/*|*/
"\001}",	/*}*/
"\001\343\016\074\017\303",	/*~*/
"\000\0",	/*narrow sp*/
"\001-",	/*hyphen*/
"\001O\b+",	/*bullet*/
"\002\[]",	/*square*/
"\001-",	/*3/4 em*/
"\001_",	/*rule*/
"\2031/4",	/*1/4*/
"\2031/2",	/*1/2*/
"\2033/4",	/*3/4*/
"\001-",	/*minus*/
"\202fi",	/*fi*/
"\202fl",	/*fl*/
"\202ff",	/*ff*/
"\203ffi",	/*ffi*/
"\203ffl",	/*ffl*/
"\001\343o\303",	/*degree*/
"\001\342-\302|",	/*dagger*/
"\001\342s\302s",	/*section*/
"\001'",	/*foot mark*/
"\001'",	/*acute accent*/
"\001\345.\201\301.\201\304",	/*grave accent*/
"\001_",	/*underrule*/
"\001/",	/*slash (longer)*/
"\000\0",	/*half narrow space*/
"\001 ",	/*unpaddable space*/
"\001\016\123\017",	/*alpha*/
"\001\046",	/*beta*/
"\001\016\107\017",	/*gamma*/
"\001\016\113\017",	/*delta*/
"\001\016\116\017",	/*epsilon*/
"\001\200c\201\301,\241\343<\302",	/*zeta*/
"\001\016\114\017",	/*eta*/
"\001O\b-",	/*theta*/
"\001i",	/*iota*/
"\001k",	/*kappa*/
"\001\016\102\017",	/*lambda*/
"\001\073",	/*mu*/
"\001\241(\203/\242",	/*nu*/
"\001\016\104\017",	/*xi*/
"\001o",	/*omicron*/
"\001\042",	/*pi*/
"\001\016\106\017",	/*rho*/
"\001\016\126\017",	/*sigma*/
"\001\016\103\017",	/*tau*/
"\001v",	/*upsilon*/
"\001o\b/",	/*phi*/
"\001x",	/*chi*/
"\001\200/-\301\202'\244'\202\341",	/*psi*/
"\001\016\130\017",	/*omega*/
"\001\242|\202\344-\304\342\202'\242\302",	/*Gamma*/
"\001\016\101\017",	/*Delta*/
"\001O\b=",	/*Theta*/
"\002/\242\016\112\017\202",	/*Lambda*/
"\001\341_\346_\307\341-\301",	/*Xi*/
"\001\242[]\204[]\242\343-\303",	/*Pi*/
"\001\341>\301\302-\346-\304\241",	/*Sigma*/
"\000\0",	/**/
"\001Y",	/*Upsilon*/
"\001o\b[\b]",	/*Phi*/
"\001\200[]-\301\202'\244'\202\341",	/*Psi*/
"\001\134",	/*Omega*/
"\001\301-\341\202\303'\202\343/\244",	/*square root*/
"\001\341s\301\202'\242",	/*terminal sigma*/
"\001\343-\303",	/*root en*/
"\001>\b_",	/*>=*/
"\001<\b_",	/*<=*/
"\001=\b_",	/*identically equal*/
"\001-",	/*equation minus*/
"\001=\b\344\016\074\017\304",	/*approx =*/
"\001\016\074\017",	/*approximates*/
"\001=\b/",	/*not equal*/
"\002 \245-\204->\201",	/*right arrow*/
"\002 \245<-\204-\201",	/*left arrow*/
"\001\016\132\017",	/*up arrow*/
"\001\016\136\017",	/*down arrow*/
"\001=",	/*equation equal*/
"\001x",	/*multiply*/
"\001\200.-\345.\305",	/*divide*/
"\001+\b_",	/*plus-minus*/
"\001U",	/*cup (union)*/
"\001\343\140\203\136\243\303",	/*cap (intersection)*/
"\002 \242\245\341(\301\341\204_\346_\203\307",	/*subset of*/
"\002 \243\341_\346_\307\204\341)\301\241",	/*superset of*/
"\002 \242\245\341(\301\341\204_\346_\307_\203",	/*improper subset of*/
"\002 \243_\341_\346_\307\341\204)\301\241",	/*improper superset of*/
"\001\016\137\017",	/*infinity*/
"\001\016\115\017",	/*partial derivative*/
"\001\200\016\112\017\203/\243\344\201-\201-\304\242",	/*gradient*/
"\001\200-\202\343,\303\242",	/*not*/
"\001\044",	/*integral sign*/
"\001\016\135\017",	/*proportional to*/
"\0010\b/",	/*empty set*/
"\001\200(\201-\241",	/*member of*/
"\001+",	/*equation plus*/
"\003(r)",	/*registered*/
"\003(c)",	/*copyright*/
"\001|",	/*box rule */
"\001c\b/",	/*cent sign*/
"\001\341=\301|",	/*dbl dagger*/
"\002*>",	/*right hand*/
"\002<*",	/*left hand*/
"\001*",	/*math * */
"\003(b)",	/*bell system sign*/
"\001|",	/*or (was star)*/
"\001O",	/*circle*/
"\001|",	/*left top (of big curly)*/
"\001|",	/*left bottom*/
"\001|",	/*right top*/
"\001|",	/*right bot*/
"\001|",	/*left center of big curly bracket*/
"\001|",	/*right center of big curly bracket*/
"\001|",	/*bold vertical*/
"\001\201\016\076\017\241",	/*left floor (left bot of big sq bract)*/
"\001\241\016\100\017\201",	/*right floor (right bot ")*/
"\001\201\140\241",	/*left ceiling (lt of ")*/
"\001\241\136\201"};	/*right ceiling (rt of ")*/

From mcvax!wcwvax!aljol@seismo.CSS.GOV  Wed Mar 26 13:23:59 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA06855; Wed, 26 Mar 86 13:23:59 PST
Return-Path: <mcvax!wcwvax!aljol>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Wed, 26 Mar 86 15:46:32 EST
From: mcvax!wcwvax!aljol@seismo.CSS.GOV
Received: by mcvax.uucp; Wed, 26 Mar 86 12:22:04 +0100 (MET)
Received: from cs.ucl.ac.uk by eagle.Ukc.AC.UK   via Janet with NIFTP
           id a026803; 26 Mar 86 7:37 GMT
Received: from wcwvax by 44d.Cs.Ucl.AC.UK   with UUCP  id a005877;
          26 Mar 86 7:59 BST
Received: by wcwvax.UUCP (4.12/4.7)
	id AA04306; Wed, 26 Mar 86 02:10:53 GMT
Message-Id: <8603260210.AA04306@wcwvax.UUCP>
Date: Wed 26 Mar 1986 01:32:40 GMT
Subject: mmap
To: mcvax!beta43_bugs@seismo.CSS.GOV,
        monet.berkeley.edu!beta43_bugs@cs.ucl.ac.uk


Please forgive me for perhaps abusing this address, but I think it's
likely that the people who read this message are the ones I want to
contact.

The 4.2BSD System Manual describes a system call 'mmap', planned for
later releases of the system.  I understand from some contacts at a beta-site 
that it still isn't implemented in the beta release of 4.3.
Some (much?) of the code already exists but is "notdef"ed out.

We have ported 4.2 to the workstations we manufacture (MG-1 & CG-1),
and we intend to port 4.3 when it is available.  

A number of our customers add their own devices to our machine and
would find it convenient to map hardware addresses into user process
memory, (like the V7 'phys' system call).  I believe this is one of the
things which ought to be possible with 'mmap'.

So my questions are:

Will mmap be available in the near future?

Is there something seriously wrong with the "notdef"ed code that we
couldn't use it now?  

Are there any guidelines for writing the device-specific mmap code
(that would be called via cdevsw), particularly for /dev/mem?

Thank you for your attention

Alan Jolley

Whitechapel Computer Works	  	Email: ..seismo!mcvax!ukc!wcwvax!aljol
75 Whitechapel Road
London E1 1DU				Phone:	(+44) 01 377 8680
England				        Telex:  885300


From dlu%tektools%tektronix.csnet@CSNET-RELAY.ARPA  Wed Mar 26 22:15:34 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA09898; Wed, 26 Mar 86 22:15:34 PST
Received: from tektronix by csnet-relay.csnet id an05171; 26 Mar 86 18:50 EST
Received: by tektronix (5.31/5.14)
	id AA11329; Wed, 26 Mar 86 15:09:58 PST
Received: by tektools (5.31/5.14)
	id AA26166; Wed, 26 Mar 86 15:08:28 PST
Message-Id: <8603262308.AA26166@tektools>
To: beta43_bugs%monet.berkeley.edu%csnet-relay%tektronix.csnet@CSNET-RELAY.ARPA
Subject: /lib/ccom incorrectly removes symbols when clearing symbol table
Date: 26 Mar 86 15:08:24 PST (Wed)
From: dlu%tektools%tektronix.csnet@CSNET-RELAY.ARPA


------- Forwarded Message

>From: tektronix!sutton (Carl Sutton)

Subject: /lib/ccom incorrectly removes symbols when clearing symbol table
Index:	lib/mip/pftn.c 4.3BSD

Description:
	The type of a symbol is set to NULL rather than TNULL
	in clearst() when the symbol hashing is cleaned up.

	This shows up as a problem when a symbol is freed, 
	the hash bucket incorrectly compressed,
	and another symbol (S) is subsequently
	hidden in that same bucket.  When the current definition
	of S is referenced, the symbol table entry incorrectly moved
	during the compression is found before the 
	correct reference.

Repeat-By:
	It is kind of hard to produce a test case because the
	location of symbols in the table is determined by the 
	hash code.  We happened to have a program with enough
	symbols for some of the hash buckets to overflow.

	A test case may be built with a slight modification of
	the compiler.

	1) Turn off hashing in lookup() by setting i to some value.
	2) Attempt to compile the following code:

	foo(bar)
	char *bar;
	{
		char *index();
	}
	foo1()
	{
		int index;
	
		index = 1;
	}

	   When the index assignment is encountered, index
	   is reported as undefined.

Fix:
	Souce code diffs follow:
RCS file: RCS/pftn.c,v
retrieving revision 1.1
diff -c -r1.1 pftn.c
*** /tmp/,RCSt1015639	Thu Mar 20 11:53:55 1986
- --- pftn.c	Wed Mar 19 12:50:30 1986
***************
*** 1898,1904
  			if( q == p || q->stype == TNULL )break;
  			if( (r = relook(q)) != q ) {
  				*r = *q;
! 				q->stype = NULL;
  				}
  			}
  		p = p->snext;

- --- 1898,1904 -----
  			if( q == p || q->stype == TNULL )break;
  			if( (r = relook(q)) != q ) {
  				*r = *q;
! 				q->stype = TNULL;
  				}
  			}
  		p = p->snext;

------- End of Forwarded Message

From lepreau  Fri Mar 28 04:42:57 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA17943; Fri, 28 Mar 86 04:42:57 PST
Date: Fri, 28 Mar 86 04:42:57 PST
From: lepreau (Jay Lepreau)
Message-Id: <8603281242.AA17943@monet.berkeley.edu>
To: van
Subject: patch bug with -c1 diffs
Cc: beta43_bugs

Any chance you will have time to work on this soon?
Some of us frequently use -c1 diffs cause they are much less
voluminous than -c yet give some context for patch (and humans).
Reminder: the files are in monet:~lepreau/patchbug.

The other bug, freeing a free area on a new context diff
is academic since the non-debugging malloc deals with this ok.
This is in ~lepreau/patchbug2.

From comay  Sat Mar 29 19:38:48 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA28139; Sat, 29 Mar 86 19:38:48 PST
Date: Sat, 29 Mar 86 19:38:48 PST
From: comay (David S. Comay)
Message-Id: <8603300338.AA28139@monet.berkeley.edu>
Subject: small problem with the tty adb script
Index: 	/usr/lib/adb/tty 4.3BSD
Apparently-To: beta43_bugs

Description:
	on the vax, the labels for the major and minor numbers are
	backwards
Repeat-By:
	echo 'pt_tty$<tty' | adb /vmunix /dev/kmem

	notice the number under the major label is really the minor
	number, etc.
Fix:
	either exchange the labels or if one wants to print the major
	number before the minor one, apply the following patch

	*** tty.orig	Sat Mar 29 19:17:41 1986
	--- tty	Sat Mar 29 19:22:57 1986
	***************
	*** 3,9 ****
	  +/"outq.cc"16t"outq.cf"16t"outq.cl"nDXX
	  +/"oproc"16t"rsel"16t"wsel"16tnpXX
	  +/"addr"16t"ldisc"nXX
	! +/"maj"8t"min"8t"flags"16t"state"16t"pgrp"nbb2+XXd
	  +/"char"8t"line"8t"col"8t"ispeed"8t"ospeed"n5b
	  +/"rocount"8t"rocol"n2b
	  +/"erase"8t"kill"8t"intrc"8t"quitc"8t"startc"nC8tC8tC8tC8tC
	--- 3,9 ----
	  +/"outq.cc"16t"outq.cf"16t"outq.cl"nDXX
	  +/"oproc"16t"rsel"16t"wsel"16tnpXX
	  +/"addr"16t"ldisc"nXX
	! +/"maj"8t"min"8t"flags"16t"state"16t"pgrp"n+b2-b3+XXd
	  +/"char"8t"line"8t"col"8t"ispeed"8t"ospeed"n5b
	  +/"rocount"8t"rocol"n2b
	  +/"erase"8t"kill"8t"intrc"8t"quitc"8t"startc"nC8tC8tC8tC8tC

From chris@mimsy.umd.edu  Sun Mar 30 14:26:09 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA00671; Sun, 30 Mar 86 14:26:09 PST
Received: by mimsy.umd.edu (5.9/4.7)
	id AA20147; Sun, 30 Mar 86 17:28:29 EST
Date: Sun, 30 Mar 86 17:28:29 EST
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8603302228.AA20147@mimsy.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: freopen has glitches with /dev/stdin

Index: /usr/src/lib/libc/stdio/freopen.c 4.3Beta

Description:
	`freopen("/dev/stdin", "r", stdin)' always fails because
	freopen fclose()s its third argument before open()ing the
	named file.

	Of course, this is not really a bug; it is *supposed* to
	leave the stream closed if the reopen fails.  This is just
	one of those odd interactions mentioned in `fd.4'.  It could
	be worked around, though, and I think perhaps it should.

Repeat-By:

	#include <stdio.h>

	main()
	{
		if (freopen("/dev/stdin", "r", stdin) == NULL)
			perror("freopen(/dev/stdin)");
	}

Chris

From whm@arizona.edu  Sun Mar 30 22:54:36 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA03430; Sun, 30 Mar 86 22:54:36 PST
Received: by arizona.arizona.edu; Sun, 30 Mar 86 23:56:27 MST
Date: Sun, 30 Mar 86 23:56:25 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8603310656.AA06629@megaron.arizona.edu>
Received: by megaron.arizona.edu; Sun, 30 Mar 86 23:56:25 MST
To: beta43_sites@monet.berkeley.edu
Subject: file table overflow with kernel updates

I recently applied the two sets of kernel updates announced by Mike Karels
in messages of 2/26 (#264) and 3/17 (#286).  I booted up a 780 with the
new kernel and while everything seemed ok, the next day the file table filled
up.  I didn't have a chance to do any problem analysis at the time, but
from /usr/adm/messages, I can see that for several hours prior to the fill-up,
sendmail encountered a number of read errors.  I've got some more test time
booked for this evening and I'll try to reproduce the problem, but I was
wondering if anyone else may have encountered this problem or have any
ideas.  Note that our kernel is vanilla 4.3 aside from some local device
drivers and a hack to provide NLOOP loopbacks.

I checked the nfile value in the old and new kernels and they're the same: 550.

From bloom  Mon Mar 31 07:53:55 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA04649; Mon, 31 Mar 86 07:53:55 PST
From: bloom (Jim Bloom)
Message-Id: <8603311553.AA04649@monet.berkeley.edu>
To: "Bill Mitchell" <whm@arizona.edu>
Cc: beta43_sites@monet.berkeley.edu
Subject: Re: file table overflow with kernel updates 
In-Reply-To: Your message of Sun, 30 Mar 86 23:56:25 MST.
             <8603310656.AA06629@megaron.arizona.edu> 
Date: Mon, 31 Mar 86 07:53:53 PST

I have witnessed the same problem on ucbvax, our mail gateway.  I
haven't had much luck tracking the problem down either.  I suspect
that there may be a bug in sendmail that is causing file descriptors
to be left open.  Do you have a large mail queue?

					Jim

From whm@arizona.edu  Mon Mar 31 14:52:20 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA00708; Mon, 31 Mar 86 14:52:20 PST
Received: by arizona.arizona.edu; Mon, 31 Mar 86 15:52:54 MST
Date: Mon, 31 Mar 86 15:52:52 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8603312252.AA23864@megaron.arizona.edu>
Received: by megaron.arizona.edu; Mon, 31 Mar 86 15:52:52 MST
To: bloom@monet.berkeley.edu
Subject: Re: file table overflow with kernel updates
Cc: beta43_sites@monet.berkeley.edu

The 780 that the new kernel was on is our mail relay, but I neglected
to check the mail queue (and everything else) before I rebooted.  I'm
once again running the new kernel, so if we run out of files again,
I'll be able to get some more data.  I've been watching it with pstat -f
and so far, everything looks normal.

From hilbert!hubert@uw-beaver.arpa  Mon Mar 31 17:31:11 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA01381; Mon, 31 Mar 86 17:31:11 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA07399; Mon, 31 Mar 86 17:38:12 PST
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA01688; Mon, 31 Mar 86 17:29:47 PST
Date: Mon, 31 Mar 86 17:29:47 PST
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Mon, 31 Mar 86 17:29:47 PST
Message-Id: <8604010129.AA01688@hilbert.UUCP>
To: beta43_bugs@monet.berkeley.edu
Subject: HUPCLS

Is there a reason why TS_HUPCLS is commented out in dz.c?  I would
like to turn it on.  Is something bad going to happen if I do?

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver

From whm@arizona.edu  Mon Mar 31 22:39:17 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA03292; Mon, 31 Mar 86 22:39:17 PST
Received: by arizona.arizona.edu; Mon, 31 Mar 86 23:39:52 MST
Date: Mon, 31 Mar 86 23:39:50 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8604010639.AA02409@megaron.arizona.edu>
Received: by megaron.arizona.edu; Mon, 31 Mar 86 23:39:50 MST
To: bloom@monet.berkeley.edu
Subject: Re: file table overflow with kernel updates
Cc: beta43_bugs@monet.berkeley.edu, lab-s@arizona.edu

I once again tried the kernels with the two batches of changes on a 780
and a 785 and things just weren't too rosy.  From a layman's point of
view, it seems like the network connections randomly wedge at various
times.  For example, when executing commands via rsh on the VAXs with
the new kernels, rsh would sometimes work normally and sometimes pause
interminably.  Other times, all the output would be produced, but it would
hang on the exit.  netstat would show a lot of connections in FIN_WAIT_2
and CLOSE_WAIT.

Usually, the only sendmail around was the daemon started in rc.local.  In
particular, I observed the wedging when there were no smtp connections
shown by netstat, so I'm not sure if your hypothesis regarding sendmail
being the root of the problem looks very promising.  Also, the very same
sendmail works just fine (considering it's sendmail?) with the old kernels.

If you have any ideas, I'll be glad to try them out, but things are
sufficiently awkward with the new kernels that I'm going to have to go
back to our earlier kernels in the meantime.

BTW--We're running DEUNAs on all the VAXs; does that ring any bells?

Note that this really isn't an urgent problem for us, but since we're such
an ordinary site, I might imagine that lots of other people may encounter
these same problems.

From whm@arizona.edu  Mon Mar 31 22:52:01 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA03315; Mon, 31 Mar 86 22:52:01 PST
Received: by arizona.arizona.edu; Mon, 31 Mar 86 23:52:38 MST
Date: Mon, 31 Mar 86 23:52:36 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8604010652.AA02761@megaron.arizona.edu>
Received: by megaron.arizona.edu; Mon, 31 Mar 86 23:52:36 MST
To: beta43_bugs@monet.berkeley.edu
Subject: sttys on unopened lines
Cc: lab-s@arizona.edu

I found that with the recent kernel updates installed it doesn't seem to
be possible to change the terminal attributes of a line that hasn't been
opened.

We have a line to our port selector that we use to gather statistics.
The port selector asserts carrier on /dev/ttyh0 and the script goes
something like:

	stty 1200 -echo >/dev/ttyh0
	exec pacxwatch /dev/ttyh0
	
Prior to the kernel updates, the attributes of ttyh0 would be changed by
the above, but with the updates, it doesn't seem to be possible to change
the attributes until the line has been opened (inside pacxwatch).

I don't remember seeing any mention of this change anywhere, so I thought
I'd mention it in case this wasn't what you had intended.

From lepreau  Tue Apr  1 01:37:29 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA03713; Tue, 1 Apr 86 01:37:29 PST
Date: Tue, 1 Apr 86 01:37:29 PST
From: lepreau (Jay Lepreau)
Message-Id: <8604010937.AA03713@monet.berkeley.edu>
To: bloom, miriam
Subject: Sendmail can fail to return failed msg to sender
Cc: beta43_bugs, donn, eric, haas@utah-20.arpa

This applies to the version we got from arpa:~ftp in October, and
apparently the current one on monet too, where I just reproduced it.

Repeat-by:
echo hello | Mail -s test nosuchu anotheru@isi-venera.arpa

sendmail will echo "nosuchu... user unknown" but a copy of the msg will
never be returned.  A little testing leads to the hypothesis that what
is important is that host of the remote user be temporarily
inaccessible, so that the mail is Q'ed.  If it is not Q'ed, the msg is
returned properly. (isi-venera happens to already have failing mail in
monet's Q so that works here at the moment.)  It may only happen if the
bad user is local, but I haven't verified that.

From schoch@orion.arpa  Tue Apr  1 08:25:28 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA04636; Tue, 1 Apr 86 08:25:28 PST
Received: by orion.arpa (5.28/1.5)
	id AA00323; Tue, 1 Apr 86 08:23:55 PST
Date: Tue, 1 Apr 86 08:23:55 PST
From: Steve Schoch <schoch@orion.arpa>
Message-Id: <8604011623.AA00323@orion.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: Background processes keep a modem line from dropping DTR

Index:	sys/sys/{sys_inode.c,kern_descrip.c,tty.c} 4.3BSD

Description:
	When a port that is configured for modem control is kept open by
	a process, DTR on that port will stay high, which will keep the
	modem from hanging up after a user logs out.  /etc/getty calls
	vhangup(), but this does not solve the problem.
Repeat-By:
	Log in from a modem, type sleep 100 &, and then log out.  You will
	get another login prompt, rather then the modem hanging up on you
	as it should.
Fix:
	Add these lines to the following four files:
	------- sys_inode.c -------
	544a545
	> 		ino_close(fp);
	545a547
	> 		fp->f_flag |= FVHANG;
	The routine forceclose now looks like this:
		if (ip->i_rdev != dev)
			continue;
		ino_close(fp);
		fp->f_flag &= ~(FREAD|FWRITE);
		fp->f_flag |= FVHANG;
	}

	------- file.h -------
	51a52
	> #define	FVHANG		010000		/* set by vhangup() */

	------- kern_descrip.c -------
	380c380,381
	< 	(*fp->f_ops->fo_close)(fp);
	---
	> 	if ((fp->f_flag & FVHANG) == 0)
	> 		(*fp->f_ops->fo_close)(fp);

	------- tty.c -------
	581a582,583
	> 	if (tp->t_pgrp == 0 && u.u_ttyp == tp)
	> 		tp->t_pgrp = pp->p_pgrp;
	-
	The routine ttyopen now looks like this:
	if (pp->p_pgrp == 0) {
		u.u_ttyp = tp;
		u.u_ttyd = dev;
		if (tp->t_pgrp == 0)
			tp->t_pgrp = pp->p_pid;
		pp->p_pgrp = tp->t_pgrp;
	}
	if (tp->t_pgrp == 0 && u.u_ttyp == tp)
		tp->t_pgrp = pp->p_pgrp;
	tp->t_state &= ~TS_WOPEN;

From lepreau@utah-cs.ARPA  Tue Apr  1 13:53:28 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA06292; Tue, 1 Apr 86 13:53:28 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA15469; Tue, 1 Apr 86 14:54:57 MST
Date: Tue, 1 Apr 86 14:54:57 MST
From: lepreau@utah-cs.arpa (Jay Lepreau)
Message-Id: <8604012154.AA15469@utah-cs.ARPA>
To: beta43_bugs@monet.berkeley.edu
Subject: kill(2) man page doesn't agree with code

Followups have documented that the man page was this way in v7, and in
v6 (with no pgrps) was
	If the process number is 0, the signal is sent to all other
	processes with the same controlling typewriter and user ID.
	Furthermore:
	In no case is it possible for a process to kill itself.

From: ptw@encore.UUCP (P. Tucker Withington)
Newsgroups: net.bugs.4bsd
Subject: Kill(2) Man page bug?  Vax and Sun
Message-ID: <287@encore.UUCP>
Date: 27 Mar 86 18:06:33 GMT
Organization: Encore Computer, Marlboro MA
Keywords: kill(2), 4.2bsd, Sun2.0, man

The kill(2) man page in both 4.2bsd and Sun Release 2.0 states:

	If the process number is 0, the signal is sent to *all other*
	processes in the sender's process group; this is a variant of
	killpg(2).  (emphasis mine)

Maybe I'm expecting too much of the English language, but I interpret
this statement to mean: whereas killpg sends to everyone in a process
group, you can use kill to send to everyone except yourself (obviating
a signal/SIGIGNORE call).

The following test program demonstrates that this is not how kill is
implemented:

	main() {
		kill(0, SIGQUIT);
	}

causes a core dump of itself.

I don't have my historical manuals in front of me, so I can't say when
this language was introduced to the kill(2) man page, but it clearly
diverges from the System V man page and the Sun and Vax
implementations.  I always have assumed kill(0, ...) does what it does
and am puzzled by the propagation of the wording in the man page.  Is
it just sloppy English, or did someone actually think this was a
useful feature and document it but never implement it?  I expect a
number of things would break if kill actually did what I interpret the
man page to say it does.

From muller@nprdc.arpa  Tue Apr  1 16:11:57 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA06911; Tue, 1 Apr 86 16:11:57 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA08238; Tue, 1 Apr 86 13:13:34 pst
Date: Tue, 1 Apr 86 13:13:34 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8604012113.AA08238@nprdc.arpa>
To: beta43_bugs@monet.berkeley.edu
Subject: nast bug in fputs and puts
Cc: muller@sdcsvax.ucsd.edu

Subject: puts and fputs on unbuffered i/o does not output all characters
Index:	src/lib/libc/vax/stdio/fputs.c 4.3BSD

Description:
	Both fputs and puts vax assembly versions incorrectly handle
	ouput on Unbuffered descriptors. Output with a character count
	that is greater than 1024 and NOT equal to a multiple of 1024
	is truncated to the smallest closest multiple of 1024. For
	example a fputs to stderr with a string of 1025,1026,....
	only writes out 1024 characters. Adding fflush (due to the way
	unberrfered i/o is "buffered" in 4.3) does not help.
Repeat-By:
	Compile the following program with an arguement of 1025,...
	such as a.out 2047 >& ZZ then do a wc (word count) on ZZ.
	Instead of the correct count of 2047, you get 1024.
	Calling a.out 2048 >& ZZ gives the correct count of 2048.
-----------------start of test program------------------------
#include <stdio.h>
main(argc, argv)
int argc;
char **argv;
{
	register int i;
	register int lim;
	register char *bp;
	char buf[8192];

	if ((lim = atoi(argv[1])) > 8191)
		lim = 8191;
	for (i = 0, bp = buf; i < lim; ++i, ++bp)
		*bp = 'A' + (i % 26);
	*bp = '\0';
	fputs(buf, stderr);
	exit(0);
}
-----------------end of test program------------------------------

Fix:

	The problem has to do with the attempt to buffer the unbuffered
	output in a local buffer. The code works fine for less than
	1024 as it makes only a single pass through the code. The call to
	_fflush is not made on the remaining piece that is left after a
	local buffer fflush is done. The loop in question is shown below.

	Anyway, at Lloop the original code is:

Lloop:
	addl3	_BASE(IOP),_BUFSIZ(IOP),COUNT	/* How many bytes? */
	subl2	_PTR(IOP),COUNT
	locc	$0,COUNT,(S)		/* Look for a null */
	jeql	Lagain

	subl2	r0,COUNT		/* Copy the data */
	movc3	COUNT,(S),*_PTR(IOP)
	movl	r3,_PTR(IOP)		/* Fix up IOP */
	subl2	COUNT,_CNT(IOP)
	bitw	$LBF,_FLAG(IOP)		/* If line buffered... */
	jneq	1f

The problem is the last two lines.  There are two possible fixes:

1.  Change	"jneq	1f"	to	"jgtr	1f"

2.  Change	"bitw	$LBF,_FLAG(IOP)"	to	"tstw	UNBUF"

These changes are mutually exclusive, but both seem to work properly.  It's
possible that other instructions would be "better" than "jneq" or "jgtr"; 
Personally, I prefer the second method...  the code goes to the trouble to
set UNBUF so we might as well use it, but there may be some problem with that
that I don't understand. Normally I would spend much more time to make sure of
the fix, but I wanted to get this to you as soon as possible. My ability at vax
assembler is not as good as it used to be.

	Keith Muller
	University of California, San Diego


From schoch@orion.arpa  Wed Apr  2 10:39:53 1986
Received: by monet.berkeley.edu (5.44/1.11)
	id AA10197; Wed, 2 Apr 86 10:39:53 PST
Received: by orion.arpa (5.28/1.5)
	id AA00284; Wed, 2 Apr 86 08:54:24 PST
Date: Wed, 2 Apr 86 08:54:24 PST
From: Steve Schoch <schoch@orion.arpa>
Message-Id: <8604021654.AA00284@orion.arpa>
To: beta43_bugs@monet.berkeley.edu, schoch@orion.arpa
Subject: Re:  Background processes keep a modem line from dropping DTR (Ignore my last message -- it was wrong).

Index:	sys/sys/{sys_inode.c,tty.c} 4.3BSD

Description:
	When a port that is configured for modem control is kept open by
	a process, DTR on that port will stay high, which will keep the
	modem from hanging up after a user logs out.  /etc/getty calls
	vhangup(), but this does not solve the problem.
Repeat-By:
	Log in from a modem, type sleep 100 &, and then log out.  You will
	get another login prompt, rather then the modem hanging up on you
	as it should.
Fix:
	Add these lines to the following files:
	------- sys_inode.c -------
	212c212
	< 	register int fmt = ip->i_mode & IFMT;
	---
	> 	register int fmt;
	214a215,218
	> 	if (ip == NULL)
	> 		return EBADF;
	> 
	> 	fmt = ip->i_mode & IFMT;
	250a255,256
	> 	if (ip == NULL)
	> 		return (1);
	274a281,282
	> 	if (ip == NULL)
	> 		return EBADF;
	313a322,325
	> 	if (ip == NULL) {
	> 		u.u_error = EBADF;
	> 		return;
	> 	}
	385a398,399
	> 	if (ip == NULL)
	> 		return (EBADF);
	544a559
	> 		ino_close(fp);
	The routine forceclose now looks like this:
		if (ip->i_rdev != dev)
			continue;
		ino_close(fp);
		fp->f_flag &= ~(FREAD|FWRITE);
	}

	------- tty.c -------
	581a582,583
	> 	if (tp->t_pgrp == 0 && u.u_ttyp == tp)
	> 		tp->t_pgrp = pp->p_pgrp;
	-
	The routine ttyopen now looks like this:
	if (pp->p_pgrp == 0) {
		u.u_ttyp = tp;
		u.u_ttyd = dev;
		if (tp->t_pgrp == 0)
			tp->t_pgrp = pp->p_pid;
		pp->p_pgrp = tp->t_pgrp;
	}
	if (tp->t_pgrp == 0 && u.u_ttyp == tp)
		tp->t_pgrp = pp->p_pgrp;
	tp->t_state &= ~TS_WOPEN;

From chris@gyre.umd.edu  Thu Apr  3 07:10:30 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA13346; Thu, 3 Apr 86 07:10:30 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03190; Thu, 3 Apr 86 10:03:27 EST
Date: Thu, 3 Apr 86 10:03:27 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604031503.AA03190@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: ftpd gives strange success codes

Index: /usr/src/etc/ftpd/ftpd.c 4.3Beta Fix

Description:
	ftpd gives an `undefined' success code `200' for some commands
	(see recent tcp-ip mail).

Repeat-By:
	% touch /tmp/foo
	% ftp umd-echo	# or yourself, same effect
	[log in]
	ftp> dele /tmp/foo

Fix:
	Below

Chris

RCS file: RCS/ftpd.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** /tmp/,RCSt1003149	Thu Apr  3 09:58:20 1986
--- /tmp/,RCSt2003149	Thu Apr  3 09:58:23 1986
***************
*** 559,565 ****
  ack(s)
  	char *s;
  {
! 	reply(200, "%s command okay.", s);
  }
  
  nack(s)
--- 559,565 ----
  ack(s)
  	char *s;
  {
! 	reply(250, "%s command okay.", s);
  }
  
  nack(s)

From wendt@arizona.edu  Thu Apr  3 15:19:58 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA14945; Thu, 3 Apr 86 15:19:58 PST
Received: by arizona.arizona.edu; Thu, 3 Apr 86 15:22:33 MST
Date: Thu, 3 Apr 86 15:22:31 MST
From: "Alan Wendt" <wendt@arizona.edu>
Message-Id: <8604032222.AA22891@megaron.arizona.edu>
Received: by megaron.arizona.edu; Thu, 3 Apr 86 15:22:31 MST
To: beta43_bugs@monet.Berkeley.EDU
Subject: dbx

In the routine exitblock in the file object.c there is a reference
to the variable 'prevlinep'.  This variable is private and not set
anywhere else in the program (grep).

The reason that I'm curious about this is that I've built a line-by-line
execution profiler by cannabilizing the source mapping from dbx.
I get bogus line numbers sometimes, I think because the call to nosource
in the routine srcline in the file mappings.c is always returning 1,
and I'm trying to determine why.

Thanks,
Alan Wendt
University of Arizona
arizona!wendt

From entropy!hubert@uw-beaver.arpa  Thu Apr  3 16:40:58 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA15202; Thu, 3 Apr 86 16:40:58 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA03379; Thu, 3 Apr 86 16:48:14 PST
Return-Path: <entropy!hubert@uw-beaver.arpa>
Received: by entropy.UUCP (5.31/1.0.Entropy)
	id AA11462; Thu, 3 Apr 86 16:38:51 PST
Date: Thu, 3 Apr 86 16:38:51 PST
From: Steve Hubert <entropy!hubert@uw-beaver.arpa>
Posted-Date: Thu, 3 Apr 86 16:38:51 PST
Message-Id: <8604040038.AA11462@entropy.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: 4.3 Bug Report (learn)
Cc: bob@uw-bluechip, burr@uw-ward, lundberg@uw-beaver.arpa, uw-beaver!oystr,
        uw-beaver!yenbut

The learn program has a bug.  The sccs version number is 4.3.
The program clobbers some of the environment.

Repeat By:
	printenv  (note the items preceding PATH, EXINIT, and PS1)
	learn files
	Hit return when it asks you to.
	printenv
  Notice that the environment items which came right before PATH, EXINIT,
and PS1 are all missing.

Fix:
	Simple.  There is an extra semicolon in mysys.c.

*** mysys.c.dist	Thu Apr  3 16:24:56 1986
--- mysys.c	Thu Apr  3 16:25:21 1986
***************
*** 44,50 ****
  		else if (strncmp(*p, "EXINIT=", 7) == 0)
  			sprintf(exinit, "%s|set prompt noopt open window=23", envp[i--]);
  #if vax
! 		else if (strncmp(*p, "PS1=", 4) == 0);
  			i--;
  	}
  	envp[2] = malloc(7);
--- 44,50 ----
  		else if (strncmp(*p, "EXINIT=", 7) == 0)
  			sprintf(exinit, "%s|set prompt noopt open window=23", envp[i--]);
  #if vax
! 		else if (strncmp(*p, "PS1=", 4) == 0)
  			i--;
  	}
  	envp[2] = malloc(7);


Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver

From satz@su-mojave.arpa  Thu Apr  3 16:44:54 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA15239; Thu, 3 Apr 86 16:44:54 PST
Message-Id: <8604040044.AA15239@monet.Berkeley.EDU>
Received: by su-mojave.arpa with TCP; Thu, 3 Apr 86 16:44:47 PST
Date: Thu, 3 Apr 86 16:44:47 PST
From: Greg Satz <satz@su-mojave.arpa>
Subject: various problems
To: beta43_bugs@monet.Berkeley.EDU

In the file h/buf.h, in the macro notavail(), I think
you want to change spl6() to splbio().

In sys/vm_page.c, in the routine fodkluster(), the
declarations for v, vmin, vmax should probably be daddr_t
instead of unsigned since the v < vmin test won't work.

For people who put NFS into 4.3, making splbio() < splimp()
is disastrous.

From muller@nprdc.arpa  Fri Apr  4 00:38:12 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA16626; Fri, 4 Apr 86 00:38:12 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06739; Fri, 4 Apr 86 00:39:05 pst
Date: Fri, 4 Apr 86 00:39:05 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8604040839.AA06739@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: login.c problem?

Subject: login clears local mode tty bits set by getty
Index:	src/bin/login.c 4.3BSD

Description:
	Getty through the use of gettytab allows easy terminal
	configuration on a per line basis. Several of
	the options set by getty are part of the tty local
	mode bits. These include options such as: ce, ck, xc
	and so forth. However login completely clears out all local 
	mode bits, making these features of getty useless.
Repeat-By:
	Set up a capability such ce in the gettytab entry for a specific
	line. log onto that line (make sure tset is NOT called). Do a
	stty everything and you will find that all local mode options
	have been cleared.
Fix:
	The problem is that very early on in the login sequence, login
	does a ioctl(0, TIOCLSET, &zero) where zero = 0. This completely
	wipes out any mode setting done by getty. This seems to be necessary
	for the pty's as both rlogin and telnetd do not set any of the local
	mode bits. Calls to login from rlogin, telenet and getty can be
	identified by the hflag, rflag and pflag. The problem is what 
	to do when login is called directly by the user (without the -r,
	-h, or -p flags). That case could be handled by assuming that
	the line has been set by a prior pass through getty, rlogind
	or telenetd. One way to handle this case is to clear only the
	those local modes bits that CANNOT be set by getty. This is not
	the cleanest solution, but seems to be the safest and is probably
	better than blindly clearing all the local mode bits.
	On the other hand it might just be prudent to allow only rlogind,
	telenetd, and getty to call login directly, and to prohibit users
	direct use of login. As calling login directly while through rlogin
	has the side effect of clearing the correctly set rows and cols
	values.

	The enclosed context diff handles the problem as described.

		Keith Muller
		University of California, San Diego
		muller@nprdc.arpa

*** /usr/src/bin/login.c	Sat Jan 11 11:46:57 1986
--- login.c	Thu Apr  3 01:02:12 1986
***************
*** 39,44 ****
--- 39,45 ----
  
  #define	SCMPN(a, b)	strncmp(a, b, sizeof(a))
  #define	SCPYN(a, b)	strncpy(a, b, sizeof(a))
+ #define NOSET	LTILDE|LMDMBUF|LLITOUT|LTOSTOP|LFLUSHO|LNOHANG|LPASS8|LPENDIN
  
  #define NMAX	sizeof(utmp.ut_name)
  #define HMAX	sizeof(utmp.ut_host)
***************
*** 98,103 ****
--- 99,105 ----
  	FILE *nlfd;
  	char *ttyn, *tty;
  	int ldisc = 0, zero = 0, i;
+ 	int noset = NOSET;
  	char **envnew;
  
  	signal(SIGALRM, timedout);
***************
*** 144,150 ****
  		}
  		break;
  	}
! 	ioctl(0, TIOCLSET, &zero);
  	ioctl(0, TIOCNXCL, 0);
  	ioctl(0, FIONBIO, &zero);
  	ioctl(0, FIOASYNC, &zero);
--- 146,159 ----
  		}
  		break;
  	}
! 	if (rflag || hflag)
! 		ioctl(0, TIOCLSET, &zero);
! 	else if (!pflag)
! 		/*
! 		 * called by user, only clear out flags getty cannot set
! 		 */
! 		ioctl(0, TIOCLBIC, &noset);
! 
  	ioctl(0, TIOCNXCL, 0);
  	ioctl(0, FIONBIO, &zero);
  	ioctl(0, FIOASYNC, &zero);

From chris@gyre.umd.edu  Fri Apr  4 06:39:57 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA17352; Fri, 4 Apr 86 06:39:57 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA04473; Thu, 3 Apr 86 17:36:48 EST
Date: Thu, 3 Apr 86 17:36:48 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604032236.AA04473@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Re: ftpd sends wrong reply codes

According to someone who would know better than I, that fix breaks
the `noop' command, which reply code is actually *supposed* to be 200.
Do the obvious thing to fix it.

From dlu%tektools%tektronix.csnet@CSNET-RELAY.ARPA  Fri Apr  4 23:56:06 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA20518; Fri, 4 Apr 86 23:56:06 PST
Received: from tektronix by csnet-relay.csnet id ai09332; 5 Apr 86 2:48 EST
Received: by tektronix (5.31/5.14)
	id AA17758; Fri, 4 Apr 86 14:48:55 PST
Received: by tektools (5.31/5.17)
	id AA28061; Fri, 4 Apr 86 14:47:03 PST
Message-Id: <8604042247.AA28061@tektools>
To: beta43_bugs%monet.berkeley.edu%csnet-relay%tektronix.csnet@CSNET-RELAY.ARPA
Subject: /lib/ccom--Hash bucket compression hangs compiler
Date: 04 Apr 86 14:46:59 PST (Fri)
From: dlu%tektools%tektronix.csnet@CSNET-RELAY.ARPA


------- Forwarded Message

>From: sutton@tektronix <Carl Sutton>
Subject: /lib/ccom--Hash bucket compression hangs compiler
Index:	lib/mip/pftn.c 4.3BSD

Description:
	The problem is in clearst().
	During step 2, if r==p the statement *r = *q writes
	over the location p points to.  The next traverse of
	clist uses the bogus pointer forward pointer contained
	in *r.

	An examination of the code for step 2 in clearst()
	makes clear the potential for problem.

Repeat-By:
	This is difficult to do since problems occur only when
	the symbol table is relatively full and hash buckets
	overflow.  We happened to have a large program (> 100kbytes)
	that caused the symbol table entry referenced by r to
	have a forward pointer pointing at the location it was
	moved to.  Traversal of the list (clist) became an endless loop.

Fix:
	Save a copy of the pointer to the next compression table entry
	prior to checking the hash bucket for the current entry.  Use
	this saved pointer to find the next element in clist.

	If the following code diffs, I include a firewall check for looping
	in the offending section of code.

Code diffs follow:

>>>>>>>>>>>>>>>>>>>>>>> CUT HERE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
RCS file: RCS/pftn.c,v
retrieving revision 1.2
retrieving revision 1.3
diff -c -r1.2 -r1.3
*** /tmp/,RCSt1027211	Fri Apr  4 14:27:08 1986
- --- /tmp/,RCSt2027211	Fri Apr  4 14:27:11 1986
***************
*** 1,5
  #ifndef lint
! static char *RCSid = "$Header: pftn.c,v 1.2 86/03/20 12:57:59 sutton Exp $";
  #endif
  #ifndef lint
  static char *sccsid ="@(#)pftn.c	1.9 (Berkeley) 8/22/85";

- --- 1,5 -----
  #ifndef lint
! static char *RCSid = "$Header: pftn.c,v 1.3 86/04/04 09:24:26 sutton Exp $";
  #endif
  #ifndef lint
  static char *sccsid ="@(#)pftn.c	1.9 (Berkeley) 8/22/85";
***************
*** 1891,1896
  	p = clist;
  	while( p ){
  		register struct symtab *r;
  
  		q = p;
  		for(;;){

- --- 1894,1901 -----
  	p = clist;
  	while( p ){
  		register struct symtab *r;
+ 		register icnt;
+ 		struct symtab *next;
  
  		q = p;
  		next = p->snext;
***************
*** 1893,1899
  		register struct symtab *r;
  
  		q = p;
! 		for(;;){
  			if( ++q >= &stab[SYMTSZ] )q = stab;
  			if( q == p || q->stype == TNULL )break;
  			if( (r = relook(q)) != q ) {

- --- 1898,1905 -----
  		struct symtab *next;
  
  		q = p;
! 		next = p->snext;
! 		for( icnt=0; icnt <= SYMTSZ; icnt++ ){
  			if( ++q >= &stab[SYMTSZ] )q = stab;
  			if( q == p || q->stype == TNULL )break;
  			if( (r = relook(q)) != q ) {
***************
*** 1901,1907
  				q->stype = TNULL;
  				}
  			}
! 		p = p->snext;
  		}
  
  	lineno = temp;

- --- 1907,1914 -----
  				q->stype = TNULL;
  				}
  			}
! 		if( icnt > SYMTSZ ) cerror( "can't clear the symbol table" );
! 		p = next;
  		}
  
  	lineno = temp;

------- End of Forwarded Message

From mcvax!dpk@seismo.CSS.GOV  Sat Apr  5 05:38:09 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA21549; Sat, 5 Apr 86 05:38:09 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Sat, 5 Apr 86 08:24:29 EST
Received: from gigue.cwi.nl (gigue.uucp) by mcvax.uucp; Sat, 5 Apr 86 13:08:09 +0100 (MET)
Date:     Sat, 5 Apr 86 13:53:19 MET DST
From: Doug Kingston <mcvax!dpk@seismo.CSS.GOV>
To: beta43_bugs@monet.Berkeley.EDU
Cc: bloom@monet.Berkeley.EDU
Subject:  [Chris Torek:  Re: FTP protocol violations]
Message-Id:  <8604051353.a002892@gigue.mcvax.UUCP>

Its real...

----- Forwarded message # 1:

Received: from mcvax by gigue.mcvax.UUCP id a002078; 4 Apr 86 23:50 MET DST
Received: by mcvax.uucp; Fri, 4 Apr 86 23:02:42 +0100 (MET)
Received: by seismo.CSS.GOV; Fri, 4 Apr 86 16:02:40 EST
Received: from sri-nic.arpa by AOS.BRL.ARPA id a017132; 4 Apr 86 12:07 EST
Received: from gyre.umd.edu by SRI-NIC.ARPA with TCP; Thu 3 Apr 86 07:06:40-PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA03176; Thu, 3 Apr 86 09:59:36 EST
Date: Thu, 3 Apr 86 09:59:36 EST
From: Chris Torek <chris@gyre.ARPA>
Message-Id: <8604031459.AA03176@gyre.umd.edu>
To: DCP@SCRC-QUABBIN.ARPA, Margulies@SCRC-YUKON.ARPA
Subject: Re:  FTP protocol violations
Cc: tcp-ip@SRI-NIC.ARPA

Instead of complaining about the broken 4.x ftp server, I thought
it more useful to provide the fix.  Here it is.  Feel free to give
it to anyone whose server is still wrong.

Chris

RCS file: RCS/ftpd.c,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** /tmp/,RCSt1003149	Thu Apr  3 09:58:20 1986
--- /tmp/,RCSt2003149	Thu Apr  3 09:58:23 1986
***************
*** 559,565 ****
  ack(s)
  	char *s;
  {
! 	reply(200, "%s command okay.", s);
  }
  
  nack(s)
--- 559,565 ----
  ack(s)
  	char *s;
  {
! 	reply(250, "%s command okay.", s);
  }
  
  nack(s)

----- End of forwarded messages

From glenn%ivrel@SUN.ARPA  Sun Apr  6 17:34:10 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA25561; Sun, 6 Apr 86 17:34:10 PST
Received: from snail.snail.uucp (snail-ptp) by sun.arpa (3.2-/SMI-3.0)
	id AA04498; Sun, 6 Apr 86 17:30:45 PST
Received: from ivrel.sun.uucp by snail.snail.snail.uucp.uucp (3.2/SMI-3.0DEV4)
	id AA13372; Sun, 6 Apr 86 17:29:51 PST
Received: by ivrel.sun.uucp (1.1/SMI-3.0DEV3)
	id AA00944; Sun, 6 Apr 86 17:33:45 PST
Date: Sun, 6 Apr 86 17:33:45 PST
From: glenn%ivrel@SUN.ARPA (Glenn C. Skinner)
Message-Id: <8604070133.AA00944@ivrel.sun.uucp>
Cc: glenn%ivrel@SUN.ARPA
Subject: C shell vulnerable to SIGINT after vfork
Index: 	bin/csh/sh.sem.c	FIX

Description:
	On machines where signal-handling information is part of user
	process address space (as opposed to part of the kernel address
	space), the C shell will exit upon receiving a SIGINT any time
	after the first vfork.  The problem is that after a vfork the
	child process establishes its own SIGINT handler.  On the machines
	in question, this action changes the parent's SIGINT handler as
	well, rendering the parent vulnerable to this signal.  The original
	code works on Vaxes becuase the record of the handler is duplicated
	as part of the vfork.  It doesn't work on Suns, because the record
	of the handler is contained in the address space shared between
	parent and child.
Repeat-By:
	Recompile the 4.3 C shell sources on a Sun.  Issue a date command
	from withing the resulting shell.  Feed the shell an interrupt and
	watch it vanish.
Fix:
	The cure is to salt away a copy of the SIGINT sigvec before vforking
	and to explicitly restore it in the parent.  (Note that the 4.2 C
	shell effectively did this, as part of its 4.1 signal emulation.)

	The following context diff contains the gory details.  Your line
	numbers will differ.

		-- Glenn Skinner, SMI

------- sh.sem.c -------
*** /tmp/d00912	Sun Apr  6 16:59:37 1986
--- sh.sem.c	Thu Mar 27 08:15:34 1986
***************
***************
*** 122,127 ****
--- 122,128 ----
  			int ochild, osetintr, ohaderr, odidfds;
  			int oSHIN, oSHOUT, oSHDIAG, oOLDSTD, otpgrp;
  			int omask;
+ 			struct sigvec osv;
  
  			omask = sigblock(sigmask(SIGCHLD));
  			ochild = child; osetintr = setintr;
***************
*** 129,134 ****
--- 130,143 ----
  			oSHIN = SHIN; oSHOUT = SHOUT;
  			oSHDIAG = SHDIAG; oOLDSTD = OLDSTD; otpgrp = tpgrp;
  			Vsav = Vdp = 0; Vav = 0;
+ 			/*
+ 			 * Record old SIGINT state, so that we can
+ 			 * restore it in the parent after the vfork.
+ 			 * (The child establishes a handler of its own,
+ 			 * which can trash the parent setting for some
+ 			 * signal implementations.)
+ 			 */
+ 			(void) sigvec(SIGINT, (struct sigvec *)0, &osv);
  			pid = vfork();
  			if (pid < 0) {
  				(void) sigsetmask(omask);
***************
*** 147,152 ****
--- 156,165 ----
  				/* this is from pfork() */
  				palloc(pid, t);
  				(void) sigsetmask(omask);
+ 				/*
+ 				 * Restore SIGINT handler.
+ 				 */
+ 				(void) sigvec(SIGINT, &osv, (struct sigvec *)0);
  			} else {
  				/* this is from pfork() */
  				int pgrp;

From glenn%ivrel@SUN.ARPA  Sun Apr  6 17:49:46 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA25577; Sun, 6 Apr 86 17:49:46 PST
Received: from snail.snail.uucp (snail-ptp) by sun.arpa (3.2-/SMI-3.0)
	id AA04616; Sun, 6 Apr 86 17:46:18 PST
Received: from ivrel.sun.uucp by snail.snail.snail.uucp.uucp (3.2/SMI-3.0DEV4)
	id AA13389; Sun, 6 Apr 86 17:45:26 PST
Received: by ivrel.sun.uucp (1.1/SMI-3.0DEV3)
	id AA00963; Sun, 6 Apr 86 17:49:18 PST
Date: Sun, 6 Apr 86 17:49:18 PST
From: glenn%ivrel@SUN.ARPA (Glenn C. Skinner)
Message-Id: <8604070149.AA00963@ivrel.sun.uucp>
Cc: glenn%ivrel@SUN.ARPA
Subject: C shell prints "Broken pipe" message
Index: 	bin/csh/sh.proc.c	FIX

Description:
	Sh.proc.c contains code to print out various messages pertaining
	to child processes that have exited.  Included in this code is a
	test intended to prevent printouts from some termination causes,
	including SIGPIPE.  Inspection of this test shows that it's flat
	out wrong, unconditionally evaluating to true.  The most noticeable
	effect is that the shell prints extraneous "Broken pipe" messages.
Repeat-By:
	Execute the command:
		cat /etc/termcap | head -20
	Observe the resulting "Broken pipe" message.
Fix:
	The following context diff corrects the offending test.  Your line
	numbers will differ.

		-- Glenn Skinner, SMI

------- sh.proc.c -------
*** /tmp/d00888	Sun Apr  6 16:56:27 1986
--- sh.proc.c	Sun Apr  6 16:55:54 1986
***************
*** 582,589 ****
  				case PINTERRUPTED:
  				case PSTOPPED:
  				case PSIGNALED:
! 					if (flag&REASON || reason != SIGINT ||
! 					    reason != SIGPIPE)
  						printf(format, mesg[pp->p_reason].pname);
  					break;
  
--- 582,590 ----
  				case PINTERRUPTED:
  				case PSTOPPED:
  				case PSIGNALED:
! 					if ((flag&(REASON|AREASON))
! 					    && reason != SIGINT
! 					    && reason != SIGPIPE)
  						printf(format, mesg[pp->p_reason].pname);
  					break;
  

From glenn%ivrel@SUN.ARPA  Sun Apr  6 17:58:43 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA25592; Sun, 6 Apr 86 17:58:43 PST
Received: from snail.snail.uucp (snail-ptp) by sun.arpa (3.2-/SMI-3.0)
	id AA04642; Sun, 6 Apr 86 17:55:15 PST
Received: from ivrel.sun.uucp by snail.snail.snail.uucp.uucp (3.2/SMI-3.0DEV4)
	id AA13401; Sun, 6 Apr 86 17:54:22 PST
Received: by ivrel.sun.uucp (1.1/SMI-3.0DEV3)
	id AA00974; Sun, 6 Apr 86 17:58:15 PST
Date: Sun, 6 Apr 86 17:58:15 PST
From: glenn%ivrel@SUN.ARPA (Glenn C. Skinner)
Message-Id: <8604070158.AA00974@ivrel.sun.uucp>
Cc: glenn%ivrel@SUN.ARPA
Subject: Null dereference bug in do{,un}limit()
Index: 	bin/csh/sh.func.c	FIX

Description:
	The dolimit and dounlimit functions in sh.func.c assume that
	their argument vectors do not contain null pointers.  This
	assumption is incorrect, resulting in core dumps on machines
	that don't map addres 0, such as Suns.
Repeat-By:
	Recompile the 4.3 C shell sources on a Sun.  Execute the
	limit and unlimit builtins with no arguments and watch the
	shell dump core.
Fix:
	The following context diff corrects the offending code.  Your line
	numbers will differ.

		-- Glenn Skinner, SMI

------- sh.func.c -------
*** /tmp/d00879	Sun Apr  6 16:54:57 1986
--- sh.func.c	Wed Mar  5 14:58:29 1986
***************
*** 909,915 ****
  	char hard = 0;
  
  	v++;
! 	if (eq(*v, "-h")) {
  		hard = 1;
  		v++;
  	}
--- 909,915 ----
  	char hard = 0;
  
  	v++;
! 	if (*v && eq(*v, "-h")) {
  		hard = 1;
  		v++;
  	}
***************
*** 1034,1040 ****
  	char hard = 0;
  
  	v++;
! 	if (eq(*v, "-h")) {
  		hard = 1;
  		v++;
  	}
--- 1034,1040 ----
  	char hard = 0;
  
  	v++;
! 	if (*v && eq(*v, "-h")) {
  		hard = 1;
  		v++;
  	}

From torek  Mon Apr  7 03:41:56 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA27233; Mon, 7 Apr 86 03:41:56 PST
Date: Mon, 7 Apr 86 03:41:56 PST
From: torek (Chris Torek)
Message-Id: <8604071141.AA27233@monet.Berkeley.EDU>
To: beta43_bugs
Subject: `mv' vs `rm'

Index: /usr/src/bin/mv.c 4.3Beta

Description:
	rm -f nonexistentfile is silent.  mv -f nonexfile newname
	is not.  Seems wrong to me.

Repeat-by:
	% mkdir t; cd t; rm -f tt; mv -f tt tt2; cd ..; rmdir t

Chris

From torek  Mon Apr  7 03:42:54 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA27244; Mon, 7 Apr 86 03:42:54 PST
Date: Mon, 7 Apr 86 03:42:54 PST
From: torek (Chris Torek)
Message-Id: <8604071142.AA27244@monet.Berkeley.EDU>
To: beta43_bugs
Subject: Two fixes from elsie!ado, not tested by me

From ado@elsie.UUCP Mon Mar 31 15:42:34 1986
Relay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site maryland.UUCP
Path: maryland!umcp-cs!seismo!elsie!ado
From: ado@elsie.UUCP
Newsgroups: net.bugs.4bsd
Subject: Re: 4.[123]bsd csh script handling bug (with fix?)
Message-ID: <6060@elsie.UUCP>
Date: 31 Mar 86 20:42:34 GMT
Date-Received: Mon, 31-Mar-86 20:30:19 EST
References: <6042@elsie.UUCP>
Organization: NIH-LEC, Bethesda, MD
Lines: 55
Keywords: bsd csh

Index:	bin/csh/sh.err.c

Description:
	csh mishandles "Command not found" errors in scripts.

Repeat-By:
	Typing the command
    repeat 25 echo oops 6789012345678901234567890123456789012345678901 > file
	and then either
		csh file
	or
		cat file | csh
	and noting the output:
		oops: Command not found.
		789012345678901: Command not found.
	where "780912345678901" turns out to be what's stored in "file"
	starting at the 1025th byte.

Fix:
	Move a misplaced "btoeof" call in "sh.err.c", as shown below.
	(Well. . .actually you'll want to wait and watch the next couple
	of weeks worth of followup postings before doing so.  And even then,
	you'll want to be sure that you can readily back out the change.)
	Changes are conditioned on OLDVERSION; these changes are for the 4.1bsd
	version of the code.

		...
		errspl = 0;

	#ifdef OLDVERSION
		/*
		 * Reset the state of the input.
		 * This buffered seek to end of file will also
		 * clear the while/foreach stack.
		 */
		btoeof();
	#endif /* OLDVERSION */

		/*
		 * Go away if -e or we are a child shell
		 */
		if (exiterr || child)
			exit(1);
	#ifndef OLDVERSION
		btoeof();
	#endif /* !OLDVERSION */

		setq("status", onev, &shvhed);
		...
--
Bugs is a Warner Brothers trademark.
Bug is a Volkswagen trademark.
--
	UUCP: ..decvax!seismo!elsie!ado		ARPA: elsie!ado@seismo.ARPA
	DEC, VAX, Elsie & Ado are Digital, Borden & Shakespeare trademarks.



From ado@elsie.UUCP Wed Apr  2 09:28:45 1986
Relay-Version: version B 2.10.3 4.3bsd-beta 6/6/85; site maryland.UUCP
Path: maryland!umcp-cs!seismo!elsie!ado
From: ado@elsie.UUCP
Newsgroups: net.bugs.4bsd
Subject: 4.[123]bsd csh && & & bug (with fix)
Message-ID: <6061@elsie.UUCP>
Date: 2 Apr 86 14:28:45 GMT
Date-Received: Thu, 3-Apr-86 04:39:34 EST
Organization: NIH-LEC, Bethesda, MD
Lines: 42
Keywords: bsd csh

Index:	bin/csh/sh.parse.c

Description:
	Here's the bug as described in a list posted to the network by Mt. Xinu:
 > csh--bin			      ralph (Ralph Campbell)   23 May 83  
 >	The command `sleep 10 && sleep 5 &' will create a non-interruptable
 >	non-suspendable pipeline which is not run in background.  I can
 >	reliably reproduced the problem.  It seems to fail if (any) other
 >	commands besides sleep are used.
 >
 >    REPEAT BY:
 >	type `sleep 10 && sleep 5 &'

Repeat-By:
	See above.

Fix:
	These changes are to the 4.1bsd version of "sh.parse.c",
	in particular to the function "syn0".
	Changes are conditioned on "OLDVERSION".
	As always, the trade secret status of the code involved precludes a
	clearer posting.

    		...
    		case '&':
    			if (l != 0)
    				break;
    			if (p->word[1] == '&')
    				continue;
    			t1 = syn1(p1, p, flags);
    #ifdef OLDVERSION
    			if (t1->t_dtyp == TLST) {
    #else /* !OLDVERSION */
    			if (t1->t_dtyp == TLST ||
    			    t1->t_dtyp == TAND ||
    			    t1->t_dtyp == TOR) {
    #endif /* !OLDVERSION */
    				t = (struct command *) calloc(1, sizeof (*t));
    		...
--
	UUCP: ..decvax!seismo!elsie!ado		ARPA: elsie!ado@seismo.ARPA
	DEC, VAX, Elsie & Ado are Digital, Borden & Shakespeare trademarks.



From mcvax!dpk@seismo.CSS.GOV  Mon Apr  7 08:10:11 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA27915; Mon, 7 Apr 86 08:10:11 PST
Return-Path: <mcvax!dpk>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Mon, 7 Apr 86 11:02:10 EST
From: mcvax!dpk@seismo.CSS.GOV
Received: from sering.uucp by mcvax.uucp; Mon, 7 Apr 86 12:38:46 +0100 (MET)
Received: by sering.uucp; Mon, 7 Apr 86 13:39:56 +0200 (MET)
Message-Id: <8604071139.AA25632@sering.uucp>
To: beta43_bugs@monet.Berkeley.EDU
Cc: lamas@brl.arpa, bellcore!jim@seismo.CSS.GOV, mcvax!jaap@seismo.CSS.GOV,
        kjd@monet.Berkeley.EDU
Subject: Comments on recent updates
Date: Mon, 07 Apr 86 13:39:54 +0100

1. The directory sys/dist/tp was missing.  This caused the make install
in /sys/mdec to fail.

2. /sys/stand/hp.old.c had a redefinition of "hptypes".  Fix: remove
the definition of this from hp.old.c and it will get it from hpmaptype.o

3. Can not run on a write protected root/swap even with 8 Megabytes
of real memory.  At least the BRL version could do this.  It panics
with I/O error in swap.

4. /usr/src/ucb/netstat still had some bbn crud in the source files.
I simply removed it all.

5. /usr/src/bin/Makefile did not install shell files in such a way
to force the mode to 555.  Our default mode is 751.  Fix:  add "-m 555"
to the install command for "SCRIPT" programs.  This is also a problem
in other Makefiles (/usr/src/usr.bin/lex comes to mind for n?form files).

6. /usr/src/ucb/dbx/Makefile removes cerror.s machine.c and runtime.c.
These are real source files and should NOT be removed.

7. /etc/termcap still lacks the up to date terminal description for the
Teletype 5620 Rev 1.0.   It is missing the description for Rev 2.0.
I have sent both to Kevin Dunlap months ago.  They are attached at the
end of this letter.

Thats all for now. I have recompiled everything in /lib, /bin, /etc,
/usr.bin, /usr.lib, and /ucb with the newly generated compiler and so
far have not seen any problems.  I have not had a chance to test the
Bourne shell very much however and that is a known problem area (McKie).

Will keep in touch.

	-Doug-

===============
#
# NOTE: Move tty5620-1 behind tty5620-2 after all DMDs are upgraded!
#
# Teletype 5620, firmware version 1.1 (8;7;3) or earlier
# The following SET-UP modes are assumed for normal operation:
#	CR_DEF=CR	NL_DEF=INDEX	DUPLEX=FULL
# Other SET-UP modes may be set for operator convenience or communication
# requirements.
# This termcap description is for the Resident Terminal Mode.
# Hardware tabs are assumed to be set every 8 columns (default).
# No delays are specified; use "stty ixon -ixany" to enable
# DC3/DC1 flow control!
# AL/DL/IC/DC are present but not documented in USER guides.
# They are documented in the Service manual ("Technical Reference").
TB|tty5620-1|tty5620|dmd|5620|Teletype 5620 with old ROMs:\
	:AL=\E[%dL:al=\E[L:am:bl=^G:cd=\E[J:ce=\E[K:cm=\E[%i%d;%dH:\
	:co#88:cr=^M:DC=\E[%dP:dc=\E[P:DL=\E[%dM:dl=\E[M:do=^J:ho=\E[H:\
	:IC=\E[%d@:ic=\E[@:it#8:kb=^H:kC=\E[2J:kd=\E[B:kH=\E[70;1H:kh=\E[H:\
	:kl=\E[D:kr=\E[C:ku=\E[A:le=^H:li#70:ll=\E[70;H:nd=\E[C:rc=\E8:rs=\Ec:\
	:sc=\E7:SF=\E[%dS:sf=^J:SR=\E[%dT:sr=\E[T:ta=^I:up=\E[A:vt#3:xo:\
	:cl=\E[H\E[J:\
	:bs:pt:
#
# Teletype 5620, firmware version 2.0 (8;7;5) or later
# The following SET-UP modes are assumed for normal operation:
#	DUPLEX=FULL	GEN_FLOW=ON	NEWLINE=INDEX	RETURN=CR
# Other SET-UP modes may be set for operator convenience or communication
# requirements.
# This termcap description is for the Resident Terminal Mode.
# Hardware tabs are assumed to be set every 8 columns (default).
# No delays are specified; use "stty ixon -ixany" to enable
# DC3/DC1 flow control!
TA|tty5620-2|tty5620|dmd|Teletype 5620 with new ROMs:\
	:AL=\E[%dL:al=\E[L:am:bl=^G:cd=\E[J:ce=\E[K:cm=\E[%i%d;%dH:\
	:co#88:cr=^M:DC=\E[%dP:dc=\E[P:DL=\E[%dM:dl=\E[M:do=^J:ho=\E[H:\
	:IC=\E[%d@:ic=\E[@:it#8:kb=^H:kC=\E[2J:kd=\E[B:kH=\E[70;1H:kh=\E[H:\
	:kl=\E[D:kr=\E[C:ku=\E[A:le=^H:li#70:ll=\E[70;H:me=\E[0m:mr=\E[7m:\
	:ms:nd=\E[C:rc=\E8:rs=\Ec:sc=\E7:se=\E[0m:SF=\E[%dS:sf=^J:so=\E[7m:\
	:SR=\E[%dT:sr=\E[T:ta=^I:ue=\E[0m:us=\E[4m:up=\E[A:vt#3:xo:\
	:cl=\E[H\E[J:\
	:bs:pt:

==============

From whm@arizona.edu  Mon Apr  7 22:21:48 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA02112; Mon, 7 Apr 86 22:21:48 PST
Received: by arizona.arizona.edu; Mon, 7 Apr 86 23:22:20 MST
Date: Mon, 7 Apr 86 23:22:18 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8604080622.AA25050@megaron.arizona.edu>
Received: by megaron.arizona.edu; Mon, 7 Apr 86 23:22:18 MST
To: beta43_bugs@monet.Berkeley.EDU
Subject: fatal ccom error for bogus program

Here's a little program that gets "compiler error: initialization alignment
error".  The program is in fact invalid (see the comment), so it's no big
deal.

enum ee {A, B, C, D, E};

struct {
    char *kwd;
    enum ee tk1, tk2;
} kwtab = {			/*  should be "kwtab[] ="  */
    {"black", A, B},
    {"white", C, D},
}


From hilbert!hubert@uw-beaver.arpa  Tue Apr  8 10:59:41 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA03960; Tue, 8 Apr 86 10:59:41 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA27833; Tue, 8 Apr 86 11:07:06 PST
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA15266; Tue, 8 Apr 86 10:57:55 PST
Date: Tue, 8 Apr 86 10:57:55 PST
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Tue, 8 Apr 86 10:57:55 PST
Message-Id: <8604081857.AA15266@hilbert.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Man page, intro(3M)
Cc: larryw@uw-beaver.arpa

We believe that the DESCRIPTION paragraph for the math library is
either incorrect or misleading.  It seems to imply that the 3M
functions are available from f77.  The few functions we checked were
not callable from f77 (e.g. ceil, floor).
------------
Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 entropy!hubert@uw-beaver


INTRO(3M)           UNIX Programmer's Manual            INTRO(3M)


NAME
     intro - introduction to mathematical library functions

DESCRIPTION
     These functions constitute the math library, libm. They are
     automatically loaded as needed by the Fortran compiler
     f77(1).  The link editor searches this library under the
     "-lm" option.  Declarations for these functions may be
     obtained from the include file <math.h>.

From allegra!jpl@ucbvax.berkeley.edu  Wed Apr  9 03:59:43 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA19890; Wed, 9 Apr 86 03:59:43 PST
Received: by ucbvax.berkeley.edu (5.48/1.11)
	id AA25452; Wed, 9 Apr 86 04:00:08 PST
From: allegra!jpl@ucbvax.berkeley.edu
Message-Id: <8604091200.AA25452@ucbvax.berkeley.edu>
Date: Wed, 9 Apr 86 06:23:52 est
To: ucbvax!ucbmonet!beta43_bugs
Subject: VANGOGHs MAXDSIZ

It is unkind to distribute VANGOGH's config file with its MAXDSIZ=64000000,
not because it doesn't work, but rather because it does.  When one then
continues down the primrose path, and tries DFLDSIZ=48000000, the resulting
kernel is not a pretty thing.  It would be a courtesy to correct VANGOGH
to look something like MAXDSIZ="(64*1024*1024/NBPG)", which not only works,
but is a better model for subsequent twiddling.

John P. Linderman  allegra!jpl

From guyton@rand-unix.ARPA  Wed Apr  9 23:26:11 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA23069; Wed, 9 Apr 86 23:26:11 PST
Received: from localhost by rand-unix.ARPA; Wed, 9 Apr 86 20:48:36 pst
Message-Id: <8604100448.AA01035@rand-unix.ARPA>
To: beta43_bugs@monet.Berkeley.EDU
Cc: James_Guyton <guyton@rand-unix.ARPA>
Subject: rmail bug
Date: Wed, 09 Apr 86 20:48:26 PST
From: guyton@rand-unix.ARPA

When you have an arpanet->uucp gateway, the from
line that is generated can be a lot bigger than
what rmail expects.  String overflow and core
dumps are the result ...

Quick hack fix ...

% diff rmail.c.orig rmail.c
35,36c35,36
<       char ufrom[64]; /* user on remote system */
<       char sys[64];   /* a system in path */
---
>       char ufrom[512]; /* user on remote system */
>       char sys[512];   /* a system in path */

From guy%gorodish@SUN.COM  Thu Apr 10 19:11:12 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA24094; Thu, 10 Apr 86 19:11:12 PST
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA27263; Thu, 10 Apr 86 18:56:30 PST
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0DEV4)
	id AA09547; Thu, 10 Apr 86 18:55:17 PST
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA00951; Thu, 10 Apr 86 19:00:04 PST
Date: Thu, 10 Apr 86 19:00:04 PST
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8604110300.AA00951@gorodish.sun.uucp>
Subject: The manual page TTY(4) is horribly out-of-date
Index: 	man/man4/tty.4 4.3BSD
To: beta43_bugs@monet.Berkeley.EDU

Description:
	It looks like this page has barely been changed since 4.1BSD.
	Many claims are incorrect, and many things aren't documented.
Repeat-By:
	Read the manual page, then read the code.
Fix:
	Here's an updated version:

.\" Copyright (c) 1983 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
.\"
.\"	@(#)tty.4	6.3 (Berkeley) 8/13/85
.\"
.TH TTY 4 "August 13, 1985"
.UC 4
.SH NAME
tty \- general terminal interface
.SH SYNOPSIS
.B #include <sgtty.h>
.SH DESCRIPTION
This section describes
both a particular special file
.B /dev/tty
and the terminal drivers used for conversational computing.
.LP
.B Line disciplines.
.PP
The system provides different
.I "line disciplines"
for controlling communications lines.
In this version of the system there are three disciplines available:
.IP "old" 8
The old (standard) terminal driver.  This is used when using the
standard shell
.IR sh (1)
and for compatibility with other standard version 7 UNIX systems.
.IP "new"
A newer terminal driver, with features for job control; this must
be used when using
.IR csh (1).
.IP "net"
A line discipline used for networking and loading data into
the system over communications lines.  It allows high speed input
at very low overhead, and is described in
.IR bk (4).
.LP
Line discipline switching is accomplished with the TIOCSETD 
.IR ioctl :
.IP
.B "int ldisc = LDISC;"
.br
.B "ioctl(f, TIOCSETD, &ldisc);"
.LP
where LDISC is OTTYDISC for the standard tty driver, NTTYDISC for the new
driver and NETLDISC for the networking discipline.
The standard (currently old) tty driver is discipline 0 by convention.
The current line discipline can be obtained with the TIOCGETD
.IR ioctl .
Pending input is discarded when the line discipline is changed.
.PP
All of the low-speed asynchronous
communications ports can use any
of the available line disciplines, no matter what
hardware is involved.
The remainder of this section discusses the
\*(lqold\*(rq and \*(lqnew\*(rq disciplines.
.LP
.B "The control terminal."
.LP
When a terminal file is opened, it causes the process to wait until a
connection is established.  In practice, user programs seldom open
these files; they are opened by
.IR init (8)
and become a user's standard input and output file.
.PP
If a process which has no control terminal opens a terminal file, then
that terminal file becomes the control terminal for that process.
The control terminal is thereafter inherited by a child process during a
.IR fork (2),
even if the control terminal is closed.
.LP
The file
.B /dev/tty
is, in each process, a synonym for a
.I "control terminal"
associated with that process.  It is useful for programs that wish to
be sure of writing messages on the terminal
no matter how output has been redirected.
It can also be used for programs that demand a file name
for output, when typed output is desired
and it is tiresome to find out which terminal
is currently in use.
.LP
A process can remove the association it has with its controlling
terminal by opening the file
.B /dev/tty
and issuing a
.IP
.B "ioctl(f, TIOCNOTTY, 0);"
.LP
This is often desirable in server processes.
.LP
.B "Process groups."
.LP
Command processors such as
.IR csh (1)
can arbitrate the terminal between different
.I jobs
by placing related jobs in a single process group and associating this
process group with the terminal.  A terminal's associated process group
may be set using the TIOCSPGRP
.IR ioctl (2):
.IP
.B "ioctl(fildes, TIOCSPGRP, &pgrp);"
.LP
or examined using TIOCGPGRP, which returns the current
process group in
.IR pgrp .
The new terminal driver aids in this arbitration by restricting access
to the terminal by processes which are not in the current process group;
see
.B "Job access control"
below.
.LP
.B "Modes."
.PP
The terminal drivers have three major modes, characterized by the
amount of processing on the input and output characters:
.IP cooked 10
The normal mode.  In this mode lines of input are collected and input editing
is done.  The edited line is made available when it is completed by
a newline
or when the \fIt_brkc\fP character, normally an EOT (control-D, hereafter ^D),
is entered.
A carriage return is usually made synonymous with newline in this mode,
and replaced with a newline whenever it is typed.
All driver functions
(input editing, interrupt generation,
output processing such as delay generation and tab expansion, etc.)
are available in this mode.
.IP CBREAK 10
This mode eliminates the character, word, and line editing input facilities,
making the input character available to the user program as it is typed.
Flow control, literal-next and interrupt processing are still done in this mode.
Output processing is done.
.IP RAW 10
This mode eliminates all input processing and makes all input characters
available as they are typed; no output processing is done either.
.PP
The style of input processing can also be very different when
the terminal is put in non-blocking i/o mode; see
the FNDELAY flag as described in
.IR fcntl (2).
In this case a
.IR read (2)
from the control terminal will never block, but rather
return an error indication (EWOULDBLOCK) if there is no
input available.
.PP
A process may also request a SIGIO signal be sent it whenever input
is present.  To enable this mode the FASYNC flag should be set using
.IR fcntl (2).
.LP
.B "Input editing."
.LP
A UNIX terminal ordinarily operates in full-duplex mode.
Characters may be typed at any time,
even while output is occurring, and are only lost when the
system's character input buffers become completely
choked, which is rare,
or when the user has accumulated the maximum allowed number of
input characters that have not yet been read by some program.
Currently this limit is 256 characters.
In RAW mode, the terminal driver
throws away all input and output without notice when the limit is reached.
In CBREAK or cooked mode it refuses to accept any further input and,
if in the new line discipline, rings the terminal bell.
.PP
Input characters are normally accepted in either even or odd parity
with the parity bit being stripped off before the character is given to
the program.  By clearing either the EVEN or ODD bit in the flags word
it is possible to have input characters with that parity discarded (see the
\fBSummary\fR below.)
.PP
In all of the line disciplines, it is possible to simulate terminal
input using the TIOCSTI
.IR ioctl ,
which takes, as its third argument,
the address of a character.  The system pretends that this character
was typed on the argument terminal, which must be the control terminal except
for the super-user (this call is not in standard version 7 UNIX).
.PP
Input characters are normally echoed by putting them in an output queue
as they arrive.  This may be disabled by clearing the ECHO bit in the
flags word using the
.IR stty (3C)
call or the TIOCSETN or TIOCSETP
.IR ioctl s
(see the \fBSummary\fR below).
.PP
In cooked mode, terminal input is processed in units of lines.
A program attempting
to read will normally be suspended until an entire line has been
received
(but see the description of SIGTTIN in \fBJob access control\fR
and of FIONREAD in
\fBSummary\fR, both below.)
No matter how many characters are requested
in the read call, at most one line will be returned.
It is not, however, necessary to read a whole line at
once; any number of characters may be
requested in a read, even one, without losing information.
.PP
During input, line editing is normally done, with the DELETE character
logically erasing the last character typed and the character ^U (control-U)
logically erasing the entire current input line.
These characters
never erase beyond the beginning of the current input line or an ^D.
These characters may be entered literally by
preceding them with `\e\|'; the `\e\|' will normally be erased when the
character is typed.
.PP
The drivers normally treat either a carriage return or a newline character
as terminating an input line, replacing the return with a newline and echoing
a return and a line feed.
If the CRMOD bit is cleared in the local mode word then the processing
for carriage return is disabled, and it is simply echoed as a return,
and does not terminate cooked mode input.
.PP
In the new driver there is a literal-next character ^V which can be typed
in both cooked and CBREAK mode preceding
.I any
character to prevent its special meaning.  This is to be preferred to the
use of `\e\|' escaping erase and kill characters, but `\e\|' is
retained with its old function in the new line discipline.
.PP
The new terminal driver also provides two other editing characters in
normal mode.  The word-erase character, normally ^W, erases the preceding
word, but not any spaces before it.  For the purposes of ^W, a word
is defined as a sequence of non-blank characters, with tabs counted as
blanks.
Finally, the reprint character, normally ^R, retypes the pending input beginning
on a new line.  Retyping occurs automatically in cooked mode if characters
which would normally be erased from the screen are fouled by program output.
.LP
.B "Input echoing and redisplay"
.LP
The terminal driver has several modes (not present in standard UNIX
Version 7 systems) for handling the echoing of
terminal input, controlled by bits in a local mode word.
.LP
.I "Hardcopy terminals."
When a hardcopy terminal is in use, the LPRTERA bit is normally set in
the local mode word.  Characters which are logically erased are
then printed out backwards preceded by `\e\|' and followed by `/' in this mode.
.LP
.I "CRT terminals."
When a CRT terminal is in use, the LCRTBS bit is normally set in the local
mode word.  The terminal driver then echoes the proper number of erase
characters when input is erased; in the normal case where the erase
character is a ^H this causes the cursor of the terminal to back up
to where it was before the logically erased character was typed.
If the input has become fouled due to interspersed asynchronous output,
the input is automatically retyped.
.LP
.I "Erasing characters from a CRT."
When a CRT terminal is in use, the LCRTERA bit may be set to cause
input to be erased from the screen with a \*(lqbackspace-space-backspace\*(rq
sequence when character or word deleting sequences are used.
A LCRTKIL bit may be set as well, causing the input to
be erased in this manner on line kill sequences as well.
.LP
.I "Echoing of control characters."
If the LCTLECH bit is set in the local state word, then non-printing (control)
characters are normally echoed as ^X (for some X)
rather than being echoed unmodified; delete is echoed as ^?.
.LP
The normal modes for use on CRT terminals are speed dependent.
At speeds less than 1200 baud, the LCRTERA and LCRTKILL processing
is painfully slow, so 
.IR stty (1)
normally just sets LCRTBS and LCTLECH; at
speeds of 1200 baud or greater all of these bits are normally set.
.IR Stty (1)
summarizes these option settings and the use of the new terminal
driver as
\*(lqnewcrt.\*(rq
.LP
.B "Output processing."
.PP
When one or more
characters are written, they are actually transmitted
to the terminal as soon as previously-written characters
have finished typing.
(As noted above, input characters are normally 
echoed by putting them in the output queue
as they arrive.)
When a process produces characters more rapidly than they can be typed,
it will be suspended when its output queue exceeds some limit.
When the queue has drained down to some threshold
the program is resumed.
Even parity is normally generated on output.
The EOT character is not transmitted in cooked mode to prevent terminals
that respond to it from hanging up; programs using RAW or CBREAK mode
should be careful.
.PP
The terminal drivers provide necessary processing for cooked and CBREAK mode
output including delay generation for certain special characters and parity
generation.   Delays are available after backspaces ^H, form feeds ^L,
carriage returns ^M, tabs ^I and newlines ^J.  The driver will also optionally
expand tabs into spaces, where the tab stops are assumed to be set every
eight columns, and optionally convert newlines to carriage returns
followed by newline.  These functions are controlled by bits in the tty
flags word; see \fBSummary\fR below.
.PP
The terminal drivers provide for mapping between upper and lower case
on terminals lacking lower case, and for other special processing on
deficient terminals.
.PP
Finally, in the new terminal driver, there is a output flush character,
normally ^O, which sets the LFLUSHO bit in the local mode word, causing
subsequent output to be flushed until it is cleared by a program or more
input is typed.  This character has effect in both cooked and CBREAK modes
and causes pending input to be retyped if there is any pending input.
An
.I ioctl
to flush the characters in the input or output queues, TIOCFLUSH,
is also available.
.LP
.B "Upper case terminals and Hazeltines"
.PP
If the LCASE bit is set in the tty flags, then
all upper-case letters are mapped into
the corresponding lower-case letter.
The upper-case letter may be generated by preceding
it by `\\'.
Upper case letters are preceded by a `\e\|' when output.
In addition, the following escape sequences can be generated
on output and accepted on input:
.PP
.nf
for	\`	|	~	{	}
use	\e\|\'	\e\|!	\e\|^	\e\|(	\e\|)
.fi
.PP
To deal with Hazeltine terminals, which do not understand that ~ has
been made into an ASCII character, the LTILDE bit may be set in the local
mode word; in this case the character
~ will be replaced with the character \` on output.
.LP
.B "Flow control."
.PP
There are two characters (the stop character, normally ^S, and the
start character, normally ^Q) which cause output to be suspended and
resumed respectively.  Extra stop characters typed when output
is already stopped have no effect, unless the start and stop characters
are made the same, in which case output resumes.
.PP
A bit in the flags word may be set to put the terminal into TANDEM mode.
In this mode the system produces a stop character (default ^S) when
the input queue is in danger of overflowing, and a start character (default
^Q) when the input has drained sufficiently.  This mode is useful
when the terminal is actually another machine that obeys the
conventions.
.LP
.B "Line control and breaks."
.LP
There are several
.I ioctl
calls available to control the state of the terminal line.
The TIOCSBRK
.I ioctl
will set the break bit in the hardware interface
causing a break condition to exist; this can be cleared (usually after a delay
with
.IR sleep (3))
by TIOCCBRK.
Break conditions in the input are reflected as a null character in RAW mode
or as the interrupt character in cooked or CBREAK mode.
The TIOCCDTR
.I ioctl
will clear the data terminal ready condition; it can
be set again by TIOCSDTR.
.PP
When the carrier signal from the dataset drops (usually
because the user has hung up his terminal) a
SIGHUP hangup signal is sent to the processes in the distinguished
process group of the terminal; this usually causes them to terminate
(the SIGHUP can be suppressed by setting the LNOHANG bit in the local
state word of the driver.)
Access to the terminal by other processes is then normally revoked,
so any further reads will fail, and programs that read a terminal and test for
end-of-file on their input will terminate appropriately.
.PP
When using an ACU
it is possible to ask that the phone line be hung up on the last close
with the TIOCHPCL
.IR ioctl ;
this is normally done on the outgoing line.
.LP
.B "Interrupt characters."
.PP
There are several characters that generate interrupts in cooked and CBREAK
mode; all are sent to the processes in the control group of the terminal,
as if a TIOCGPGRP
.I ioctl
were done to get the process group and then a
.IR killpg (2)
system call were done,
except that these characters also flush pending input and output when
typed at a terminal
(\fI\z'a\`'la\fR TIOCFLUSH).
The characters shown here are the defaults; the field names in the structures
(given below)
are also shown.
The characters may be changed.
.IP ^C
\fBt_intrc\fR (ETX) generates a SIGINT signal.
This is the normal way to stop a process which is no longer interesting,
or to regain control in an interactive program.
.IP ^\e
\fBt_quitc\fR (FS) generates a SIGQUIT signal.
This is used to cause a program to terminate and produce a core image,
if possible,
in the file
.B core
in the current directory.
.IP ^Z
\fBt_suspc\fR (EM) generates a SIGTSTP signal, which is used to suspend
the current process group.
.IP ^Y
\fBt_dsuspc\fR (SUB) generates a SIGTSTP signal as ^Z does, but the
signal is sent when a program attempts to read the ^Y, rather than when
it is typed.
.LP
.B "Job access control."
.PP
When using the new terminal driver,
if a process which is not in the distinguished process group of its
control terminal attempts to read from that terminal its process group is
sent a SIGTTIN signal.  This signal normally causes the members of
that process group to stop. 
If, however, the process is ignoring SIGTTIN, has SIGTTIN blocked,
or is in the middle of process creation using
.IR vfork (2)),
the read will return \-1 and set
.I errno
to EIO.
.PP
When using the new terminal driver with the LTOSTOP bit set in the local
modes, a process is prohibited from writing on its control terminal if it is
not in the distinguished process group for that terminal.
Processes which are holding or ignoring SIGTTOU signals
or which are in the middle of a
.IR vfork (2)
are excepted and allowed to produce output.
.LP
.B "Summary of modes."
.LP
Unfortunately, due to the evolution of the terminal driver,
there are 4 different structures which contain various portions of the
driver data.  The first of these (\fBsgttyb\fR)
contains that part of the information
largely common between version 6 and version 7 UNIX systems.
The second contains additional control characters added in version 7.
The third is a word of local state added in 4BSD,
and the fourth is another structure of special characters added for the
new driver.  In the future a single structure may be made available
to programs which need to access all this information; most programs
need not concern themselves with all this state.
.de Ul
.ie t \\$1\l'|0\(ul'
.el \fI\\$1\fP
..
.LP
.Ul "Basic modes: sgtty."
.PP
The basic
.IR ioctl s
use the structure
defined in
.IR <sgtty.h> :
.PP
.ta .5i 1i
.nf
.ft 3
struct sgttyb {
	char	sg_ispeed;
	char	sg_ospeed;
	char	sg_erase;
	char	sg_kill;
	short	sg_flags;
};
.ft R
.fi
.PP
The
.I sg_ispeed 
and 
.I sg_ospeed
fields describe the input and output speeds of the
device according to the following table,
which corresponds to the DEC DH-11 interface.
If other hardware is used,
impossible speed changes are ignored.
Symbolic values in the table are as defined in
.IR <sgtty.h> .
.PP
.nf
.ta \w'B9600   'u +5n
B0	0	(hang up dataphone)
B50	1	50 baud
B75	2	75 baud
B110	3	110 baud
B134	4	134.5 baud
B150	5	150 baud
B200	6	200 baud
B300	7	300 baud
B600	8	600 baud
B1200	9	1200 baud
B1800	10	1800 baud
B2400	11	2400 baud
B4800	12	4800 baud
B9600	13	9600 baud
EXTA	14	External A
EXTB	15	External B
.fi
.DT
.PP
Code conversion and line control required for
IBM 2741's (134.5 baud)
must be implemented by the user's
program.
The half-duplex line discipline
required for the 202 dataset (1200 baud)
is not supplied; full-duplex 212 datasets work fine.
.PP
The
.I sg_erase
and
.I sg_kill
fields of the argument structure
specify the erase and kill characters respectively.
(Defaults are DELETE and ^U.)
.PP
The
.I sg_flags
field of the argument structure
contains several bits that determine the
system's treatment of the terminal:
.PP
.ta \w'ALLDELAY 'u +\w'0100000 'u
.nf
ALLDELAY	0177400	Delay algorithm selection
BSDELAY	0100000	Select backspace delays (not implemented):
BS0	0
BS1	0100000
VTDELAY	0040000	Select form-feed and vertical-tab delays:
FF0	0
FF1	0100000
CRDELAY	0030000	Select carriage-return delays:
CR0	0
CR1	0010000
CR2	0020000
CR3	0030000
TBDELAY	0006000	Select tab delays:
TAB0	0
TAB1	0001000
TAB2	0004000
XTABS	0006000
NLDELAY	0001400	Select new-line delays:
NL0	0
NL1	0000400
NL2	0001000
NL3	0001400
EVENP	0000200	Even parity allowed on input and generated on output
ODDP	0000100	Odd parity allowed on input and generated on output
RAW	0000040	Raw mode: wake up on all characters, 8-bit interface
CRMOD	0000020	Map CR into LF; output LF as CR-LF
ECHO	0000010	Echo (full duplex)
LCASE	0000004	Map upper case to lower on input and lower to upper on output
CBREAK	0000002	Return each character as soon as typed
TANDEM	0000001	Automatic flow control
.DT
.fi
.PP
The delay bits specify how long
transmission stops to allow for mechanical or other movement
when certain characters are sent to the terminal.
In all cases a value of 0 indicates no delay.
.PP
Backspace delays are currently ignored but might
be used for Terminet 300's.
.PP
If a form-feed/vertical tab delay is specified,
it lasts for about 2 seconds.
.PP
Carriage-return delay type 1 lasts about .08 seconds
and is suitable for the Terminet 300.
Delay type 2 lasts about .16 seconds and is suitable
for the VT05 and the TI 700.
Delay type 3 is suitable for the concept-100 and pads lines
to be at least 9 characters at 9600 baud.
.PP
New-line delay type 1 is dependent on the current column
and is tuned for Teletype model 37's.
Type 2 is useful for the VT05 and is about .10 seconds.
Type 3 is unimplemented and is 0.
.PP
Tab delay type 1 is dependent on the amount of movement
and is tuned to the Teletype model
37.
Type 3, called XTABS,
is not a delay at all but causes tabs to be replaced
by the appropriate number of spaces on output.
.PP
Input characters with the wrong parity, as determined by bits 200 and
100, are ignored in cooked and CBREAK mode.
.PP
RAW
disables all processing save output flushing with LFLUSHO;
full 8 bits of input are given as soon as
it is available; all 8 bits are passed on output.
A break condition in the input is reported as a null character.
If the input queue overflows in raw mode all data in the input and output
queues are discarded; this applies to both new and old drivers.
.PP
CRMOD causes input carriage returns to be turned into
new-lines, and output and echoed new-lines to be output as a carriage return
followed by a line feed.
.PP
CBREAK is a sort of half-cooked (rare?) mode.
Programs can read each character as soon as typed, instead
of waiting for a full line;
all processing is done except the input editing:
character and word erase and line kill, input reprint,
and the special treatment of \e and EOT are disabled.
.PP
TANDEM mode causes the system to produce
a stop character (default ^S) whenever the input
queue is in danger of overflowing, and a start character
(default ^Q)
when the input queue has drained sufficiently.
It is useful for flow control when the `terminal'
is really another computer which understands the conventions.
.LP
.B Note:
The same ``stop'' and ``start'' characters are used for both directions
of flow control; the
.I t_stopc
character is accepted on input as the character that stops output and is
produced on output as the character to stop input, and the
.I t_startc
character is accepted on input as the character that restarts output and is
produced on output as the character to restart input.
.LP
.Ul "Basic ioctls"
.PP
A large number of
.IR ioctl (2)
calls apply to terminals.  Some have the general form:
.PP
.B #include <sgtty.h>
.PP
.B ioctl(fildes, code, arg)
.br
.B struct sgttyb *arg;
.PP
The applicable codes are:
.IP TIOCGETP 15
Fetch the basic parameters associated with the terminal, and store
in the pointed-to \fIsgttyb\fR structure.
.IP TIOCSETP
Set the parameters according to the pointed-to \fIsgttyb\fR structure.
The interface delays until output is quiescent,
then throws away any unread characters,
before changing the modes.
.IP TIOCSETN
Set the parameters like TIOCSETP but do not delay or flush input.
Input is not preserved, however, when changing to or from RAW.
.PP
With the following codes
.I arg
is ignored.
.IP TIOCEXCL 15
Set \*(lqexclusive-use\*(rq mode:
no further opens are permitted until the file has been closed.
.IP TIOCNXCL
Turn off \*(lqexclusive-use\*(rq mode.
.IP TIOCHPCL
When the file is closed for the last time,
hang up the terminal.
This is useful when the line is associated
with an ACU used to place outgoing calls.
.PP
With the following codes
.I arg
is a pointer to an
.BR int .
.IP TIOCGETD 15
.I arg
is a pointer to an
.B int
into which is placed the current line discipline number.
.IP TIOCSETD
.I arg
is a pointer to an
.B int
whose value becomes the current line discipline number.
.IP TIOCFLUSH
If the
.B int
pointed to by
.I arg
has a zero value, all characters waiting in input or output queues are flushed.
Otherwise, the value of the
.B int
is treated as the logical OR of the FREAD and FWRITE defined in
.BR <sys/file.h> ;
if the FREAD bit is set, all characters waiting in input queues are flushed,
and if the FWRITE bit is set, all characters waiting in output queues are
flushed.
.LP
The remaining calls are not available in vanilla version 7 UNIX.
In cases where arguments are required, they are described; \fIarg\fR
should otherwise be given as 0.
.IP TIOCSTI 15
the argument points to a character which the system
pretends had been typed on the terminal.
.IP TIOCSBRK 15
the break bit is set in the terminal.
.IP TIOCCBRK
the break bit is cleared.
.IP TIOCSDTR 
data terminal ready is set.
.IP TIOCCDTR
data terminal ready is cleared.
.IP TIOCSTOP 15
output is stopped as if the ``stop'' character had been typed.
.IP TIOCSTART
output is restarted as if the ``start'' character had been typed.
.IP TIOCGPGRP
.I arg
is a pointer to an
.B int
into which is placed the process group ID of the process group
for which this terminal is the control terminal.
.IP TIOCSPGRP
.I arg
is a pointer to an
.B int
(typically a process ID); the process group whose process group ID
is the value of this
.B int
becomes the process group for which this terminal is the control terminal.
.IP TIOCOUTQ
returns in the
.B int
pointed to by
.I arg
the number of characters queued up to be output to the terminal.
.IP FIONREAD
returns in the
.B int
pointed to by
.I arg
the number of immediately readable characters from the argument unit.
This works for files, pipes, and terminals.
.PP
.Ul Tchars
.PP
The second structure associated with each terminal specifies
characters that are special in both the old and new terminal interfaces:
The following structure is defined in
.IR <sys/ioctl.h> ,
which is automatically included in
.IR <sgtty.h> :
.PP
.nf
.ft 3
.ta .5i 1i 2i 
struct tchars {
	char	t_intrc;	/* interrupt */
	char	t_quitc;	/* quit */
	char	t_startc;	/* start output */
	char	t_stopc;	/* stop output */
	char	t_eofc;		/* end-of-file */
	char	t_brkc;		/* input delimiter (like nl) */
};
.DT
.fi
.ft R
.PP
The default values for these characters are
^?, ^\e\|, ^Q, ^S, ^D, and \-1.
A character value of \-1
eliminates the effect of that character.
The
.I t_brkc
character, by default \-1,
acts like a new-line in that it terminates a `line,'
is echoed, and is passed to the program.
The `stop' and `start' characters may be the same,
to produce a toggle effect.
It is probably counterproductive to make
other special characters (including erase and kill)
identical.
The applicable
.I ioctl
calls are:
.IP TIOCGETC 12
Get the special characters and put them in the specified structure.
.IP TIOCSETC 12
Set the special characters to those given in the structure.
.LP
.Ul "Local mode"
.PP
The third structure associated with each terminal is a local mode word.
The bits of the local mode word are:
.sp
.nf
LCRTBS	000001	Backspace on erase rather than echoing erase
LPRTERA	000002	Printing terminal erase mode
LCRTERA	000004	Erase character echoes as backspace-space-backspace
LTILDE	000010	Convert ~ to \` on output (for Hazeltine terminals)
LMDMBUF	000020	Stop/start output when carrier drops
LLITOUT	000040	Suppress output translations
LTOSTOP	000100	Send SIGTTOU for background output
LFLUSHO	000200	Output is being flushed
LNOHANG	000400	Don't send hangup when carrier drops
LETXACK	001000	Diablo style buffer hacking (unimplemented)
LCRTKIL	002000	BS-space-BS erase entire line on line kill
LPASS8	004000	Pass all 8 bits through on input, in any mode
LCTLECH	010000	Echo input control chars as ^X, delete as ^?
LPENDIN	020000	Retype pending input at next read or input character
LDECCTQ	040000	Only ^Q restarts output after ^S, like DEC systems
LNOFLSH	100000	Inhibit flushing of pending I/O when an interrupt character is typed.
.fi
.sp
The applicable
.I ioctl
functions are:
.IP TIOCLBIS 15
.I arg
is a pointer to an
.B int
whose value is a mask containing the bits to be set in the local mode word.
.IP TIOCLBIC
.I arg
is a pointer to an
.B int
whose value is a mask containing the bits to be cleared in the local mode word.
.IP TIOCLSET
.I arg
is a pointer to an
.B int
whose value is stored in the local mode word.
.IP TIOCLGET
.I arg
is a pointer to an
.B int
into which the current local mode word is placed.
.LP
.Ul "Local special chars"
.PP
The
final structure associated with each terminal is the
.I ltchars
structure which defines control characters
for the new terminal driver.
Its structure is:
.nf
.sp
.ta .5i 1i 2i
.ft B
struct ltchars {
	char	t_suspc;	/* stop process signal */
	char	t_dsuspc;	/* delayed stop process signal */
	char	t_rprntc;	/* reprint line */
	char	t_flushc;	/* flush output (toggles) */
	char	t_werasc;	/* word erase */
	char	t_lnextc;	/* literal next character */
};
.ft R
.fi
.sp
The default values for these characters are ^Z, ^Y, ^R, ^O, ^W, and ^V.
A value of \-1 disables the character.
.PP
The applicable \fIioctl\fR functions are:
.IP TIOCSLTC 12
.I arg
is a pointer to an
.I ltchars
structure which defines the new local special characters.
.IP TIOCGLTC 12
.I arg
is a pointer to an
.I ltchars
structure into which is placed the current set of local special characters.
.SH FILES
/dev/tty
.br
/dev/tty*
.br
/dev/console
.SH SEE ALSO
csh(1),
stty(1),
ioctl(2),
sigvec(2),
stty(3C),
getty(8),
init(8)
.SH BUGS
Half-duplex terminals are not supported.

From guy%gorodish@SUN.COM  Fri Apr 11 12:05:59 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA06206; Fri, 11 Apr 86 12:05:59 PST
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA01526; Fri, 11 Apr 86 11:41:40 PST
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0DEV4)
	id AA12367; Fri, 11 Apr 86 11:40:30 PST
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA01684; Fri, 11 Apr 86 11:45:21 PST
Date: Fri, 11 Apr 86 11:45:21 PST
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8604111945.AA01684@gorodish.sun.uucp>
Subject: "tar" chooses the wrong block size for reading
Index: 	bin/tar.c 4.3BSD beta
To: beta43_bugs@monet.Berkeley.EDU

Description:
	The delta 4.23, with the comments

		Tape Blocking via stat, vfile output and linebuffering output 
		F flag now skips RCS files, Force i/o blocking to 20 over non
		tape devices

	incorrectly chooses the block size based on the size of the archive
	rather than based on the blocksize of the file system it's on.

	Also, it sets "mtdev" based on whether the archive is on a character
	special file or not; this is incorrect, because if "mtdev" is 0
	"tar" uses mag tape "ioctl"s to manipulate the device.
Repeat-By:
	Create a "tar" file with a size greater than or equal to 512 blocks,
	and note that when you read this the new "tar" reads it with a
	block size of 1.
Fix:
	Here's a context diff which fixes this and various other problems.
	The list of other problems is given here, along with the actual
	changes for some of them.

Improved the error messages.

Put the code to open the "tar" tape (or file) into a common routine, and
fixed it to truncate any file it's going to write to (previously, it just
started writing, and any stuff that wasn't written over was just left there).

Avoid infinite loop on EOF when using B option:

1221c1268,1269
< 	static int lastread = 0;
---
> #define	NOREAD -2147483648
> 	static int lastread = NOREAD;
1227,1228c1275
< 		lastread = read(fd, buf, size - count);
< 		if (lastread <= 0) {
---
> 		if (lastread <= 0 && lastread != NOREAD) {
1232a1280
> 		lastread = read(fd, buf, size - count);
1235a1284
> #undef NOREAD

Handle absolute path names:

482c505,508
< 		sprintf(newparent, "%s/%s", parent, shortname);
---
> 		if (*shortname != '/')
> 			sprintf(newparent, "%s/%s", parent, shortname);
> 		else
> 			sprintf(newparent, "%s", shortname);
484c510,511
< 			perror(shortname);
---
> 			fprintf(stderr, "tar: ");
> 			perror(newparent);

Changed "select" to "selectbits"; this doesn't matter now, but a version
here which supported remote tapes using "rmt" didn't work, because it used the
Yellow Pages to get a host name and that used the "select" system call.

Handle EOT on tape writes properly:

1158,1161c1187,1189
< 		if (write(mt, tbuf, TBLOCK*nblock) < 0) {
< 			fprintf(stderr,"tar: tape write error\n");
< 			done(2);
< 		}
---
> 		i = write(mt, tbuf, TBLOCK*nblock);
> 		if (i != TBLOCK*nblock)
> 			mterr("write", i, 2);
1172,1175c1200,1202
< 		if (write(mt, buffer, TBLOCK*nblock) < 0) {
< 			fprintf(stderr,"tar: tape write error\n");
< 			done(2);
< 		}
---
> 		i = write(mt, buffer, TBLOCK*nblock);
> 		if (i != TBLOCK*nblock)
> 			mterr("write", i, 2);
1184,1187c1211,1213
< 			if (write(mt, tbuf, TBLOCK*nblock) < 0) {
< 					fprintf(stderr,"tar: tape write error\n");
< 					done(2);
< 			}
---
> 			i = write(mt, tbuf, TBLOCK*nblock);
> 			if (i != TBLOCK*nblock)
> 				mterr("write", i, 2);

Here's a (new-style) context diff against version 5.4:

*** tar.c.orig	Fri Apr 11 11:37:54 1986
--- tar.c	Fri Apr 11 11:37:11 1986
***************
*** 26,36 ****
  #include <sys/time.h>
  #include <signal.h>
  #include <errno.h>
  
  #define TBLOCK	512
  #define NBLOCK	20
  #define NAMSIZ	100
- #define FILEBLOCK 20
  
  #define	writetape(b)	writetbuf(b, 1)
  #define	min(a,b)  ((a) < (b) ? (a) : (b))
--- 26,36 ----
  #include <sys/time.h>
  #include <signal.h>
  #include <errno.h>
+ #include <fcntl.h>
  
  #define TBLOCK	512
  #define NBLOCK	20
  #define NAMSIZ	100
  
  #define	writetape(b)	writetbuf(b, 1)
  #define	min(a,b)  ((a) < (b) ? (a) : (b))
***************
*** 80,86 ****
  int	Fflag;
  
  int	mt;
- int	mtdev = 1;
  int	term;
  int	chksum;
  int	recno;
--- 80,85 ----
***************
*** 107,112 ****
--- 106,112 ----
  char	*malloc();
  char	*sprintf();
  char	*strcat();
+ char	*strcpy();
  char	*rindex();
  char	*getcwd();
  char	*getwd();
***************
*** 254,285 ****
  		if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
  			signal(SIGTERM, onterm);
  #endif
! 		if (strcmp(usefile, "-") == 0) {
! 			if (cflag == 0) {
! 				fprintf(stderr,
! 			 "tar: can only create standard output archives\n");
! 				done(1);
! 			}
! 			vfile = stderr;
! 			setlinebuf(vfile);
! 			mt = dup(1);
! 		} else if ((mt = open(usefile, 2)) < 0) {
! 			if (cflag == 0 || (mt =  creat(usefile, 0666)) < 0) {
! 				fprintf(stderr,
! 					"tar: cannot open %s\n", usefile);
! 				done(1);
! 			}
! 		}
  		dorep(argv);
  		done(0);
  	}
! 	if (strcmp(usefile, "-") == 0) {
! 		mt = dup(0);
! 		Bflag++;
! 	} else if ((mt = open(usefile, 0)) < 0) {
! 		fprintf(stderr, "tar: cannot open %s\n", usefile);
! 		done(1);
! 	}
  	if (xflag)
  		doxtract(argv);
  	else
--- 254,264 ----
  		if (signal(SIGTERM, SIG_IGN) != SIG_IGN)
  			signal(SIGTERM, onterm);
  #endif
! 		mt = openmt(usefile, 1);
  		dorep(argv);
  		done(0);
  	}
! 	mt = openmt(usefile, 0);
  	if (xflag)
  		doxtract(argv);
  	else
***************
*** 294,299 ****
--- 273,324 ----
  	done(1);
  }
  
+ int
+ openmt(tape, writing)
+ 	char *tape;
+ 	int writing;
+ {
+ 	register char *rmtape;
+ 	extern char *rmterr;
+ 
+ 	if (strcmp(tape, "-") == 0) {
+ 		/*
+ 		 * Read from standard input or write to standard output.
+ 		 */
+ 		if (writing) {
+ 			if (cflag == 0) {
+ 				fprintf(stderr,
+ 			 "tar: can only create standard output archives\n");
+ 				done(1);
+ 			}
+ 			vfile = stderr;
+ 			setlinebuf(vfile);
+ 			mt = dup(1);
+ 		} else {
+ 			mt = dup(0);
+ 			Bflag++;
+ 		}
+ 	} else {
+ 		/*
+ 		 * Use file or tape on local machine.
+ 		 */
+ 		if (writing) {
+ 			if (cflag)
+ 				mt = open(tape, O_RDWR|O_CREAT|O_TRUNC,
+ 				    0666);
+ 			else
+ 				mt = open(tape, O_RDWR);
+ 		} else
+ 			mt = open(tape, O_RDONLY);
+ 		if (mt < 0) {
+ 			fprintf(stderr, "tar: ");
+ 			perror(tape);
+ 			done(1);
+ 		}
+ 	}
+ 	return(mt);
+ }
+ 
  dorep(argv)
  	char *argv[];
  {
***************
*** 328,336 ****
  		cp2 = *argv;
  		if (!strcmp(cp2, "-C") && argv[1]) {
  			argv++;
! 			if (chdir(*argv) < 0)
  				perror(*argv);
! 			else
  				(void) getcwd(wdir);
  			argv++;
  			continue;
--- 353,362 ----
  		cp2 = *argv;
  		if (!strcmp(cp2, "-C") && argv[1]) {
  			argv++;
! 			if (chdir(*argv) < 0) {
! 				fprintf(stderr, "tar: can't change directories to ");
  				perror(*argv);
! 			} else
  				(void) getcwd(wdir);
  			argv++;
  			continue;
***************
*** 342,347 ****
--- 368,374 ----
  		if (cp2 != *argv) {
  			*cp2 = '\0';
  			if (chdir(*argv) < 0) {
+ 				fprintf(stderr, "tar: can't change directories to ");
  				perror(*argv);
  				continue;
  			}
***************
*** 440,457 ****
  	else
  		i = stat(shortname, &stbuf);
  	if (i < 0) {
! 		switch (errno) {
! 		case EACCES:
! 			fprintf(stderr, "tar: %s: cannot open file\n", longname);
! 			break;
! 		case ENOENT:
! 			fprintf(stderr, "tar: %s: no such file or directory\n",
! 			    longname);
! 			break;
! 		default:
! 			fprintf(stderr, "tar: %s: cannot stat file\n", longname);
! 			break;
! 		}
  		return;
  	}
  	if (tfile != NULL && checkupdate(longname) == 0)
--- 467,474 ----
  	else
  		i = stat(shortname, &stbuf);
  	if (i < 0) {
! 		fprintf(stderr, "tar: ");
! 		perror(longname);
  		return;
  	}
  	if (tfile != NULL && checkupdate(longname) == 0)
***************
*** 479,492 ****
  			sprintf(dblock.dbuf.chksum, "%6o", checksum());
  			writetape((char *)&dblock);
  		}
! 		sprintf(newparent, "%s/%s", parent, shortname);
  		if (chdir(shortname) < 0) {
! 			perror(shortname);
  			return;
  		}
  		if ((dirp = opendir(".")) == NULL) {
! 			fprintf(stderr, "tar: %s: directory read error\n",
! 			    longname);
  			if (chdir(parent) < 0) {
  				fprintf(stderr, "tar: cannot change back?: ");
  				perror(parent);
--- 496,513 ----
  			sprintf(dblock.dbuf.chksum, "%6o", checksum());
  			writetape((char *)&dblock);
  		}
! 		if (*shortname != '/')
! 			sprintf(newparent, "%s/%s", parent, shortname);
! 		else
! 			sprintf(newparent, "%s", shortname);
  		if (chdir(shortname) < 0) {
! 			fprintf(stderr, "tar: ");
! 			perror(newparent);
  			return;
  		}
  		if ((dirp = opendir(".")) == NULL) {
! 			fprintf(stderr, "tar: can't open directory ");
! 			perror(longname);
  			if (chdir(parent) < 0) {
  				fprintf(stderr, "tar: cannot change back?: ");
  				perror(parent);
***************
*** 528,533 ****
--- 549,555 ----
  		}
  		i = readlink(shortname, dblock.dbuf.linkname, NAMSIZ - 1);
  		if (i < 0) {
+ 			fprintf(stderr, "tar: can't read symbolic link ");
  			perror(longname);
  			return;
  		}
***************
*** 543,549 ****
  
  	case S_IFREG:
  		if ((infile = open(shortname, 0)) < 0) {
! 			fprintf(stderr, "tar: %s: cannot open file\n", longname);
  			return;
  		}
  		tomodes(&stbuf);
--- 565,572 ----
  
  	case S_IFREG:
  		if ((infile = open(shortname, 0)) < 0) {
! 			fprintf(stderr, "tar: ");
! 			perror(longname);
  			return;
  		}
  		tomodes(&stbuf);
***************
*** 610,616 ****
  		close(infile);
  		if (bigbuf != buf)
  			free(bigbuf);
! 		if (blocks != 0 || i != 0)
  			fprintf(stderr, "tar: %s: file changed size\n",
  			    longname);
  		while (--blocks >=  0)
--- 633,642 ----
  		close(infile);
  		if (bigbuf != buf)
  			free(bigbuf);
! 		if (i < 0) {
! 			fprintf("tar: Read error on ");
! 			perror(longname);
! 		} else if (blocks != 0 || i != 0)
  			fprintf(stderr, "tar: %s: file changed size\n",
  			    longname);
  		while (--blocks >=  0)
***************
*** 675,682 ****
  					unlink(dblock.dbuf.name);
  			}
  			if (symlink(dblock.dbuf.linkname, dblock.dbuf.name)<0) {
! 				fprintf(stderr, "tar: %s: symbolic link failed\n",
  				    dblock.dbuf.name);
  				continue;
  			}
  			if (vflag)
--- 701,709 ----
  					unlink(dblock.dbuf.name);
  			}
  			if (symlink(dblock.dbuf.linkname, dblock.dbuf.name)<0) {
! 				fprintf(stderr, "tar: %s: symbolic link failed: ",
  				    dblock.dbuf.name);
+ 				perror("");
  				continue;
  			}
  			if (vflag)
***************
*** 702,709 ****
  					unlink(dblock.dbuf.name);
  			}
  			if (link(dblock.dbuf.linkname, dblock.dbuf.name) < 0) {
! 				fprintf(stderr, "tar: %s: cannot link\n",
! 				    dblock.dbuf.name);
  				continue;
  			}
  			if (vflag)
--- 729,737 ----
  					unlink(dblock.dbuf.name);
  			}
  			if (link(dblock.dbuf.linkname, dblock.dbuf.name) < 0) {
! 				fprintf(stderr, "tar: can't link %s to %s: ",
! 				    dblock.dbuf.name, dblock.dbuf.linkname);
! 				perror("");
  				continue;
  			}
  			if (vflag)
***************
*** 712,719 ****
  			continue;
  		}
  		if ((ofile = creat(dblock.dbuf.name,stbuf.st_mode&0xfff)) < 0) {
! 			fprintf(stderr, "tar: %s - cannot create\n",
  			    dblock.dbuf.name);
  			passtape();
  			continue;
  		}
--- 740,748 ----
  			continue;
  		}
  		if ((ofile = creat(dblock.dbuf.name,stbuf.st_mode&0xfff)) < 0) {
! 			fprintf(stderr, "tar: can't create %s: ",
  			    dblock.dbuf.name);
+ 			perror("");
  			passtape();
  			continue;
  		}
***************
*** 733,740 ****
  			nread = readtbuf(&bufp, nwant);
  			if (write(ofile, bufp, (int)min(nread, bytes)) < 0) {
  				fprintf(stderr,
! 				    "tar: %s: HELP - extract write error\n",
  				    dblock.dbuf.name);
  				done(2);
  			}
  			bytes -= nread;
--- 762,770 ----
  			nread = readtbuf(&bufp, nwant);
  			if (write(ofile, bufp, (int)min(nread, bytes)) < 0) {
  				fprintf(stderr,
! 				    "tar: %s: HELP - extract write error",
  				    dblock.dbuf.name);
+ 				perror("");
  				done(2);
  			}
  			bytes -= nread;
***************
*** 821,830 ****
  	register int **mp;
  
  	for (mp = &m[0]; mp < &m[9];)
! 		select(*mp++, st);
  }
  
! select(pairp, st)
  	int *pairp;
  	struct stat *st;
  {
--- 851,860 ----
  	register int **mp;
  
  	for (mp = &m[0]; mp < &m[9];)
! 		selectbits(*mp++, st);
  }
  
! selectbits(pairp, st)
  	int *pairp;
  	struct stat *st;
  {
***************
*** 1120,1129 ****
  	register int i;
  
  	if (recno >= nblock || first == 0) {
! 		if ((i = bread(mt, tbuf, TBLOCK*nblock)) < 0) {
! 			fprintf(stderr, "tar: tape read error\n");
! 			done(3);
! 		}
  		if (first == 0) {
  			if ((i % TBLOCK) != 0) {
  				fprintf(stderr, "tar: tape blocksize error\n");
--- 1150,1157 ----
  	register int i;
  
  	if (recno >= nblock || first == 0) {
! 		if ((i = bread(mt, tbuf, TBLOCK*nblock)) < 0)
! 			mterr("read", i, 3);
  		if (first == 0) {
  			if ((i % TBLOCK) != 0) {
  				fprintf(stderr, "tar: tape blocksize error\n");
***************
*** 1149,1154 ****
--- 1177,1183 ----
  	register char *buffer;
  	register int n;
  {
+ 	register int i;
  
  	if (first == 0) {
  		getbuf();
***************
*** 1155,1164 ****
  		first = 1;
  	}
  	if (recno >= nblock) {
! 		if (write(mt, tbuf, TBLOCK*nblock) < 0) {
! 			fprintf(stderr,"tar: tape write error\n");
! 			done(2);
! 		}
  		recno = 0;
  	}
  
--- 1184,1192 ----
  		first = 1;
  	}
  	if (recno >= nblock) {
! 		i = write(mt, tbuf, TBLOCK*nblock);
! 		if (i != TBLOCK*nblock)
! 			mterr("write", i, 2);
  		recno = 0;
  	}
  
***************
*** 1169,1178 ****
  	 *  residual to the tape buffer.
  	 */
  	while (recno == 0 && n >= nblock) {
! 		if (write(mt, buffer, TBLOCK*nblock) < 0) {
! 			fprintf(stderr,"tar: tape write error\n");
! 			done(2);
! 		}
  		n -= nblock;
  		buffer += (nblock * TBLOCK);
  	}
--- 1197,1205 ----
  	 *  residual to the tape buffer.
  	 */
  	while (recno == 0 && n >= nblock) {
! 		i = write(mt, buffer, TBLOCK*nblock);
! 		if (i != TBLOCK*nblock)
! 			mterr("write", i, 2);
  		n -= nblock;
  		buffer += (nblock * TBLOCK);
  	}
***************
*** 1181,1190 ****
  		bcopy(buffer, (char *)&tbuf[recno++], TBLOCK);
  		buffer += TBLOCK;
  		if (recno >= nblock) {
! 			if (write(mt, tbuf, TBLOCK*nblock) < 0) {
! 					fprintf(stderr,"tar: tape write error\n");
! 					done(2);
! 			}
  			recno = 0;
  		}
  	}
--- 1208,1216 ----
  		bcopy(buffer, (char *)&tbuf[recno++], TBLOCK);
  		buffer += TBLOCK;
  		if (recno >= nblock) {
! 			i = write(mt, tbuf, TBLOCK*nblock);
! 			if (i != TBLOCK*nblock)
! 				mterr("write", i, 2);
  			recno = 0;
  		}
  	}
***************
*** 1195,1205 ****
  
  backtape()
  {
  	static struct mtop mtop = {MTBSR, 1};
! 
  	if (mtdev == 0) {
  		if (ioctl(mt, MTIOCTOP, &mtop) < 0) {
! 			fprintf(stderr, "tar: tape backspace error\n");
  			done(4);
  		}
  	} else
--- 1221,1236 ----
  
  backtape()
  {
+ 	static int mtdev = 1;
  	static struct mtop mtop = {MTBSR, 1};
! 	struct mtget mtget;
! 	
! 	if (mtdev == 1)
! 		mtdev = ioctl(mt, MTIOCGET, &mtget);
  	if (mtdev == 0) {
  		if (ioctl(mt, MTIOCTOP, &mtop) < 0) {
! 			fprintf(stderr, "tar: tape backspace error: ");
! 			perror("");
  			done(4);
  		}
  	} else
***************
*** 1209,1217 ****
  
  flushtape()
  {
! 	write(mt, tbuf, TBLOCK*nblock);
  }
  
  bread(fd, buf, size)
  	int fd;
  	char *buf;
--- 1240,1264 ----
  
  flushtape()
  {
! 	register int i;
! 
! 	i = write(mt, tbuf, TBLOCK*nblock);
! 	if (i != TBLOCK*nblock)
! 		mterr("write", i, 2);
  }
  
+ mterr(operation, i, exitcode)
+ 	char *operation;
+ 	int i;
+ {
+ 	fprintf(stderr, "tar: tape %s error: ", operation);
+ 	if (i < 0)
+ 		perror("");
+ 	else
+ 		fprintf(stderr, "unexpected EOF\n");
+ 	done(exitcode);
+ }
+ 
  bread(fd, buf, size)
  	int fd;
  	char *buf;
***************
*** 1218,1238 ****
  	int size;
  {
  	int count;
! 	static int lastread = 0;
  
  	if (!Bflag)
  		return (read(fd, buf, size)); 
  
  	for (count = 0; count < size; count += lastread) {
! 		lastread = read(fd, buf, size - count);
! 		if (lastread <= 0) {
  			if (count > 0)
  				return (count);
  			return (lastread);
  		}
  		buf += lastread;
  	}
  	return (count);
  }
  
  char *
--- 1265,1287 ----
  	int size;
  {
  	int count;
! #define	NOREAD -2147483648
! 	static int lastread = NOREAD;
  
  	if (!Bflag)
  		return (read(fd, buf, size)); 
  
  	for (count = 0; count < size; count += lastread) {
! 		if (lastread <= 0 && lastread != NOREAD) {
  			if (count > 0)
  				return (count);
  			return (lastread);
  		}
+ 		lastread = read(fd, buf, size - count);
  		buf += lastread;
  	}
  	return (count);
+ #undef NOREAD
  }
  
  char *
***************
*** 1249,1271 ****
  getbuf()
  {
  	
! 	if (mtdev == 1) {
  		fstat(mt, &stbuf);
  		if ((stbuf.st_mode & S_IFMT) == S_IFCHR)
! 			mtdev = 0;
! 		else
! 			mtdev = -1;
! 	}
! 	if (nblock == 0) {
! 		if (mtdev == 0)
! 			nblock = FILEBLOCK;
  		else {
! 			fstat(mt, &stbuf);
! 			nblock = stbuf.st_blocks / TBLOCK;
  		}
  	}
- 	if (nblock == 0)
- 		nblock = FILEBLOCK;
  	tbuf = (union hblock *)malloc(nblock*TBLOCK);
  	if (tbuf == NULL) {
  		fprintf(stderr, "tar: blocksize %d too big, can't get memory\n",
--- 1298,1313 ----
  getbuf()
  {
  	
! 	if (nblock == 0) {
  		fstat(mt, &stbuf);
  		if ((stbuf.st_mode & S_IFMT) == S_IFCHR)
! 			nblock = NBLOCK;
  		else {
! 			nblock = stbuf.st_blksize / TBLOCK;
! 			if (nblock == 0)
! 				nblock = NBLOCK;
  		}
  	}
  	tbuf = (union hblock *)malloc(nblock*TBLOCK);
  	if (tbuf == NULL) {
  		fprintf(stderr, "tar: blocksize %d too big, can't get memory\n",
***************
*** 1340,1347 ****
  	tv[0].tv_sec = time((time_t *) 0);
  	tv[1].tv_sec = mt;
  	tv[0].tv_usec = tv[1].tv_usec = 0;
! 	if (utimes(path, tv) < 0)
! 		fprintf(stderr, "tar: can't set time on %s\n", path);
  }
  
  char *
--- 1382,1391 ----
  	tv[0].tv_sec = time((time_t *) 0);
  	tv[1].tv_sec = mt;
  	tv[0].tv_usec = tv[1].tv_usec = 0;
! 	if (utimes(path, tv) < 0) {
! 		fprintf(stderr, "tar: can't set time on %s: ", path);
! 		perror("");
! 	}
  }
  
  char *

From guy%gorodish@SUN.COM  Fri Apr 11 13:17:22 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA06427; Fri, 11 Apr 86 13:17:22 PST
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA01948; Fri, 11 Apr 86 13:01:58 PST
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0DEV4)
	id AA12822; Fri, 11 Apr 86 13:00:52 PST
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA02001; Fri, 11 Apr 86 13:05:43 PST
Date: Fri, 11 Apr 86 13:05:43 PST
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8604112105.AA02001@gorodish.sun.uucp>
Subject: "getch" turns on RAW, rather than CBREAK, mode
Index: 	usr.lib/libcurses/getch.c 4.3BSD beta
To: beta43_bugs@monet.Berkeley.EDU

Description:
	According to the (4.2BSD) documentation on "curses", "getch" and
	"wgetch" will turn on "cbreak" mode if neither "noecho",
	"raw", nor "cbreak" are already set, and will restore the mode
	when the character is read.

	It actually turns on "raw" mode, not "cbreak" mode.  This means,
	for example, that if a program calls "getstr" or "wgetstr" without
	setting "cbreak" mode, "raw" mode is set, which means that if the
	user's terminal has a RETURN key which transmits <CR>, that key
	will NOT act as an input terminator; they must type the LINE
	FEED key instead.
Repeat-By:
	Try running the following program:

	#include <curses.h>
	
	main()
	{
		char	source[80];
		WINDOW	*win1;

		initscr();	
		win1=newwin(0,0,0,0);
		wmove(win1,1,1);
		waddstr(win1,"Input: ");
		wmove(win1,1,8);
		wrefresh(win1);

		/* Terminal will hang after input if the lines containing
		   crmode() and nocrmode() are removed. */
		crmode();  /* Set terminal to cbreak mode */
		wscanw(win1,"%s",source);
		nocrmode(); /* Unset terminal from cbreak mode */

		wmove(win1,2,1);
		wprintw(win1,"You typed: %s",source);
		wmove(win1,3,1);
		wrefresh(win1);
		endwin();
		exit(0);
	}

and then try running it with the two lines in question deleted.  Try typing
"foo<RETURN>" at it both times.  The first time, it should say
"You typed: foo" and exit; the second time, it should still be waiting and
only finish if you type the LINE FEED key.

Fix:

Fix "getch.c" like this:

*** getch.c.orig	Fri Apr 11 12:45:59 1986
--- getch.c	Fri Apr 11 12:46:31 1986
***************
*** 27,33 ****
  	fprintf(outf, "WGETCH: _echoit = %c, _rawmode = %c\n", _echoit ? 'T' : 'F', _rawmode ? 'T' : 'F');
  # endif
  	if (_echoit && !_rawmode) {
! 		raw();
  		weset++;
  	}
  	inp = getchar();
--- 27,33 ----
  	fprintf(outf, "WGETCH: _echoit = %c, _rawmode = %c\n", _echoit ? 'T' : 'F', _rawmode ? 'T' : 'F');
  # endif
  	if (_echoit && !_rawmode) {
! 		cbreak();
  		weset++;
  	}
  	inp = getchar();
***************
*** 40,45 ****
  		waddch(win, inp);
  	}
  	if (weset)
! 		noraw();
  	return inp;
  }
--- 40,45 ----
  		waddch(win, inp);
  	}
  	if (weset)
! 		nocbreak();
  	return inp;
  }

From comay  Fri Apr 11 22:49:42 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA09056; Fri, 11 Apr 86 22:49:42 PST
Date: Fri, 11 Apr 86 22:49:42 PST
From: comay (David S. Comay)
Message-Id: <8604120649.AA09056@monet.Berkeley.EDU>
Subject: `systat -s' hangs when swapping on more than MAXSWAPDEV partitions
Index: 	ucb/systat/swap.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	running a system with more than MAXSWAPDEV swap partitions will
	cause systat to hang if the swap option is used.  the problem
	exist because the value of `nswdev' is used without checking to
	see if it exceeds MAXSWAPDEV and this value is used to index
	the `buckets' array.
Repeat-By:
	run `systat -s' on a system with more than MAXSWAPDEV
	(currently 4) swap partitions.
Fix:
	*** swap.c.orig	Fri Apr 11 22:05:33 1986
	--- swap.c	Fri Apr 11 22:17:48 1986
	***************
	*** 208,214 ****
	                  dmmin = getw(nlst[X_DMMIN].n_value);
	                  dmmax = getw(nlst[X_DMMAX].n_value);
	                  dmtext = getw(nlst[X_DMTEXT].n_value);
	!                 nswdev = getw(nlst[X_NSWDEV].n_value);
	  		swdevt = (struct swdevt *)calloc(nswdev, sizeof (*swdevt));
	  		klseek(kmem, nlst[X_SWDEVT].n_value, L_SET);
	  		read(kmem, swdevt, nswdev * sizeof (struct swdevt));
	--- 208,214 ----
	                  dmmin = getw(nlst[X_DMMIN].n_value);
	                  dmmax = getw(nlst[X_DMMAX].n_value);
	                  dmtext = getw(nlst[X_DMTEXT].n_value);
	!                 nswdev = (nswdev = getw(nlst[X_NSWDEV].n_value)) > MAXSWAPDEV ? MAXSWAPDEV : nswdev;
	  		swdevt = (struct swdevt *)calloc(nswdev, sizeof (*swdevt));
	  		klseek(kmem, nlst[X_SWDEVT].n_value, L_SET);
	  		read(kmem, swdevt, nswdev * sizeof (struct swdevt));

From chris@gyre.umd.edu  Sat Apr 12 23:31:33 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA13635; Sat, 12 Apr 86 23:31:33 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05211; Sun, 13 Apr 86 02:31:31 EST
Date: Sun, 13 Apr 86 02:31:31 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604130731.AA05211@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU, donn@utah-cs.arpa
Subject: c2 mishandles side effects on jlbc

Index: /usr/src/lib/c2/c21.c 4.3Beta Fix

Description:
	[From Ken Lalonde <kwlalonde@watmath>]
	`The optimizer will replace a single bit AND operation
	followed by a jump with a jump-on-bit-set, that is,

		bitb power-of-2,x	=> jbc log2(p2),x,Label
		jxx Label

	C2 also checks for the special case p2 == 1, and replaces

		jbc $0,x,Label	=>	jlbc x,Label

	Now, bitb and jbc consider "x" to be a byte quantity,
	but "jlbc" wants a longword.  If "x" involves autoincrement
	or autodecrement, the second optimization is wrong.'

	While installing his fix, I noticed a missed optimisation:
	the code assumes it is going to use the byte-reference
	jbc or jbs instruction, and aborts early if `x' is not
	a byte reference and has potential side effects.  However,
	if the instruction is `bitl $1,...' it is safe to replace
	this with a `jlbc' or `jlbs'---as Ken seems to have discovered
	the hard way.

Repeat-By:
	Examine the output of `cc -O -S' (or /lib/ccom | /lib/c2)
	on the following:

	f()
	{
		register char *cp;
		register long *lp;

		if (*cp & 1);
		if (*cp++ & 1);
		if (*cp & 2);
		if (*cp++ & 2);
		if (*lp & 1);
		if (*lp++ & 1);
		if (*lp & 2);
		if (*lp++ & 2);
	}

	(Ken's bug example is different; but mine covers more cases.)

Fix:
	Two in one, below.  Donn, you should pass judgment on it
	first:  I am not certain just what the zeroing of regs[...][0]
	and regs[...][1] in source() is for, and whether this change
	might adversely affect other routines (though I doubt it).

Chris

RCS file: RCS/c21.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -c2 -r1.1 -r1.3
*** /tmp/,RCSt1005104	Sun Apr 13 02:24:38 1986
--- /tmp/,RCSt2005104	Sun Apr 13 02:24:41 1986
***************
*** 744,753 ****
  	/* into JBC or JBS.  watch out for I/O registers. (?)
  	/* assumes that 'splitrand' has already been called.
  	*/
  	register char *cp1,*cp2; int b;
  	cp1=regs[RT1]; cp2=regs[RT2];
! 	if (*cp1++!='$' || !okio(cp2) || p->forw->op!=CBR || p->forw->subop&-2 ||
! 		0>(b=ispow2(getnum(cp1))) ||
! 		p->subop!=BYTE && (source(cp2) || indexa(cp2))) return;
  	if (b>=bitsize[p->subop]) {/* you dummy! */
  		if (source(cp2)) {/* side effect: auto increment or decrement */
--- 744,759 ----
  	/* into JBC or JBS.  watch out for I/O registers. (?)
  	/* assumes that 'splitrand' has already been called.
+ 	/* note that jbc & jbs are byte reference instructions, but
+ 	/* jlbc is a longword ref instruction.
  	*/
  	register char *cp1,*cp2; int b;
  	cp1=regs[RT1]; cp2=regs[RT2];
! 	if (*cp1++!='$' || !okio(cp2) || p->forw->op!=CBR ||
! 		p->forw->subop&-2 || 0>(b=ispow2(getnum(cp1)))) return;
! 	if (p->subop!=BYTE && (source(cp2) || indexa(cp2))) {
! 		/* not a byte ref; but can still do jlbc optim if long */
! 		if (b==0 && p->subop==LONG) goto dojlbc;
! 		return;
! 	}
  	if (b>=bitsize[p->subop]) {/* you dummy! */
  		if (source(cp2)) {/* side effect: auto increment or decrement */
***************
*** 764,768 ****
  		cp2=regs[RT3]; while (*cp2++= *cp1++);
  	}
! 	if (b==0 && (p->subop==LONG || !indexa(regs[RT2]))) {/* JLB optimization, ala BLISS */
  		cp2=regs[RT1]; cp1=regs[RT2]; while (*cp2++= *cp1++);
  		cp2=regs[RT2]; cp1=regs[RT3]; while (*cp2++= *cp1++);
--- 770,775 ----
  		cp2=regs[RT3]; while (*cp2++= *cp1++);
  	}
! 	if (b==0 && (p->subop==LONG || !autoid(regs[RT2]) && !indexa(regs[RT2]))) {/* JLB optimization, ala BLISS */
! dojlbc:
  		cp2=regs[RT1]; cp1=regs[RT2]; while (*cp2++= *cp1++);
  		cp2=regs[RT2]; cp1=regs[RT3]; while (*cp2++= *cp1++);

From chris@gyre.umd.edu  Sun Apr 13 00:32:20 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA13721; Sun, 13 Apr 86 00:32:20 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA05211; Sun, 13 Apr 86 02:31:31 EST
Date: Sun, 13 Apr 86 02:31:31 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604130731.AA05211@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU, donn@utah-cs.arpa
Subject: c2 mishandles side effects on jlbc

Index: /usr/src/lib/c2/c21.c 4.3Beta Fix

Description:
	[From Ken Lalonde <kwlalonde@watmath>]
	`The optimizer will replace a single bit AND operation
	followed by a jump with a jump-on-bit-set, that is,

		bitb power-of-2,x	=> jbc log2(p2),x,Label
		jxx Label

	C2 also checks for the special case p2 == 1, and replaces

		jbc $0,x,Label	=>	jlbc x,Label

	Now, bitb and jbc consider "x" to be a byte quantity,
	but "jlbc" wants a longword.  If "x" involves autoincrement
	or autodecrement, the second optimization is wrong.'

	While installing his fix, I noticed a missed optimisation:
	the code assumes it is going to use the byte-reference
	jbc or jbs instruction, and aborts early if `x' is not
	a byte reference and has potential side effects.  However,
	if the instruction is `bitl $1,...' it is safe to replace
	this with a `jlbc' or `jlbs'---as Ken seems to have discovered
	the hard way.

Repeat-By:
	Examine the output of `cc -O -S' (or /lib/ccom | /lib/c2)
	on the following:

	f()
	{
		register char *cp;
		register long *lp;

		if (*cp & 1);
		if (*cp++ & 1);
		if (*cp & 2);
		if (*cp++ & 2);
		if (*lp & 1);
		if (*lp++ & 1);
		if (*lp & 2);
		if (*lp++ & 2);
	}

	(Ken's bug example is different; but mine covers more cases.)

Fix:
	Two in one, below.  Donn, you should pass judgment on it
	first:  I am not certain just what the zeroing of regs[...][0]
	and regs[...][1] in source() is for, and whether this change
	might adversely affect other routines (though I doubt it).

Chris

RCS file: RCS/c21.c,v
retrieving revision 1.1
retrieving revision 1.3
diff -c2 -r1.1 -r1.3
*** /tmp/,RCSt1005104	Sun Apr 13 02:24:38 1986
--- /tmp/,RCSt2005104	Sun Apr 13 02:24:41 1986
***************
*** 744,753 ****
  	/* into JBC or JBS.  watch out for I/O registers. (?)
  	/* assumes that 'splitrand' has already been called.
  	*/
  	register char *cp1,*cp2; int b;
  	cp1=regs[RT1]; cp2=regs[RT2];
! 	if (*cp1++!='$' || !okio(cp2) || p->forw->op!=CBR || p->forw->subop&-2 ||
! 		0>(b=ispow2(getnum(cp1))) ||
! 		p->subop!=BYTE && (source(cp2) || indexa(cp2))) return;
  	if (b>=bitsize[p->subop]) {/* you dummy! */
  		if (source(cp2)) {/* side effect: auto increment or decrement */
--- 744,759 ----
  	/* into JBC or JBS.  watch out for I/O registers. (?)
  	/* assumes that 'splitrand' has already been called.
+ 	/* note that jbc & jbs are byte reference instructions, but
+ 	/* jlbc is a longword ref instruction.
  	*/
  	register char *cp1,*cp2; int b;
  	cp1=regs[RT1]; cp2=regs[RT2];
! 	if (*cp1++!='$' || !okio(cp2) || p->forw->op!=CBR ||
! 		p->forw->subop&-2 || 0>(b=ispow2(getnum(cp1)))) return;
! 	if (p->subop!=BYTE && (source(cp2) || indexa(cp2))) {
! 		/* not a byte ref; but can still do jlbc optim if long */
! 		if (b==0 && p->subop==LONG) goto dojlbc;
! 		return;
! 	}
  	if (b>=bitsize[p->subop]) {/* you dummy! */
  		if (source(cp2)) {/* side effect: auto increment or decrement */
***************
*** 764,768 ****
  		cp2=regs[RT3]; while (*cp2++= *cp1++);
  	}
! 	if (b==0 && (p->subop==LONG || !indexa(regs[RT2]))) {/* JLB optimization, ala BLISS */
  		cp2=regs[RT1]; cp1=regs[RT2]; while (*cp2++= *cp1++);
  		cp2=regs[RT2]; cp1=regs[RT3]; while (*cp2++= *cp1++);
--- 770,775 ----
  		cp2=regs[RT3]; while (*cp2++= *cp1++);
  	}
! 	if (b==0 && (p->subop==LONG || !autoid(regs[RT2]) && !indexa(regs[RT2]))) {/* JLB optimization, ala BLISS */
! dojlbc:
  		cp2=regs[RT1]; cp1=regs[RT2]; while (*cp2++= *cp1++);
  		cp2=regs[RT2]; cp1=regs[RT3]; while (*cp2++= *cp1++);

From muller@nprdc.arpa  Sun Apr 13 21:58:00 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA16151; Sun, 13 Apr 86 21:58:00 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06138; Sun, 13 Apr 86 21:58:50 pst
Date: Sun, 13 Apr 86 21:58:50 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8604140558.AA06138@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: more refer bugs?

Subject: refer should sort and condense numeric signals
Index:	/usr/src/usr.bin/refer 4.3BSD

Description:
	When refer places numeric signals (e.g. superscripts)
	in text, the numbers should be sorted and condensed.  For 
	example the set of numbers (5,4,7,1,6) should be sorted
	and condensed to (1,4-7).

	This is the problem which is refered to in the "TOFIX" file
	as "collapsing ranges with dash".

Repeat-By:
	Run refer with the -e option on the document, doc, which is
	included in the attached shar archive:
		refer -e doc
	Notice that refer attaches the set of numbers (1,2,3,4,5)
	to the first sentence.  These should be condensed to (1-5).

	Refer attaches the set of numbers (4,1,3,5) to the second
	sentence.  These should be sorted and condensed to (1,3-5).
Fix:
	Note, a recent bugreport defined MXSIG in refer5.c.  This
	report moves that definition from refer5.c to refer..c.

RCS file: RCS/TOFIX,v
retrieving revision 1.1
diff -c -r1.1 TOFIX
*** /tmp/,RCSt1029856	Fri Apr  4 17:22:52 1986
--- TOFIX	Fri Apr  4 10:39:44 1986
***************
*** 1,4
  refer:
  	%Q sort unimplemented
  	trailing white space
- 	collapsing ranges with dash

--- 1,3 -----
  refer:
  	%Q sort unimplemented
  	trailing white space

------------diff refer..c-----------
RCS file: RCS/refer..c,v
retrieving revision 1.1
diff -c -r1.1 refer..c
*** /tmp/,RCSt1029872	Fri Apr  4 17:23:32 1986
--- refer..c	Fri Apr  4 10:33:32 1986
***************
*** 5,10
  #include <assert.h>
  
  #define FLAG 003
  #define NRFTXT 10000
  #define NRFTBL 500
  #define NTFILE 20

--- 5,11 -----
  #include <assert.h>
  
  #define FLAG 003
+ #define AFLAG 007
  #define NRFTXT 10000
  #define NRFTBL 500
  #define NTFILE 20
***************
*** 12,17
  #define ANSLEN 1024
  #define TAGLEN 400
  #define NSERCH 20
  
  extern FILE *in;
  extern int endpush, sort, labels, keywant, bare;

--- 13,19 -----
  #define ANSLEN 1024
  #define TAGLEN 400
  #define NSERCH 20
+ #define MXSIG 200		/* max bytes in aggregate signal */
  
  extern FILE *in;
  extern int endpush, sort, labels, keywant, bare;
-------------diff refer1.c---------
*** refer1.c.orig	Mon Aug 26 19:14:25 1985
--- refer1.c	Sun Apr 13 11:35:54 1986
***************
*** 81,86 ****
--- 81,94 ----
  		*search++ = getenv("REFER");
  	else if (nodeflt == 0)
  		*search++ = "/usr/dict/papers/Ind";
+ 	if (!labels) {
+ 		sprintf(ofile, "/tmp/rj%db", getpid());
+ 		ftemp = fopen(ofile, "w");
+ 		if (ftemp == NULL) {
+ 			fprintf(stderr, "Can't open scratch file\n");
+ 			exit(1);
+ 		}
+ 	}
  	if (endpush) {
  		sprintf(tfile, "/tmp/rj%da", getpid());
  		fo = fopen(tfile, "w");
***************
*** 89,103 ****
  			fprintf(stderr, "Can't open scratch file");
  		}
  		sep = 002; /* separate records without confusing sort..*/
! 	}
! 	if (sort && !labels) {
! 		sprintf(ofile, "/tmp/rj%db", getpid());
! 		ftemp = fopen(ofile, "w");
! 		if (ftemp == NULL) {
! 			fprintf(stderr, "Can't open scratch file\n");
! 			exit(1);
! 		}
! 	}
  	do {
  		if (argc > 1) {
  			fclose(in);
--- 97,104 ----
  			fprintf(stderr, "Can't open scratch file");
  		}
  		sep = 002; /* separate records without confusing sort..*/
! 	} else 
! 		fo = ftemp;
  	do {
  		if (argc > 1) {
  			fclose(in);
***************
*** 126,132 ****
  	if (endpush && fo != NULL)
  		dumpold();
  	output("");
! 	if (sort && !labels)
  		recopy(ofile);
  	clfgrep();
  	cleanup();
--- 127,133 ----
  	if (endpush && fo != NULL)
  		dumpold();
  	output("");
! 	if (!labels)
  		recopy(ofile);
  	clfgrep();
  	cleanup();
------------diff refer5.c------------
RCS file: RCS/refer5.c,v
retrieving revision 1.2
diff -c -r1.2 refer5.c
*** /tmp/,RCSt1029783	Fri Apr  4 17:20:10 1986
--- refer5.c	Fri Apr  4 10:35:23 1986
***************
*** 6,12
  #define SAME 0
  #define NFLAB 3000		/* number of bytes to record all labels */
  #define NLABC 1000		/* max number of labels */
- #define MXSIG 200		/* max bytes in aggregate signal */
  
  static char sig[MXSIG];
  static char bflab[NFLAB];

--- 6,11 -----
  #define SAME 0
  #define NFLAB 3000		/* number of bytes to record all labels */
  #define NLABC 1000		/* max number of labels */
  
  static char sig[MXSIG];
  static char bflab[NFLAB];
***************
*** 73,82
  		}
  	}
  	else {
! 		if (sort)
! 			sprintf(t, "%c%d%c", FLAG, nref, FLAG);
! 		else
! 			sprintf(t, "%d", nref);
  	}
  	another = prefix (".[", sd=lookat());
  	if (another && (strcmp(".[\n", sd) != SAME))

--- 72,78 -----
  		}
  	}
  	else {
! 		sprintf(t, "%c%d%c", FLAG, nref, FLAG);
  	}
  	another = prefix (".[", sd=lookat());
  	if (another && (strcmp(".[\n", sd) != SAME))
***************
*** 128,134
  			}
  		}
  		else {
! 			strcat(sig, ",\\|");
  			if (fo == ftemp) {	/* hide if need be */
  				sprintf(hidenam, "/tmp/rj%dc", getpid());
  #if EBUG

--- 124,140 -----
  			}
  		}
  		else {
! 			if (labels) {
! 				strcat(sig, ",\\|");
! 			} else {
! 				/*
! 				 * Seperate reference numbers with AFLAG
! 				 * for later sorting and condensing.
! 				 */
! 				t1[0] = AFLAG;
! 				t1[1] = '\0';
! 				strcat(sig, t1);
! 			}
  			if (fo == ftemp) {	/* hide if need be */
  				sprintf(hidenam, "/tmp/rj%dc", getpid());
  #if EBUG
----------diff refer7.c-------------
*** refer7.c.orig	Thu Feb 16 01:06:27 1984
--- refer7.c	Sun Apr 13 12:06:00 1986
***************
*** 80,86 ****
--- 80,93 ----
  char *fnam;
  {
  	int c;
+ 	int *wref = NULL;
+ 	int wcnt = 0;
+ 	int wsize = 50;
+ 	int finalrn;
+ 	char sig[MXSIG];
+ 	extern int *realloc();
  
+ 	wref = (int *)calloc((unsigned)wsize, (unsigned)sizeof(int));
  	fclose(ftemp);
  	ftemp = fopen(fnam, "r");
  	if (ftemp == NULL) {
***************
*** 94,104 ****
  			while ((c = getc(ftemp)) != FLAG)
  				*s++ = c;
  			*s = 0;
! 			printf("%d", newr[atoi(tb)]);
! 			continue;
  		}
  		putchar(c);
  	}
  	fclose(ftemp);
  	unlink(fnam);
  }
--- 101,163 ----
  			while ((c = getc(ftemp)) != FLAG)
  				*s++ = c;
  			*s = 0;
! 			/*
! 			 * If sort was done, permute the reference number
! 			 * to obtain the final reference number, finalrn.
! 			 */
! 			if (sort)
! 				finalrn = newr[atoi(tb)];
! 			else
! 				finalrn = atoi(tb);
! 			if ((++wcnt > wsize) && 
! 			 ((wref=realloc(wref,(wsize+=50)*sizeof(int)))==NULL)){
! 				fprintf(stderr, "Ref condense out of memory.");
! 				exit(1);
! 			}
! 			wref[wcnt-1] = finalrn;
! 			if ((c = getc(ftemp)) == AFLAG) 
! 				continue;
! 			wref[wcnt] = 0;
! 			condense(wref,wcnt,sig);
! 			wcnt = 0;
! 			printf("%s", sig);
  		}
  		putchar(c);
  	}
  	fclose(ftemp);
  	unlink(fnam);
+ }
+ 
+ /*
+  * sort and condense referance signals when they are placed in
+  * the text. Viz, the signal 1,2,3,4 is condensed to 1-4 and signals
+  * of the form 5,2,9 are converted to 2,5,9
+  */
+ condense(wref, wcnt, sig)
+ int	*wref;
+ int	wcnt;
+ char	*sig;
+ {
+ 	register int i = 0;
+ 	char wt[4];
+ 	extern int wswap();
+ 
+ 	qsort(wref, wcnt, sizeof(int), wswap);
+ 	sig[0] = 0;
+ 	while (i < wcnt) {
+ 		sprintf(wt,"%d",wref[i]);
+ 		strcat(sig,wt);
+ 		if ((i+2 < wcnt) && (wref[i] == (wref[i+2] - 2))) {
+ 			while (wref[i] == (wref[i+1] - 1))
+ 				i++;
+ 			strcat(sig, "-");
+ 		} else if (++i < wcnt)
+ 			strcat(sig,",\\|");
+ 	}
+ }
+ 
+ wswap(iw1, iw2)
+ register int *iw1,*iw2;
+ {
+ 	return(*iw1 - *iw2);
  }
-----------------doc shar-------------------
#! /bin/sh
# This is a shell archive, meaning:
# 1. Remove everything above the #! /bin/sh line.
# 2. Save the resulting text in a file.
# 3. Execute the file with /bin/sh (not csh) to create the files:
#	doc
# This archive created: Sun Apr 13 11:56:03 1986
export PATH; PATH=/bin:$PATH
echo shar: extracting "'doc'" '(217 characters)'
if test -f 'doc'
then
	echo shar: will not over-write existing file "'doc'"
else
sed 's/^	X//' << \SHAR_EOF > 'doc'
	XThis is the first sentence.
	X.[
	Xluderer
	X.]
	X.[
	Xrovegno
	X.]
	X.[
	Xpekarich
	X.]
	X.[
	Xnagelberg
	X.]
	X.[
	Xcherry mcmahon
	X.]
	XThis is the second sentence.
	X.[
	Xnagelberg
	X.]
	X.[
	Xluderer
	X.]
	X.[
	Xpekarich
	X.]
	X.[
	Xcherry mcmahon
	X.]
	X
	X.[
	X$LIST$
	X.]
SHAR_EOF
if test 217 -ne "`wc -c < 'doc'`"
then
	echo shar: error transmitting "'doc'" '(should have been 217 characters)'
fi
fi # end of overwriting check
#	End of shell archive
exit 0
------------------end of shar----------------

From muller@nprdc.arpa  Mon Apr 14 01:05:16 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA16388; Mon, 14 Apr 86 01:05:16 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06656; Mon, 14 Apr 86 01:06:12 pst
Date: Mon, 14 Apr 86 01:06:12 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8604140906.AA06656@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: minor bug (missing man pages)

Subject: Numerous missing section 3 manual pages
Index:	/usr/man/man3 4.3BSD

Description:
	Several manual pages refered to by a .so in the manual page file
	do not exist. For example in man3/alog.3f has a:
	.so man3/log.3f
	The file log.3f does not exsist.
Repeat-By:
	Do a:

	/etc/catman >&/tmp/L.catman&

	inspect the file L.catman. There will be numerous complaints about
	missing .so files. On the beta tape the following files did not exist:

	abs.3f acos.3f aimag.3f aint.3f asin.3f atan.3f atan2.3f conjg.3f
	cos.3f cosh.3f exp.3f ftype.3f log.3f log10.3f max.3f min.3f mod.3f
	osyslog.3 round.3f sign.3f sin.3f sinh.3f sqrt.3f tan.3f tanh.3f

	Keith Muller
	University of California, San Diego

From muller@nprdc.arpa  Mon Apr 14 01:30:41 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA16422; Mon, 14 Apr 86 01:30:41 PST
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06709; Mon, 14 Apr 86 01:23:20 pst
Date: Mon, 14 Apr 86 01:23:20 pst
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8604140923.AA06709@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: minor bug in learn

Subject: Several lessions while doing a learn C fail
Index:	/usr/lib/learn/C/{getline.c,getnum.c} 4.3BSD

Description:
	While doing the c lessions in learn it attempts to link in one or
	both of the files /usr/lib/learn/C/getline.o or getnum.o 
	The linkage fails due to old format .o files.
Repeat-By:
	Do learn C
	and go to lession 11.1 Do that lession and it will fail when
	it tries to link getnum.o to your program.
Fix:
	perform a cc -c on /usr/lib/learn/C/getnum.c and getline.c
	to recreate the two object files:
	/usr/lib/learn/C/getnum.o
	/usr/lib/learn/C/getline.o

	Keith Muller
	University of California, San Diego

From guy%gorodish@SUN.COM  Tue Apr 15 14:20:07 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA25262; Tue, 15 Apr 86 14:20:07 PST
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA05862; Tue, 15 Apr 86 14:16:10 PST
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0DEV4)
	id AA13597; Tue, 15 Apr 86 14:15:53 PST
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA05198; Tue, 15 Apr 86 14:19:54 PST
Date: Tue, 15 Apr 86 14:19:54 PST
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8604152219.AA05198@gorodish.sun.uucp>
Subject: "vi"'s handling of SIGWINCH is severely deficient
Index: 	ucb/ex 4.3BSD beta
To: beta43_bugs@monet.Berkeley.EDU

Description:
	"vi" does a "longjmp" back to the routine which starts up "open"
	or "visual" mode when it gets a SIGWINCH.  Unfortunately, if it
	was in the middle of doing just about anything non-trivial,
	chaos results; if, for example, it was reading in a file, you
	can get a partial read.

	Furthermore, it blocks SIGWINCH when doing an insert command,
	so that the screen gets confused and stays that way until
	the insert is terminated.
Repeat-By:
	Start up a "vi" reading in a large file, and somehow contrive to
	get a SIGWINCH delivered to it (running it in a Sun shell
	subwindow and changing its window size, or obscuring its window
	and then exposing it again, is sufficient).

	Start up a "vi", do an "insert", and while still in insert mode
	do the same.

From lepreau@utah-cs.ARPA  Wed Apr 16 05:24:15 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA02040; Wed, 16 Apr 86 05:24:15 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA22504; Wed, 16 Apr 86 06:26:05 MST
Date: Wed, 16 Apr 86 06:26:05 MST
Message-Id: <8604161326.AA22504@utah-cs.ARPA>
From: lepreau@utah-cs.ARPA (Jay Lepreau)
To: beta43_bugs@monet.Berkeley.EDU
Cc: lepreau@utah-cs.ARPA
Subject: Misc user bugs 

Here are some things I have noted and plan or hope to get to but
haven't had a chance yet.  If someone else does, let me know.

"ps k ..." never or hardly ever works-- it loops in gettty().  It also
loops  (elsewhere), or core dumps, if psdatabase is out of date.  This
can be a problem single user, or while rebooting if something in
rc.local runs ps-- it happened here.  I have asked someone else here to
look at this (peter).  Is there some reason for not comparing the
mtimes of /vmunix and psdatabase?  It is too trusting now, it only
cares that the vmunix name is the same.

wtmp logout records are getting lost, but the utmp entry does get
removed.  I have at least one instance pinned down where rlogind is the
apparent culprit, and there were no other records added near the time
rlogind exited, so a program not using APPEND is not to blame.  If not
that, hard to see how this could happen.  The only obvious hole in
rlogind.c is a call to fatalperror() if a select fails, but adding a
syslog call to fatal() has not turned up anything.  I have not verified
that we've missed any more recs attributable to rlogind since I added
that syslog, however.

sort has core dumped on me (during find/updatedb).  I think I still
have the evidence squirreled away here somewhere if someone wants to
get to this first.

ftpd has problems (besides the code being rather ugly-- I spent some
time in it and ftp consolidating about 400 lines of repeated code into
functions but not quite done yet.  I'm as bad as sam...).  Two bugs I
know of on "get": it doesn't always flush out the last 2K buffer, and
it can insert and delete nulls and CR's-- the latter apparently happens
adjacent to CR's and might happen in binary mode too (not sure of
that).  monet:/usr/ucb/ftp works as a test file, try getting in both
ascii and binary modes.  (Shouldn't unix-unix ascii transfer be an
identity function?)

I suspect inetd will not handle some configuration changes to
"internal" functions: e.g. make one external, then HUP'ing inetd..

systat can scroggle the display in the lower left hand area.


---These last 3 I plan to finish:
man/catman and linked cat? files.  Completely broken.  I propose to use
symlinks as Sun has done-- perhaps the rest of their code too?

csh: have not forgotten the nice issue (actually am running code here
which makes [+-]<nice> relative and <nice> absolute).
Have replaced hardwired 80 columns in sh.file.c with winsz stuff and
running here ok.  Have also been running one of elsie!ado's fixes here
ok.  Need to look at a bunch more bugs from net and Kirk.

timed needs to update wtmp-- code is written, just needs some minor
testing here.

From hilbert!hubert@uw-beaver.arpa  Wed Apr 16 10:51:50 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA02708; Wed, 16 Apr 86 10:51:50 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA01728; Wed, 16 Apr 86 10:44:20 PST
Return-Path: <hilbert!hubert>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA26070; Wed, 16 Apr 86 10:33:34 PST
Date: Wed, 16 Apr 86 10:33:34 PST
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Wed, 16 Apr 86 10:33:34 PST
Message-Id: <8604161833.AA26070@hilbert.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: 43. Bug Report (at)
Cc: bob@uw-bluechip, burr@uw-ward, lundberg@uw-beaver.arpa, uw-beaver!oystr,
        schwartz@uw-wally, uw-beaver!yenbut

The at program has a bug when the shell that does the execution
is csh.  The bug is that "~" is expanded to "\" rather than to
the user's home directory.  I have no fix.

Repeat By:

  at -c <time>
  at> echo ~ > /tmp/out
  at> ^D

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 {decvax,ihnp4,ucbvax!lbl-csam}!uw-beaver!hilbert!hubert
 hilbert!hubert@uw-beaver

From chris@gyre.umd.edu  Wed Apr 16 15:14:08 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA03792; Wed, 16 Apr 86 15:14:08 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA01909; Wed, 16 Apr 86 18:14:33 EST
Date: Wed, 16 Apr 86 18:14:33 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604162314.AA01909@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: I should have realised . . .

that of course our hosts file was missing monet.berkeley.edu.  A
quick-and-dirty fix in a moment, but first:

From chris Wed Apr 16 16:38:19 1986
Received: by gyre.umd.edu (5.9/4.7)
	id AA01494; Wed, 16 Apr 86 16:38:06 EST
Date: Wed, 16 Apr 86 16:38:06 EST
From: Mail Delivery Subsystem <MAILER-DAEMON@gyre.umd.edu>
Subject: Returned mail: Host unknown
Message-Id: <8604162138.AA01494@gyre.umd.edu>
To: chris@gyre.umd.edu
Status: RO

   ----- Transcript of session follows -----
550 monet.berkeley.edu.tcp... 550 Host unknown
550 beta43_bugs@monet.berkeley.edu... Host unknown

   ----- Unsent message follows -----
Received: by gyre.umd.edu (5.9/4.7)
	id AA01492; Wed, 16 Apr 86 16:38:06 EST
Date: Wed, 16 Apr 86 16:38:06 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604162138.AA01492@gyre.umd.edu>
To: beta43_bugs@monet.berkeley.edu
Subject: htable `do_entry' case KW_NET is bogus

Index: /usr/src/etc/htable/htable.c 4.3Beta

Description:
	The code handling KW_NET is very strange.  If it were to
	be given an entry containing multiple addresses, it would
	take *(char *)0; if it were given multiple names, it would
	probably confuse things that read /etc/networks.  Fortunately,
	both cases are explicitly outlawed in RFC810, so why the
	code to handle them in the first place?

Repeat-By:
	Inspection.

Recommended fix is to throw out htable completely, but I have not
finished my replacement yet. . . .

Chris


From chris@gyre.umd.edu  Wed Apr 16 15:19:36 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA03815; Wed, 16 Apr 86 15:19:36 PST
Received: by gyre.umd.edu (5.9/4.7)
	id AA01942; Wed, 16 Apr 86 18:19:15 EST
Date: Wed, 16 Apr 86 18:19:15 EST
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8604162319.AA01942@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: htable breaks on current nictab.txt (with fix)
Cc: tcp-ip@sri-nic.arpa, unix-wizards@brl.arpa

Index: /usr/src/etc/htable/scan.l 4.3Beta Fix

Description:
	As you probably know by now, the NIC tables acquired some
	new names that broke htable.  I do not speak of the one-
	letter names that leaked out of BU, but rather of the
	lowercase in all the `.Berkeley.EDU', and of the `CPUType'
	`3B5'.

Repeat-By:
	Run htable on the current nictab.txt.

Fix:
	Below.  This is not terribly clean, but suffices for the
	moment...

Chris

RCS file: RCS/scan.l,v
retrieving revision 1.1
retrieving revision 1.2
diff -c2 -r1.1 -r1.2
*** /tmp/,RCSt1001893	Wed Apr 16 18:12:31 1986
--- /tmp/,RCSt2001893	Wed Apr 16 18:12:32 1986
***************
*** 16,22 ****
  BLANK	[ \t]
  DIGIT	[0-9]
! ALPHA	[A-Z]
! ANUM	[0-9A-Z]
! NAMECHR	[0-9A-Z./-]
  
  %%
--- 16,22 ----
  BLANK	[ \t]
  DIGIT	[0-9]
! ALPHA	[A-Za-z]
! ANUM	[0-9A-Za-z]
! NAMECHR	[0-9A-Za-z./-]
  
  %%
***************
*** 42,45 ****
--- 42,52 ----
  
  {ALPHA}		{
+ 			yylval.namelist = newname(yytext);
+ 			return (NAME);
+ 		}
+ 
+ {DIGIT}+{ALPHA}{NAMECHR}* {
+ 			fprintf(stderr, "Warning: nonstandard name \"%s\"\n",
+ 				yytext);
  			yylval.namelist = newname(yytext);
  			return (NAME);

From whm@arizona.edu  Thu Apr 17 13:00:07 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA07933; Thu, 17 Apr 86 13:00:07 PST
Received: by arizona.arizona.edu; Thu, 17 Apr 86 14:00:45 MST
Date: Thu, 17 Apr 86 14:00:44 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8604172100.AA19552@megaron.arizona.edu>
Received: by megaron.arizona.edu; Thu, 17 Apr 86 14:00:44 MST
To: beta43_bugs@monet.Berkeley.EDU, eric@monet.Berkeley.EDU
Subject: sendmail bugs|features
Cc: lab-s@arizona.edu, llp@arizona.edu

I've found that sendmail behaves differently wrt. failed message returns
when it is running in daemon mode and in run-the-queue mode.

We use machine-generated alias files for all our local systems to provide
location-transparent naming.  I.e., if user "x" has an account on one machine,
mailing to "x" on any of our machines supposedly gets the mail to the machine
that the user has designated to receive it on.

In the case of message timeouts however, sendmail returns the message to
the user on the machine where the timeout occurs.  Our sendmail configs are
arranged so that one machine handles all the Internet transactions and this
isn't the machine that most people use.  The net result is that if a message
times out, the returned message lands on a machine that the user may seldom
(or never) use, thus effectively losing the message for a period of time.

In trying to reproduce the problem I found that I could queue a message
for a site that seems to be unreachable most of the time and then edit
the qf file to make sendmail think that the message has been waiting for
many days.  If I then do sendmail -q, the message is delivered with
aliasing in effect and the message is returned to the host I expect it
to be returned to.  If I just wait and let the run of the queue by the
daemon return the message, the message is returned without aliasing in
effect, thus landing on that same machine.

I prowled around in the code a bit, but I didn't see any place that could
account for the differing treatments.  We'd like to having aliasing always
in effect; is there some way to arrange this?

Also, is there a way to prevent metoo'ing when mailing to :include: lists;
that's a real drag.

					Thanks,
					Bill Mitchell

From entropy!hubert@uw-beaver.arpa  Thu Apr 17 17:59:28 1986
Received: by monet.Berkeley.EDU (5.49/1.11)
	id AA09651; Thu, 17 Apr 86 17:59:28 PST
Received: by uw-beaver.arpa (4.42/4.2)
	id AA05892; Thu, 17 Apr 86 17:59:30 PST
Return-Path: <entropy!hubert@uw-beaver.arpa>
Received: by entropy.UUCP (5.31/1.0.Entropy)
	id AA11463; Thu, 17 Apr 86 17:57:23 PST
Date: Thu, 17 Apr 86 17:57:23 PST
From: Steve Hubert <entropy!hubert@uw-beaver.arpa>
Posted-Date: Thu, 17 Apr 86 17:57:23 PST
Message-Id: <8604180157.AA11463@entropy.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: 4.3 Bug Report (lint)
Cc: bob@uw-bluechip, burr@uw-ward, lundberg@uw-beaver.arpa, uw-beaver!oystr,
        uw-beaver!yenbut

Lint incorrectly complains about "division by zero" in the
following example.  4.2 did not complain about the same function.

main()
{
	int x;

	x = 1./3.;
}

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 {decvax,ihnp4,ucbvax!lbl-csam}!uw-beaver!entropy!hubert
 hubert%entropy@uw-beaver.arpa

From comay  Fri Apr 18 22:37:00 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA16549; Fri, 18 Apr 86 22:37:00 PST
Date: Fri, 18 Apr 86 22:37:00 PST
From: comay (David S. Comay)
Message-Id: <8604190637.AA16549@monet.Berkeley.EDU>
Subject: `passwd' updates database incorrectly when accounts have equal uids
Index: 	bin/passwd.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	if one changes the password of an account that shares its uid
	with other users, the dbm database may be incorrectly updated.
	for example, if usera and userb share the same uid (call it
	`id') and usera appears before userb in the password file and
	userb changes his or her password, the `pwd' structure returned
	by getpwuid(id) will correspond to userb, not usera.  i believe
	this behavior is different from earlier versions of unix, which
	returns the pwd structure corresponding to the first user
	listed in the password file with the specified uid.
Repeat-By:
	on monet, change the password of `toor' which has the same uid
	as `root'.  then do a `ls -l' on a file owned by root.  notice
	the owner of the file is toor, not root.
Fix:
	in replace before calling dbm_store with the uid as the key,
	fetch the current password entry for that uid by calling
	dbm_fetch.  if the user name returned by the fetch is not the
	same name as the user changing his or her password, then it is
	okay to call dbm_store with the uid as the key.  otherwise, the
	correct passwd entry already exists for that uid in the
	database.  the fix below `knows' about the format of the
	compacted password entry (see the COMPACT macro), especially
	the fact that the pw_name field comes first in the compacted
	entry.

	*** passwd.c.orig	Fri Apr 18 19:48:07 1986
	--- passwd.c	Fri Apr 18 19:50:32 1986
	***************
	*** 250,256 ****
	  	dbm_store(dp, key, content, DBM_REPLACE);
	  	key.dptr = (char *)&pwd->pw_uid;
	  	key.dsize = sizeof (int);
	! 	dbm_store(dp, key, content, DBM_REPLACE);
	  }
	  
	  char *
	--- 250,261 ----
	  	dbm_store(dp, key, content, DBM_REPLACE);
	  	key.dptr = (char *)&pwd->pw_uid;
	  	key.dsize = sizeof (int);
	! 	key = dbm_fetch(dp, key);
	! 	if (strncmp(pwd->pw_name, key.dptr, strlen(pwd->pw_name)) != 0) {
	! 		key.dptr = (char *)&pwd->pw_uid;
	! 		key.dsize = sizeof (int);
	! 		dbm_store(dp, key, content, DBM_REPLACE);
	! 	}
	  }
	  
	  char *

From comay  Fri Apr 18 22:45:52 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA16598; Fri, 18 Apr 86 22:45:52 PST
Date: Fri, 18 Apr 86 22:45:52 PST
From: comay (David S. Comay)
Message-Id: <8604190645.AA16598@monet.Berkeley.EDU>
Subject: getopt(3) references getopt(1) which doesn't exist
Index: 	/usr/man/man3/getopt.3 4.3BSD
Apparently-To: beta43_bugs

Description:
	getopt(3) references getopt(1) (the system v program), however
	the program doesn't exist nor its man page.
Repeat-By:
	examine the getopt(3) man page.
Fix:
	remove the reference?

From eric  Sat Apr 19 15:31:55 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA18998; Sat, 19 Apr 86 15:31:55 PST
From: eric (Eric Allman)
Message-Id: <8604192331.AA18998@monet.Berkeley.EDU>
To: Bill Mitchell <whm@arizona.edu>
Cc: beta43_bugs@monet.Berkeley.EDU, lab-s@arizona.edu, llp@arizona.edu
Subject: Re: sendmail bugs|features 
In-Reply-To: Your message of Thu, 17 Apr 86 14:00:44 MST.
             <8604172100.AA19552@megaron.arizona.edu> 
Date: Sat, 19 Apr 86 15:31:52 PST

Thanks for reporting a particularly obscure bug.  I have fixed it
for the release.  In the meantime, you can fix your problem by
running your sendmail as:

	/usr/lib/sendmail -q30m
	/usr/lib/sendmail -bd

(that is, put the daemon and the queue running into separate daemons;
the problem is caused by an interaction of these two modes).

I don't understand why metoo'ing should be any different for :include:
lists as a vanilla alias.  Why do you want to have these treated
differently?

eric

From donn@utah-cs.ARPA  Tue Apr 22 13:50:44 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA18866; Tue, 22 Apr 86 13:50:44 PST
Received: by utah-cs.ARPA (5.31/4.40.2)
	id AA29152; Tue, 22 Apr 86 14:52:44 MST
Date: Tue, 22 Apr 86 14:52:44 MST
From: donn@utah-cs.arpa (Donn Seeley)
Message-Id: <8604222152.AA29152@utah-cs.ARPA>
To: beta43_bugs@monet.Berkeley.EDU
Subject: 'restore t' dumps core on dumps of funny filesystems
Cc: lepreau@utah-cs.ARPA

Subject: 'restore t' dumps core on dumps of funny filesystems
Index:	etc/restore 4.3BSD

Description:
	When 'restore' is used to scan a dump of a filesystem that
	contains a directory that is missing its '.' file, it divides
	by zero and dumps core.  I didn't really expect 'restore' to
	process a dump of a scrogged filesystem, but it seems that
	there is some code in 'restore' for handling this eventuality,
	and this code apparently doesn't work.

Repeat-By:
	Our 'lpd' went berserk and unlinked '.' in a spool directory.
	(Is it really the case that unlink(NULL) removes '.'?  If so,
	that's awfully dangerous...)  To duplicate your own mangled
	filesystem, simply make a filesystem, create a directory in
	it and unlink its '.' file (using a program which calls
	unlink(".")).  Dump the filesystem and then try to read the
	dump with 'restore t'; 'restore' will get a floating exception
	and dump core.  A sample dump which causes the monet 'restore'
	to dump core is in donn@monet:nbsd-r.

	I looked at the code and decided I'd leave it to someone who is
	more familiar with it...  The precise location of the exception
	is a divide by zero in urem(), as a result of the variable
	'entrytblsize' being zero in lookupino(), which is in turn
	called from treescan() when a directory doesn't have a '.'
	file.  If the call to lookupino() had succeeded, 'restore'
	would have printed '. missing from directory foo'.

From whm@arizona.edu  Tue Apr 22 23:05:02 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA20888; Tue, 22 Apr 86 23:05:02 PST
Received: by arizona.arizona.edu; Wed, 23 Apr 86 00:05:47 MST
Date: Wed, 23 Apr 86 00:05:44 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8604230705.AA25395@megaron.arizona.edu>
Received: by megaron.arizona.edu; Wed, 23 Apr 86 00:05:44 MST
To: eric@monet.Berkeley.EDU
Subject: Re: sendmail bugs|features
Cc: beta43_bugs@monet.Berkeley.EDU, lab-s@arizona.edu, llp@arizona.edu

Thanks for the fix; splitting the queue run and the daemon seems to fix
things right up.
   
Regarding my question about metoo'ing you wrote:

   I don't understand why metoo'ing should be any different for :include:
   lists as [than?] a vanilla alias.  Why do you want to have these treated
   differently?

I might be misreading you here, but it sounds like you're saying that
aliases enumerated in /usr/lib/aliases and those expanded via :include:s
are handled the same, but (at least on our system), they aren't.  If
/usr/lib/aliases contains the two aliases:

	d-alias: john,mark,whm
	i-alias: :include:/usr/whm/alist
	
and alist contains:

	john
	mark
	whm

If I mail to d-alias, then I don't get a copy of the message, i.e., I'm
not metoo'd, but if I mail to i-alias, I am metoo'd.  I view the metoo'ing
in the latter case as being a real drag.

						Thanks,
						Bill Mitchell

From guy%gorodish@SUN.COM  Wed Apr 30 18:39:23 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA06069; Wed, 30 Apr 86 18:39:23 PDT
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA26230; Wed, 30 Apr 86 18:35:12 PDT
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0)
	id AA03897; Wed, 30 Apr 86 18:38:42 PDT
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA00293; Wed, 30 Apr 86 18:39:41 PDT
Date: Wed, 30 Apr 86 18:39:41 PDT
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8605010139.AA00293@gorodish.sun.uucp>
To: beta43_bugs@monet.Berkeley.EDU
Subject: The manual page for "atof" is incorrect

Index: 	man/man3/atof.3 4.3betaBSD

Description:
	The manual page for "atof" says that "atof recognizes an optional
	string of spaces".  It should indicate that "space" here includes
	blanks (ASCII SP) as well as backspaces, tabs, newlines, vertical
	tabs, formfeeds, and carriage returns.  System V recognizes all of
	these except backspaces - the S5 manual and code say that it
	treats "space" as anything for which "isspace" return true.

From guy%gorodish@SUN.COM  Thu May  1 06:43:32 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA08533; Thu, 1 May 86 06:43:32 PDT
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA27078; Thu, 1 May 86 02:58:24 PDT
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0)
	id AA04612; Thu, 1 May 86 03:01:55 PDT
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA00140; Thu, 1 May 86 03:02:56 PDT
Date: Thu, 1 May 86 03:02:56 PDT
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8605011002.AA00140@gorodish.sun.uucp>
Subject: A couple more fixes to TTY(4)
Index: 	man/man4/tty.4 4.3BSD
To: beta43_bugs@monet.Berkeley.EDU

Description:
	A couple more fixes, to be dumped on top of the manual page
	I already sent.
Fix:
*** tty.4.BAK	Thu Apr 10 18:55:49 1986
--- tty.4	Thu May  1 03:01:17 1986
***************
*** 550,556 ****
  BS1	0100000
  VTDELAY	0040000	Select form-feed and vertical-tab delays:
  FF0	0
! FF1	0100000
  CRDELAY	0030000	Select carriage-return delays:
  CR0	0
  CR1	0010000
--- 550,556 ----
  BS1	0100000
  VTDELAY	0040000	Select form-feed and vertical-tab delays:
  FF0	0
! FF1	0040000
  CRDELAY	0030000	Select carriage-return delays:
  CR0	0
  CR1	0010000
***************
*** 558,564 ****
  CR3	0030000
  TBDELAY	0006000	Select tab delays:
  TAB0	0
! TAB1	0001000
  TAB2	0004000
  XTABS	0006000
  NLDELAY	0001400	Select new-line delays:
--- 558,564 ----
  CR3	0030000
  TBDELAY	0006000	Select tab delays:
  TAB0	0
! TAB1	0002000
  TAB2	0004000
  XTABS	0006000
  NLDELAY	0001400	Select new-line delays:
***************
*** 785,791 ****
  .ft R
  .PP
  The default values for these characters are
! ^?, ^\e\|, ^Q, ^S, ^D, and \-1.
  A character value of \-1
  eliminates the effect of that character.
  The
--- 785,791 ----
  .ft R
  .PP
  The default values for these characters are
! ^C, ^\e\|, ^Q, ^S, ^D, and \-1.
  A character value of \-1
  eliminates the effect of that character.
  The

From chris@gyre.umd.edu  Thu May  1 16:41:47 1986
Received: by monet.Berkeley.EDU (5.50/1.12)
	id AA10982; Thu, 1 May 86 16:41:47 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA00327; Thu, 1 May 86 19:43:12 EDT
Date: Thu, 1 May 86 19:43:12 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8605012343.AA00327@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: /etc/bad144, hpecc() crashes kernel
Cc: chris@gyre.umd.edu

Index: /sys/vaxmba/hp.c 4.3Beta Fix?

Description:
	bad144 and hpecc do not seem to get along well together.
	I have not yet looked into why, but running bad144 can
	cause an ECC error with `bp' pointing at &rhpbuf[...], and
	bp->b_bcount == 4.  This makes the expression

		npf = btodb(bp->b_bcount - bcr);

	return 0, so that a bit lower `npf--' turns it to -1, and
	then getmemc() does nasty things.

	Now, it may be that bp->b_bcount should not be 4 in the
	first place, so I am not certain this will help, but I
	*think* I understand the logic of this ecc routine, so I
	think my fix is right.  It may be that bad144 is also
	broken, but even so, the machine should not crash.

Repeat-By:
	Find an rp06 with a bad sector, and run

		/etc/bad144 -a -c -f rp06 hp0 40129

	(or whatever).

Fix: (?)
	I think the expression should round up:

		npf = howmany(bp->b_bcount - bcr, DEV_BSIZE);

	or some faster variation thereupon.

Chris

From muller@nprdc.arpa  Fri May  2 19:11:37 1986
Received: by monet.Berkeley.EDU (5.50/1.14)
	id AA01627; Fri, 2 May 86 19:11:37 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA04504; Fri, 2 May 86 19:12:59 pdt
Date: Fri, 2 May 86 19:12:59 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605030212.AA04504@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: maryland serial line tcp/ip bug

Subject: serial line code hangs
Index:	src/sys/(net or netinet?)/if_sl.c 4.3BSD

Description:
	While playing with the serial tcp code based on rick adams at seismo
	slip (from u of maryland for 4.3), i ran into some problems.
	(I understand that a modified  version of this code will be in
	the released 4.3). Anyway when using it, it either wedges the line
	or fails to flush out characters on large data transfers.
	I suspect you fixed this already, but just in case....
	The problem is two missing lines that update the character count 
	and length variables after b_to_q stuffs them in the output queue.
Repeat-By:
	Run serial line code between two 4.3 machines, transfer large
	files, the line will hang after some number of bytes are transmitted.

	Keith Muller
	University of California, San Diego

Fix:
	This piece of code is in slstart() in if_sl.c

*** if_sl.c.orig	Mon Mar 10 19:06:19 1986
--- if_sl.c.good	Fri May  2 15:30:28 1986
***************
*** 292,321 ****
--- 287,318 ----
  			while (len > 0) {
  				/*
  				 * Find out how many bytes in the string we can
  				 * handle without doing something special.
  				 */
  				nd = locc(FRAME_ESCAPE, len, cp);
  				np = locc(FRAME_END, len, cp);
  				n = len - MAX(nd, np);
  				if (n) {
  					/*
  					 * Put n characters at once
  					 * into the tty output queue.
  					 */
  					if (b_to_q((char *)cp, n, &tp->t_outq))
  						break;
+ 					len -= n;
+ 					cp += n;
  				}
  				/*
  				 * If there are characters left in the mbuf,
  				 * the first one must be special..
  				 * Put it out in a different form.
  				 */
  				if (len) {
  					if (putc(FRAME_ESCAPE, &tp->t_outq))
  						break;
  					if (putc(*cp == FRAME_ESCAPE ?
  					   TRANS_FRAME_ESCAPE : TRANS_FRAME_END,
  					   &tp->t_outq)) {
  						(void) unputc(&tp->t_outq);
  						break;
  					}

From chris@gyre.umd.edu  Mon May  5 09:12:15 1986
Received: by monet.Berkeley.EDU (5.50/1.14)
	id AA00173; Mon, 5 May 86 09:12:15 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA06677; Mon, 5 May 86 12:12:29 EDT
Date: Mon, 5 May 86 12:12:29 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8605051612.AA06677@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: New and improved
Cc: louie@trantor.umd.edu

I discovered that Multics likes to generate finger requests that
look like `user/W' (as opposed to the more common `/W user').
I decided the finger server should handle these too.  Since fingerd.c
is so small, and the diffs are so large, here is the whole thing.

Chris

/*
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 */

#ifndef lint
char copyright[] =
"@(#) Copyright (c) 1983 Regents of the University of California.\n\
 All rights reserved.\n";
#endif not lint

#ifndef lint
static char sccsid[] = "@(#)fingerd.c	5.1 (Berkeley) 6/6/85";
#endif not lint

/*
 * Finger server.
 */
#include <sys/types.h>
#include <sys/file.h>
#include <netinet/in.h>

#include <stdio.h>
#include <ctype.h>
#include <netdb.h>

main(argc, argv)
	char *argv[];
{
	register char *sp;
	char line[1024];
	struct sockaddr_in sin;
	int i, p[2], pid, status;
	FILE *fp;
	char *av[100];
	char *index();

	i = sizeof (sin);
	if (getpeername(0, &sin, &i) < 0)
		fatal(argv[0], "getpeername");
	line[0] = '\0';
	(void) gets(line);
	if ((sp = index(line, '\r')) != NULL)
		*sp = 0;
	log(&sin, line);

	av[0] = "finger";
	i = 1;

	/*
	 * Find `/W' if there, and add `-l' if so.  It can
	 * appear anywhere, and even more than once.  The
	 * only restriction here is that there can be no
	 * other `/'s before `/W'.
	 */
	while ((sp = index(line, '/')) != NULL) {
		if (sp[1] != 'w' && sp[1] != 'W')
			break;
		av[1] = "-l";
		i = 2;
		*sp++ = ' ';
		*sp = ' ';
	}

	/* make argv */
	sp = line;
	for (;;) {
		while (isspace(*sp))
			sp++;
		if (*sp == 0)
			break;
		if (*sp && !isspace(*sp)) {
			av[i++] = sp;
			while (*sp && !isspace(*sp))
				sp++;
			if (*sp == 0)
				break;
			*sp++ = 0;
		}
	}
	av[i] = 0;

	/* run finger, convert its output to `network format' */
	if (pipe(p) < 0)
		fatal(argv[0], "pipe");
	if ((pid = fork()) == 0) {
		(void) close(p[0]);
		if (p[1] != 1) {
			(void) dup2(p[1], 1);
			(void) close(p[1]);
		}
		(void) dup2(1, 2);
		execv("/usr/ucb/finger", av);
		perror("execv(/usr/ucb/finger)");
		_exit(1);
	}
	if (pid == -1)
		fatal(argv[0], "fork");
	(void) close(p[1]);
	if ((fp = fdopen(p[0], "r")) == NULL)
		fatal(argv[0], "fdopen");
	while ((i = getc(fp)) != EOF) {
		if (i == '\n')
			(void) putchar('\r');
		(void) putchar(i);
	}
	(void) fclose(fp);

	/* consume children */
	while ((i = wait(&status)) != pid && i != -1)
		;
	exit(0);
}

/*
 * Log a finger request from the host `s'.
 */
log(s, args)
	struct sockaddr_in *s;
	char *args;
{
	struct hostent *hp;
	char *name;
	int fd;
	FILE *fp;
	time_t t;
	time_t time();
	char *inet_ntoa(), *ctime();

	/* log iff the file is writable; do not ever create it */
	if ((fd = open("/usr/adm/fingerd.log", O_WRONLY|O_APPEND)) < 0)
		return;
	if ((fp = fdopen(fd, "w")) == NULL) {
		(void) close(fd);
		return;
	}
	/* get host name, if available */
	hp = gethostbyaddr(&s->sin_addr, sizeof (s->sin_addr), s->sin_family);
	if (hp == NULL)
		name = inet_ntoa(s->sin_addr);
	else
		name = hp->h_name;
	(void) time(&t);
	(void) fprintf(fp, "%s fingers \"%s\" @ %s", name, args, ctime(&t));
	(void) fclose(fp);
}

/*
 * Abort with an error message.
 */
fatal(prog, s)
	char *prog, *s;
{

	(void) fprintf(stderr, "%s: ", prog);
	perror(s);
	exit(1);
}

From guy%gorodish@SUN.COM  Mon May  5 17:19:52 1986
Received: by monet.Berkeley.EDU (5.50/1.14)
	id AA03088; Mon, 5 May 86 17:19:52 PDT
Received: from snail.sun.com (snail-ptp) by sun.com (3.2-/SMI-3.0)
	id AA29249; Mon, 5 May 86 17:15:54 PDT
Received: from gorodish.sun.uucp by snail.sun.com (3.2/SMI-3.0)
	id AA25193; Mon, 5 May 86 17:19:06 PDT
Received: by gorodish.sun.uucp (3.2/SMI-3.0DEV3)
	id AA01062; Mon, 5 May 86 17:20:40 PDT
Date: Mon, 5 May 86 17:20:40 PDT
From: guy%gorodish@SUN.COM (Guy Harris)
Message-Id: <8605060020.AA01062@gorodish.sun.uucp>
Subject: "pstat -s" counts non-"swapon"ed devices
Index: 	etc/pstat.c 4.3betaBSD
To: beta43_bugs@monet.Berkeley.EDU

Description:
	"pstat -s" includes all configured swap devices when it computes
	"nswap".  It should only count those devices which have actually
	been enabled as swap devices.
Repeat-By:
	Try doing "pstat -s" when single-user and the kernel includes
	more than one swap device.
Fix:
	This also corrects a typo - note the "," at the end of the
	"nswap += sw->sw_nblks" line in the "before" picture.

*** /space/4.3beta/usr/src/etc/pstat.c	Wed Sep  4 21:06:20 1985
--- ./pstat.c	Mon May  5 17:16:01 1986
***************
*** 743,750 ****
  	dmmin = getw(nl[SDMMIN].n_value);
  	dmmax = getw(nl[SDMMAX].n_value);
  	nswap = 0;
! 	for (sw = swdevt; sw < &swdevt[nswdev]; sw++)
! 		nswap += sw->sw_nblks,
  	free = 0;
  	for (me = (struct mapent *)(swapmap+1);
  	    me < (struct mapent *)&swapmap[nswapmap]; me++)
--- 743,752 ----
  	dmmin = getw(nl[SDMMIN].n_value);
  	dmmax = getw(nl[SDMMAX].n_value);
  	nswap = 0;
! 	for (sw = swdevt; sw < &swdevt[nswdev]; sw++) {
! 		if (sw->sw_freed)
! 			nswap += sw->sw_nblks;
! 	}
  	free = 0;
  	for (me = (struct mapent *)(swapmap+1);
  	    me < (struct mapent *)&swapmap[nswapmap]; me++)

From hilbert!hubert@uw-beaver.arpa  Tue May  6 16:20:26 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA08324; Tue, 6 May 86 16:20:26 PDT
Received: by uw-beaver.arpa (4.42/4.2)
	id AA07236; Tue, 6 May 86 16:21:23 PDT
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA14366; Tue, 6 May 86 16:19:00 PDT
Date: Tue, 6 May 86 16:19:00 PDT
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Tue, 6 May 86 16:19:00 PDT
Message-Id: <8605062319.AA14366@hilbert.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: f77

I don't have an f77 standard to look at but I thought I would ask about
this anyway.  I have an oldtime fortran programmer who says that many
fortran programs are written which use "a" output format to write
temporary files.  This is not possible with 4.3 f77 since it eats up
null characters.  He says the same thing has worked on many other
systems he has used.  He doesn't want to use binary writes because
those will put record length information in the output.  In his
particular case he is trying to write a bitmap for a Versatec which
will be read by the lineprinter filters.  Looking at putc in wsfe.c
it is obvious that the eating of nulls is intentional.  Should it be?
Here is a sample program.

	program tsta2
c
c	   test a2 format
c
	integer*2 b(10)
c
	open(1,file='tsta2.out',status='unknown')
	rewind 1
c
	do 10 i=1,10
10	b(i)=i-5
	write(1,20)b
20	format(100a2)
	write(1,30)b
30	format(100a2$)
	call exit
	end

[ od -h tsta2.out ]

0000000  fffc fffd fffe ffff 0201 0403 0a05 fffc
0000020  fffd fffe ffff 0201 0403 0a05
0000034


	program tsta4
c
c	   test a4 format
c
	integer b(10)
c
	open(1,file='tsta4.out',status='unknown')
	rewind 1
c
	do 10 i=1,10
10	b(i)=i-5
	write(1,20)b
20	format(100a4)
	write(1,30)b
30	format(100a4$)
	call exit
	end


[ od -h tsta4.out ]

0000000  fffc ffff fffd ffff fffe ffff ffff ffff
0000020  0201 0403 0a05 fffc ffff fffd ffff fffe
0000040  ffff ffff ffff 0201 0403 0a05
0000054

Steve Hubert
 Dept. of Stat., U. of Wash, Seattle
 {decvax,ihnp4,ucbvax!lbl-csam}!uw-beaver!hilbert!hubert
 hilbert!hubert@uw-beaver

From muller@nprdc.arpa  Wed May  7 22:32:12 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA09943; Wed, 7 May 86 22:32:12 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA02379; Wed, 7 May 86 22:34:23 pdt
Date: Wed, 7 May 86 22:34:23 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605080534.AA02379@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: quota.c bug

Subject: quota fails on user with all digit logins
Index:	src/ucb/quota.c 4.3BSD

Description:
	If a user has a login name that consists completely of digits,
	quota fails to report the quota for that user, but instead
	reports the quota for the user with that uid.
Repeat-By:
	Create a user with the login name 44 and any uid. Then
	create another user with the uid 44. When aksed for the
	quota of user 44, quota returns the quota for the user with
	uid 44.
Fix:
	The problem is that quota assumes that login names are never
	all digits. Instead that assumption should only be made after
	an unsuccessful attempt to look for a user with that name.
	The diff below is a fix:

	Keith Muller
	University of California, San Diego


RCS file: RCS/quota.c,v
retrieving revision 1.1
diff -c -r1.1 quota.c
*** /tmp/,RCSt1022128	Wed May  7 22:18:39 1986
--- quota.c	Wed May  7 15:01:53 1986
***************
*** 71,82
  		showuid(getuid());
  		exit(0);
  	}
! 	for (; argc > 0; argc--, argv++) {
! 		if (alldigits(*argv))
! 			showuid(atoi(*argv));
! 		else
! 			showname(*argv);
! 	}
  }
  
  showuid(uid)

--- 71,78 -----
  		showuid(getuid());
  		exit(0);
  	}
! 	for (; argc > 0; argc--, argv++)
! 		showname(*argv);
  }
  
  showuid(uid)
***************
*** 96,103
  	struct passwd *pwd = getpwnam(name);
  
  	if (pwd == NULL) {
! 		fprintf(stderr, "quota: %s: unknown user\n", name);
! 		return;
  	}
  	showquotas(pwd->pw_uid, name);
  }

--- 92,102 -----
  	struct passwd *pwd = getpwnam(name);
  
  	if (pwd == NULL) {
! 		if (!alldigits(name)) {
! 			fprintf(stderr, "quota: %s: unknown user\n", name);
! 			return;
! 		}
! 		showuid(atoi(name));
  	}
  	showquotas(pwd->pw_uid, name);
  }

From muller@nprdc.arpa  Wed May  7 22:32:44 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA09950; Wed, 7 May 86 22:32:44 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA02384; Wed, 7 May 86 22:34:55 pdt
Date: Wed, 7 May 86 22:34:55 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605080534.AA02384@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: edquota.c bug

Subject: edquota fails to work for user names that are all digits
Index:	src/etc/edquota.c 4.3BSD

Description:
	When trying to set or change a quota on a user whose login
	name consists of all digits, edquota assumes it is a uid
	and not a login name
Repeat-By:
	Create a user 44 and try and place a quota on him. Edquota
	will put the quota on the user with uid of 44 and not the
	user with the login name 44
Fix:
	The fix is to have edquota only assume the name is a uid
	if it is all digits and is not a valid login name.

	Keith Muller
	University of California, San Diego


RCS file: RCS/edquota.c,v
retrieving revision 1.1
diff -c -r1.1 edquota.c
*** /tmp/,RCSt1022179	Wed May  7 22:20:57 1986
--- edquota.c	Wed May  7 15:15:26 1986
***************
*** 98,106
  	struct passwd *pw;
  	int uid;
  
! 	if (alldigits(name))
! 		uid = atoi(name);
! 	else if (pw = getpwnam(name))
  		uid = pw->pw_uid;
  	else {
  		fprintf(stderr, "%s: no such user\n", name);

--- 98,104 -----
  	struct passwd *pw;
  	int uid;
  
! 	if (pw = getpwnam(name))
  		uid = pw->pw_uid;
  	else if (alldigits(name))
  		uid = atoi(name);
***************
*** 102,107
  		uid = atoi(name);
  	else if (pw = getpwnam(name))
  		uid = pw->pw_uid;
  	else {
  		fprintf(stderr, "%s: no such user\n", name);
  		sleep(1);

--- 100,107 -----
  
  	if (pw = getpwnam(name))
  		uid = pw->pw_uid;
+ 	else if (alldigits(name))
+ 		uid = atoi(name);
  	else {
  		fprintf(stderr, "%s: no such user\n", name);
  		sleep(1);

From muller@nprdc.arpa  Thu May  8 13:17:35 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA13351; Thu, 8 May 86 13:17:35 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA09855; Thu, 8 May 86 13:19:27 pdt
Date: Thu, 8 May 86 13:19:27 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605082019.AA09855@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: updated quota.c fix

here is the correct bug report. I screwed up the rcsdiff on the last one
and a return got dropped, sorry.

Subject: quota fails on user with all digit logins
Index:	src/ucb/quota.c 4.3BSD

Description:
	If a user has a login name that consists completely of digits,
	quota fails to report the quota for that user, but instead
	reports the quota for the user with that uid.
Repeat-By:
	Create a user with the login name 44 and any uid. Then
	create another user with the uid 44. When aksed for the
	quota of user 44, quota returns the quota for the user with
	uid 44.
Fix:
	The problem is that quota assumes that login names are never
	all digits. Instead that assumption should only be made after
	an unsuccessful attempt to look for a user with that name.
	The diff below is a fix:

	Keith Muller
	University of California, San Diego

RCS file: RCS/quota.c,v
retrieving revision 1.1
diff -c -r1.1 quota.c
*** /tmp/,RCSt1002772	Thu May  8 13:13:30 1986
--- quota.c	Thu May  8 13:12:19 1986
***************
*** 71,82
  		showuid(getuid());
  		exit(0);
  	}
! 	for (; argc > 0; argc--, argv++) {
! 		if (alldigits(*argv))
! 			showuid(atoi(*argv));
! 		else
! 			showname(*argv);
! 	}
  }
  
  showuid(uid)

--- 71,78 -----
  		showuid(getuid());
  		exit(0);
  	}
! 	for (; argc > 0; argc--, argv++)
! 		showname(*argv);
  }
  
  showuid(uid)
***************
*** 96,102
  	struct passwd *pwd = getpwnam(name);
  
  	if (pwd == NULL) {
! 		fprintf(stderr, "quota: %s: unknown user\n", name);
  		return;
  	}
  	showquotas(pwd->pw_uid, name);

--- 92,102 -----
  	struct passwd *pwd = getpwnam(name);
  
  	if (pwd == NULL) {
! 		if (!alldigits(name)) {
! 			fprintf(stderr, "quota: %s: unknown user\n", name);
! 			return;
! 		}
! 		showuid(atoi(name));
  		return;
  	}
  	showquotas(pwd->pw_uid, name);

From hilbert!hubert@uw-beaver.arpa  Fri May  9 17:26:34 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA02318; Fri, 9 May 86 17:26:34 PDT
Received: by uw-beaver.arpa (4.42/4.2)
	id AA25145; Fri, 9 May 86 17:27:21 PDT
Return-Path: <hilbert!hubert@uw-beaver.arpa>
Received: by hilbert.UUCP (5.31/1.0.Entropy)
	id AA04843; Fri, 9 May 86 17:24:24 PDT
Date: Fri, 9 May 86 17:24:24 PDT
From: Steve Hubert <hilbert!hubert@uw-beaver.arpa>
Posted-Date: Fri, 9 May 86 17:24:24 PDT
Message-Id: <8605100024.AA04843@hilbert.UUCP>
To: beta43_bugs@monet.Berkeley.EDU
Subject: 4.3 sendmail bug

==============================================================
Subject: Sendmail version 5.45 doesn't do aliases while processing 
	 queued mails.
Description:
	Sendmail doesn't read alias database when a child of sendmail
	daemon scans queue.
Repeat-by:
	Create a mail in the mail queue addressed to a name in the alias file.
	Run a sendmail daemon to process it.
Fix:
	Added three lines in queue.c as below:
	
				
*** 308,313 ****
--- 309,317 ----
  #else SIGCHLD
	          (void) signal(SIGCHLD, SIG_DFL);
		    #endif SIGCHLD
		    +               /* the alias database hasn't been open; open it */
		    +               if (OpMode == MD_DAEMON)
		    +                       initaliases(AliasFile, FALSE);
		            }
			      
				        setproctitle("running queue");
					
=========================================================================

From muller@nprdc.arpa  Sat May 10 15:53:18 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA13713; Sat, 10 May 86 15:53:18 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA26543; Sat, 10 May 86 15:54:49 pdt
Date: Sat, 10 May 86 15:54:49 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605102254.AA26543@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: small typo bug

Subject: a missing = in termcap.src
Index:	src/etc/termcap/termcap.src 4.3BSD

Description:
	The string defining cm for a graphon is missing an = sign
Repeat-By:
	Try to use a program that does cursor motion on a graphon
Fix:
	A context diff below fixes the problem.
	Keith Muller
	University of California, San Diego


RCS file: RCS/termcap.src,v
retrieving revision 1.1
diff -c -r1.1 termcap.src
*** /tmp/,RCSt1006227	Sat May 10 15:50:13 1986
--- termcap.src	Wed May  7 00:28:44 1986
***************
*** 2226,2232
  	:kl=^H:kr=^L:ku=^K:kd=^J:kh=\036:up=^K:\
  	:BS=^U:CL=^V:CR=^B:RK=^L:UK=^K:LK=^H:DK=^J:HM=\036:
  zu|go140|graphon go-140:\
! 	:co#80:li#24:cl=10\E[;H\E[2J:bs:cm\E[%i%2;%2H:nd=\E[C:up=\E[A:\
  	:ce=\E[K:cd=10\E[J:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
  	:is=\E<\E=\E[?3l\E[?7l\E(B\E[J\E7\E[;r\E8\E[m\E[q:\
  	:dl=\E[M:al=\E[L:dc=\E[P:im=\E[4h:ei=\E[4l:\

--- 2226,2232 -----
  	:kl=^H:kr=^L:ku=^K:kd=^J:kh=\036:up=^K:\
  	:BS=^U:CL=^V:CR=^B:RK=^L:UK=^K:LK=^H:DK=^J:HM=\036:
  zu|go140|graphon go-140:\
! 	:co#80:li#24:cl=10\E[;H\E[2J:bs:cm=\E[%i%2;%2H:nd=\E[C:up=\E[A:\
  	:ce=\E[K:cd=10\E[J:so=\E[7m:se=\E[m:us=\E[4m:ue=\E[m:\
  	:is=\E<\E=\E[?3l\E[?7l\E(B\E[J\E7\E[;r\E8\E[m\E[q:\
  	:dl=\E[M:al=\E[L:dc=\E[P:im=\E[4h:ei=\E[4l:\

From whm@arizona.edu  Tue May 13 11:57:31 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA02062; Tue, 13 May 86 11:57:31 PDT
Received: by arizona.arizona.edu; Tue, 13 May 86 11:57:37 MST
Date: Tue, 13 May 86 11:57:35 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8605131857.AA09590@megaron.arizona.edu>
Received: by megaron.arizona.edu; Tue, 13 May 86 11:57:35 MST
To: beta43_sites@monet.Berkeley.EDU
Subject: ksh mods for 4.3?

Does anybody have the changes necessary to make ksh from the Toolchest
work under 4.3?

					Thanks,
					Bill Mitchell
					whm@arizona.edu
					ihnp4!arizona!whm

From muller@nprdc.arpa  Wed May 14 19:44:26 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA10602; Wed, 14 May 86 19:44:26 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06680; Wed, 14 May 86 19:46:10 pdt
Date: Wed, 14 May 86 19:46:10 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605150246.AA06680@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: two more if_sl.c bugs, both bad ones

Here are two more fixes to maryland version of seismo slip code. Both
of these are real nasty bugs. Since putting these (and the previous
bug fix I sent you) fixes in, the serial line has run perfectly for
almost 48 hours (it used crash the machine at least every other hour).

Subject: serial line code crashes system and punts on large packets
Index:	src/sys/net/if_sl.c 4.3BSD

Description:
	Two problems:
	1) When transferring files over a serial line with a command like
	rcp for long periods of time and there is another active network
	interface the system crashes from various things like "out of
	mbufs", "protection fault", etc.
	2) Receive on large packets fail at various times.
Repeat-By:
	Configure a system to include a serial line connect it to another
	system also running the serial line code, start up an rdist
	and wait for about 15 minutes (more or less) and one or both
	of the systems will crash.
Fix:
	These are two related problems, both having to do with large
	packets. The first problem involves the routine sl_btom() which
	was incorrectly swapping buffers/CLPAGES. This is the cause of
	the crash. The second problem involves the routine slinput() which
	was incorrectly trying to recieve exactly MTU chars in a packet.
	The first diff "hunk" is for the crashing problem, the second is
	for the MTU problem.

	Keith Muller
	University of California, San Diego
	muller@NPRDC.ARPA
	muller@sdcsvax.ucsd.edu

*** if_sl.c.orig	Wed May 14 19:13:07 1986
--- if_sl.c	Wed May 14 19:13:41 1986
***************
*** 383,403 ****
  		 * allocate a new page.  Swap the current buffer page
  		 * with the new one.  We depend on having a space
  		 * left at the beginning of the buffer
  		 * for the interface pointer.
  		 */
  		if (len >= NBPG) {
  			MCLGET(m);
  			if (m->m_len == CLBYTES) {
  				cp = mtod(m, char *);
  				m->m_off = (int)sc->sc_buf - (int)m;
! 				sc->sc_buf = mtod(m, char *);
  				if (ifp) {
  					m->m_off += sizeof(ifp);
  					count = MIN(len,
  					    CLBYTES - sizeof(struct ifnet *));
  				} else
  					count = MIN(len, CLBYTES);
  				goto nocopy;
  			}
  		}
  		if (ifp)
--- 383,403 ----
  		 * allocate a new page.  Swap the current buffer page
  		 * with the new one.  We depend on having a space
  		 * left at the beginning of the buffer
  		 * for the interface pointer.
  		 */
  		if (len >= NBPG) {
  			MCLGET(m);
  			if (m->m_len == CLBYTES) {
  				cp = mtod(m, char *);
  				m->m_off = (int)sc->sc_buf - (int)m;
! 				sc->sc_buf = cp;
  				if (ifp) {
  					m->m_off += sizeof(ifp);
  					count = MIN(len,
  					    CLBYTES - sizeof(struct ifnet *));
  				} else
  					count = MIN(len, CLBYTES);
  				goto nocopy;
  			}
  		}
  		if (ifp)
***************
*** 479,499 ****
  				schednetisr(NETISR_IP);
  			}
  			splx(s);
  			return;
  
  		case FRAME_ESCAPE:
  			sc->sc_flags |= SC_ESCAPED;
  			return;
  		}
  	}
! 	if (++sc->sc_ilen >= SLMTU) {
  		sc->sc_if.if_ierrors++;
  		sc->sc_mp = sc->sc_buf + sizeof(struct ifnet *);
  		sc->sc_ilen = 0;
  		return;
  	}
  	*sc->sc_mp++ = c;
  }
  
  /*
   * Process an ioctl request.
--- 479,499 ----
  				schednetisr(NETISR_IP);
  			}
  			splx(s);
  			return;
  
  		case FRAME_ESCAPE:
  			sc->sc_flags |= SC_ESCAPED;
  			return;
  		}
  	}
! 	if (sc->sc_ilen++ >= SLMTU) {
  		sc->sc_if.if_ierrors++;
  		sc->sc_mp = sc->sc_buf + sizeof(struct ifnet *);
  		sc->sc_ilen = 0;
  		return;
  	}
  	*sc->sc_mp++ = c;
  }
  
  /*
   * Process an ioctl request.

From comay  Fri May 16 12:49:40 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA22145; Fri, 16 May 86 12:49:40 PDT
Date: Fri, 16 May 86 12:49:40 PDT
From: comay (David S. Comay)
Message-Id: <8605161949.AA22145@monet.Berkeley.EDU>
Subject: man page for col is out of date
Index: 	/usr/man/man1/col.1 4.3BSD
Apparently-To: beta43_bugs

Description:
	the current man page says that the conversion of blanks to tabs
	is the default and that the `x' flag should be used to suppress
	the conversion.  in reality, col does not do the conversion by
	default, and the `h' option should be specified to enable the
	conversion.
Repeat-By:
	examine the man page
Fix:
	*** col.1.orig	Fri May 16 12:33:06 1986
	--- col.1	Fri May 16 12:47:41 1986
	***************
	*** 7,13 ****
	  .SH SYNOPSIS
	  .B col
	  [
	! .B \-bfx
	  ]
	  .SH DESCRIPTION
	  .I Col
	--- 7,13 ----
	  .SH SYNOPSIS
	  .B col
	  [
	! .B \-bfh
	  ]
	  .SH DESCRIPTION
	  .I Col
	***************
	*** 52,62 ****
	  character read is remembered; on output, SO and SI characters are generated
	  where necessary to maintain the correct treatment of each character.
	  .PP
	- .I Col
	- normally converts white space to tabs to shorten printing time.
	  If the
	! .B \-x
	! option is given, this conversion is suppressed.
	  .PP
	  All control characters are removed from the input except space,
	  backspace,
	--- 52,62 ----
	  character read is remembered; on output, SO and SI characters are generated
	  where necessary to maintain the correct treatment of each character.
	  .PP
	  If the
	! .B \-h
	! option is given,
	! .I col
	! converts white space to tabs to shorten printing time.
	  .PP
	  All control characters are removed from the input except space,
	  backspace,

From comay  Fri May 16 12:58:16 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA22203; Fri, 16 May 86 12:58:16 PDT
Date: Fri, 16 May 86 12:58:16 PDT
From: comay (David S. Comay)
Message-Id: <8605161958.AA22203@monet.Berkeley.EDU>
Subject: csr specified in il(4) is wrong
Index: 	/usr/man/man4/il.4 4.3BSD
Apparently-To: beta43_bugs

Description:
	the standard csr specified in il(4) is incorrect.  i believe
	the correct value is what's in /sys/conf/GENERIC, namely
	164000.
Repeat-By:
	examine the man page.
Fix:
	change 161000 to 164000.

From karels  Sun May 18 17:38:07 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA29844; Sun, 18 May 86 17:38:07 PDT
From: karels (Mike Karels)
Message-Id: <8605190038.AA29844@monet.Berkeley.EDU>
To: beta43_sites
Cc: ferrari@ernie, graham@arpa
Subject: 4.3 information packets are out
Date: Sun, 18 May 86 17:38:05 PDT

I'm pleased to announce that the 4.3BSD information packets and ordering
information were mailed to all 4.2BSD licensees on Friday.  Meanwhile,
we are finishing the typesetting and other last-minute details.  I'd like
to thank all of the beta sites for the feedback we've received.

In order to facilitate the ordering process, I'll summarize the ordering
procedure.  First, the information packets were sent to the administrative
contact listed on the 4.2BSD licenses.  Presuming that you know who that is,
it may be reasonable to prepare them for a rapid turn-around (we anticipate
that the orders will come in fairly quickly).  There is a one-page addendum
to the 4.2BSD license that adds the new release under the terms of the
previous license.  As usual, this addendum is to be signed by the same
person who signed the 4.2 license or by his replacement; better start
figuring out who that will be! The cost for the new release to 4.2
licensees is $600; for new licensees it will be $1000.  The only
difference between the packages received will be the omission of 780
floppies and 750/730 cassettes from the update kits.

For the beta sites that are redistributors of 4BSD-based systems,
I'd like to remind you of the terms of the beta test release.
In particular, all beta sites agreed to upgrade to the final release
of 4.3BSD.  A number of redistributors asked for and received permission
to use parts of 4.3, especially subnet support, in external releases.
However, I am anxious that all externally-released software that is
described as 4.3BSD actually consist of the final release, not the beta
release.  The number of changes between the beta release and the final
release is fairly large, but not difficult to incorporate.  Note that
I am very familiar with the differences between the two, and if necessary
will offer my assistance to customers, potential customers and competitors
of 4.3BSD vendors to verify that new releases are accurately described.
Sorry to sound restrictive, but I've heard rumors that a few vendors
plan to announce 4.3 support two weeks after Berkeley's announcement.
I'll be pleased if such announcements occur, but only if the releases
described as 4.3BSD really are 4.3.  Incidentally, any "secondary"
beta sites that have received copies of 4.3beta from other beta sites
should receive copies of this message.

I have one last update to offer the beta sites for last-minute testing.
Both telnet and ftp have received substantial work in the last several
weeks.  The ftp changes should take care of several interoperability
problems that were noticed after the last update; note, though, that
ascii mode transfer between 4.2 and 4.3 systems will not work as expected
due to bugs in 4.2's treatment of line-feeds.  The telnet client and
server both support line mode, local translation of special characters
(interrupt, etc) to telnet equivalents, and flush of output on interrupt
or flush.  The new sources and manual pages are available by anonymous
ftp from ucbarpa.berkeley.edu as pub/4.3/update/{telnet,ftp}.tar;
as before, the directories leading to these files are unreadable.
I'd like to have these tested as quickly as possible, especially by
those who reported problems earlier.  Thanks.

		Mike

From comay  Wed May 21 00:48:33 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA07935; Wed, 21 May 86 00:48:33 PDT
Date: Wed, 21 May 86 00:48:33 PDT
From: comay (David S. Comay)
Message-Id: <8605210748.AA07935@monet.Berkeley.EDU>
Subject: `netstat -s' generates statistics and list of active unix sockets
Index: 	ucb/netstat/main.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	running `netstat -s' generates protocols statistics like it
	should, but it also generates a list of active unix domain
	sockets.  i assume this is a bug, since the list of active unix
	domains sockets can either be generated by a `netstat' or a
	`netstat -u'.
Repeat-By:
	run `netstat -s'.
Fix:
	simply check the value of `sflag' before printing the unix
	domain list (or perhaps in the future print some interesting
	statistics regarding the unix domain)

	*** main.c.orig	Tue May 20 23:49:08 1986
	--- main.c	Tue May 20 23:54:50 1986
	***************
	*** 320,326 ****
	  			(*tp->pr_cblocks)(nl[tp->pr_index].n_value, tp->pr_name);
	  	}
	      }
	!     if (af == AF_UNIX || af == AF_UNSPEC)
	  	    unixpr(nl[N_NFILE].n_value, nl[N_FILE].n_value,
	  		nl[N_UNIXSW].n_value);
	      exit(0);
	--- 320,326 ----
	  			(*tp->pr_cblocks)(nl[tp->pr_index].n_value, tp->pr_name);
	  	}
	      }
	!     if ((af == AF_UNIX || af == AF_UNSPEC) && !sflag)
	  	    unixpr(nl[N_NFILE].n_value, nl[N_FILE].n_value,
	  		nl[N_UNIXSW].n_value);
	      exit(0);

From comay  Wed May 21 01:09:37 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA08121; Wed, 21 May 86 01:09:37 PDT
Date: Wed, 21 May 86 01:09:37 PDT
From: comay (David S. Comay)
Message-Id: <8605210809.AA08121@monet.Berkeley.EDU>
Subject: `ct' driver doesn't compile
Index: 	sys/vaxuba/ct.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	the cat driver doesn't compile since the winsize structure is
	not defined.
Repeat-By:
	include a `ct' device in the conf file and try to make a new
	kernel.
Fix:
	need to include ioctl.h before tty.h

	*** ct.c.orig	Wed May 21 00:55:22 1986
	--- ct.c	Wed May 21 00:54:58 1986
	***************
	*** 15,20 ****
	--- 15,21 ----
	  
	  #include "param.h"
	  #include "systm.h"
	+ #include "ioctl.h"
	  #include "tty.h"
	  #include "map.h"
	  #include "buf.h"

From jim  Wed May 21 12:13:05 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA09864; Wed, 21 May 86 12:13:05 PDT
Date: Wed, 21 May 86 12:13:05 PDT
From: jim (Jim McKie)
Message-Id: <8605211913.AA09864@monet.Berkeley.EDU>
To: beta43_bugs

Subject: /usr/src/usr.lib/me/Makefile
A new version which uses DESTDIR correctly and does away
with the 'install.csh' script can be found in
monet:~jim/Makefile.me.

/usr/src/etc/named/MAkefile also doesn't handle DESTDIR correctly.

--jim

From jim  Thu May 22 09:12:42 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA13478; Thu, 22 May 86 09:12:42 PDT
Date: Thu, 22 May 86 09:12:42 PDT
From: jim (Jim McKie)
Message-Id: <8605221612.AA13478@monet.Berkeley.EDU>
Subject: <sys/types.h> FD_* macros incompatible with V8
Apparently-To: beta43_bugs

The fd_set argument to the FD_* macros in V8 is a fd_set name,
in 4.3 it is a pointer to an fd_set, e.g.
4.3:
#define FD_SET(n, p)    ((p)->fds_bits[(n)/NFDBITS] |= (1 << ((n) % NFDBITS)))
V8:
#define FD_SET(n,s)     (s).fds_bits[(n)/(NBPW*NBBY)] |= 1<<((n)%(NBPW*NBBY))

--jim

From muller@nprdc.arpa  Thu May 22 15:48:15 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA16325; Thu, 22 May 86 15:48:15 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA21518; Thu, 22 May 86 15:49:40 pdt
Date: Thu, 22 May 86 15:49:40 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605222249.AA21518@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: dmf bug

This is the first of two dmf bug fixes. They are much better than any
other report I sent up to you before.
Subject: dmf driver fails in dma mode on all emulex versions
Index:	sys/vaxuba/dmf.c 4.3BSD

Description:
	Output lines which are greater than 4 long and have an odd character
	count cause one character too many to be flushed from the character
	queue. The result is the first character is missing from the next
	line output.
Repeat-By:
	on an emulex model of a dmf cat any file, certain characters will
	be missing from the output when the previous line output has an odd
	character count.
Fix:
	Emulex models do all unibus accesses in unibus word mode. When given
	a character count that is ODD the internal address of the last memory
	location is ALWAYS EVEN. If this address is subtracted from the starting
	address at the completion of a dma to determine the character count
	to be given to ndflush the count will too large by 1. The fix is
	to store the character count in a local variable.

	Keith Muller
	University of California San Diego
	muller@NPRDC.ARPA
	muller@sdcsvax.ucsd.EDU


RCS file: RCS/dmf.c,v
retrieving revision 1.1
diff -c -r1.1 dmf.c
*** /tmp/,RCSt1004155	Thu May 22 14:58:06 1986
--- dmf.c	Thu May 22 11:06:32 1986
***************
*** 123,128
  int	cbase[NUBA];			/* base address in unibus map */
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
  char	dmf_dma[NDMF*8];
  
  /*
   * Routine for configuration to set dmf interrupt.

--- 123,129 -----
  int	cbase[NUBA];			/* base address in unibus map */
  #define	UBACVT(x, uban)		(cbase[uban] + ((x)-(char *)cfree))
  char	dmf_dma[NDMF*8];
+ int	dmf_count[NDMF*8];
  
  /*
   * Routine for configuration to set dmf interrupt.
***************
*** 579,594
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
! 		else if (dmf_dma[unit0 + t]) {
! 			/*
! 			 * Do arithmetic in a short to make up
! 			 * for lost 16&17 bits.
! 			 */
! 			addr->dmfcsr = DMFIR_TBA | DMF_IE | t;
! 			cntr = addr->dmftba -
! 			    UBACVT(tp->t_outq.c_cf, ui->ui_ubanum);
! 			ndflush(&tp->t_outq, (int)cntr);
! 		}
  		if (tp->t_line)
  			(*linesw[tp->t_line].l_start)(tp);
  		else

--- 580,587 -----
  		tp->t_state &= ~TS_BUSY;
  		if (tp->t_state&TS_FLUSH)
  			tp->t_state &= ~TS_FLUSH;
! 		else if (dmf_dma[unit0 + t])
! 			ndflush(&tp->t_outq, dmf_count[unit0 + t]);
  		if (tp->t_line)
  			(*linesw[tp->t_line].l_start)(tp);
  		else
***************
*** 674,679
  		register car;
  
  		dmf_dma[minor(tp->t_dev)] = 1;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);

--- 667,673 -----
  		register car;
  
  		dmf_dma[minor(tp->t_dev)] = 1;
+ 		dmf_count[minor(tp->t_dev)] = nch;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);

From muller@nprdc.arpa  Thu May 22 15:48:53 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA16364; Thu, 22 May 86 15:48:53 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA21534; Thu, 22 May 86 15:50:09 pdt
Date: Thu, 22 May 86 15:50:09 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8605222250.AA21534@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: dmf bug #2

Subject: stop/start control flow on dmf's often duplicate output lines
Index:	sys/vaxuba/dmf.c 4.3BSD

Description:
	On vax 750's and faster machines stop/start control flow such
	as control-s/control-q input from a printer or high speed
	terminal often results in the duplicated output lines at many
	of the times a control-s is transmitted to the dmf.
	Due to nature of this problem (it is a timing problem) it
	is very hard to duplicate on vax730 and slower machines.
Repeat-By:
	On a vax750 cat a very large file on a terminal running 9600
	baud or greater. Rapidly type control-s then control-q several
	times in a row. After stopping output and then starting again,
	the last line that was output under dma mode is printed again
	after the control-q is processed. 
Fix:
	This is a race condition between sequental lines in the
	driver and operation on the dmf that cause asynch. interrupts.
	The problem is due to the setting of tty state flags AFTER the
	operation they represent was started on the dmf. The dmf quite 
	often will interrupt BEFORE the flag is set. The fix is to
	move the setting of the state variable to before the write to
	the dmf csr register that would initiate an operation that 
	terminates with an interrupt.

	NOTE: The diffs below include a line from my previous emulex
	dmf bug fix

	Keith Muller
	University of California San Diego
	muller@NPRDC.ARPA
	muller@sdcsvax.ucsd.EDU


RCS file: RCS/dmf.c,v
retrieving revision 1.1
diff -c -r1.1 dmf.c
*** /tmp/,RCSt1004155	Thu May 22 14:58:06 1986
--- dmf.c	Thu May 22 11:06:32 1986
***************
*** 628,633
  	 */
  	addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
  	if (addr->dmftsc) {
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		tp->t_state |= TS_BUSY;

--- 621,627 -----
  	 */
  	addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
  	if (addr->dmftsc) {
+ 		tp->t_state |= TS_BUSY;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		goto out;
***************
*** 630,636
  	if (addr->dmftsc) {
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
- 		tp->t_state |= TS_BUSY;
  		goto out;
  	}
  	/*

--- 624,629 -----
  		tp->t_state |= TS_BUSY;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		goto out;
  	}
  	/*
***************
*** 674,679
  		register car;
  
  		dmf_dma[minor(tp->t_dev)] = 1;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);

--- 667,674 -----
  		register car;
  
  		dmf_dma[minor(tp->t_dev)] = 1;
+ 		dmf_count[minor(tp->t_dev)] = nch;
+ 		tp->t_state |= TS_BUSY;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		car = UBACVT(tp->t_outq.c_cf, dmfinfo[dmf]->ui_ubanum);
***************
*** 680,686
  		addr->dmfcsr = DMF_IE | DMFIR_TBA | unit;
  		addr->dmftba = car;
  		addr->dmftcc = ((car >> 2) & 0xc000) | nch;
- 		tp->t_state |= TS_BUSY;
  	} else if (nch) {
  		register char *cp = tp->t_outq.c_cf;
  		register int i;

--- 675,680 -----
  		addr->dmfcsr = DMF_IE | DMFIR_TBA | unit;
  		addr->dmftba = car;
  		addr->dmftcc = ((car >> 2) & 0xc000) | nch;
  	} else if (nch) {
  		register char *cp = tp->t_outq.c_cf;
  		register int i;
***************
*** 687,692
  
  		dmf_dma[minor(tp->t_dev)] = 0;
  		nch = MIN(nch, DMF_SILOCNT);
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;

--- 681,687 -----
  
  		dmf_dma[minor(tp->t_dev)] = 0;
  		nch = MIN(nch, DMF_SILOCNT);
+ 		tp->t_state |= TS_BUSY;
  		addr->dmfcsr = DMF_IE | DMFIR_LCR | unit;
  		addr->dmflctms = addr->dmflctms | DMF_TE;
  		addr->dmfcsr = DMF_IE | DMFIR_TBUF | unit;
***************
*** 693,699
  		for (i = 0; i < nch; i++)
  			addr->dmftbuf = *cp++;
  		ndflush(&tp->t_outq, nch);
- 		tp->t_state |= TS_BUSY;
  	}
  out:
  	splx(s);

--- 688,693 -----
  		for (i = 0; i < nch; i++)
  			addr->dmftbuf = *cp++;
  		ndflush(&tp->t_outq, nch);
  	}
  out:
  	splx(s);
***************
*** 723,728
  			 * (TS_BUSY), if the silo contains untransmitted
  			 * characters.
  			 */
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms | DMF_TE | DMF_FLUSH;
  			/* this will interrupt so let dmfxint handle the rest */

--- 717,723 -----
  			 * (TS_BUSY), if the silo contains untransmitted
  			 * characters.
  			 */
+ 			tp->t_state |= TS_FLUSH|TS_BUSY;
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms | DMF_TE | DMF_FLUSH;
  			/* this will interrupt so let dmfxint handle the rest */
***************
*** 726,732
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms | DMF_TE | DMF_FLUSH;
  			/* this will interrupt so let dmfxint handle the rest */
- 			tp->t_state |= TS_FLUSH|TS_BUSY;
  		}
  	} else {
  		if (tp->t_state & TS_BUSY) {

--- 721,726 -----
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms | DMF_TE | DMF_FLUSH;
  			/* this will interrupt so let dmfxint handle the rest */
  		}
  	} else {
  		if (tp->t_state & TS_BUSY) {
***************
*** 735,740
  			 * the transmitter.  We'll pick up where we
  			 * left off by reenabling in dmfstart.
  			 */
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms &~ DMF_TE;
  			/* no interrupt here */

--- 729,735 -----
  			 * the transmitter.  We'll pick up where we
  			 * left off by reenabling in dmfstart.
  			 */
+ 			tp->t_state &= ~TS_BUSY;
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms &~ DMF_TE;
  			/* no interrupt here */
***************
*** 738,744
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms &~ DMF_TE;
  			/* no interrupt here */
- 			tp->t_state &= ~TS_BUSY;
  		}
  	}
  	splx(s);

--- 733,738 -----
  			addr->dmfcsr = DMFIR_LCR | unit | DMF_IE;
  			addr->dmflctms = addr->dmflctms &~ DMF_TE;
  			/* no interrupt here */
  		}
  	}
  	splx(s);

From comay  Wed May 28 15:30:58 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA03217; Wed, 28 May 86 15:30:58 PDT
Date: Wed, 28 May 86 15:30:58 PDT
From: comay (David S. Comay)
Message-Id: <8605282230.AA03217@monet.Berkeley.EDU>
Subject: `occured' (sic) misspelled in message to user
Index: 	usr.bin/at/atrun.c 4.3BSD
Apparently-To: beta43_bugs

Description:
	`occurred' is misspelled in the message `atrun' mails to
	a user when his or her job terminates abnormally.
Repeat-By:
	examine the source code.
Fix:

	*** atrun.c.orig	Wed May 28 15:23:09 1986
	--- atrun.c	Wed May 28 15:23:16 1986
	***************
	*** 259,269 ****
	  		}
	  		exitstatus = ((errbuf.st_size == 0) ? NORMAL : ABNORMAL);
	  
	! 		/* If errors occured, then we send mail to the owner
	  		 * telling him/her that we ran into trouble.  
	  		 *
	  		 * (NOTE: this could easily be modified so that if any 
	! 		 * errors occured while running a job, mail is sent regard-
	  		 * less of whether the -m flag was set or not.
	  		 *
	  		 * i.e. rather than:
	--- 259,269 ----
	  		}
	  		exitstatus = ((errbuf.st_size == 0) ? NORMAL : ABNORMAL);
	  
	! 		/* If errors occurred, then we send mail to the owner
	  		 * telling him/her that we ran into trouble.  
	  		 *
	  		 * (NOTE: this could easily be modified so that if any 
	! 		 * errors occurred while running a job, mail is sent regard-
	  		 * less of whether the -m flag was set or not.
	  		 *
	  		 * i.e. rather than:
	***************
	*** 390,396 ****
	  	/*
	  	 * If the job exited abnormally, send a letter notifying the user
	  	 * that the job didn't run proberly. Also, send a copy of the errors 
	! 	 * that occured to the user.
	  	 */
	  	else {
	  		if (exitstatus == ABNORMAL) {
	--- 390,396 ----
	  	/*
	  	 * If the job exited abnormally, send a letter notifying the user
	  	 * that the job didn't run proberly. Also, send a copy of the errors 
	! 	 * that occurred to the user.
	  	 */
	  	else {
	  		if (exitstatus == ABNORMAL) {
	***************
	*** 401,411 ****
	  			fprintf(mailptr,"\n\nThe job you submitted to at, ");
	  			fprintf(mailptr,"\"%s\", ",jobname);
	  			fprintf(mailptr,"exited abnormally.\nA list of the ");
	! 			fprintf(mailptr," errors that occured follows:\n\n\n");
	  
	  			/*
	  			 * Open the file containing a log of the errors that
	! 			 * occured.
	  			 */
	  			if ((errptr = fopen(errfile,"r")) == NULL) {
	  				perror(errfile);
	--- 401,411 ----
	  			fprintf(mailptr,"\n\nThe job you submitted to at, ");
	  			fprintf(mailptr,"\"%s\", ",jobname);
	  			fprintf(mailptr,"exited abnormally.\nA list of the ");
	! 			fprintf(mailptr," errors that occurred follows:\n\n\n");
	  
	  			/*
	  			 * Open the file containing a log of the errors that
	! 			 * occurred.
	  			 */
	  			if ((errptr = fopen(errfile,"r")) == NULL) {
	  				perror(errfile);

From jim  Mon Jun  2 13:13:22 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA24062; Mon, 2 Jun 86 13:13:22 PDT
Date: Mon, 2 Jun 86 13:13:22 PDT
From: jim (Jim McKie)
Message-Id: <8606022013.AA24062@monet.Berkeley.EDU>
Subject: new microcode patch for 11/750's
Apparently-To: beta43_bugs

A pcs750.bin file which brings the ucode rev level up to 99 can
be found in monet:~jim/pcs750.bin.rev99.

--jim

From muller@nprdc.arpa  Tue Jun  3 02:42:11 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA03762; Tue, 3 Jun 86 02:42:11 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA06088; Tue, 3 Jun 86 02:44:25 pdt
Date: Tue, 3 Jun 86 02:44:25 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8606030944.AA06088@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: possable nasty sys/vaxmba/hp.c problem

This is a bit of a funny bug report, but anyway... I was talking on the
phone the other day to someone who claims to have access to the current 4.3
source. The discussion involved bad block fowarding and this person told
me that in hpecc() in sys/vaxmba/hp.c the code:
	if (bp-b_flags & B_BAD)
		npf = bp->b_error;
	else
		npf = btodb(bp->b_count - bcr);

was changed at the line with the call to btodb. I was told that
the last line in the fragment above now reads:

		npf = btodb(bp->b_count - bcr + 511);
	
The added + 511 doesn't seem right to me, but I had to try it. The disk I tried
it on was an eagle on a 750 on a emulex sc750 controller. And sure enough the
system crashed on freeing a free inode. The problem was that on a BSE error
detecting a marked block, it could NOT be found in the table by isbad(); After
carefully checking the problem, it turns out that this only happened under
the right conditions to certain i/o operations on some subset of the fowarderd
bad blocks. 

For example the block that caused the crash was sn217854 on the g partition 
(this block is properly marked and properly enetered in the bad block table
(see the table below, it is sn593214 on the c partition)

The call to calculate npf with btodb had:
	bp->b_count = 1024
	bcr = 1020
The result was npf was 1 (WRONG it should be 0). Later on in hpecc() isbad
was looking for
	217855 cn 617 tn 18 sn 31 
which is a GOOD block. It failed. It should have been looking for
	217854 cn 617 tn 18 sn 30 

WITHOUT the + 511 everything works fine. Since I do not have access to the
source myself I might be wasting everyones time, but just in case....

The g partition which was set up with 8k primary/1k frags .
The bad block table for the disk follows: (the stuff in () I added and are
the sn relative the partition)

bad block information at sector 808272 in /dev/hp2c:
cartridge serial number: 0(10)
sn=107502, cn=111, tn=19, sn=30		(h partition sn23982)
sn=299463, cn=311, tn=18, sn=39		(h partition sn215943)
sn=394468, cn=410, tn=18, sn=4		(g partition sn19108)
sn=456879, cn=475, tn=18, sn=15		(g partition sn81519)
sn=593214, cn=617, tn=18, sn=30		(g partition sn217854) <- problem
sn=597050, cn=621, tn=18, sn=26		(g partition sn221690)
sn=599925, cn=624, tn=18, sn=21		(g partition sn224565)
sn=642020, cn=668, tn=15, sn=20		(g partition sn266660)
sn=653671, cn=680, tn=18, sn=7		(g partition sn278311)
sn=668864, cn=696, tn=14, sn=32		(g partition sn293504)
sn=706493, cn=735, tn=18, sn=29		(g partition sn331133)
sn=714146, cn=743, tn=18, sn=2		(g partition sn338786)
sn=758349, cn=789, tn=18, sn=45		(g partition sn382989)
sn=761273, cn=792, tn=19, sn=41		(g partition sn385913)
sn=802482, cn=835, tn=18, sn=18		(g partition sn427122)
sn=802555, cn=835, tn=19, sn=43		(g partition sn427195)

I understand this is hard to reproduce, but taking an eagle set up as
above and using bad144 to force that sector into the table should do
it. Then write to that block......  This was not the ONLY such block
that failed, but just one of many which all work WITHOUT the + 511

	Keith Muller
	University of California, San Diego
	muller@NPRDC.ARPA
	muller@sdcsvax.ucsd.EDU

From whm@arizona.edu  Thu Jun  5 03:26:03 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA27241; Thu, 5 Jun 86 03:26:03 PDT
Received: by arizona.arizona.edu; Thu, 5 Jun 86 03:08:47 MST
Date: Thu, 5 Jun 86 03:08:45 MST
From: "Bill Mitchell" <whm@arizona.edu>
Message-Id: <8606051008.AA10406@megaron.arizona.edu>
Received: by megaron.arizona.edu; Thu, 5 Jun 86 03:08:45 MST
To: beta43_bugs@monet.Berkeley.EDU
Subject: Questions about uucico's cntrl.c

I got around to investigating the cause of some "can't access" errors on uucp
spool files on our system and came up with a couple of questions that I can't
answer.  I should mention that prior to this evening I'd made no significant
investigations of uucico's operation so I hope you'll pardon my ignorance.
Also, we're running uucp from 4.3, but I note that similar source code for the
section I'll be mentioning is present in 4.2 uucp and Sun's 2.0 uucp.  If
anyone could offer expert advice, I'd certainly appreciate it.

The problem at hand was to determine the source of messages such as
"arizona!/usr/spool/uucp/D.arizonaABCD -- can't access".  I found that
this message is generated in cntrl.c when a given file that is to be sent
to a remote system does not exist.  For example, this problem can be
reproduced by queueing a uucp operation and then deleting one of the
data files.

With this information in hand, the question became "Where did the data
file go?".  Examination of the log files revealed sequences such as:

root ihnp4 (5/20-18:29-6545) OK (startup)
uucp ihnp4 (5/20-18:31-6545) REQUEST (S D.arizonaBAGy2 D.arizonaBAGy2 uucp)
uucp ihnp4 (5/20-18:32-6545) REQUEST (S D.arizonaXAGy0 X.arizonaXAGy0 uucp)
uucp ihnp4 (5/20-18:33-6545) BAD READ (expected 'S' got FAIL (2))
uucp ihnp4 (5/20-18:33-6545) FAILED (conversation complete)
uucp ihnp4 (5/20-18:51-6566) OK (startup)
uucp ihnp4 (5/20-18:51-6566) REQUEST (S D.arizonaBAGy2 D.arizonaBAGy2 uucp)
uucp ihnp4 (5/20-18:51-6566) FAILED (CAN'T READ DATA)
uucp ihnp4 (5/20-18:51-6566) REQUEST (S D.arizonaXAGy0 X.arizonaXAGy0 uucp)
uucp ihnp4 (5/20-18:52-6566) BAD READ (expected 'S' got FAIL (2))
uucp ihnp4 (5/20-18:52-6566) FAILED (conversation complete)
daemon ihnp4 (5/20-23:15-7278) SUCCEEDED (call to ihnp4 )
daemon ihnp4 (5/20-23:15-7278) OK (startup)
uucp ihnp4 (5/20-23:15-7278) REQUEST (S D.arizonaBAGy2 D.arizonaBAGy2 uucp)
uucp ihnp4 (5/20-23:15-7278) FAILED (CAN'T READ DATA)
uucp ihnp4 (5/20-23:15-7278) REQUEST (S D.arizonaXAGy0 X.arizonaXAGy0 uucp)
uucp ihnp4 (5/20-23:15-7278) FAILED (CAN'T READ DATA)
uucp ihnp4 (5/20-23:15-7278) OK (conversation complete)

In the first session, BAGy2 is sent without trouble, but apparently
while "SY" is being expected for XAGy0, the connection fails.  In the
second session, an attempt is made to send BAGy2 again, but it's gone.
The code in cntrl.c appears to delete each file after it has been
sent, and I guess there are some possibly good reasons for that,
but if it's expected to have situations where one file gets sent and
it's partner doesn't make it, producing a C. file that names a non-existent
data file, why make the user think that something is wrong?

In the same vein, when cntrl.c is sending a file (using the SNDFILE case)
it calls the "Wrdata" (protocol dependent) to ship the data across and
then attempts to get a RQSTCMPT message from the remote system.  If it
gets it, it deletes the data file.  I don't know that I've ever seen a
RQSTCMPT message that was "CN" instead of "CY", but there is code there
to handle a "CN" message.  I didn't investigate what might cause a CN,
but it seems that the data file should be deleted only after the CY is
received and not after getting a "C?"  If success of Wrdata guarantees
a CY, then I suppose there's nothing to worry about, but is this the case?

As a final question, in the above log excerpt it seems obvious that
BAGy2 was deleted because it was considered to be successfully sent, but
I'm not clear on where XAGy0 went.  It looks like uucico was expecting
an SY when it croaked, but was the SY for XAGy0 or the next file?
If the former, it doesn't seem that XAGy0 should have been deleted.
If the latter, I would expected that the C. file for the transaction
would have been removed since (I'm assuming) that only two files were
involved and they've both been sent.  Any comments on this?

Thanks in advance for any help you can offer!

					Bill Mitchell
					whm@arizona.edu
					{ihnp4,noao,mcnc,utah-cs}!arizona!whm

p.s.
I also sent this to net.bugs.uucp since the problem would seem to be
non-4.3 specific.

From muller@nprdc.arpa  Thu Jun  5 13:42:37 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA17575; Thu, 5 Jun 86 13:42:37 PDT
Received: by nprdc.arpa (4.12/ 1.1)
	id AA08602; Thu, 5 Jun 86 13:44:37 pdt
Date: Thu, 5 Jun 86 13:44:37 pdt
From: muller@nprdc.arpa (Keith Muller)
Message-Id: <8606052044.AA08602@nprdc.arpa>
To: beta43_bugs@monet.Berkeley.EDU
Subject: lpr bug

Subject: lpr can fail to remove the df data files
Index:	src/usr.lib/lpr/recvjob.c 4.3BSD

Description:
		After receiving all the df files in a job from a 
		remote machine, a request for accepting the cf file
		(selection \2) will be received.  If an error occurs
		while receiving cf file, lpd will call the routine
		rcleanup() to clean up the temporary cf file (tf)
		and all associated df files.  However, the variable
		dfname is just a pointer into the string "line".
		The data in "line" would have been written over by
		a request for receiving cf file.  Therefore, when
		rcleanup() trys to clean up the df files,  it is unable
		to do so because it no longer has the last df file name
		available to it (the data in "line" would have the
		cf file name instead).  rcleanup() fails in attemping 
		to loop and decrement the first character in dfname
		until a "d" is found as the actual first character 
		where dfname points to is "c".

Repeat-By:
		This is a bit hard to repeat, but causing a failure while
		accepting a cf file could be duplicated by a fixed up routine
		to send a bad cf file to lpd.
Fix: 
		One way to fix it is be done by allocating space for dfname
		(just like tfname).  This will preserve the data in
		dfname and save the last df file name. An alternate would
		be to change rcleanup() to be more intelligent about
		unlinking files.

		Keith Muller
		University of California, San Diego
		muller@NPRDC.ARPA
		muller@sdcsvax.ucsd.EDU

RCS file: RCS/recvjob.c,v
retrieving revision 1.1
diff -c -r1.1 recvjob.c
*** /tmp/,RCSt1012630	Thu Jun  5 12:49:58 1986
--- recvjob.c	Thu Jun  5 12:48:16 1986
***************
*** 20,26 ****
  #define ack()	(void) write(1, sp, 1);
  
  char    tfname[40];		/* tmp copy of cf before linking */
! char    *dfname;		/* data files */
  int	minfree;		/* keep at least minfree blocks available */
  char	*ddev;			/* disk device (for checking free space) */
  int	dfd;			/* file system device descriptor */
--- 20,26 ----
  #define ack()	(void) write(1, sp, 1);
  
  char    tfname[40];		/* tmp copy of cf before linking */
! char    dfname[40];		/* data files */
  int	minfree;		/* keep at least minfree blocks available */
  char	*ddev;			/* disk device (for checking free space) */
  int	dfd;			/* file system device descriptor */
***************
*** 174,180 ****
  				(void) write(1, "\2", 1);
  				continue;
  			}
! 			(void) readfile(dfname = cp, size);
  			continue;
  		}
  		frecverr("protocol screwup");
--- 174,181 ----
  				(void) write(1, "\2", 1);
  				continue;
  			}
! 			strcpy(dfname, cp);
! 			(void) readfile(dfname, size);
  			continue;
  		}
  		frecverr("protocol screwup");
***************
*** 289,295 ****
  
  	if (tfname[0])
  		(void) unlink(tfname);
! 	if (dfname)
  		do {
  			do
  				(void) unlink(dfname);
--- 290,296 ----
  
  	if (tfname[0])
  		(void) unlink(tfname);
! 	if (dfname[0])
  		do {
  			do
  				(void) unlink(dfname);
***************
*** 296,301 ****
--- 297,303 ----
  			while (dfname[2]-- != 'A');
  			dfname[2] = 'z';
  		} while (dfname[0]-- != 'd');
+ 	dfname[0] = '\0';
  }
  
  frecverr(msg, a1, a2)

From torek@calder.Berkeley.EDU  Sun Jun 22 18:54:51 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA05390; Sun, 22 Jun 86 18:54:51 PDT
Received: by calder.Berkeley.EDU (5.51/1.14)
	id AA00479; Sun, 22 Jun 86 18:54:44 PDT
Date: Sun, 22 Jun 86 18:54:44 PDT
From: torek@calder.berkeley.edu (Chris Torek)
Message-Id: <8606230154.AA00479@calder.Berkeley.EDU>
To: beta43_bugs@monet.Berkeley.EDU
Subject: /usr/include/{,arpa/}resolv.h

Why are there two files for this, especially since they are
identical?  I think I will make one a symlink on gyre.

From bloom  Mon Jun 23 09:09:10 1986
Received: by monet.Berkeley.EDU (5.51/1.14)
	id AA07164; Mon, 23 Jun 86 09:09:10 PDT
From: bloom (Jim Bloom)
Message-Id: <8606231609.AA07164@monet.Berkeley.EDU>
To: torek@calder.berkeley.edu (Chris Torek)
Cc: beta43_bugs@monet.Berkeley.EDU
Subject: Re: /usr/include/{,arpa/}resolv.h 
In-Reply-To: Your message of Sun, 22 Jun 86 18:54:44 PDT.
             <8606230154.AA00479@calder.Berkeley.EDU> 
Date: Mon, 23 Jun 86 09:09:08 PDT

Remove the one in /usr/include/arpa.  The file was moved a while ago.

					Jim

From helge  Mon Jul 14 07:49:20 1986
Received: by monet.Berkeley.EDU (5.53/1.14)
	id AA10665; Mon, 14 Jul 86 07:49:20 PDT
Date: Mon, 14 Jul 86 07:49:20 PDT
From: helge (Helge Skrivervik)
Message-Id: <8607141449.AA10665@monet.Berkeley.EDU>
To: beta43_bugs
Subject: uucp dialer problem

the hayes dialer fails on many hayes compatible modems
which are too slow too handle the number at full speed (like the old ventel dialer).
the fix is to use slowrite to send the number to the modem.

helge

From chris@gyre.umd.edu  Sun Jul 20 00:13:35 1986
Received: by monet.Berkeley.EDU (5.53/1.14)
	id AA05339; Sun, 20 Jul 86 00:13:35 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA00628; Sun, 20 Jul 86 03:15:28 EDT
Date: Sun, 20 Jul 86 03:15:28 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8607200715.AA00628@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: type glitch in ioctls
Cc: donn@utah-cs.arpa

Index: /sys/h/ioctl.h 4.3beta Fix

Description:
	`read' and `void' ioctl entries are of type `int'; `write'
	and `read/write' ioctls are of type `unsigned'.  This is
	because the constant 0x80000000 is unsigned.  (Surprise!)

Repeat-By:
	lint a kernel, e.g.

Fix:
	Change IOC_IN to `(int)0x80000000'.

Chris

From chris@gyre.umd.edu  Sun Jul 27 14:48:34 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA20929; Sun, 27 Jul 86 14:48:34 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA00204; Sun, 27 Jul 86 17:50:59 EDT
Date: Sun, 27 Jul 86 17:50:59 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8607272150.AA00204@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: arp.c has bizarre code

Index: /usr/src/etc/arp.c 4.3

Description:
	arp has been changed to handle five arguments per line for
	a file (arp -f), yet the sscanf format string tells scanf
	to look only for four.

Repeat-By:
	Examination

From chris@mimsy.umd.edu  Mon Aug  4 23:25:16 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA06940; Mon, 4 Aug 86 23:25:16 PDT
Received: by mimsy.umd.edu (5.9/4.7) id AA23400; Tue, 5 Aug 86 02:24:47 EDT
Date: Tue, 5 Aug 86 02:24:47 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8608050624.AA23400@mimsy.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Better ... but still not right
Cc: chris@gyre.umd.edu, steve@mimsy.umd.edu

Index: /usr/src/ucb/rlogin.c+/usr/src/lib/libc/net/rcmd.c 4.3.? Fix

Description:
	Rlogin's window OOB handling is still not quite right.

	[Also, rcmd is excessively protective, and slightly wrong
	in places.  The sigmask(SIGURG)s are not necessary, since
	no data can sneak in until one connect()s the socket, and
	by then the F_SETOWN is done.  And perror(0) is not type-
	correct; nor will it work at all on a Sun.]

Repeat-By:
	Indeed?  And why should it be repeatable?

	Let us try instead a thought experiment.

	Rlogin fires up, and gets to the two lines that do this:

		signal(SIGURG, oob);
		oldmask = sigblock(sigmask(SIGURG));

	Any OOB signals will now go to oob(), in this process and
	any child it forks.  So far so good.

	Now rlogin does this:

		rem = rcmd(...);

	Rcmd() sets the socket's owner to the process ID, and uses
	a positive number.  In 4.3 this means only the given process
	gets any OOB signal (in 4.2 the signal goes to the process
	group---nothing special here).  Now rlogin trips merrily
	along, and eventually does this:

		child = fork();

	But wait!  What happens if OOB data came in before the
	fork()?  Well, in that case, since SIGURG is still blocked,
	the parent is all set to call oob(), while the child has
	no signals pending (since pending signals are not carried
	across fork()s).

	Well, this would not be TOO terrible: oob() will still
	get called.  But what is this?  The next few lines in the
	parent process do this:

		signal(SIGURG, writeroob);
		sigsetmask(oldmask);

	which means that the very next thing that will happen is
	that the kernel will call writeroob(), regardless of the
	actual OOB data!

	Well, that is one thing that can go wrong.  What else?

	Let us suppose that no OOB data comes in until after the
	fork.  What does the child do?

		mode(1);
		sigsetmask(oldmask);
		if (reader() == 0)

	The first lines of reader do this:

		pid = getpid();
		fcntl(rem, F_SETOWN, pid);

	which will set the owner to the single process (not pgroup)
	which is the child.  If OOB data shows up afterward, it will
	interrupt the reader and be properly handled by oob().

	But hold!  What if some OOB data sneaks in between the
	beginning of the child and the fcntl()?  That darned socket
	is still owned by the parent, and look what he is about to
	do, or perhaps even has done already: redirect his OOB
	handler to writeroob().

	Alas, alack!  OOB *must* be handled by the reader, and the
	reader must be the child, so that ~^Y can work.  But only
	the parent might receive an out of band signal.  How then
	can we solve this?

	I am afraid the only reliable solution is a radical one.
	The parent must handle out of band signals, at least until
	the child is established.  Is this truly reliable?  Well
	no: for signals are not queued.  More than one out of band
	data byte might sneak in.  But that is too hard even to
	consider.

Fix:
	This is untested, but should work.

	main(...)
		...
		signal(SIGPIPE, lostpeer);
		/* no SIGURG trap yet */
		/* will use SIGUSR1 for window size hack */
		oldmask = sigblock(sigmask(SIGURG)|sigmask(SIGUSR1));
		rem = rcmd(...);
		...
		doit(oldmask)
		...
	}
	...

	doit(oldmask)
		...
		if (child == 0) {
			mode(1);
			/* no sigsetmask yet */
			if (reader(oldmask) == 0) {
				prf("Connection closed.");
				exit(0);
			}
			sleep(1);
			prf("\007Connection closed.");
			exit(3);
		}

		/*
		 * Until the child takes over the socket, we must
		 * catch any out of band data signals.  If any such
		 * occur, pass them on to the child.
		 */
		signal(SIGURG, copytochild);	/* NOT writeroob */
		signal(SIGUSR1, writeroob);	/* NOT sigurg */
		signal(SIGCHLD, catchild);
		sigsetmask(oldmask);
		while (fcntl(rem, F_GETOWN, 0) != child)
			/* N.B.: above test should be -child for 4.2 */
			nap(100);		/* sleep .1 seconds */
		writer();
		prf("Closed connection.");
		done(0);
	}

	/*
	 * Sleep for the specified number of milliseconds.
	 */
	nap(ms)
		int ms;
	{
		struct timeval tv;

		tv.tv_sec = 0;
		tv.tv_usec = ms * 1000;
		(void) select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &tv);
	}

	/*
	 * Copy out of band signals to the child process.
	 */
	copytochild()
	{

		kill(child, SIGURG);
	}

	...
	/* oob does not do FLUSHREAD, alas */
	oob()
	{
		...
		if (mark & TIOCPKT_WINDOW) {
			/*
			 * Let server know about window size changes
			 */
			kill(ppid, SIGUSR1);
		}
		...
	}

	...

	reader(oldmask)
		int oldmask;
	{
		...

		signal(SIGTTOU, SIG_IGN);
		/*
		 * No, silly, not yet!  Not until the setjmp and ppid
		 * assignments are done.
		 *
		 * fcntl(rem, F_SETOWN, pid);
		 */
		ppid = getppid();
		(void) setjmp(rcvtop);

		/* NOW! */
		fcntl(rem, F_SETOWN, pid);

		for (;;) {
			...

From chris@gyre.umd.edu  Tue Aug  5 14:34:20 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA09550; Tue, 5 Aug 86 14:34:20 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA05199; Tue, 5 Aug 86 17:35:28 EDT
Date: Tue, 5 Aug 86 17:35:28 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8608052135.AA05199@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU, chris@mimsy.umd.edu
Subject: Re:  Better ... but still not right
Cc: steve@mimsy.umd.edu

Oops, I left one thing out: reader needs to do a sigsetmask(oldmask)
just after the fcntl().

Incidentally, the loop before writer() with the nap() calls should
not be necessary after all, with the signals separated.  Sending
SIGURG back to writer() for window information was the real mistake.

Chris

From chris@gyre.umd.edu  Wed Aug  6 22:22:02 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA03563; Wed, 6 Aug 86 22:22:02 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA05233; Thu, 7 Aug 86 01:20:16 EDT
Date: Thu, 7 Aug 86 01:20:16 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8608070520.AA05233@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Changes to rlogin.c

The following compiles, runs, and (get this) lints.
I think it is right.

Chris

RCS file: RCS/rlogin.c,v
retrieving revision 1.1.1.2	[taken from monet yesterday]
retrieving revision 1.1.1.2.1.4	[local branch for fixes to that version]
diff -c -r1.1.1.2 -r1.1.1.2.1.4
*** /tmp/,RCSt1005166	Thu Aug  7 01:09:37 1986
--- /tmp/,RCSt2005166	Thu Aug  7 01:10:23 1986
***************
*** 21,26 ****
--- 21,28 ----
  #include <sys/errno.h>
  #include <sys/file.h>
  #include <sys/socket.h>
+ #include <sys/time.h>
+ #include <sys/resource.h>
  #include <sys/wait.h>
  
  #include <netinet/in.h>
***************
*** 37,43 ****
  # define TIOCPKT_WINDOW 0x80
  # endif TIOCPKT_WINDOW
  
! char	*index(), *rindex(), *malloc(), *getenv();
  struct	passwd *getpwuid();
  char	*name;
  int	rem;
--- 39,50 ----
  # define TIOCPKT_WINDOW 0x80
  # endif TIOCPKT_WINDOW
  
! /* concession to sun */
! # ifndef SIGUSR1
! # define SIGUSR1 30
! # endif SIGUSR1
! 
! char	*index(), *rindex(), *malloc(), *getenv(), *strcat(), *strcpy();
  struct	passwd *getpwuid();
  char	*name;
  int	rem;
***************
*** 55,70 ****
  #define sigmask(m)	(1 << ((m)-1))
  #endif
  #ifdef sun
- struct	ttysize winsize;
  struct winsize {
  	unsigned short ws_row, ws_col;
  	unsigned short ws_xpixel, ws_ypixel;
  };
- #else sun
- struct	winsize winsize;
  #endif sun
  int	sigwinch(), oob();
  
  main(argc, argv)
  	int argc;
  	char **argv;
--- 62,101 ----
  #define sigmask(m)	(1 << ((m)-1))
  #endif
  #ifdef sun
  struct winsize {
  	unsigned short ws_row, ws_col;
  	unsigned short ws_xpixel, ws_ypixel;
  };
  #endif sun
+ struct	winsize winsize;
  int	sigwinch(), oob();
  
+ /*
+  * The following routine provides compatibility (such as it is)
+  * between 4.2BSD Suns and others.  Suns have only a `ttysize',
+  * so we convert it to a winsize.
+  */
+ #ifdef sun
+ int
+ get_window_size(fd, wp)
+ 	int fd;
+ 	struct winsize *wp;
+ {
+ 	struct ttysize ts;
+ 	int error;
+ 
+ 	if ((error = ioctl(0, TIOCGSIZE, &ts)) != 0)
+ 		return (error);
+ 	wp->ws_row = ts.ts_lines;
+ 	wp->ws_col = ts.ts_cols;
+ 	wp->ws_xpixel = 0;
+ 	wp->ws_ypixel = 0;
+ 	return (0);
+ }
+ #else sun
+ #define get_window_size(fd, wp)	ioctl(fd, TIOCGWINSZ, wp)
+ #endif sun
+ 
  main(argc, argv)
  	int argc;
  	char **argv;
***************
*** 128,146 ****
  	}
  	cp = getenv("TERM");
  	if (cp)
! 		strcpy(term, cp);
  	if (ioctl(0, TIOCGETP, &ttyb) == 0) {
! 		strcat(term, "/");
! 		strcat(term, speeds[ttyb.sg_ospeed]);
  	}
! #ifdef sun
! 	(void) ioctl(0, TIOCGSIZE, &winsize);
! #else sun
! 	(void) ioctl(0, TIOCGWINSZ, &winsize);
! #endif sun
! 	signal(SIGPIPE, lostpeer);
! 	signal(SIGURG, oob);
! 	oldmask = sigblock(sigmask(SIGURG));
          rem = rcmd(&host, sp->s_port, pwd->pw_name,
  	    name ? name : pwd->pw_name, term, 0);
          if (rem < 0)
--- 159,173 ----
  	}
  	cp = getenv("TERM");
  	if (cp)
! 		(void) strcpy(term, cp);
  	if (ioctl(0, TIOCGETP, &ttyb) == 0) {
! 		(void) strcat(term, "/");
! 		(void) strcat(term, speeds[ttyb.sg_ospeed]);
  	}
! 	(void) get_window_size(0, &winsize);
! 	(void) signal(SIGPIPE, lostpeer);
! 	/* will use SIGUSR1 for window size hack, so hold it off */
! 	oldmask = sigblock(sigmask(SIGURG) | sigmask(SIGUSR1));
          rem = rcmd(&host, sp->s_port, pwd->pw_name,
  	    name ? name : pwd->pw_name, term, 0);
          if (rem < 0)
***************
*** 165,171 ****
  
  int	child;
  int	catchild();
! int	writeroob();
  
  int	defflags, tabflag;
  int	deflflags;
--- 192,198 ----
  
  int	child;
  int	catchild();
! int	copytochild(), writeroob();
  
  int	defflags, tabflag;
  int	deflflags;
***************
*** 180,199 ****
  	int exit();
  	struct sgttyb sb;
  
! 	ioctl(0, TIOCGETP, (char *)&sb);
  	defflags = sb.sg_flags;
  	tabflag = defflags & TBDELAY;
  	defflags &= ECHO | CRMOD;
  	deferase = sb.sg_erase;
  	defkill = sb.sg_kill;
! 	ioctl(0, TIOCLGET, (char *)&deflflags);
! 	ioctl(0, TIOCGETC, (char *)&deftc);
  	notc.t_startc = deftc.t_startc;
  	notc.t_stopc = deftc.t_stopc;
! 	ioctl(0, TIOCGLTC, (char *)&defltc);
! 	signal(SIGINT, SIG_IGN);
! 	signal(SIGHUP, exit);
! 	signal(SIGQUIT, exit);
  	child = fork();
  	if (child == -1) {
  		perror("rlogin: fork");
--- 207,226 ----
  	int exit();
  	struct sgttyb sb;
  
! 	(void) ioctl(0, TIOCGETP, (char *)&sb);
  	defflags = sb.sg_flags;
  	tabflag = defflags & TBDELAY;
  	defflags &= ECHO | CRMOD;
  	deferase = sb.sg_erase;
  	defkill = sb.sg_kill;
! 	(void) ioctl(0, TIOCLGET, (char *)&deflflags);
! 	(void) ioctl(0, TIOCGETC, (char *)&deftc);
  	notc.t_startc = deftc.t_startc;
  	notc.t_stopc = deftc.t_stopc;
! 	(void) ioctl(0, TIOCGLTC, (char *)&defltc);
! 	(void) signal(SIGINT, SIG_IGN);
! 	setsignal(SIGHUP, exit);
! 	setsignal(SIGQUIT, exit);
  	child = fork();
  	if (child == -1) {
  		perror("rlogin: fork");
***************
*** 201,208 ****
  	}
  	if (child == 0) {
  		mode(1);
! 		sigsetmask(oldmask);
! 		if (reader() == 0) {
  			prf("Connection closed.");
  			exit(0);
  		}
--- 228,234 ----
  	}
  	if (child == 0) {
  		mode(1);
! 		if (reader(oldmask) == 0) {
  			prf("Connection closed.");
  			exit(0);
  		}
***************
*** 210,234 ****
  		prf("\007Connection closed.");
  		exit(3);
  	}
! 	signal(SIGURG, writeroob);
! 	sigsetmask(oldmask);
! 	signal(SIGCHLD, catchild);
  	writer();
  	prf("Closed connection.");
  	done(0);
  }
  
  done(status)
  	int status;
  {
  
  	mode(0);
! 	if (child > 0 && kill(child, SIGKILL) >= 0)
! 		wait((int *)0);
  	exit(status);
  }
  
  /*
   * This is called when the reader process gets the out-of-band (urgent)
   * request to turn on the window-changing protocol.
   */
--- 236,296 ----
  		prf("\007Connection closed.");
  		exit(3);
  	}
! 
! 	/*
! 	 * We may still own the socket, and may have a pending SIGURG
! 	 * (or might receive one soon) that we really want to send to
! 	 * the reader.  Set a trap that simply copies such signals to
! 	 * the child.
! 	 */
! 	(void) signal(SIGURG, copytochild);
! 	(void) signal(SIGUSR1, writeroob);
! 	(void) sigsetmask(oldmask);
! 	(void) signal(SIGCHLD, catchild);
  	writer();
  	prf("Closed connection.");
  	done(0);
  }
  
+ /*
+  * Trap a signal, unless it is being ignored.
+  */
+ setsignal(sig, act)
+ 	int sig, (*act)();
+ {
+ 	int omask = sigblock(sigmask(sig));
+ 
+ 	if (signal(sig, act) == SIG_IGN)
+ 		(void) signal(sig, SIG_IGN);
+ 	(void) sigsetmask(omask);
+ }
+ 
  done(status)
  	int status;
  {
+ 	int w;
  
  	mode(0);
! 	if (child > 0) {
! 		/* make sure catchild does not snap it up */
! 		(void) signal(SIGCHLD, SIG_DFL);
! 		if (kill(child, SIGKILL) >= 0)
! 			while ((w = wait((union wait *)0)) > 0 && w != child)
! 				/*void*/;
! 	}
  	exit(status);
  }
  
  /*
+  * Copy SIGURGs to the child process.
+  */
+ copytochild()
+ {
+ 
+ 	(void) kill(child, SIGURG);
+ }
+ 
+ /*
   * This is called when the reader process gets the out-of-band (urgent)
   * request to turn on the window-changing protocol.
   */
***************
*** 237,243 ****
  
  	if (dosigwinch == 0) {
  		sendwindow();
! 		signal(SIGWINCH, sigwinch);
  	}
  	dosigwinch = 1;
  }
--- 299,305 ----
  
  	if (dosigwinch == 0) {
  		sendwindow();
! 		(void) signal(SIGWINCH, sigwinch);
  	}
  	dosigwinch = 1;
  }
***************
*** 248,254 ****
  	int pid;
  
  again:
! 	pid = wait3(&status, WNOHANG|WUNTRACED, 0);
  	if (pid == 0)
  		return;
  	/*
--- 310,316 ----
  	int pid;
  
  again:
! 	pid = wait3(&status, WNOHANG|WUNTRACED, (struct rusage *)0);
  	if (pid == 0)
  		return;
  	/*
***************
*** 255,261 ****
  	 * if the child (reader) dies, just quit
  	 */
  	if (pid < 0 || pid == child && !WIFSTOPPED(status))
! 		done(status.w_termsig | status.w_retcode);
  	goto again;
  }
  
--- 317,323 ----
  	 * if the child (reader) dies, just quit
  	 */
  	if (pid < 0 || pid == child && !WIFSTOPPED(status))
! 		done((int)(status.w_termsig | status.w_retcode));
  	goto again;
  }
  
***************
*** 307,313 ****
  				continue;
  			}
  			if (c != cmdchar)
! 				write(rem, &cmdchar, 1);
  		}
  		if (write(rem, &c, 1) == 0) {
  			prf("line gone");
--- 369,375 ----
  				continue;
  			}
  			if (c != cmdchar)
! 				(void) write(rem, &cmdchar, 1);
  		}
  		if (write(rem, &c, 1) == 0) {
  			prf("line gone");
***************
*** 337,343 ****
  		*p++ = c;
  	*p++ = '\r';
  	*p++ = '\n';
! 	write(1, buf, p - buf);
  }
  
  stop(cmdc)
--- 399,405 ----
  		*p++ = c;
  	*p++ = '\r';
  	*p++ = '\n';
! 	(void) write(1, buf, p - buf);
  }
  
  stop(cmdc)
***************
*** 344,380 ****
  	char cmdc;
  {
  	mode(0);
! 	signal(SIGCHLD, SIG_IGN);
! 	kill(cmdc == defltc.t_suspc ? 0 : getpid(), SIGTSTP);
! 	signal(SIGCHLD, catchild);
  	mode(1);
  	sigwinch();			/* check for size changes */
  }
  
- #ifdef sun
  sigwinch()
  {
- 	struct ttysize ws;
- 
- 	if (dosigwinch && ioctl(0, TIOCGSIZE, &ws) == 0 &&
- 	    bcmp(&ws, &winsize, sizeof (ws))) {
- 		winsize = ws;
- 		sendwindow();
- 	}
- }
- 
- #else sun
- sigwinch()
- {
  	struct winsize ws;
  
! 	if (dosigwinch && ioctl(0, TIOCGWINSZ, &ws) == 0 &&
  	    bcmp(&ws, &winsize, sizeof (ws))) {
  		winsize = ws;
  		sendwindow();
  	}
  }
- #endif
  
  /*
   * Send the window size to the server via the magic escape
--- 406,428 ----
  	char cmdc;
  {
  	mode(0);
! 	(void) signal(SIGCHLD, SIG_IGN);
! 	(void) kill(cmdc == defltc.t_suspc ? 0 : getpid(), SIGTSTP);
! 	(void) signal(SIGCHLD, catchild);
  	mode(1);
  	sigwinch();			/* check for size changes */
  }
  
  sigwinch()
  {
  	struct winsize ws;
  
! 	if (dosigwinch && get_window_size(0, &ws) == 0 &&
  	    bcmp(&ws, &winsize, sizeof (ws))) {
  		winsize = ws;
  		sendwindow();
  	}
  }
  
  /*
   * Send the window size to the server via the magic escape
***************
*** 388,404 ****
  	obuf[1] = 0377;
  	obuf[2] = 's';
  	obuf[3] = 's';
- #ifdef sun
- 	wp->ws_row = htons(winsize.ts_lines);
- 	wp->ws_col = htons(winsize.ts_cols);
- 	wp->ws_xpixel = 0;
- 	wp->ws_ypixel = 0;
- #else sun
  	wp->ws_row = htons(winsize.ws_row);
  	wp->ws_col = htons(winsize.ws_col);
  	wp->ws_xpixel = htons(winsize.ws_xpixel);
  	wp->ws_ypixel = htons(winsize.ws_ypixel);
- #endif sun
  	(void) write(rem, obuf, sizeof(obuf));
  }
  
--- 436,445 ----
***************
*** 451,478 ****
  		/*
  		 * Let server know about window size changes
  		 */
! 		kill(ppid, SIGURG);
  	}
  	if (!eight && (mark & TIOCPKT_NOSTOP)) {
! 		ioctl(0, TIOCGETP, (char *)&sb);
  		sb.sg_flags &= ~CBREAK;
  		sb.sg_flags |= RAW;
! 		ioctl(0, TIOCSETN, (char *)&sb);
  		notc.t_stopc = -1;
  		notc.t_startc = -1;
! 		ioctl(0, TIOCSETC, (char *)&notc);
  	}
  	if (!eight && (mark & TIOCPKT_DOSTOP)) {
! 		ioctl(0, TIOCGETP, (char *)&sb);
  		sb.sg_flags &= ~RAW;
  		sb.sg_flags |= CBREAK;
! 		ioctl(0, TIOCSETN, (char *)&sb);
  		notc.t_stopc = deftc.t_stopc;
  		notc.t_startc = deftc.t_startc;
! 		ioctl(0, TIOCSETC, (char *)&notc);
  	}
  	if (mark & TIOCPKT_FLUSHWRITE) {
! 		ioctl(1, TIOCFLUSH, (char *)&out);
  		for (;;) {
  			if (ioctl(rem, SIOCATMARK, &atmark) < 0) {
  				perror("ioctl");
--- 492,519 ----
  		/*
  		 * Let server know about window size changes
  		 */
! 		(void) kill(ppid, SIGUSR1);
  	}
  	if (!eight && (mark & TIOCPKT_NOSTOP)) {
! 		(void) ioctl(0, TIOCGETP, (char *)&sb);
  		sb.sg_flags &= ~CBREAK;
  		sb.sg_flags |= RAW;
! 		(void) ioctl(0, TIOCSETN, (char *)&sb);
  		notc.t_stopc = -1;
  		notc.t_startc = -1;
! 		(void) ioctl(0, TIOCSETC, (char *)&notc);
  	}
  	if (!eight && (mark & TIOCPKT_DOSTOP)) {
! 		(void) ioctl(0, TIOCGETP, (char *)&sb);
  		sb.sg_flags &= ~RAW;
  		sb.sg_flags |= CBREAK;
! 		(void) ioctl(0, TIOCSETN, (char *)&sb);
  		notc.t_stopc = deftc.t_stopc;
  		notc.t_startc = deftc.t_startc;
! 		(void) ioctl(0, TIOCSETC, (char *)&notc);
  	}
  	if (mark & TIOCPKT_FLUSHWRITE) {
! 		(void) ioctl(1, TIOCFLUSH, (char *)&out);
  		for (;;) {
  			if (ioctl(rem, SIOCATMARK, &atmark) < 0) {
  				perror("ioctl");
***************
*** 494,500 ****
--- 535,546 ----
  		rcvcnt = 0;
  		longjmp(rcvtop, 1);
  	}
+ 
  	/*
+ 	 * oob does not do FLUSHREAD (alas!)
+ 	 */
+ 
+ 	/*
  	 * If we filled the receive buffer while a read was pending,
  	 * longjmp to the top to restart appropriately.  Don't abort
  	 * a pending write, however, or we won't know how much was written.
***************
*** 506,512 ****
  /*
   * reader: read from remote: line -> 1
   */
! reader()
  {
  #if !defined(BSD) || BSD < 43
  	int pid = -getpid();
--- 552,559 ----
  /*
   * reader: read from remote: line -> 1
   */
! reader(oldmask)
! 	int oldmask;
  {
  #if !defined(BSD) || BSD < 43
  	int pid = -getpid();
***************
*** 516,525 ****
  	int n, remaining;
  	char *bufp = rcvbuf;
  
! 	signal(SIGTTOU, SIG_IGN);
! 	fcntl(rem, F_SETOWN, pid);
  	ppid = getppid();
! 	(void) setjmp(rcvtop);
  	for (;;) {
  		while ((remaining = rcvcnt - (bufp - rcvbuf)) > 0) {
  			rcvstate = WRITING;
--- 563,574 ----
  	int n, remaining;
  	char *bufp = rcvbuf;
  
! 	(void) signal(SIGTTOU, SIG_IGN);
! 	(void) signal(SIGURG, oob);
  	ppid = getppid();
! 	(void) fcntl(rem, F_SETOWN, pid);
! 	if (setjmp(rcvtop) == 0)
! 		(void) sigsetmask(oldmask);
  	for (;;) {
  		while ((remaining = rcvcnt - (bufp - rcvbuf)) > 0) {
  			rcvstate = WRITING;
***************
*** 553,560 ****
  	struct sgttyb sb;
  	int	lflags;
  
! 	ioctl(0, TIOCGETP, (char *)&sb);
! 	ioctl(0, TIOCLGET, (char *)&lflags);
  	switch (f) {
  
  	case 0:
--- 602,609 ----
  	struct sgttyb sb;
  	int	lflags;
  
! 	(void) ioctl(0, TIOCGETP, (char *)&sb);
! 	(void) ioctl(0, TIOCLGET, (char *)&lflags);
  	switch (f) {
  
  	case 0:
***************
*** 583,592 ****
  	default:
  		return;
  	}
! 	ioctl(0, TIOCSLTC, (char *)ltc);
! 	ioctl(0, TIOCSETC, (char *)tc);
! 	ioctl(0, TIOCSETN, (char *)&sb);
! 	ioctl(0, TIOCLSET, (char *)&lflags);
  }
  
  /*VARARGS*/
--- 632,641 ----
  	default:
  		return;
  	}
! 	(void) ioctl(0, TIOCSLTC, (char *)ltc);
! 	(void) ioctl(0, TIOCSETC, (char *)tc);
! 	(void) ioctl(0, TIOCSETN, (char *)&sb);
! 	(void) ioctl(0, TIOCLSET, (char *)&lflags);
  }
  
  /*VARARGS*/
***************
*** 593,598 ****
--- 642,648 ----
  prf(f, a1, a2, a3, a4, a5)
  	char *f;
  {
+ 
  	fprintf(stderr, f, a1, a2, a3, a4, a5);
  	fprintf(stderr, CRLF);
  }
***************
*** 599,605 ****
  
  lostpeer()
  {
! 	signal(SIGPIPE, SIG_IGN);
  	prf("\007Connection closed.");
  	done(1);
  }
--- 649,656 ----
  
  lostpeer()
  {
! 
! 	(void) signal(SIGPIPE, SIG_IGN);
  	prf("\007Connection closed.");
  	done(1);
  }

From chris@gyre.umd.edu  Wed Aug  6 23:23:17 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA03783; Wed, 6 Aug 86 23:23:17 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA05757; Thu, 7 Aug 86 02:24:30 EDT
Date: Thu, 7 Aug 86 02:24:30 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8608070624.AA05757@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Oops

My brain must have been on fire when I did the changes to reader().
The sigsetmask is always needed after a longjmp.  Apply this change
on top of previous changes:

RCS file: RCS/rlogin.c,v
retrieving revision 1.1.1.2.1.4
retrieving revision 1.1.1.2.1.5
diff -c -r1.1.1.2.1.4 -r1.1.1.2.1.5
*** /tmp/,RCSt1005745	Thu Aug  7 02:23:03 1986
--- /tmp/,RCSt2005745	Thu Aug  7 02:23:16 1986
***************
*** 567,574 ****
  	(void) signal(SIGURG, oob);
  	ppid = getppid();
  	(void) fcntl(rem, F_SETOWN, pid);
! 	if (setjmp(rcvtop) == 0)
! 		(void) sigsetmask(oldmask);
  	for (;;) {
  		while ((remaining = rcvcnt - (bufp - rcvbuf)) > 0) {
  			rcvstate = WRITING;
--- 567,574 ----
  	(void) signal(SIGURG, oob);
  	ppid = getppid();
  	(void) fcntl(rem, F_SETOWN, pid);
! 	(void) setjmp(rcvtop);
! 	(void) sigsetmask(oldmask);
  	for (;;) {
  		while ((remaining = rcvcnt - (bufp - rcvbuf)) > 0) {
  			rcvstate = WRITING;

From chris@mimsy.umd.edu  Thu Aug  7 15:55:34 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA02075; Thu, 7 Aug 86 15:55:34 PDT
Received: by mimsy.umd.edu (5.9/4.7) id AA28050; Thu, 7 Aug 86 18:54:15 EDT
Date: Thu, 7 Aug 86 18:54:15 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8608072254.AA28050@mimsy.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: rcp deadhost:remotefile localfile does exit(0)

Index: /usr/src/bin/rcp.c 4.3 Fix?

Description:
	Rcp from a dead host to a local file returns a successful
	status.

Repeat-by:
	Find a dead host, then

		if rcp deadhost:file /dev/null; then echo bug; fi

Fix?:
	It looks as though rcp is supposed to continue after one
	of these, in case there are more remote files to copy, so
	I would say change

		if (rem < 0)
			continue;

	near the end of main() to

		if (rem < 0) {
			errs++;
			continue;
		}

Chris

From chris@gyre.umd.edu  Thu Aug  7 16:35:11 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA02338; Thu, 7 Aug 86 16:35:11 PDT
Received: by gyre.umd.edu (5.9/4.7)
	id AA09918; Thu, 7 Aug 86 19:36:11 EDT
Date: Thu, 7 Aug 86 19:36:11 EDT
From: Chris Torek <chris@gyre.umd.edu>
Message-Id: <8608072336.AA09918@gyre.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: Awk makefile is awkward

Index: /usr/src/bin/awk/Makefile 4.3 Fix

Description:
	There is no `depend' entry, and some of the dependencies
	are wrong (not to mention incomplete).

Repeat-by:
	Examination

Fix:
	Below

Chris

RCS file: RCS/Makefile,v
retrieving revision 1.1
diff -c2 -r1.1 Makefile
*** /tmp/,RCSt1009905	Thu Aug  7 19:33:59 1986
--- Makefile	Thu Aug  7 19:33:42 1986
***************
*** 1,15 ****
  #	Makefile	4.2	83/07/08
  #
! CFLAGS=-O
! YFLAGS=-d
! FILES=awk.lx.o b.o main.o token.o tran.o lib.o run.o parse.o proctab.o freeze.o
! SOURCE=awk.def awk.g.y awk.lx.l b.c lib.c main.c parse.c \
! 	proc.c freeze.c\
! 	run.c token.c tran.c
  
! awk:	$(FILES) awk.g.o
! 	cc $(CFLAGS) awk.g.o  $(FILES)  -lm -o awk
  
! y.tab.h:	awk.g.o
  
  awk.h:	y.tab.h
--- 1,18 ----
  #	Makefile	4.2	83/07/08
  #
! DESTDIR=
! CFLAGS=	-O
! YFLAGS=	-d
! OBJ=	awk.lx.o b.o main.o token.o tran.o lib.o run.o parse.o \
! 	proctab.o freeze.o
! SRC=	awk.def awk.g.y awk.lx.l b.c lib.c main.c parse.c \
! 	proc.c freeze.c run.c token.c tran.c
! DEPSRC=	awk.lx.c awk.g.c b.c main.c token.c tran.c lib.c run.c parse.c \
! 	proc.c proctab.c freeze.c
  
! awk:	${OBJ} awk.g.o
! 	${CC} ${CFLAGS} awk.g.o ${OBJ} -lm -o awk
  
! y.tab.h:	awk.g.c
  
  awk.h:	y.tab.h
***************
*** 16,21 ****
  	-cmp -s y.tab.h awk.h || cp y.tab.h awk.h
  
- $(FILES):	awk.h awk.def
- 
  token.c:	awk.h
  	e - <tokenscript
--- 19,22 ----
***************
*** 22,26 ****
  
  get:
! 	for i in $(SOURCE) Makefile tokenscript README; do \
  		cp /usr/src/bin/awk/$$i .;
  	done
--- 23,27 ----
  
  get:
! 	for i in ${SRC} Makefile tokenscript README; do \
  		cp /usr/src/bin/awk/$$i .;
  	done
***************
*** 27,40 ****
  
  install:
! 	install -s awk ${DESTDIR}/bin
  
! profile:	awk.g.o $(FILES) mon.o
! 	cc -p -i awk.g.o $(FILES) mon.o -lm
  
  find:
! 	egrep -n "$(PAT)" *.[ylhc] awk.def
  
  list:
! 	-pr $(SOURCE) Makefile tokenscript README EXPLAIN
  
  lint:
--- 28,41 ----
  
  install:
! 	install -s awk ${DESTDIR}/bin/awk
  
! profile:	awk.g.o ${OBJ} mon.o
! 	${CC} -p -i awk.g.o ${OBJ} mon.o -lm
  
  find:
! 	egrep -n "${PAT}" *.[ylhc] awk.def
  
  list:
! 	-pr ${SRC} Makefile tokenscript README EXPLAIN
  
  lint:
***************
*** 45,54 ****
  	proc >proctab.c
  
! proc:	awk.h proc.o token.o
! 	cc -o proc proc.o token.o
  
  clean:
! 	-rm -f *.o t.* *temp* *.out *junk* y.tab.* awk.h proc proctab.c awk yacc*
  
  diffs:
! 	-for i in $(SOURCE); do echo $$i:; diff $$i /usr/src/cmd/awk | ind; done
--- 46,91 ----
  	proc >proctab.c
  
! proc:	proc.o token.o
! 	${CC} -o proc proc.o token.o
  
  clean:
! 	rm -f *.o t.* *temp* *.out *junk* y.tab.*
! 	rm -f awk.g.c awk.h proc proctab.c awk yacc*
  
  diffs:
! 	-for i in ${SRC}; do echo $$i:; diff $$i /usr/src/cmd/awk | ind; done
! 
! depend: ${DEPSRC}
! 	${CC} -M ${DEPSRC} | sed -e 's, \./, ,' | \
! 	    /bin/awk '{ if ($$1 != prev) { \
! 		if (rec != "") print rec; rec = $$0; prev = $$1; } \
! 		else { if (length(rec $$2) > 78) { print rec; rec = $$0; } \
! 		else rec = rec " " $$2 } } \
! 		END { print rec }' >makedep
! 	echo '/^# DO NOT DELETE THIS LINE/+2,$$d' >eddep
! 	echo '$$r makedep' >>eddep
! 	echo 'w' >>eddep
! 	cp Makefile Makefile.bak
! 	ed - Makefile < eddep
! 	rm eddep makedep
! 	echo '# DEPENDENCIES MUST END AT END OF FILE' >>Makefile
! 	echo '# IF YOU PUT STUFF HERE IT WILL GO AWAY' >>Makefile
! 	echo '# see make depend above' >>Makefile
! 
! # DO NOT DELETE THIS LINE -- make depend uses it
! 
! awk.lx.o: awk.lx.c /usr/include/stdio.h awk.h awk.def
! awk.g.o: awk.g.c awk.def
! b.o: b.c awk.def /usr/include/stdio.h awk.h
! main.o: main.c /usr/include/stdio.h /usr/include/ctype.h awk.def awk.h
! token.o: token.c awk.h
! tran.o: tran.c /usr/include/stdio.h awk.def awk.h
! lib.o: lib.c /usr/include/stdio.h awk.def awk.h /usr/include/ctype.h
! run.o: run.c awk.def /usr/include/math.h awk.h /usr/include/stdio.h
! parse.o: parse.c awk.def awk.h /usr/include/stdio.h
! proc.o: proc.c awk.h
! proctab.o: proctab.c awk.def
! freeze.o: freeze.c /usr/include/stdio.h
! # DEPENDENCIES MUST END AT END OF FILE
! # IF YOU PUT STUFF HERE IT WILL GO AWAY
! # see make depend above

From chris@mimsy.umd.edu  Sat Aug  9 00:22:08 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA10722; Sat, 9 Aug 86 00:22:08 PDT
Received: by mimsy.umd.edu (5.9/4.7) id AA16655; Sat, 9 Aug 86 03:21:44 EDT
Date: Sat, 9 Aug 86 03:21:44 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8608090721.AA16655@mimsy.umd.edu>
To: beta43_bugs@monet.Berkeley.EDU
Subject: sh, csh umask bugs
Cc: don@mimsy.umd.edu, fred@mimsy.umd.edu, steve@mimsy.umd.edu

Index: /bin/{,c}sh 4.3beta

Description:
	Although the kernel lets you set your umask to clear setuid,
	setgid, and sticky bits at creation, the C shell will not
	allow this.  The Bourne shell will, but incorrectly reports
	the umask as not having those bits set.

Repeat-by:
	% umask 07022
	umask: Improper mask.
	% sh
	$ umask 07022
	$ umask
	0022
	$ cat t.c
	main(){_exit(creat("junk", 06666)<0);}
	$ ls -l junk
	junk not found
	$ cc -o t t.c
	$ ./t
	$ ls -l junk
	-rw-r--r--  1 chris           0 Aug  9 03:19 junk
	$ rm junk
	$ umask 022
	$ ./t
	$ ls -l junk
	-rwsr-sr--  1 chris           0 Aug  9 03:20 junk
	$

Chris

From chris@mimsy.umd.edu  Wed Aug 20 22:56:37 1986
Received: by monet (5.54/1.14)
	id AA02771; Wed, 20 Aug 86 22:56:37 PDT
Received: by mimsy.umd.edu (5.9/4.7) id AA13601; Thu, 21 Aug 86 01:47:30 EDT
Date: Thu, 21 Aug 86 01:47:30 EDT
From: Chris Torek <chris@mimsy.umd.edu>
Message-Id: <8608210547.AA13601@mimsy.umd.edu>
To: beta43_bugs@monet
Subject: `ls' manual lies

Index: /usr/man/man1/ls.1 4.3Beta

Description:
	The ls manual claims to be able to divine file creation
	dates.

Repeat-By:
	% man ls
	[read section under `-c' option]

Chris

From mcvax!piet@seismo.CSS.GOV  Thu Sep  4 03:37:49 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA05971; Thu, 4 Sep 86 03:37:49 PDT
Return-Path: <mcvax!piet>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Thu, 4 Sep 86 06:27:46 EDT
Received: by mcvax.uucp; Thu, 4 Sep 86 12:01:51 +0200 (MET)
Message-Id: <8609041001.AA28411@mcvax.uucp>
To: Bug-MH@UCI.EDU
Subject: MH 6.4 bug and fix
Cc: beta43_bugs@monet.Berkeley.EDU
Date: Thu, 04 Sep 86 12:01:48 +0100
From: Piet Beertema <mcvax!piet@seismo.CSS.GOV>

I ran into a problem when installing MH 6.4 under our 4.3 beta system:
apparently everything went OK, but any call of "whom", "send" etc.
would result in a "Segmentation fault -- core dumped"...

When tracing the problem it became clear that it was due to the setup
I used, which may be rather unusual:
- sendmail (*without* /smtp) is specified as mts;
- option BERK is not set; I'll come back to this later.

This combination led to "post" being used as postprocessor instead of
"spost". And it was "post" that failed to compile, thus producing an
incomplete object file, which "make install" happily installed...
That failure went unnoticed initially in all the noise of the make output;
besides, make didn't stop on it.

Then when trying "make post" (in the uip directory), it turned out that
the loader complained about an undefined "_discard". But discard was
there, in the ../sbr/libmh.a library!
Well, the reason for the failure turned out to be that almost all uip
sources include ../h/mh.h, where there's a "void discard()" definition,
whereas in mts/sendmail/smail.c discard() is also used - in sm_end() -
but it is *not* specified as "void discard()" in the header of that
routine. That led to a type clash and hence to the loader problem.
Adding that one line solved the problem.


Why didn't I use option BERK? Well, that gives problems with "scan",
which I haven't traced yet. The result of setting BERK is that -  no
matter what you specify as format - you always get the "proper" address
format. Not setting BERK made it possible to use at least both "proper"
and "friendly"; that latter case gave the personal name, if present.



	Piet

From mrose@nrtc-gremlin  Thu Sep  4 09:15:43 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA06663; Thu, 4 Sep 86 09:15:43 PDT
Received: from killer-rat by NRTC-GREMLIN.NORTHROP.COM id a005950;
          4 Sep 86 9:14 PDT
To: Piet Beertema <mcvax!piet@seismo.css.GOV>
Cc: Bug-MH@ics.uci.EDU, beta43_bugs@monet.Berkeley.EDU
Reply-To: Bug-MH@ics.uci.EDU
Subject: Re: MH 6.4 bug and fix 
In-Reply-To: Your message of Thu, 04 Sep 86 12:01:48 +0100.
             <8609041001.AA28411@mcvax.uucp> 
Date: Thu, 04 Sep 86 09:14:07 -0700
Message-Id: <1567.526234447@nrtc-gremlin.northrop.com>
From: Marshall Rose <mrose@nrtc-gremlin>

I think the problem is the way libraries get loaded.  With the loader on
my development system, it seems to be three-pass and so the discard() reference
gets resolved.  On the standard Berkeley loader, discard may not get
resolved correctly.  On the last version I gave to Van, who was putting
MH in 4.3BSD, I just had a dummy reference to discard in post.c, which
made the loader happy.  

The uip/ Makefile should have reported the error on building xpost, but
I imagine so much trash gets generated that you missed the report of
"Error code xxx".

Oh well,

/mtr

From mcvax!piet@seismo.CSS.GOV  Fri Sep  5 02:07:07 1986
Received: by monet.Berkeley.EDU (5.54/1.14)
	id AA03309; Fri, 5 Sep 86 02:07:07 PDT
Return-Path: <mcvax!piet>
Received: from mcvax.UUCP by seismo.CSS.GOV with UUCP; Fri, 5 Sep 86 04:29:06 EDT
Received: by mcvax.uucp; Fri, 5 Sep 86 10:24:25 +0200 (MET)
Message-Id: <8609050824.AA12122@mcvax.uucp>
To: Bug-MH@ics.uci.EDU
In-Reply-To: Your message of Thu, 04 Sep 86 09:14:07 -0700 .
	<1567.526234447@nrtc-gremlin.northrop.com> 
Subject: Re: MH 6.4 bug and fix 
Cc: beta43_bugs@monet.Berkeley.EDU
Date: Fri, 05 Sep 86 10:24:21 +0100
From: Piet Beertema <mcvax!piet@seismo.CSS.GOV>

	On the standard Berkeley loader, discard may not get resolved correctly.
	On the last version I gave to Van, who was putting MH in 4.3BSD, I just
	had a dummy reference to discard in post.c, which made the loader happy.  
That's exactly the way I initially solved the problem. But it's because
I don't like that kind of "fix" that I went deeper into the source to
find the real cause. Now since discard() is explicitly defined as type
void in sbr/discard.c, defining it as such in mts/sendmail/smail.c for
me is the correct fix.

	The uip/ Makefile should have reported the error on building xpost, but
	I imagine so much trash gets generated that you missed the report of
	"Error code xxx".
Indeed.


	Piet

