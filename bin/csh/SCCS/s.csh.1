h23308
s 00012/00001/02147
d D 8.4 94/06/01 21:13:12 ah 31 30
c page breaks for 4.4BSD manuals
e
s 00001/00002/02147
d D 8.3 94/05/04 14:13:25 mckusick 30 29
c avoid macro that makes ditroff die
e
s 00001/00001/02148
d D 8.2 94/01/21 13:26:22 mckusick 29 28
c copy edit nits
e
s 00002/00002/02147
d D 8.1 93/05/31 16:43:11 bostic 28 27
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00208/00198/01941
d D 6.25 93/05/31 16:38:43 mckusick 27 26
c format and editing nits
e
s 00001/00001/02138
d D 6.24 93/05/23 12:10:27 christos 26 25
c Added missing \ in \*(ua in the operator section
e
s 00006/00000/02133
d D 6.23 92/03/02 00:13:17 christos 25 24
c Fixed and documented $histfile
e
s 00007/00007/02126
d D 6.22 92/02/18 09:34:47 bostic 24 23
c one more time, with feeling
e
s 00007/00002/02122
d D 6.21 92/02/12 18:20:07 bostic 23 22
c fix -l documentation
e
s 00007/00002/02122
d D 6.20 92/02/12 20:22:54 christos 22 21
c documented -l
e
s 00014/00002/02110
d D 6.19 91/11/04 18:50:05 christos 21 20
c Some modifier, which, and $! documentation
e
s 00004/00005/02108
d D 6.18 91/07/30 17:20:49 cael 20 19
c make groff, escape ?' with \&?'
e
s 00004/00003/02109
d D 6.17 91/06/07 11:13:10 bostic 19 18
c rename all the files (they weren't going to diff anyway)
c add function prototypes for extern functions, decls.h -> extern.h
c delete btell function, VFORK #define, lots of other minor cleanups
e
s 00316/00605/01796
d D 6.16 91/03/14 01:41:30 cael 18 17
c updated to -mdoc version 3
e
s 00001/00001/02400
d D 6.15 90/11/06 09:26:40 karels 17 16
c csh has no -^ option (that was a half-narrow space)
e
s 00141/00058/02260
d D 6.14 90/07/24 22:43:06 cael 16 15
c .Xr botch fix
e
s 01293/01279/01025
d D 6.13 90/06/11 05:55:11 cael 15 14
c converted man page
e
s 00009/00006/02295
d D 6.12 89/02/15 11:06:20 bostic 14 13
c use pathname include files; remove IIASA commands; remove newgrp
c command; add globall .cshrc, .login, and .logout files; minor cleanups
e
s 00001/00001/02300
d D 6.11 88/04/24 00:17:29 edward 13 12
c fixed mistake in filename completion (control-D to escape)
e
s 00001/00001/02300
d D 6.10 87/09/30 09:17:31 bostic 12 11
c :e works on variables; bug report 4.3BSD/man/11
e
s 00001/00001/02300
d D 6.9 87/04/25 14:21:20 bostic 11 10
c bug report 4.2BSD/man/36
e
s 00002/00002/02299
d D 6.8 86/06/05 18:29:25 bloom 10 9
c fix plus because cfo decided to change things
e
s 00012/00012/02289
d D 6.7 86/05/12 14:46:31 anne 9 8
c grammar, spelling
e
s 00014/00009/02287
d D 6.6 86/05/11 16:19:14 lepreau 8 7
c bring doc of "alloc" up to date; clarify nice doc; filec caveat.
e
s 00010/00001/02286
d D 6.5 86/05/08 15:10:54 karels 7 6
c add -b
e
s 00030/00007/02257
d D 6.4 86/02/10 18:52:18 edward 6 5
c Changes from John Coker
e
s 00069/00011/02195
d D 6.3 85/10/07 16:02:21 edward 5 4
c File name completion added
e
s 00013/00002/02193
d D 6.2 85/06/01 18:02:38 edward 4 3
c update setenv (see /usr/src/bin/csh/sh.func.c)
e
s 00030/00004/02165
d D 6.1 85/04/29 18:21:19 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00056/00046/02113
d D 5.1 85/04/29 18:19:49 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 02159/00000/00000
d D 4.1 85/04/29 18:18:58 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 15
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 15
I 15
D 28
.\" Copyright (c) 1980, 1990 The Regents of the University of California.
.\" All rights reserved.
E 28
I 28
.\" Copyright (c) 1980, 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 28
E 15
.\"
D 15
.\"	%W% (Berkeley) %G%
E 15
I 15
.\" %sccs.include.redist.man%
E 15
.\"
D 2
.TH CSH 1 9/1/81
E 2
I 2
D 3
.TH CSH 1 "18 July 1983"
E 3
I 3
D 15
.TH CSH 1 "%Q%"
E 3
E 2
.UC 4
.de sh
.br
.ne 5
.PP
\fB\\$1\fR
.PP
..
D 5
.if n .ds ua \o'^|'
E 5
I 5
.if n .ds ua ^
E 5
.if t .ds ua \(ua
.if n .ds aa '
.if t .ds aa \(aa
.if n .ds ga `
.if t .ds ga \(ga
.if t .tr *\(**
.SH NAME
csh \- a shell (command interpreter) with C-like syntax
.SH SYNOPSIS
.B csh
[
.B \-cef\^instvVxX
] [
arg ...
]
.SH DESCRIPTION
.I Csh
is a first implementation of a command language interpreter
D 5
incorporating a history mechanism (see
.B "History Substitutions)"
D 2
job control facilities
(see
E 2
I 2
job control facilities (see
E 2
.B Jobs)
E 5
I 5
incorporating a history mechanism (see \fBHistory Substitutions\fP),
job control facilities (see \fBJobs\fP), interactive file name
and user name completion (see \fBFile Name Completion\fP),
E 5
and a C-like syntax.
So as to be able to use its job control facilities, users of
.I csh
D 2
must (and automatically) use the new tty driver summarized in
.IR newtty (4)
and fully described in
E 2
I 2
must (and automatically) use the new tty driver fully described in
E 2
.IR tty (4).
This new tty driver allows generation of interrupt characters
D 2
from the keyboard to tell jobs to stop.
See
E 2
I 2
from the keyboard to tell jobs to stop.  See
E 2
.IR stty (1)
for details on setting options in the new tty driver.
.PP
An instance of
.I csh
D 2
begins by executing commands from the file `.cshrc'
in the
E 2
I 2
D 14
begins by executing commands from the file `.cshrc' in the
E 14
I 14
begins by executing commands from the file ``/etc/csh.cshrc'' and,
if this is a login shell, ``/etc/csh.login''.  It then executes
commands from ``.cshrc''' in the
E 14
E 2
.I home
E 15
I 15
.\"     %W% (Berkeley) %G%
.\"
.Dd %Q%
.Dt CSH 1
.Os BSD 4
.Sh NAME
.Nm csh
.Nd a shell (command interpreter) with C-like syntax
.Sh SYNOPSIS
.Nm csh
D 17
.Op Fl cef\*(uainstvVxX
E 17
I 17
D 18
.Op Fl cef\^instvVxX
E 18
I 18
.Op Fl bcefinstvVxX
E 18
E 17
.Op arg ...
I 23
.Nm csh
.Op Fl l
E 23
D 23
I 22
.Nm csh
.It Fl l
E 23
E 22
.Sh DESCRIPTION
The
D 23
.Nm Csh
E 23
I 23
.Nm csh
E 23
is a command language interpreter
incorporating a history mechanism (see
.Nm History Substitutions ) ,
job control facilities (see
.Nm Jobs ) ,
interactive file name
and user name completion (see
.Nm File Name Completion ) ,
and a C-like syntax. It is used both as an interactive
login shell and a shell script command processor.
.Ss Argument list processing
D 30
If the first argument (argument 0) to the shell is
D 16
.Fl
E 16
I 16
D 18
.Sq Fl
E 18
I 18
D 27
.Ql Fl
E 27
I 27
.Ql Fl \& ,
E 30
I 30
D 31
If the first argument (argument 0) to the shell is `-',
E 31
I 31
If the first argument (argument 0) to the shell is
.Ql Fl \& ,
E 31
E 30
E 27
E 18
E 16
D 24
then this
D 22
is a login shell.
D 23
The flag arguments are interpreted as follows:
E 23
I 23
A login shell can be also simulated by invoking the shell with the 
E 24
I 24
then this is a login shell.
D 27
A login shell can be also specified by invoking the shell with the 
E 27
I 27
A login shell also can be specified by invoking the shell with the 
E 27
E 24
.Ql Fl l
flag as the only argument.
I 24
.Pp
E 24
The rest of the flag arguments are interpreted as follows:
E 23
E 22
I 22
D 24
is a login shell. A login shell can be also simulated by invoking the
shell with the 
.Ql Fl l
flag as the only argument.
The rest of the flag arguments are interpreted as follows:
E 24
E 22
D 18
.Tw 5n
.Tp Fl b
E 18
I 18
.Bl -tag -width 5n
.It Fl b
E 18
This flag forces a ``break'' from option processing, causing any further
shell arguments to be treated as non-option arguments.
The remaining arguments will not be interpreted as shell options.
This may be used to pass options to a shell script without confusion
or possible subterfuge.
The shell will not run a set-user ID script without this option.
D 18
.Tp Fl c
E 18
I 18
.It Fl c
E 18
Commands are read from the (single) following argument which must
be present.
Any remaining arguments are placed in
.Ar argv .
D 18
.Tp Fl e
E 18
I 18
.It Fl e
E 18
The shell exits if any invoked command terminates abnormally
or yields a non-zero exit status.
D 18
.Tp Fl f
E 18
I 18
.It Fl f
E 18
The shell will start faster, because it will neither search for nor
execute commands from the file
.Pa \&.cshrc
in the invoker's home directory.
D 18
.Tp Fl i
E 18
I 18
.It Fl i
E 18
The shell is interactive and prompts for its top-level input,
D 27
even if it appears to not be a terminal.
E 27
I 27
even if it appears not to be a terminal.
E 27
Shells are interactive without this option if their inputs
and outputs are terminals.
I 24
.It Fl l
The shell is a login shell (only applicable if
.Fl l
is the only flag specified).
E 24
D 18
.Tp Fl n
E 18
I 18
.It Fl n
E 18
Commands are parsed, but not executed.
This aids in syntactic checking of shell scripts.
D 18
.Tp Fl s
E 18
I 18
.It Fl s
E 18
Command input is taken from the standard input.
D 18
.Tp Fl t
E 18
I 18
.It Fl t
E 18
A single line of input is read and executed.
D 18
A `\e' may be used to escape the newline at the end of this
E 18
I 18
A
.Ql \e
may be used to escape the newline at the end of this
E 18
line and continue onto another line.
D 18
.Tp Fl v
E 18
I 18
.It Fl v
E 18
Causes the
.Ar verbose
variable to be set, with the effect
that command input is echoed after history substitution.
D 18
.Tp Fl x
E 18
I 18
.It Fl x
E 18
Causes the
.Ar echo
variable to be set, so that commands are echoed immediately before execution.
D 18
.Tp Fl V
E 18
I 18
.It Fl V
E 18
Causes the
.Ar verbose
D 16
variable to be set even before `\&.cshrc' is executed.
E 16
I 16
variable to be set even before
D 18
.Pa \&.cshrc is executed.
E 16
.Tp Fl X
E 18
I 18
.Pa .cshrc
is executed.
.It Fl X
E 18
Is to
.Fl x
as
.Fl V
is to
.Fl v .
D 18
.Tp
E 18
I 18
.El
E 18
.Pp
After processing of flag arguments, if arguments remain but none of the
.Fl c ,
.Fl i ,
.Fl s ,
or
.Fl t
D 16
options was given, the first argument is taken as the name of a file of
E 16
I 16
options were given, the first argument is taken as the name of a file of
E 16
commands to be executed.
The shell opens this file, and saves its name for possible resubstitution
by `$0'.
Since many systems use either the standard version 6 or version 7 shells
whose shell scripts are not compatible with this shell, the shell will
execute such a `standard' shell if the first character of a script
D 27
is not a `#', i.e. if the script does not start with a comment.
E 27
I 27
is not a `#', i.e., if the script does not start with a comment.
E 27
Remaining arguments initialize the variable
.Ar argv .
.Pp
D 16
.\" An instance of
E 16
I 16
An instance of
E 16
.Nm csh
begins by executing commands from the file
.Pa /etc/csh.cshrc
and,
if this is a login shell,
.Pa \&/etc/csh.login .
It then executes
commands from
.Pa \&.cshrc
in the
.Ar home
E 15
D 14
directory of the invoker.
If this is a login shell then it also executes commands from the file
`.login' there.
E 14
I 14
directory of the invoker, and, if this is a login shell, the file
D 15
``.login'' in the same location.
E 14
It is typical for users on crt's to put the command ``stty crt'' in their
.I \&.login
E 15
I 15
.Pa \&.login
in the same location.
It is typical for users on crt's to put the command ``stty crt''
in their
.Pa \&.login
E 15
file, and to also invoke
D 15
.IR tset (1)
E 15
I 15
.Xr tset  1
E 15
there.
D 15
.PP
E 15
I 15
.Pp
E 15
D 18
In the normal case, the shell will then begin reading commands from the
E 18
I 18
In the normal case, the shell will begin reading commands from the
E 18
terminal, prompting with `% '.
Processing of arguments and the use of the shell to process files
containing command scripts will be described later.
D 15
.PP
E 15
I 15
.Pp
E 15
D 18
The shell then repeatedly performs the following actions:
E 18
I 18
The shell repeatedly performs the following actions:
E 18
a line of command input is read and broken into
D 2
.I words.
E 2
I 2
D 15
.IR words .
E 15
I 15
.Ar words  .
E 15
E 2
D 18
This sequence of words is placed on the command history list and then parsed.
E 18
I 18
This sequence of words is placed on the command history list and parsed.
E 18
Finally each command in the current line is executed.
D 15
.PP
E 15
I 15
.Pp
E 15
D 14
When a login shell terminates it executes commands from the file `.logout'
in the users home directory.
E 14
I 14
When a login shell terminates it executes commands from the files
D 15
``.logout'' in the user's
.I home
directory and ``/etc/csh.logout''.
E 14
.sh "Lexical structure"
E 15
I 15
.Pa .logout
in the user's
.Ar home
directory and
.Pa /etc/csh.logout .
.Ss Lexical structure
E 15
The shell splits input lines into words at blanks and tabs with the
following exceptions.
The characters
D 15
`&' `|' `;' `<' `>' `(' `)'
E 15
I 15
D 16
`&' `' `;' `<' `>' `(' `)'
E 16
I 16
`&' `\&|' `;' `<' `>' `(' `)'
E 16
E 15
form separate words.
D 15
If doubled in `&&', `|\|\||', `<<' or `>>' these pairs form single words.
E 15
I 15
D 16
If doubled in `&&', `\\', `<<' or `>>' these pairs form single words.
E 16
I 16
If doubled in `&&', `\&|\&|', `<<' or `>>' these pairs form single words.
E 16
E 15
These parser metacharacters may be made part of other words, or prevented their
special meaning, by preceding them with `\e'.
A newline preceded by a `\e' is equivalent to a blank.
D 15
.PP
E 15
I 15
.Pp
E 15
D 18
In addition strings enclosed in matched pairs of quotations,
E 18
I 18
Strings enclosed in matched pairs of quotations,
E 18
D 27
`\*(aa', `\*(ga' or `"',
E 27
I 27
`'\|', `\*(ga' or `"',
E 27
form parts of a word; metacharacters in these strings, including blanks
and tabs, do not form separate words.
D 27
These quotations have semantics to be described subsequently.
Within pairs of `\'' or `"' characters a newline preceded by a `\e' gives
E 27
I 27
These quotations have semantics to be described later.
Within pairs of `\'' or `"' characters, a newline preceded by a `\e' gives
E 27
a true newline character.
D 15
.PP
E 15
I 15
.Pp
E 15
When the shell's input is not a terminal,
D 27
the character `#' introduces a comment which continues to the end of the
E 27
I 27
the character `#' introduces a comment that continues to the end of the
E 27
input line.
It is prevented this special meaning when preceded by `\e'
and in quotations using `\`', `\'', and `"'.
D 15
.sh "Commands"
E 15
I 15
.Ss Commands
E 15
A simple command is a sequence of words, the first of which
specifies the command to be executed.
A simple command or
D 15
a sequence of simple commands separated by `|' characters
E 15
I 15
D 16
a sequence of simple commands separated by `' characters
E 16
I 16
a sequence of simple commands separated by `\&|' characters
E 16
E 15
forms a pipeline.
The output of each command in a pipeline is connected to the input of the next.
Sequences of pipelines may be separated by `;', and are then executed
sequentially.
D 15
A sequence of pipelines may be executed without immediately 
E 15
I 15
A sequence of pipelines may be executed without immediately
E 15
waiting for it to terminate by following it with an `&'.
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
Any of the above may be placed in `(' `)' to form a simple command (which
may be a component of a pipeline, etc.)
D 15
It is also possible to separate pipelines with `|\|\||' or `&&' indicating,
E 15
I 15
D 16
It is also possible to separate pipelines with `\\' or `&&' indicating,
E 16
I 16
It is also possible to separate pipelines with `\&|\&|' or `&&' indicating,
E 27
I 27
Any of the above may be placed in `(' `)' to form a simple command (that
may be a component of a pipeline, etc.).
It is also possible to separate pipelines with `\&|\&|' or `&&' showing,
E 27
E 16
E 15
as in the C language,
that the second is to be executed only if the first fails or succeeds
respectively. (See
D 15
.I Expressions.)
.sh "Jobs"
The shell associates a \fIjob\fR with each pipeline.  It keeps
E 15
I 15
D 16
.Ar Expressions . )
E 16
I 16
.Em Expressions . )
E 16
.Ss Jobs
The shell associates a
.Ar job
with each pipeline.  It keeps
E 15
a table of current jobs, printed by the
D 15
\fIjobs\fR command, and assigns them small integer numbers.  When
E 15
I 15
.Ar jobs
command, and assigns them small integer numbers.  When
E 15
D 27
a job is started asynchronously with `&', the shell prints a line which looks
E 27
I 27
a job is started asynchronously with `&', the shell prints a line that looks
E 27
like:
D 15
.PP
.DT
	[1] 1234
.PP
E 15
I 15
D 18
.Pp
.Df I
E 18
I 18
.Bd -filled -offset indent
E 18
.Op 1
1234
D 18
.De
E 18
I 18
.Ed
E 18
.Pp
E 15
D 9
indicating that the jobs which was started asynchronously was job number
E 9
I 9
D 27
indicating that the job which was started asynchronously was job number
E 27
I 27
showing that the job which was started asynchronously was job number
E 27
E 9
1 and had one (top-level) process, whose process id was 1234.
D 15
.PP
E 15
I 15
.Pp
E 15
If you are running a job and wish to do something else you may hit the key
D 15
\fB^Z\fR (control-Z) which sends a STOP signal to the current job.
E 15
I 15
.Nm ^Z
(control-Z) which sends a STOP signal to the current job.
E 15
D 27
The shell will then normally indicate that the job has been `Stopped',
E 27
I 27
The shell will then normally show that the job has been `Stopped',
E 27
and print another prompt.  You can then manipulate the state of this job,
D 15
putting it in the background with the \fIbg\fR command, or run some other
E 15
I 15
D 18
putting it in the background with the
E 18
I 18
putting it in the
.Em background
with the
E 18
.Ar bg
command, or run some other
E 15
D 27
commands and then eventually bring the job back into the foreground with
E 27
I 27
commands and eventually bring the job back into the foreground with
E 27
D 15
the foreground command \fIfg\fR.  A \fB^Z\fR takes effect immediately and
E 15
I 15
D 18
the foreground command
E 18
I 18
the
.Em foreground
command
E 18
.Ar fg  .
A
.Nm ^Z
takes effect immediately and
E 15
is like an interrupt in that pending output and unread input are discarded
D 15
when it is typed.  There is another special key \fB^Y\fR which does 
E 15
I 15
when it is typed.  There is another special key
.Nm ^Y
D 27
which does
E 15
not generate a STOP signal until a program attempts to
E 27
I 27
that does not generate a STOP signal until a program attempts to
E 27
D 15
.IR read (2)
E 15
I 15
.Xr read  2
E 15
it.
D 27
This can usefully be typed ahead when you have prepared some commands
for a job which you wish to stop after it has read them.
E 27
I 27
This request can usefully be typed ahead when you have prepared some commands
for a job that you wish to stop after it has read them.
E 27
D 15
.PP
E 15
I 15
.Pp
E 15
A job being run in the background will stop if it tries to read
from the terminal.  Background jobs are normally allowed to produce output,
but this can be disabled by giving the command ``stty tostop''.
If you set this
tty option, then background jobs will stop when they try to produce
output like they do when they try to read input.
D 15
.PP
E 15
I 15
.Pp
E 15
There are several ways to refer to jobs in the shell.  The character
`%' introduces a job name.  If you wish to refer to job number 1, you can
name it as `%1'.  Just naming a job brings it to the foreground; thus
D 27
`%1' is a synonym for `fg %1', bringing job 1 back into the foreground.
Similarly saying `%1 &' resumes job 1 in the background.
E 27
I 27
`%1' is a synonym for `fg %1', bringing job number 1 back into the foreground.
Similarly saying `%1 &' resumes job number 1 in the background.
E 27
Jobs can also be named by prefixes of the string typed in to start them,
if these prefixes are unambiguous, thus `%ex' would normally restart
a suspended
D 15
.IR ex (1)
E 15
I 15
.Xr ex  1
E 15
job, if there were only one suspended job whose name began with
the string `ex'.  It is also possible to say `%?string'
which specifies a job whose text contains
D 15
.I string,
E 15
I 15
.Ar string ,
E 15
if there is only one such job.
D 15
.PP
E 15
I 15
.Pp
E 15
The shell maintains a notion of the current and previous jobs.
D 27
In output pertaining to jobs, the current job is marked with a `+'
E 27
I 27
In output about jobs, the current job is marked with a `+'
E 27
and the previous job with a `\-'.  The abbreviation `%+' refers
to the current job and `%\-' refers to the previous job.  For close
analogy with the syntax of the
D 15
.I history
E 15
I 15
.Ar history
E 15
mechanism (described below),
`%%' is also a synonym for the current job.
D 15
.sh "Status reporting"
E 15
I 15
.Pp
The job control mechanism requires that the
.Xr stty 1
option
.Ic new
be set. It is an artifact from a
.Em new
implementation
of the
D 27
tty driver which allows generation of interrupt characters from
E 27
I 27
tty driver that allows generation of interrupt characters from
E 27
the keyboard to tell jobs to stop.  See stty(1) for details
on setting options in the new tty driver.
.Ss Status reporting
E 15
This shell learns immediately whenever a process changes state.
It normally informs you whenever a job becomes blocked so that
no further progress is possible, but only just before it prints
a prompt.  This is done so that it does not otherwise disturb your work.
If, however, you set the shell variable
D 15
.I notify,
E 15
I 15
.Ar notify ,
E 15
the shell will notify you immediately of changes of status in background
jobs.
There is also a shell command
D 15
.I notify
E 15
I 15
.Ar notify
E 15
D 27
which marks a single process so that its status changes will be immediately
E 27
I 27
that marks a single process so that its status changes will be immediately
E 27
D 15
reported.  By default 
.I notify
E 15
I 15
reported.  By default
.Ar notify
E 15
marks the current process;
simply say `notify' after starting a background job to mark it.
D 15
.PP
E 15
I 15
.Pp
E 15
When you try to leave the shell while jobs are stopped, you will
D 15
be warned that `You have stopped jobs.'  You may use the \fIjobs\fR
E 15
I 15
be warned that `You have stopped jobs.'  You may use the
.Ar jobs
E 15
command to see what they are.  If you do this or immediately try to
exit again, the shell will not warn you a second time, and the suspended
jobs will be terminated.
I 5
D 15
.sh "File Name Completion"
E 15
I 15
.Ss File Name Completion
E 15
When the file name completion feature is enabled by setting
D 15
the shell variable \fIfilec\fP (see \fBset\fP), \fIcsh\fP will
E 15
I 15
the shell variable
.Ar filec
(see
.Ic set ) ,
.Nm csh
will
E 15
interactively complete file names and user names from unique
prefixes, when they are input from the terminal followed by
D 15
the escape character (the escape key, or control-[).  For example,
E 15
I 15
the escape character (the escape key, or control-[)
For example,
E 15
if the current directory looks like
D 15
.ta 1i 2i 3i 4i 5i 6i
D 6
.br
	DSC.OLD	bin	cmd	lib	memos
.br
	DSC.NEW	chaosnet	cmtest	mail	netnews
.br
	bench	class	dev	mbox	new
.br
E 6
I 6
.nf
	DSC.OLD	bin	cmd	lib	xmpl.c
	DSC.NEW	chaosnet	cmtest	mail	xmpl.o
	bench	class	dev	mbox	xmpl.out
.fi
E 15
I 15
D 18
.Ds I
.Cw DSC.NEW chaosnet cmtest mbox
.Cl DSC.OLD	bin	cmd	lib	xmpl.c
.Cl DSC.NEW	chaosnet	cmtest	mail	xmpl.o
.Cl bench	class	dev	mbox	xmpl.out
.Cw
.De
E 18
I 18
.Bd -literal -offset indent
DSC.OLD  bin      cmd      lib      xmpl.c
DSC.NEW  chaosnet cmtest   mail     xmpl.o
bench    class    dev      mbox     xmpl.out
.Ed
E 18
.Pp
E 15
E 6
and the input is
D 15
.br
	% vi ch<escape>
.br
\fIcsh\fP will complete the prefix ``ch''
E 15
I 15
.Pp
D 18
.Dl \&% vi ch<escape>
E 18
I 18
.Dl % vi ch<escape>
I 31
.ne 1i
E 31
E 18
.Pp
.Nm csh
will complete the prefix ``ch''
E 15
to the only matching file name ``chaosnet'', changing the input
line to
D 15
.br
	% vi chaosnet
.br
E 15
I 15
.Pp
D 18
.Dl \&% vi chaosnet
E 18
I 18
.Dl % vi chaosnet
E 18
.Pp
E 15
However, given
D 15
.br
	% vi D<escape>
.br
\fIcsh\fP will only expand the input to
.br
	% vi DSC.
.br
E 15
I 15
.Pp
.Dl % vi D<escape>
.Pp
.Nm csh
will only expand the input to
.Pp
D 18
.Dl \&% vi DSC.
E 18
I 18
.Dl % vi DSC.
E 18
.Pp
E 15
D 9
and will sound the terminal bell to indicate the expansion is
E 9
I 9
and will sound the terminal bell to indicate that the expansion is
E 9
incomplete, since there are two file names matching the prefix ``D''.
D 15
.PP
E 15
I 15
.Pp
E 15
If a partial file name is followed by the end-of-file character
D 15
(usually control-D), then, instead of completing the name, \fIcsh\fP
E 15
I 15
(usually control-D), then, instead of completing the name,
.Nm csh
E 15
will list all file names matching the prefix.  For example,
the input
D 15
.br
	% vi D<control-D>
.br
E 15
I 15
.Pp
D 18
.Dl \&% vi D<control-D>
E 18
I 18
.Dl % vi D<control-D>
E 18
.Pp
E 15
causes all files beginning with ``D'' to be listed:
D 15
.br
	DSC.NEW	DSC.OLD
.br
E 15
I 15
.Pp
D 18
.Dl \&DSC.NEW	DSC.OLD
E 18
I 18
.Dl DSC.NEW	DSC.OLD
E 18
.Pp
E 15
while the input line remains unchanged.
D 15
.PP
E 15
I 15
.Pp
E 15
The same system of escape and end-of-file can also be used to
expand partial user names, if the word to be completed
(or listed) begins with the character ``~''.  For example,
typing
D 15
.br
D 13
	cd ~ro<control-D>
E 13
I 13
	cd ~ro<escape>
E 13
.br
E 15
I 15
.Pp
D 18
.Dl \&cd ~ro<escape>
E 18
I 18
.Dl cd ~ro<escape>
E 18
.Pp
E 15
may produce the expansion
D 15
.br
	cd ~root
I 6
.PP
E 15
I 15
.Pp
D 18
.Dl \&cd ~root
E 18
I 18
.Dl cd ~root
E 18
.Pp
E 15
The use of the terminal bell to signal errors or multiple matches
D 15
can be inhibited by setting the variable \fInobeep\fP.
.PP
E 15
I 15
can be inhibited by setting the variable
.Ar nobeep  .
.Pp
E 15
Normally, all files in the particular directory are candidates
for name completion.  Files with certain suffixes can be excluded
D 15
from consideration by setting the variable \fIfignore\fP to the
list of suffixes to be ignored.  Thus, if \fIfignore\fP is set by
E 15
I 15
from consideration by setting the variable
.Ar fignore
to the
list of suffixes to be ignored.  Thus, if
.Ar fignore
is set by
E 15
the command
D 15
.br
	% set fignore = (.o .out)
.br
E 15
I 15
.Pp
D 18
.Dl \&% set fignore = (.o .out)
E 18
I 18
.Dl % set fignore = (.o .out)
E 18
.Pp
E 15
then typing
D 15
.br
	% vi x<escape>
.br
E 15
I 15
.Pp
D 18
.Dl \&% vi x<escape>
E 18
I 18
.Dl % vi x<escape>
E 18
.Pp
E 15
would result in the completion to
D 15
.br
	% vi xmpl.c
.br
E 15
I 15
.Pp
D 18
.Dl \&% vi xmpl.c
E 18
I 18
.Dl % vi xmpl.c
E 18
.Pp
E 15
ignoring the files "xmpl.o" and "xmpl.out".
However, if the only completion possible requires not ignoring these
D 15
suffixes, then they are not ignored.  In addition, \fIfignore\fP
E 15
I 15
suffixes, then they are not ignored.  In addition,
.Ar fignore
E 15
does not affect the listing of file names by control-D.  All files
are listed regardless of their suffixes.
E 6
E 5
D 15
.sh Substitutions
E 15
I 15
.Ss Substitutions
E 15
We now describe the various transformations the shell performs on the
input in the order in which they occur.
D 15
.sh "History substitutions"
E 15
I 15
.Ss History substitutions
E 15
History substitutions place words from previous command input as portions
of new commands, making it easy to repeat commands, repeat arguments
of a previous command in the current command, or fix spelling mistakes
in the previous command with little typing and a high degree of confidence.
History substitutions begin with the character `!' and may begin
D 15
.B anywhere
E 15
I 15
.Ar anywhere
E 15
in the input stream (with the proviso that they
D 15
.B "do not"
E 15
I 15
.Nm "do not"
E 15
nest.)
D 27
This `!' may be preceded by an `\e' to prevent its special meaning; for
convenience, a `!' is passed unchanged when it is followed by a blank,
E 27
I 27
This `!' may be preceded by a `\e' to prevent its special meaning; for
convenience, an `!' is passed unchanged when it is followed by a blank,
E 27
tab, newline, `=' or `('.
(History substitutions also occur when an input line begins with `\*(ua'.
This special abbreviation will be described later.)
D 27
Any input line which contains history substitution is echoed on the terminal
E 27
I 27
Any input line that contains history substitution is echoed on the terminal
E 27
before it is executed as it could have been typed without history substitution.
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
Commands input from the terminal which consist of one or more words
E 27
I 27
Commands input from the terminal that consist of one or more words
E 27
are saved on the history list.
The history substitutions reintroduce sequences of words from these
saved commands into the input stream.
D 27
The size of which is controlled by the
E 27
I 27
The size of the history list is controlled by the
E 27
D 15
.I history
E 15
I 15
.Ar history
E 15
D 27
variable; the previous command is always retained, regardless of its value.
E 27
I 27
variable; the previous command is always retained,
regardless of the value of the history variable.
E 27
Commands are numbered sequentially from 1.
D 15
.PP
E 15
I 15
.Pp
E 15
For definiteness, consider the following output from the
D 15
.I history
E 15
I 15
.Ar history
E 15
command:
I 18
.Bd -literal -offset indent
\09  write michael
10  ex write.c
11  cat oldwrite.c
12  diff *write.c
.Ed
E 18
D 15
.PP
E 15
I 15
.Pp
E 15
D 18
.DT
D 15
.br
	\09  write michael
.br
	10  ex write.c
.br
	11  cat oldwrite.c
.br
	12  diff *write.c
.PP
E 15
I 15
.Pp
.Dl \&\09  write michael
.Dl 10  ex write.c
.Dl 11  cat oldwrite.c
.Dl 12  diff *write.c
.Pp
E 18
E 15
The commands are shown with their event numbers.
It is not usually necessary to use event numbers, but the current event
number can be made part of the
D 15
.I prompt
E 15
I 15
.Ar prompt
E 15
by placing an `!' in the prompt string.
D 15
.PP
E 15
I 15
.Pp
E 15
With the current event 13 we can refer to previous events by event
number `!11', relatively as in `!\-2' (referring to the same event),
by a prefix of a command word
as in `!d' for event 12 or `!wri' for event 9, or by a string contained in
a word in the command as in `!?mic?' also referring to event 9.
D 27
These forms, without further modification, simply reintroduce the words
E 27
I 27
These forms, without further change, simply reintroduce the words
E 27
of the specified events, each separated by a single blank.
D 27
As a special case `!!' refers to the previous command; thus `!!'
alone is essentially a
E 27
I 27
As a special case, `!!' refers to the previous command; thus `!!'
alone is a
E 27
D 15
.I redo.
.PP
E 15
I 15
.Ar redo .
.Pp
E 15
To select words from an event we can follow the event specification by
a `:' and a designator for the desired words.
D 9
The words of a input line are numbered from 0,
E 9
I 9
The words of an input line are numbered from 0,
E 9
the first (usually command) word being 0, the second word (first argument)
being 1, etc.
The basic word designators are:
D 15
.PP
.DT
.nf
	0	first (command) word
	\fIn\fR	\fIn\fR\|'th argument
	\*(ua	first argument,  i.e. `1'
	$	last argument
	%	word matched by (immediately preceding) ?\fIs\fR\|? search
	\fIx\fR\|\-\fIy\fR	range of words
	\-\fIy\fR	abbreviates `0\-\fIy\fR\|'
	*	abbreviates `\*(ua\-$', or nothing if only 1 word in event
	\fIx\fR\|*	abbreviates `\fIx\fR\|\-$'
	\fIx\fR\|\-	like `\fIx\fR\|*' but omitting word `$'
.fi
.PP
E 15
I 15
.Pp
D 18
.Dw Ds
.Dp \&0
E 18
I 18
.Bl -tag -width Ds -compact -offset indent
.It \&0
E 18
first (command) word
D 18
.Dp Ar n
.Cx Ar n
.Cx \'th
.Cx
E 18
I 18
.It Ar n
D 20
.Ar n Ns \'th
E 20
I 20
.Ar n Ns 'th
E 20
E 18
argument
D 18
.Dp \*(ua
E 18
I 18
.It \*(ua
E 18
D 27
first argument,  i.e. `1'
E 27
I 27
first argument,  i.e., `1'
E 27
D 18
.Dp $
E 18
I 18
.It $
E 18
last argument
D 18
.Dp %
E 18
I 18
.It %
E 18
word matched by (immediately preceding)
D 18
.Cx \&?
.Ar s
.Cx \?
.Cx
E 18
I 18
D 20
.No \&? Ns Ar s Ns \?
E 20
I 20
.No \&? Ns Ar s Ns \&?
E 20
E 18
search
D 18
.Dp Ar \&x\-y
E 18
I 18
.It Ar \&x\-y
E 18
range of words
D 18
.Dp Ar \&\-y
E 18
I 18
.It Ar \&\-y
E 18
abbreviates
.Ar `\&0\-y\'
D 18
.Dp \&*
E 18
I 18
.It *
E 18
abbreviates `\*(ua\-$', or nothing if only 1 word in event
D 16
.Dp Ar x\*
E 16
I 16
D 18
.Dp Ar x\&*
E 18
I 18
.It Ar x*
E 18
E 16
abbreviates
.Ar `x\-$\'
D 18
.Dp Ar x\-
E 18
I 18
.It Ar x\-
E 18
like
D 16
.Ar `x\*\'
E 16
I 16
D 18
.Ar `x\&*\'
E 18
I 18
.Ar `x*\'
E 18
E 16
but omitting word `$'
D 18
.Dp
E 18
I 18
.El
E 18
.Pp
E 15
The `:' separating the event specification from the word designator
can be omitted if the argument selector begins with a `\*(ua', `$', `*'
`\-' or `%'.
After the optional word designator can be
placed a sequence of modifiers, each preceded by a `:'.
The following modifiers are defined:
D 15
.ta .5i 1.2i
.PP
.nf
	h	Remove a trailing pathname component, leaving the head.
	r	Remove a trailing `.xxx' component, leaving the root name.
	e	Remove all but the extension `.xxx' part.
	s/\fIl\fR\|/\fIr\fR\|/	Substitute \fIl\fR for \fIr\fR
	t	Remove all leading pathname components, leaving the tail.
	&	Repeat the previous substitution.
	g	Apply the change globally, prefixing the above, e.g. `g&'.
D 11
	p	Print the new command but do not execute it.
E 11
I 11
	p	Print the new command line but do not execute it.
E 11
	q	Quote the substituted words, preventing further substitutions.
	x	Like q, but break into words at blanks, tabs and newlines.
.fi
.PP
E 15
I 15
D 18
.Dw Ds
.Dp h
E 18
I 18
.Pp
.Bl -tag -width Ds -compact -offset indent
.It h
E 18
Remove a trailing pathname component, leaving the head.
D 18
.Dp r
E 18
I 18
.It r
E 18
Remove a trailing `.xxx' component, leaving the root name.
D 18
.Dp e
E 18
I 18
.It e
E 18
Remove all but the extension `.xxx' part.
D 16
.Cx s/
E 16
I 16
D 18
.Dp Cx s/
E 16
.Ar l
.Cx \/
.Ar r
.Cx \/
.Cx
E 18
I 18
.It s Ns Ar /l/r/
E 18
Substitute
.Ar l
for
.Ar r
D 18
.Dp t
E 18
I 18
.It t
E 18
Remove all leading pathname components, leaving the tail.
D 18
.Dp \&&
E 18
I 18
.It \&&
E 18
Repeat the previous substitution.
D 18
.Dp g
E 18
I 18
.It g
E 18
D 21
Apply the change globally, prefixing the above, e.g. `g&'.
E 21
I 21
D 27
Apply the change once on each word, prefixing the above, e.g. `g&'.
E 27
I 27
Apply the change once on each word, prefixing the above, e.g., `g&'.
E 27
.It a
Apply the change as many times as possible on a single word, prefixing
the above. It can be used together with `g' to apply a substitution 
globally.
E 21
D 18
.Dp p
E 18
I 18
.It p
E 18
Print the new command line but do not execute it.
D 18
.Dp q
E 18
I 18
.It q
E 18
Quote the substituted words, preventing further substitutions.
D 18
.Dp x
E 18
I 18
.It x
E 18
Like q, but break into words at blanks, tabs and newlines.
D 18
.Dp
E 18
I 18
.El
E 18
.Pp
E 15
D 27
Unless preceded by a `g' the modification is applied only to the first
E 27
I 27
Unless preceded by a `g' the change is applied only to the first
E 27
modifiable word.  With substitutions, it is an error for no word to be
applicable.
D 15
.PP
E 15
I 15
.Pp
E 15
The left hand side of substitutions are not regular expressions in the sense
D 27
of the editors, but rather strings.
E 27
I 27
of the editors, but instead strings.
E 27
Any character may be used as the delimiter in place of `/';
a `\e' quotes the delimiter into the
D 15
.IR l ""
E 15
I 15
.Ar l  " "
E 15
and
D 15
.IR r ""
E 15
I 15
.Ar r  " "
E 15
strings.
The character `&' in the right hand side is replaced by the text from
the left.
D 27
A `\e' quotes `&' also.
E 27
I 27
A `\e' also quotes `&'.
E 27
A null
D 15
.IR l ""
E 15
I 15
D 18
.Ar l  " "
E 18
I 18
.Ar l
D 27
(" ")
E 18
E 15
uses the previous string either from a
E 27
I 27
(`//')
uses the previous string either from an
E 27
D 15
.IR l ""
E 15
I 15
D 18
.Ar l  " "
E 18
I 18
.Ar l
E 18
E 15
or from a
contextual scan string
D 15
.IR s ""
in `!?\fIs\fR\|?'.
E 15
I 15
D 18
.Ar s  " "
E 18
I 18
.Ar s
E 18
D 20
in `!?
.Ar s
\?'.
E 20
I 20
in
.No \&`!? Ns Ar s Ns \e?' .
E 20
E 15
The trailing delimiter in the substitution may be omitted if a newline
follows immediately as may the trailing `?' in a contextual scan.
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
A history reference may be given without an event specification, e.g. `!$'.
In this case the reference is to the previous command unless a previous
E 27
I 27
A history reference may be given without an event specification, e.g., `!$'.
Here, the reference is to the previous command unless a previous
E 27
history reference occurred on the same line in which case this form repeats
the previous reference.
Thus `!?foo?\*(ua !$' gives the first and last arguments
from the command matching `?foo?'.
D 15
.PP
E 15
I 15
.Pp
E 15
A special abbreviation of a history reference occurs when the first
non-blank character of an input line is a `\*(ua'.
This is equivalent to `!:s\*(ua' providing a convenient shorthand for substitutions
on the text of the previous line.
D 15
Thus `\*(ualb\*(ualib' fixes the spelling of 
E 15
I 15
Thus `\*(ualb\*(ualib' fixes the spelling of
E 15
`lib'
in the previous command.
Finally, a history substitution may be surrounded with `{' and `}'
D 27
if necessary to insulate it from the characters which follow.
E 27
I 27
if necessary to insulate it from the characters that follow.
E 27
Thus, after `ls \-ld ~paul' we might do `!{l}a' to do `ls \-ld ~paula',
D 27
while `!la' would look for a command starting `la'.
E 27
I 27
while `!la' would look for a command starting with `la'.
E 27
D 15
.PP
.if n .ul
\fBQuotations\ with\ \'\ and\ "\fR
.PP
E 15
I 15
.Pp
D 16
.Ss Quotations with \' and \*(Lq
E 16
I 16
.Ss Quotations with \' and \&"
E 16
E 15
The quotation of strings by `\'' and `"' can be used
to prevent all or some of the remaining substitutions.
Strings enclosed in `\'' are prevented any further interpretation.
D 2
Strings enclosed in `"' are yet variable and command expanded
as described below.
E 2
I 2
Strings enclosed in `"' may be expanded as described below.
E 2
D 15
.PP
E 15
I 15
.Pp
E 15
In both cases the resulting text becomes (all or part of) a single word;
only in one special case (see
D 15
.I "Command Substitition"
E 15
I 15
D 16
.Nm "Command Substitition"
E 16
I 16
D 27
.Em Command Substitition
E 27
I 27
.Em Command Substitution
E 27
E 16
E 15
below) does a `"' quoted string yield parts of more than one word;
`\'' quoted strings never do.
D 15
.sh "Alias substitution"
E 15
I 15
.Ss Alias substitution
E 15
D 27
The shell maintains a list of aliases which can be established, displayed
E 27
I 27
The shell maintains a list of aliases that can be established, displayed
E 27
and modified by the
D 15
.I alias
E 15
I 15
.Ar alias
E 15
and
D 15
.I unalias
E 15
I 15
.Ar unalias
E 15
commands.
After a command line is scanned, it is parsed into distinct commands and
the first word of each command, left-to-right, is checked to see if it
has an alias.
D 27
If it does, then the text which is the alias for that command is reread
E 27
I 27
If it does, then the text that is the alias for that command is reread
E 27
with the history mechanism available
as though that command were the previous input line.
The resulting words replace the
command and argument list.
If no reference is made to the history list, then the argument list is
left unchanged.
D 15
.PP
E 15
I 15
.Pp
E 15
Thus if the alias for `ls' is `ls \-l' the command `ls /usr' would map to
`ls \-l /usr', the argument list here being undisturbed.
Similarly if the alias for `lookup' was `grep !\*(ua /etc/passwd' then
`lookup bill' would map to `grep bill /etc/passwd'.
D 15
.PP
E 15
I 15
.Pp
E 15
If an alias is found, the word transformation of the input text
is performed and the aliasing process begins again on the reformed input line.
Looping is prevented if the first word of the new text is the same as the old
by flagging it to prevent further aliasing.
Other loops are detected and cause an error.
D 15
.PP
E 15
I 15
.Pp
E 15
Note that the mechanism allows aliases to introduce parser metasyntax.
D 15
Thus we can `alias print \'pr \e!* \||\| lpr\'' to make a command which
.I pr's
E 15
I 15
D 16
Thus we can `alias print \'pr \e!* \\ lpr\'' to make a command which
E 16
I 16
D 27
Thus we can `alias print \'pr \e!* \&| lpr\'' to make a command which
E 16
D 18
.Ar pr 's
E 18
I 18
.Ar pr \'s
E 27
I 27
Thus, we can `alias print \'pr \e!* \&| lpr\'' to make a command that
.Ar pr Ns 's
E 27
E 18
E 15
its arguments to the line printer.
D 15
.sh "Variable substitution"
E 15
I 15
.Ss Variable substitution
E 15
The shell maintains a set of variables, each of which has as value a list
of zero or more words.
Some of these variables are set by the shell or referred to by it.
For instance, the
D 15
.I argv
E 15
I 15
.Ar argv
E 15
variable is an image of the shell's argument list, and words of this
variable's value are referred to in special ways.
D 15
.PP
E 15
I 15
.Pp
E 15
The values of variables may be displayed and changed by using the
D 15
.I set
E 15
I 15
.Ar set
E 15
and
D 15
.I unset
E 15
I 15
.Ar unset
E 15
commands.
Of the variables referred to by the shell a number are toggles;
the shell does not care what their value is,
only whether they are set or not.
For instance, the
D 15
.I verbose
E 15
I 15
.Ar verbose
E 15
D 27
variable is a toggle which causes command input to be echoed.
E 27
I 27
variable is a toggle that causes command input to be echoed.
E 27
The setting of this variable results from the
D 15
.B \-v
E 15
I 15
.Fl v
E 15
command line option.
D 15
.PP
E 15
I 15
.Pp
E 15
Other operations treat variables numerically.
The `@' command permits numeric calculations to be performed and the result
assigned to a variable.
Variable values are, however, always represented as (zero or more) strings.
For the purposes of numeric operations, the null string is considered to be
D 27
zero, and the second and subsequent words of multiword values are ignored.
E 27
I 27
zero, and the second and additional words of multiword values are ignored.
E 27
D 15
.PP
E 15
I 15
.Pp
E 15
After the input line is aliased and parsed, and before each command
is executed, variable substitution
is performed keyed by `$' characters.
This expansion can be prevented by preceding the `$' with a `\e' except
within `"'s where it
D 15
.B always
E 15
I 15
D 18
.Ar always
E 18
I 18
.Em always
E 18
E 15
occurs, and within `\''s where it
D 15
.B never
E 15
I 15
D 18
.Ar never
E 18
I 18
.Em never
E 18
E 15
occurs.
Strings quoted by `\*(ga' are interpreted later (see
D 15
.I "Command substitution"
E 15
I 15
.Nm "Command substitution"
E 15
below) so `$' substitution does not occur there until later, if at all.
A `$' is passed unchanged if followed by a blank, tab, or end-of-line.
D 15
.PP
E 15
I 15
.Pp
E 15
Input/output redirections are recognized before variable expansion,
and are variable expanded separately.
Otherwise, the command name and entire argument list are expanded together.
D 27
It is thus possible for the first (command) word to this point to generate
E 27
I 27
It is thus possible for the first (command) word (to this point) to generate
E 27
more than one word, the first of which becomes the command name,
and the rest of which become arguments.
D 15
.PP
E 15
I 15
.Pp
E 15
Unless enclosed in `"' or given the `:q' modifier the results of variable
substitution may eventually be command and filename substituted.
D 9
Within `"' a variable whose value consists of multiple words expands to a
E 9
I 9
Within `"', a variable whose value consists of multiple words expands to a
E 9
(portion of) a single word, with the words of the variables value
separated by blanks.
When the `:q' modifier is applied to a substitution
the variable will expand to multiple words with each word separated
by a blank and quoted to prevent later command or filename substitution.
D 15
.PP
E 15
I 15
.Pp
E 15
The following metasequences are provided for introducing variable values into
the shell input.
D 27
Except as noted, it is an error to reference a variable which is not set.
E 27
I 27
Except as noted, it is an error to reference a variable that is not set.
E 27
D 15
.HP 5
$name
.br
.ns
.HP 5
${name}
.br
E 15
I 15
D 18
.Dw Ds
I 16
.Di L
E 16
.Dp $name
.Dp ${name}
E 18
I 18
.Pp
.Bl -tag -width Ds -compact -offset indent
.It $name
.It ${name}
E 18
E 15
Are replaced by the words of the value of variable
D 15
.I name,
E 15
I 15
.Ar name ,
E 15
each separated by a blank.
Braces insulate
D 15
.I name
E 15
I 15
.Ar name
E 15
D 27
from following characters which would otherwise be part of it.
E 27
I 27
from following characters that would otherwise be part of it.
E 27
Shell variables have names consisting of up to 20 letters and digits
starting with a letter.  The underscore character is considered a letter.
D 27
.br
E 27
If
D 15
.I name
E 15
I 15
.Ar name
E 15
is not a shell variable, but is set in the environment, then
D 15
that value is returned (but \fB:\fR modifiers and the other forms
E 15
I 15
that value is returned (but
.Nm :
modifiers and the other forms
E 15
D 27
given below are not available in this case).
E 27
I 27
given below are not available here).
E 27
I 16
D 18
.Pp
E 16
D 15
.HP 5
$name[selector]
.br
.ns
.HP 5
${name[selector]}
.br
E 15
I 15
.Dp Cx $name
.Op selector
.Cx
.Dp Cx ${name
.Op selector
.Cx }
.Cx
E 18
I 18
.It $name Ns Op selector
D 27
.It ${name Ns Op selector Ns }
E 27
I 27
.It ${name Ns [ selector ] }
E 27
E 18
E 15
May be used to select only some of the words from the value of
D 15
.I name.
E 15
I 15
.Ar name .
E 15
The selector is subjected to `$' substitution and may consist of a single
number or two numbers separated by a `\-'.
The first word of a variables value is numbered `1'.
If the first number of a range is omitted it defaults to `1'.
D 27
If the last member of a range is omitted it defaults to `$#name'.
E 27
I 27
If the last number of a range is omitted it defaults to `$#name'.
E 27
The selector `*' selects all words.
It is not an error for a range to be empty if the second argument is omitted
or in range.
I 31
.ne 1i
E 31
I 16
D 18
.Pp
E 16
D 15
.HP 5
$#name
.br
.ns
.HP 5
${#name}
.br
E 15
I 15
.Dp $#name
.Dp ${#name}
E 18
I 18
.It $#name
.It ${#name}
E 18
E 15
Gives the number of words in the variable.
D 15
This is useful for later use in a `[selector]'.
.HP 5
$0
.br
E 15
I 15
This is useful for later use in a
D 18
.Cx `$argv
.Op selector
.Cx \' .
.Cx
I 16
.Pp
E 16
.Dp $0
E 18
I 18
`$argv[selector]'.
.It $0
E 18
E 15
Substitutes the name of the file from which command input is being read.
An error occurs if the name is not known.
I 16
D 18
.Pp
E 16
D 15
.HP 5
$number
.br
.ns
.HP 5
${number}
.br
Equivalent to `$argv[number]'.
.HP 5
$*
.br
Equivalent to `$argv[*]'.
.PP
E 15
I 15
.Dp $number
.Dp ${number}
E 18
I 18
.It $number
.It ${number}
E 18
Equivalent to
D 18
.Cx `$argv
.Op number
.Cx \' .
.Cx
I 16
.Pp
.Dp $*
E 18
I 18
`$argv[number]'.
.It $*
E 18
E 16
Equivalent to
D 18
.Cx `$argv
.Op *
.Cx \' .
.Cx
E 18
I 18
`$argv[*]'.
E 18
D 16
.Pp
E 16
E 15
D 12
The modifiers `:h', `:t', `:r', `:q' and `:x' may be applied to
E 12
I 12
The modifiers `:e', `:h', `:t', `:r', `:q' and `:x' may be applied to
E 12
the substitutions above as may `:gh', `:gt' and `:gr'.
If braces `{' '}' appear in the command form then the modifiers
must appear within the braces.
D 15
.B  "The current implementation allows only one `:' modifier on each `$' expansion."
.PP
E 15
I 15
The current implementation allows only one `:' modifier on each `$' expansion.
I 16
D 18
.Dp
E 18
I 18
.El
E 18
E 16
.Pp
E 15
The following substitutions may not be modified with `:' modifiers.
I 16
D 18
.Pp
.Dw Ds
.Di L
E 16
D 15
.HP 5
$?name
.br
.ns
.HP 5
${?name}
.br
E 15
I 15
.Dp $?name
.Dp ${?name}
E 18
I 18
.Bl -tag -width Ds -compact -offset indent
.It $?name
.It ${?name}
E 18
E 15
Substitutes the string `1' if name is set, `0' if it is not.
I 16
D 18
.Pp
E 16
D 15
.HP 5
$?0
.br
E 15
I 15
.Dp $?0
E 18
I 18
.It $?0
E 18
E 15
D 2
Substitutes `1' if the current input filename is know, `0' if it is not.
E 2
I 2
Substitutes `1' if the current input filename is known, `0' if it is not.
I 16
D 18
.Pp
E 16
E 2
D 15
.HP 5
$$
.br
E 15
I 15
.Dp $$
E 18
I 18
D 27
.It $$
E 27
I 27
.It \&$\&$\&
E 27
E 18
E 15
Substitute the (decimal) process number of the (parent) shell.
I 21
.It $!
D 27
Substiture the (decimal) process number of the last background process
E 27
I 27
Substitute the (decimal) process number of the last background process
E 27
started by this shell.
E 21
I 16
D 18
.Pp
E 16
D 15
.HP 5
$<
.br
E 15
I 15
.Dp $<
E 18
I 18
.It $<
E 18
E 15
Substitutes a line from the standard
D 27
input, with no further interpretation thereafter.  It can be used
to read from the keyboard in a shell script.
E 27
I 27
input, with no further interpretation.
It can be used to read from the keyboard in a shell script.
E 27
D 15
.sh "Command and filename substitution"
E 15
I 15
D 18
.Dp
E 18
I 18
.El
E 18
.Ss Command and filename substitution
E 15
The remaining substitutions, command and filename substitution,
are applied selectively to the arguments of builtin commands.
D 27
This means that portions of expressions which are not evaluated are
not subjected to these expansions.
For commands which are not internal to the shell, the command
E 27
I 27
By selectively, we mean that portions of expressions which are
not evaluated are not subjected to these expansions.
For commands that are not internal to the shell, the command
E 27
name is substituted separately from the argument list.
This occurs very late,
after input-output redirection is performed, and in a child
of the main shell.
D 15
.sh "Command substitution"
E 15
I 15
.Ss Command substitution
E 15
D 27
Command substitution is indicated by a command enclosed in `\*(ga'.
E 27
I 27
Command substitution is shown by a command enclosed in `\*(ga'.
E 27
The output from such a command is normally broken into separate words
D 27
at blanks, tabs and newlines, with null words being discarded,
this text then replacing the original string.
E 27
I 27
at blanks, tabs and newlines, with null words being discarded;
this text then replaces the original string.
E 27
Within `"'s, only newlines force new words; blanks and tabs are preserved.
D 15
.PP
E 15
I 15
.Pp
E 15
In any case, the single final newline does not force a new word.
Note that it is thus possible for a command substitution to yield
only part of a word, even if the command outputs a complete line.
D 15
.sh "Filename substitution"
If a word contains any of the characters `*', `?', `[' or `{'
E 15
I 15
.Ss Filename substitution
D 16
If a word contains any of the characters `*', `?', `
.Op ' or `{'
E 16
I 16
If a word contains any of the characters `*', `?', `[' or `{'
E 16
E 15
or begins with the character `~', then that word is a candidate for
filename substitution, also known as `globbing'.
This word is then regarded as a pattern, and replaced with an alphabetically
D 27
sorted list of file names which match the pattern.
E 27
I 27
sorted list of file names that match the pattern.
E 27
In a list of words specifying filename substitution it is an error for
no pattern to match an existing file name, but it is not required
for each pattern to match.
D 15
Only the metacharacters `*', `?' and `[' imply pattern matching,
E 15
I 15
D 16
Only the metacharacters `*', `?' and `
.Op ' imply pattern matching,
E 16
I 16
Only the metacharacters `*', `?' and `[' imply pattern matching,
E 16
E 15
the characters `~' and `{' being more akin to abbreviations.
D 15
.PP
E 15
I 15
.Pp
E 15
In matching filenames, the character `.' at the beginning of a filename
or immediately following a `/', as well as the character `/' must
be matched explicitly.
The character `*' matches any string of characters, including the null
string.
The character `?' matches any single character.
D 15
The sequence `[...]' matches any one of the characters enclosed.
Within `[...]',
E 15
I 15
D 16
The sequence `
.Op ...
' matches any one of the characters enclosed.
Within `
.Op ...
',
E 16
I 16
The sequence
.Sq Op ...
matches any one of the characters enclosed.
Within
.Sq Op ... ,
E 16
E 15
a pair of characters separated by `\-' matches any character lexically between
D 27
the two.
E 27
I 27
the two (inclusive).
E 27
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
The character `~' at the beginning of a filename is used to refer to home
E 27
I 27
The character `~' at the beginning of a filename refers to home
E 27
directories.
D 27
Standing alone, i.e. `~' it expands to the invokers home directory as reflected
E 27
I 27
Standing alone, i.e., `~' it expands to the invokers home directory as reflected
E 27
in the value of the variable
D 15
.I home.
E 15
I 15
.Ar home .
E 15
D 27
When followed by a name consisting of letters, digits and `\-' characters
E 27
I 27
When followed by a name consisting of letters, digits and `\-' characters,
E 27
the shell searches for a user with that name and substitutes their
home directory;  thus `~ken' might expand to `/usr/ken' and `~ken/chmach'
to `/usr/ken/chmach'.
If the character `~' is followed by a character other than a letter or `/'
D 27
or appears not at the beginning of a word,
E 27
I 27
or does not appear at the beginning of a word,
E 27
it is left undisturbed.
D 15
.PP
E 15
I 15
.Pp
E 15
The metanotation `a{b,c,d}e' is a shorthand for `abe ace ade'.
Left to right order is preserved, with results of matches being sorted
separately at a low level to preserve this order.
This construct may be nested.
D 27
Thus `~source/s1/{oldls,ls}.c' expands to
E 27
I 27
Thus, `~source/s1/{oldls,ls}.c' expands to
E 27
`/usr/source/s1/oldls.c /usr/source/s1/ls.c'
D 27
whether or not these files exist without any chance of error
E 27
I 27
without chance of error
E 27
if the home directory for `source' is `/usr/source'.
Similarly `../{memo,*box}' might expand to `../memo ../box ../mbox'.
D 27
(Note that `memo' was not sorted with the results of matching `*box'.)
E 27
I 27
(Note that `memo' was not sorted with the results of the match to `*box'.)
E 27
As a special case `{', `}' and `{}' are passed undisturbed.
D 15
.sh Input/output
E 15
I 15
.Ss Input/output
E 15
D 27
The standard input and standard output of a command may be redirected
E 27
I 27
The standard input and the standard output of a command may be redirected
E 27
with the following syntax:
D 15
.HP 5
< name
.br
E 15
I 15
D 18
.Dw Ds
I 16
.Di L
E 16
.Dp < name
E 18
I 18
.Pp
.Bl -tag -width Ds -compact -offset indent
.It < name
E 18
E 15
Open file
D 15
.I name
E 15
I 15
.Ar name
E 15
(which is first variable, command and filename expanded) as the standard
input.
I 16
D 18
.Pp
E 16
D 15
.HP 5
<< word
.br
E 15
I 15
.Dp << word
E 18
I 18
.It << word
E 18
E 15
D 27
Read the shell input up to a line which is identical to
E 27
I 27
Read the shell input up to a line that is identical to
E 27
D 15
.I word.
.I Word
E 15
I 15
.Ar word .
.Ar Word
E 15
is not subjected to variable, filename or command substitution,
and each input line is compared to
D 15
.I word
E 15
I 15
.Ar word
E 15
D 27
before any substitutions are done on this input line.
E 27
I 27
before any substitutions are done on the input line.
E 27
Unless a quoting `\e', `"', `\*(aa' or `\*(ga' appears in
D 15
.I word
E 15
I 15
D 27
.Ar word
E 27
I 27
.Ar word ,
E 27
E 15
variable and command substitution is performed on the intervening lines,
allowing `\e' to quote `$', `\e' and `\*(ga'.
D 27
Commands which are substituted have all blanks, tabs, and newlines
E 27
I 27
Commands that are substituted have all blanks, tabs, and newlines
E 27
preserved, except for the final newline which is dropped.
D 27
The resultant text is placed in an anonymous temporary file which
is given to the command as standard input.
E 27
I 27
The resultant text is placed in an anonymous temporary file that
is given to the command as its standard input.
E 27
I 16
D 18
.Pp
E 16
D 15
.HP 5
> name
.br
.ns
.HP 5
>! name
.br
.ns
.HP 5
>& name
.br
.ns
.HP 5
>&! name
.br
E 15
I 15
.Dp > name
.Dp >! name
.Dp >& name
.Dp >&! name
E 18
I 18
.It > name
.It >! name
.It >& name
.It >&! name
E 18
E 15
The file
D 15
.I name
E 15
I 15
.Ar name
E 15
D 27
is used as standard output.
E 27
I 27
is used as the standard output.
E 27
If the file does not exist then it is created;
D 27
if the file exists, its is truncated, its previous contents being lost.
E 27
I 27
if the file exists, it is truncated; its previous contents are lost.
E 27
D 15
.IP
E 15
I 15
.Pp
E 15
If the variable
D 15
.I noclobber
E 15
I 15
.Ar noclobber
E 15
D 27
is set, then the file must not exist or be a character special file (e.g. a
E 27
I 27
is set, then the file must not exist or be a character special file (e.g., a
E 27
terminal or `/dev/null') or an error results.
This helps prevent accidental destruction of files.
D 27
In this case the `!' forms can be used and suppress this check.
E 27
I 27
Here, the `!' forms can be used to suppress this check.
E 27
D 15
.IP
E 15
I 15
.Pp
E 15
D 27
The forms involving `&' route the diagnostic output into the specified
E 27
I 27
The forms involving `&' route the standard error output into the specified
E 27
file as well as the standard output.
D 15
.I Name
E 15
I 15
.Ar Name
E 15
is expanded in the same way as `<' input filenames are.
I 16
D 18
.Pp
E 16
D 15
.HP 5
>> name
.br
.ns
.HP 5
>>& name
.br
.ns
.HP 5
>>! name
.br
.ns
.HP 5
>>&! name
.br
E 15
I 15
.Dp >> name
.Dp >>& name
.Dp >>! name
.Dp >>&! name
E 18
I 18
.It >> name
.It >>& name
.It >>! name
.It >>&! name
E 18
E 15
Uses file
D 15
.I name
E 15
I 15
.Ar name
E 15
D 27
as standard output like `>' but places output at the end of the file.
E 27
I 27
as the standard output;
like `>' but places output at the end of the file.
E 27
If the variable
D 15
.I noclobber
E 15
I 15
.Ar noclobber
E 15
D 2
is set, then
it is an error for the file not to exist unless
E 2
I 2
is set, then it is an error for the file not to exist unless
E 2
one of the `!' forms is given.
Otherwise similar to `>'.
D 15
.PP
E 15
I 15
D 18
.Dp
E 18
I 18
.El
E 18
.Pp
E 15
A command receives the environment in which the shell was
invoked as modified by the input-output parameters and
the presence of the command in a pipeline.
Thus, unlike some previous shells, commands run from a file of shell commands
D 27
have no access to the text of the commands by default; rather
they receive the original standard input of the shell.
E 27
I 27
have no access to the text of the commands by default;
instead they receive the original standard input of the shell.
E 27
The `<<' mechanism should be used to present inline data.
This permits shell command scripts to function as components of pipelines
and allows the shell to block read its input.
Note that the default standard input for a command run detached is
D 15
.B not
modified to be the empty file `/dev/null'; rather the standard input
E 15
I 15
.Ar not
modified to be the empty file
.Pa /dev/null ;
D 27
rather the standard input
E 27
I 27
instead the standard input
E 27
E 15
remains as the original standard input of the shell.  If this is a terminal
and if the process attempts to read from the terminal, then the process
will block and the user will be notified (see
D 15
.B Jobs
E 15
I 15
D 18
.Ar Jobs
E 18
I 18
.Sx Jobs
E 18
E 15
D 9
above.)
E 9
I 9
above).
E 9
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
Diagnostic output may be directed through a pipe with the standard output.
D 15
Simply use the form `|\|&' rather than just `|'.
.sh Expressions
E 15
I 15
D 16
Simply use the form `\&' rather than just `'.
E 16
I 16
Simply use the form `\&|&' rather than just `\&|'.
E 27
I 27
The standard error output may be directed through
a pipe with the standard output.
Simply use the form `\&|&' instead of just `\&|'.
E 27
E 16
.Ss Expressions
E 15
D 27
A number of the builtin commands (to be described subsequently)
E 27
I 27
Several of the builtin commands (to be described later)
E 27
take expressions, in which the operators are similar to those of C, with
the same precedence.
These expressions appear in the
D 15
.I @,
.I exit,
.I if,
E 15
I 15
.Nm @,
.Ar exit ,
.Ar if ,
E 15
and
D 15
.I while
E 15
I 15
.Ar while
E 15
commands.
The following operators are available:
I 18
.Bd -ragged -offset indent
D 26
\&|\&|  &&  \&| *(ua  &  ==  !=  =~  !~  <=  >=
E 26
I 26
\&|\&|  &&  \&| \*(ua  &  ==  !=  =~  !~  <=  >=
E 26
<  > <<  >>  +  \-  *  /  %  !  ~  (  )
.Ed
E 18
D 15
.DT
.PP
	|\|\||  &&  |  \*(ua  &  ==  !=  =~  !~  <=  >=  <  >  <<  >>  +  \-  *  /  %  !  ~  (  )
.PP
E 15
I 15
.Pp
D 18
.Ds I
D 16
\\  &&  \*(ua  &  ==  !=  =~  !~  <=  >=  <  >
E 16
I 16
\&|\&|  &&  \&| *(ua  &  ==  !=  =~  !~  <=  >=  <  >
E 16
<<  >>  +  \-  *  /  %  !  ~  (  )
.De
.Pp
E 18
E 15
Here the precedence increases to the right,
`==' `!=' `=~' and `!~', `<=' `>=' `<' and `>', `<<' and `>>', `+' and `\-',
`*' `/' and `%' being, in groups, at the same level.
The `==' `!=' `=~' and `!~' operators compare their arguments as strings;
all others operate on numbers.
The operators `=~' and `!~' are like `!=' and `==' except that the right
hand side is a
D 15
.I pattern
(containing, e.g. `*'s, `?'s and instances of `[...]')
E 15
I 15
.Ar pattern
D 27
(containing, e.g. `*'s, `?'s and instances of
D 18
.Cx `
.Op ...
.Cx \' )
.Cx
E 18
I 18
`[...]'
E 27
I 27
(containing, e.g., `*'s, `?'s and instances of `[...]')
E 27
E 18
E 15
against which the left hand operand is matched.  This reduces the
need for use of the
D 15
.I switch
E 15
I 15
.Ar switch
E 15
statement in shell scripts when all that is really needed is pattern matching.
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
Strings which begin with `0' are considered octal numbers.
E 27
I 27
Strings that begin with `0' are considered octal numbers.
E 27
Null or missing arguments are considered `0'.
The result of all expressions are strings,
which represent decimal numbers.
It is important to note that no two components of an expression can appear
D 27
in the same word; except when adjacent to components of expressions which
D 15
are syntactically significant to the parser (`&' `|' `<' `>' `(' `)')
E 15
I 15
D 16
are syntactically significant to the parser (`&' `' `<' `>' `(' `)')
E 16
I 16
are syntactically significant to the parser (`&' `\&|' `<' `>' `(' `)')
E 27
I 27
in the same word; except when adjacent to components of expressions that
are syntactically significant to the parser (`&' `\&|' `<' `>' `(' `)'),
E 27
E 16
E 15
they should be surrounded by spaces.
D 15
.PP
E 15
I 15
.Pp
E 15
Also available in expressions as primitive operands are command executions
enclosed in `{' and `}'
D 15
and file enquiries of the form `\-\fIl\fR  name' where
.I  l
E 15
I 15
and file enquiries of the form
.Fl l
.Ar name
where
.Ic l
E 15
is one of:
D 15
.PP
.DT
.nf
	r	read access
	w	write access
	x	execute access
	e	existence
	o	ownership
	z	zero size
	f	plain file
	d	directory
.fi
.PP
E 15
I 15
D 18
.Pp
.Ds I
E 18
I 18
D 27
.Bd -ragged -offset indent
E 27
I 27
.Bd -literal -offset indent
E 27
E 18
r	read access
w	write access
x	execute access
e	existence
o	ownership
z	zero size
f	plain file
d	directory
D 18
.De
E 18
I 18
.Ed
E 18
.Pp
E 15
The specified name is command and filename expanded and then tested
to see if it has the specified relationship to the real user.
If the file does not exist or is inaccessible then all enquiries return
D 27
false, i.e. `0'.
Command executions succeed, returning true, i.e. `1',
E 27
I 27
false, i.e., `0'.
Command executions succeed, returning true, i.e., `1',
E 27
if the command exits with status 0, otherwise they fail, returning
D 27
false, i.e. `0'.
E 27
I 27
false, i.e., `0'.
E 27
If more detailed status information is required then the command
D 27
should be executed outside of an expression and the variable
E 27
I 27
should be executed outside an expression and the variable
E 27
D 15
.I status
E 15
I 15
.Ar status
E 15
examined.
D 15
.sh "Control flow"
E 15
I 15
.Ss Control flow
E 15
D 27
The shell contains a number of commands which can be used to regulate the
E 27
I 27
The shell contains several commands that can be used to regulate the
E 27
flow of control in command files (shell scripts) and
(in limited but useful ways) from terminal input.
These commands all operate by forcing the shell to reread or skip in its
D 27
input and, due to the implementation, restrict the placement of some
E 27
I 27
input and, because of the implementation, restrict the placement of some
E 27
of the commands.
D 15
.PP
E 15
I 15
.Pp
E 15
The
D 15
.I foreach,
.I switch,
E 15
I 15
.Ic foreach ,
.Ic switch ,
E 15
and
D 15
.I while
E 15
I 15
.Ic while
E 15
statements, as well as the
D 15
.I if\-then\-else
E 15
I 15
.Ic if\-then\-else
E 15
form of the
D 15
.I if
E 15
I 15
.Ic if
E 15
statement require that the major keywords appear in a single simple command
on an input line as shown below.
I 31
.pl +1
E 31
D 15
.PP
E 15
I 15
.Pp
E 15
If the shell's input is not seekable,
the shell buffers up input whenever a loop is being read
and performs seeks in this internal buffer to accomplish the rereading
implied by the loop.
(To the extent that this allows, backward goto's will succeed on
non-seekable inputs.)
D 15
.sh "Builtin commands"
E 15
I 15
.Ss Builtin commands
E 15
Builtin commands are executed within the shell.
If a builtin command occurs as any component of a pipeline
except the last then it is executed in a subshell.
D 15
.HP 5
.B  alias
.br
.ns
.HP 5
.BR alias " name"
.br
.ns
.HP 5
.BR alias " name wordlist"
.br
E 15
I 15
D 18
.Dw Ds
D 16
.Ds L
E 16
I 16
.Di L
E 16
.Dp Ic alias
.Dp Cx Ic alias
.Cx \&\ \&
.Cx Ar name
.Cx
.Dp Cx Ic alias
.Cx \&\ \&
.Ar name wordlist
.Cx
E 18
I 18
.Pp
.Bl -tag -width Ds -compact -offset indent
.It Ic alias
.It Ic alias Ar name
.It Ic alias Ar name wordlist
E 18
E 15
The first form prints all aliases.
The second form prints the alias for name.
The final form assigns the specified
D 15
.I wordlist
as the alias of 
.I name;
.I wordlist
E 15
I 15
.Ar wordlist
as the alias of
.Ar name ;
.Ar wordlist
E 15
is command and filename substituted.
D 15
.I Name
E 15
I 15
.Ar Name
E 15
is not allowed to be
D 15
.I alias
E 15
I 15
.Ar alias
E 15
or
D 15
.I unalias.
.HP 5
.B  alloc
.br
E 15
I 15
.Ar unalias .
I 16
.Pp
E 16
D 18
.Dp Ic alloc
E 18
I 18
.It Ic alloc
E 18
E 15
D 8
Shows the amount of dynamic core in use, broken down into used and
free core, and address of the last location in the heap.
With an argument shows each used and free block on the internal dynamic
memory chain indicating its address, size, and whether it is used or free.
This is a debugging command and may not work in production versions of the
shell; it requires a modified version of the system memory allocator.
E 8
I 8
Shows the amount of dynamic memory acquired, broken down into used and
free memory.
With an argument shows the number of free and used blocks in each size
category.  The categories start at size 8 and double at each step.
This command's output may vary across system types, since
systems other than the VAX may use a different memory allocator.
I 16
.Pp
E 16
E 8
D 15
.HP 5
.B bg
.br
.ns
.HP 5
\fBbg\ %\fRjob\ ...
.br
E 15
I 15
D 18
.Dp Ic bg
.Dp Cx Ic bg \&%
.Ar job ...
.Cx
E 18
I 18
.It Ic bg
.It Ic bg \&% Ns Ar job ...
E 18
E 15
Puts the current or specified jobs into the background, continuing them
if they were stopped.
I 16
.Pp
E 16
D 15
.HP 5
.B  break
.br
E 15
I 15
D 18
.Dp Ic break
E 18
I 18
.It Ic break
E 18
E 15
Causes execution to resume after the
D 15
.I end
E 15
I 15
.Ic end
E 15
of the nearest enclosing
D 15
.I foreach
E 15
I 15
.Ic foreach
E 15
or
D 15
.I while.
E 15
I 15
.Ic while .
E 15
The remaining commands on the current line are executed.
Multi-level breaks are thus possible by writing them all on one line.
I 16
.Pp
E 16
D 15
.HP 5
.B  breaksw
.br
E 15
I 15
D 18
.Dp Ic breaksw
E 18
I 18
.It Ic breaksw
E 18
E 15
Causes a break from a
D 15
.I switch,
E 15
I 15
.Ic switch ,
E 15
resuming after the
D 15
.I endsw.
.HP 5
.BR case " label:"
.br
E 15
I 15
.Ic endsw .
I 16
.Pp
E 16
D 18
.Dp Cx Ic case
.Cx \&\ \&
.Ar label :
.Cx
E 18
I 18
.It Ic case Ar label :
E 18
E 15
A label in a
D 15
.I switch
E 15
I 15
.Ic switch
E 15
statement as discussed below.
I 16
.Pp
E 16
D 15
.HP 5
.B  cd
.br
.ns
.HP 5
.BR cd " name"
.br
.ns
.HP 5
.B  chdir
.br
.ns
.HP 5
.BR chdir " name"
.br
E 15
I 15
D 18
.Dp Ic cd
.Dp Cx Ic cd
.Cx \&\ \&
.Ar name
.Cx
.Dp Ic chdir
.Dp Cx Ic chdir
.Cx \&\ \&
.Ar name
.Cx
E 18
I 18
.It Ic cd
.It Ic cd Ar name
.It Ic chdir
.It Ic chdir Ar name
E 18
E 15
D 9
Change the shells working directory to directory
E 9
I 9
Change the shell's working directory to directory
E 9
D 15
.I name.
E 15
I 15
.Ar name .
E 15
If no argument is given then change to the home directory of the user.
D 15
.br
E 15
If
D 15
.I name
E 15
I 15
.Ar name
E 15
is not found as a subdirectory of the current directory (and does not begin
with `/', `./' or `../'), then each
component of the variable
D 15
.I cdpath
E 15
I 15
.Ic cdpath
E 15
is checked to see if it has a subdirectory
D 15
.I name.
E 15
I 15
.Ar name .
E 15
Finally, if all else fails but
D 15
.I name
E 15
I 15
.Ar name
E 15
is a shell variable whose value begins with `/', then this
is tried to see if it is a directory.
I 16
.Pp
E 16
D 15
.HP 5
.B  continue
.br
E 15
I 15
D 18
.Dp Ic continue
E 18
I 18
.It Ic continue
E 18
E 15
Continue execution of the nearest enclosing
D 15
.I while
E 15
I 15
.Ic while
E 15
or
D 15
.I foreach.
E 15
I 15
.Ic foreach .
E 15
The rest of the commands on the current line are executed.
I 16
.Pp
E 16
D 15
.HP 5
.B  default:
.br
E 15
I 15
D 18
.Dp Ic default :
E 18
I 18
.It Ic default :
E 18
E 15
Labels the default case in a
D 15
.I switch
E 15
I 15
.Ic switch
E 15
statement.
The default should come after all
D 15
.I case
E 15
I 15
.Ic case
E 15
labels.
I 16
.Pp
E 16
D 15
.HP 5
.BR "dirs"
.br
E 15
I 15
D 18
.Dp Ic dirs
E 18
I 18
.It Ic dirs
E 18
E 15
Prints the directory stack; the top of the stack is at the left,
the first directory in the stack being the current directory.
I 16
.Pp
E 16
D 15
.HP 5
.BR echo " wordlist"
.br
.ns
.HP 5
.BR "echo \-n" " wordlist"
.br
E 15
I 15
D 18
.Dp Cx Ic echo
.Cx \&\ \&
.Ar  wordlist
.Cx
.Dp Cx Ic echo
.Cx \&\ \&
.Fl n
.Cx \&\ \&
.Ar wordlist
.Cx
E 18
I 18
.It Ic echo Ar  wordlist
.It Ic echo Fl n Ar wordlist
E 18
E 15
D 27
The specified words are written to the shells standard output, separated
E 27
I 27
The specified words are written to the shell's standard output, separated
E 27
by spaces, and terminated with a newline unless the
D 15
.B \-n
E 15
I 15
.Fl n
E 15
option is specified.
I 16
.Pp
E 16
D 15
.HP 5
.B  else
.br
.ns
.HP 5
.B  end
.br
.ns
.HP 5
.B  endif
.br
.ns
.HP 5
.B  endsw
.br
E 15
I 15
D 18
.Dp Ic else
.Dp Ic end
.Dp Ic endif
.Dp Ic endsw
E 18
I 18
.It Ic else
.It Ic end
.It Ic endif
.It Ic endsw
E 18
E 15
See the description of the
D 15
.I foreach,
.I if,
.I switch,
E 15
I 15
.Ic foreach ,
.Ic if ,
.Ic switch ,
E 15
and
D 15
.I while
E 15
I 15
.Ic while
E 15
statements below.
I 16
.Pp
E 16
D 15
.HP 5
.BR eval " arg ..."
.br
E 15
I 15
D 18
.Dp Cx Ic eval
.Cx \&\ \&
.Ar arg ...
.Cx
E 18
I 18
.It Ic eval Ar arg ...
E 18
E 15
(As in
D 15
.IR sh (1).)
E 15
I 15
.Xr sh  1  . )
E 15
The arguments are read as input to the shell and the resulting
D 2
command(s) executed.  This is usually used to execute commands
E 2
I 2
command(s) executed in the context of the current shell.
This is usually used to execute commands
E 2
generated as the result of command or variable substitution, since
parsing occurs before these substitutions.  See
D 15
.IR tset (1)
E 15
I 15
.Xr tset  1
E 15
for an example of using
D 2
.I eval.
E 2
I 2
D 15
.IR eval .
E 2
.HP 5
.BR exec " command"
.br
E 15
I 15
.Ic eval .
I 16
.Pp
E 16
D 18
.Dp Cx Ic exec
.Cx \&\ \&
.Ar command
.Cx
E 18
I 18
.It Ic exec Ar command
E 18
E 15
The specified command is executed in place of the current shell.
I 16
.Pp
E 16
D 15
.HP 5
.B  exit
.br
.ns
.HP 5
.BR exit (expr)
.br
E 15
I 15
D 18
.Dp Ic exit
.Dp Cx Ic exit
.Cx \&\ \&
.Ar (expr )
.Cx
E 18
I 18
.It Ic exit
.It Ic exit Ar (expr )
E 18
E 15
The shell exits either with the value of the
D 15
.I status
E 15
I 15
.Ic status
E 15
variable (first form) or with the value of the specified
D 15
.I  expr
E 15
I 15
.Ic expr
E 15
(second form).
I 16
.Pp
E 16
D 15
.HP 5
.B fg
.br
.ns
.HP 5
\fBfg\ %\fRjob\ ...
.br
E 15
I 15
D 18
.Dp Ic fg
.Dp Cx Ic fg \&%
.Ar job ...
.Cx
E 18
I 18
.It Ic fg
D 27
.It Ic fg \&% Ar job ...
E 27
I 27
.It Ic fg % Ns Ar job ...
E 27
E 18
E 15
Brings the current or specified jobs into the foreground, continuing them if
they were stopped.
I 16
.Pp
E 16
D 15
.HP 5
.BR foreach " name (wordlist)"
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
.B  end
.br
E 15
I 15
D 18
.Dp Cx Ic foreach
.Cx \&\ \&
.Ar name (wordlist)
.Cx
.Dp ...
.Dp Ic end
E 18
I 18
.It Ic foreach Ar name (wordlist)
.It ...
.It Ic end
E 18
E 15
The variable
D 15
.I name
E 15
I 15
.Ic name
E 15
is successively set to each member of
D 15
.I wordlist
E 15
I 15
.Ic wordlist
E 15
and the sequence of commands between this command and the matching
D 15
.I end
E 15
I 15
.Ic end
E 15
are executed.
(Both
D 15
.I foreach
E 15
I 15
.Ic foreach
E 15
and
D 15
.I end
E 15
I 15
.Ic end
E 15
must appear alone on separate lines.)
D 15
.IP
E 15
The builtin command
D 15
.I continue
E 15
I 15
.Ic continue
E 15
may be used to continue the loop prematurely and the builtin
command
D 15
.I break
E 15
I 15
.Ic break
E 15
to terminate it prematurely.
D 27
When this command is read from the terminal, the loop is read up once
E 27
I 27
When this command is read from the terminal, the loop is read once
E 27
prompting with `?' before any statements in the loop are executed.
If you make a mistake typing in a loop at the terminal you can rub it out.
I 16
.Pp
E 16
D 15
.HP 5
.BR glob " wordlist"
.br
E 15
I 15
D 18
.Dp Cx Ic glob
.Cx \&\ \&
.Ar wordlist
.Cx
E 18
I 18
.It Ic glob Ar wordlist
E 18
E 15
Like
D 15
.I echo
E 15
I 15
.Ic echo
E 15
but no `\e' escapes are recognized and words are delimited
by null characters in the output.
D 27
Useful for programs which wish to use the shell to filename expand a list
E 27
I 27
Useful for programs that wish to use the shell to filename expand a list
E 27
of words.
I 16
.Pp
E 16
D 15
.HP 5
.BR goto " word"
.br
E 15
I 15
D 18
.Dp Cx Ic goto
.Cx \&\ \&
.Ar word
.Cx
E 18
I 18
.It Ic goto Ar word
E 18
E 15
The specified
D 15
.I word
E 15
I 15
.Ic word
E 15
is filename and command expanded to yield a string of the form `label'.
The shell rewinds its input as much as possible
and searches for a line of the form `label:'
possibly preceded by blanks or tabs.
Execution continues after the specified line.
I 16
.Pp
E 16
D 15
.HP 5
.BR hashstat
.br
E 15
I 15
D 18
.Dp Ic hashstat
E 18
I 18
.It Ic hashstat
E 18
E 15
D 27
Print a statistics line indicating how effective the internal hash
E 27
I 27
Print a statistics line showing how effective the internal hash
E 27
table has been at locating commands (and avoiding
D 2
.I exec's).
E 2
I 2
D 15
.IR exec 's).
E 15
I 15
D 18
.Cx Ic exec
.Cx 's ) .
.Cx
E 18
I 18
.Ic exec Ns \'s ) .
E 18
E 15
E 2
An
D 15
.I exec
E 15
I 15
.Ic exec
E 15
is attempted for each component of the
D 15
.I path
E 15
I 15
.Em path
E 15
where the hash function indicates a possible hit, and in each component
D 27
which does not begin with a `/'.
E 27
I 27
that does not begin with a `/'.
E 27
I 16
.Pp
E 16
D 15
.HP 5
.B  history
.br
.ns
.HP 5
.BI history " n"
.br
.ns
.HP 5
.BI "history \-r" " n"
.br
I 2
.ns
.HP 5
.BI "history \-h" " n"
.br
E 2
Displays the history event list; if \fIn\fR is given only the
.I n
E 15
I 15
D 18
.Dp Ic history
.Dp Cx Ic history
.Cx \&\ \&
.Ar n
.Cx
.Dp Cx Ic history
.Cx \&\ \&
.Fl r
.Cx \&\ \&
.Ar n
.Cx
.Dp Cx Ic history
.Cx \&\ \&
.Fl h
.Cx \&\ \&
.Ar n
.Cx
E 18
I 18
.It Ic history
.It Ic history Ar n
.It Ic history Fl r Ar n
.It Ic history Fl h Ar n
E 18
Displays the history event list; if
.Ar n
is given only the
.Ar n
E 15
most recent events are printed.
The
D 15
.B \-r
E 15
I 15
.Fl r
E 15
option reverses the order of printout to be most recent first
D 27
rather than oldest first.
E 27
I 27
instead of oldest first.
E 27
I 2
The
D 15
.B \-h
E 15
I 15
.Fl h
E 15
option causes the history list to be printed without leading numbers.
D 27
This is used to produce files suitable for sourceing using the \-h
E 27
I 27
This format produces files suitable for sourcing using the \-h
E 27
option to
D 15
.IR source .
E 2
.HP 5
.BR if " (expr) command"
.br
E 15
I 15
.Ic source  .
I 16
.Pp
E 16
D 18
.Dp Cx Ic if
.Cx \&\ \&
.Cx \&(
.Ar expr
.Cx \&)
.Cx
.Ar command
E 18
I 18
D 29
.It Ic if Pq Ar expr No command
E 29
I 29
.It Ic if ( Ar expr ) No command
E 29
E 18
E 15
If the specified expression evaluates true, then the single
D 15
.I  command
E 15
I 15
.Ar command
E 15
with arguments is executed.
Variable substitution on
D 15
.IR command ""
E 15
I 15
.Ar command
E 15
happens early, at the same
time it does for the rest of the
D 15
.I if
command.
.I Command
E 15
I 15
.Ic if
D 18
.Ar command .
E 18
I 18
command.
E 18
.Ar Command
E 15
must be a simple command, not
a pipeline, a command list, or a parenthesized command list.
Input/output redirection occurs even if
D 15
.I expr
E 15
I 15
.Ar expr
E 15
D 27
is false, when command is
E 27
I 27
is false, i.e., when command is
E 27
D 15
.B not
E 15
I 15
.Sy not
E 15
executed (this is a bug).
I 16
.Pp
E 16
D 15
.HP 5
.BR if " (expr) " "then"
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
.BR else " " "if\fR (expr2) \fBthen"
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
.B  else
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
.B  endif
.br
E 15
I 15
D 18
.Dp Cx Ic if
.Cx \&\ \&
.Cx \&(
.Ar expr
.Cx \&)
.Cx \&\ \&
.Ar then 
.Cx
.Dp ...
.Dp Cx Ic else if
.Cx \&\ \&
.Cx \&(
.Ar expr2
.Cx \&)
.Cx \&\ \&
.Ic then
.Cx
.Dp ...
.Dp Ic else
.Dp ...
.Dp Ic endif
E 18
I 18
.It Ic if ( Ar expr ) Ic then
.It ...
.It Ic else if ( Ar expr2 ) Ic then
.It ...
.It Ic else
.It ...
.It Ic endif
E 18
E 15
If the specified
D 15
.IR expr ""
E 15
I 15
.Ar expr
E 15
D 27
is true then the commands to the first
E 27
I 27
is true then the commands up to the first
E 27
D 15
.I else
E 15
I 15
.Ic else
E 15
D 9
are executed; else if
E 9
I 9
are executed; otherwise if
E 9
D 15
.IR expr2 ""
E 15
I 15
.Ar expr2
E 15
D 27
is true then the commands to the
E 27
I 27
is true then the commands up to the
E 27
D 9
second else are executed, etc.
E 9
I 9
D 15
second \fIelse\fR are executed, etc.
E 15
I 15
second
.Ic else
are executed, etc.
E 15
E 9
Any number of
D 15
.I else-if
E 15
I 15
.Ic else-if
E 15
pairs are possible; only one
D 15
.I endif
E 15
I 15
.Ic endif
E 15
is needed.
The
D 15
.I else
E 15
I 15
.Ic else
E 15
part is likewise optional.
(The words
D 15
.I else
E 15
I 15
.Ic else
E 15
and
D 15
.I endif
E 15
I 15
.Ic endif
E 15
must appear at the beginning of input lines;
the
D 15
.I if
E 15
I 15
.Ic if
E 15
must appear alone on its input line or after an
D 15
.I else.)
.HP 5
.B jobs
.br
.ns
.HP 5
.B "jobs \-l"
.br
E 15
I 15
.Ic else . )
I 16
.Pp
E 16
D 18
.Dp Ic jobs
.Dp Cx Ic jobs
.Cx \&\ \&
.Fl l
.Cx
E 18
I 18
.It Ic jobs
.It Ic jobs Fl l
E 18
E 15
D 27
Lists the active jobs; given the
E 27
I 27
Lists the active jobs; the
E 27
D 15
.B \-l
E 15
I 15
.Fl l
E 15
D 27
options lists process id's in addition to the normal information.
E 27
I 27
option lists process id's in addition to the normal information.
E 27
I 16
.Pp
E 16
D 15
.HP 5
\fBkill %\fRjob
.br
.ns
.HP 5
\fBkill\ \-\fRsig\ \fB%\fRjob\ ...
.br
.ns
.HP 5
\fBkill\fR\ pid
.br
.ns
.HP 5
\fBkill\ \-\fRsig\ pid\ ...
.br
.ns
.HP 5
\fBkill\ \-l\fR
.br
E 15
I 15
D 18
.Dp Cx Ic kill  %
.Ar job
.Cx
.Dp Cx Ic kill
.Cx \&\ \&
.Ar pid
.Cx
.Dp Cx Ic kill
.Cx \&\ \&
.Fl sig
.Ar pid ...
.Cx
.Dp Cx Ic kill
.Cx \&\ \&
.Fl l
.Cx
E 18
I 18
D 27
.It Ic kill % Ar job
E 27
I 27
.It Ic kill % Ns Ar job
E 27
.It Ic kill Ar pid
.It Ic kill Fl sig Ar pid ...
.It Ic kill Fl l
E 18
E 15
Sends either the TERM (terminate) signal or the
specified signal to the specified jobs or processes.
Signals are either given by number or by names (as given in
D 15
.I /usr/include/signal.h,
E 15
I 15
.Pa /usr/include/signal.h,
E 15
stripped of the prefix ``SIG'').
The signal names are listed by ``kill \-l''.
D 27
There is no default, saying just `kill' does not
E 27
I 27
There is no default, just saying `kill' does not
E 27
send a signal to the current job.
If the signal being sent is TERM (terminate) or HUP (hangup),
then the job or process will be sent a CONT (continue) signal as well.
I 16
.Pp
E 16
D 15
.HP
\fBlimit\fR
.br
.ns
.HP 5
\fBlimit\fR \fIresource\fR
.br
.ns
.HP 5
\fBlimit\fR \fIresource\fR \fImaximum-use\fR
.br
I 3
.ns
.HP 5
\fBlimit\ \-h\fR
.br
.ns
.HP 5
\fBlimit\ \-h\fR \fIresource\fR
.br
.ns
.HP 5
\fBlimit\ \-h\fR \fIresource\fR \fImaximum-use\fR
.br
E 15
I 15
D 18
.Dp Ic limit
.Dp Cx Ic limit
.Cx \&\ \&
.Ar resource
.Cx
.Dp Cx Ic limit
.Cx \&\ \&
.Ar resource maximum-use
.Cx
.Dp Cx Ic limit
.Cx \&\ \&
.Fl h
.Cx
.Dp Cx Ic limit
.Cx \&\ \&
.Fl h
.Cx \&\ \&
.Ar resource
.Cx
.Dp Cx Ic limit
.Cx \&\ \&
.Fl h
.Cx \&\ \&
.Ar resource maximum-use
.Cx
E 18
I 18
.It Ic limit
.It Ic limit Ar resource
.It Ic limit Ar resource maximum-use
.It Ic limit Fl h
.It Ic limit Fl h Ar resource
.It Ic limit Fl h Ar resource maximum-use
E 18
E 15
E 3
Limits the consumption by the current process and each process
D 15
it creates to not individually exceed \fImaximum-use\fR on the
specified \fIresource\fR.  If no \fImaximum-use\fR is given, then
the current limit is printed; if no \fIresource\fR is given, then
D 3
all limitations are given.
E 3
I 3
all limitations are given.  If the \fB\-h\fR
E 15
I 15
it creates to not individually exceed
.Ar maximum-use
on the
specified
.Ar resource  .
If no
.Ar maximum-use
is given, then
the current limit is printed; if no
.Ar resource
is given, then
all limitations are given.  If the
.Fl h
E 15
flag is given, the hard limits are used instead of the current
limits.  The hard limits impose a ceiling on the values of
the current limits.  Only the super-user may raise the hard limits,
but a user may lower or raise the current limits within the legal range.
E 3
D 15
.IP
Resources controllable currently include \fIcputime\fR (the maximum
number of cpu-seconds to be used by each process), \fIfilesize\fR
(the largest single file which can be created), \fIdatasize\fR
E 15
I 15
.Pp
Resources controllable currently include
.Ar cputime
(the maximum
number of cpu-seconds to be used by each process),
.Ar filesize
D 27
(the largest single file which can be created),
E 27
I 27
(the largest single file that can be created),
E 27
.Ar datasize
E 15
(the maximum growth of the data+stack region via
D 15
.IR sbrk (2)
beyond the end of the program text), \fIstacksize\fR (the maximum
size of the automatically-extended stack region), and \fIcoredumpsize\fR
E 15
I 15
.Xr sbrk  2
beyond the end of the program text),
.Ar stacksize
(the maximum
size of the automatically-extended stack region), and
.Ar coredumpsize
E 15
(the size of the largest core dump that will be created).
I 31
.lp -1
.ne 1i
E 31
D 15
.IP
The \fImaximum-use\fR may be given as a (floating point or integer)
number followed by a scale factor.  For all limits other than \fIcputime\fR
E 15
I 15
.Pp
The
.Ar maximum-use
may be given as a (floating point or integer)
number followed by a scale factor.  For all limits other than
.Ar cputime
E 15
the default scale is `k' or `kilobytes' (1024 bytes);
a scale factor of `m' or `megabytes' may also be used.
For
D 15
.I cputime
E 15
I 15
.Ar cputime
E 15
D 27
the default scaling is `seconds', while `m' for minutes
E 27
I 27
the default scale is `seconds';
a scale factor of `m' for minutes
E 27
or `h' for hours, or a time of the form `mm:ss' giving minutes
D 27
and seconds may be used.
E 27
I 27
and seconds also may be used.
E 27
D 15
.IP
For both \fIresource\fR names and scale factors, unambiguous prefixes
E 15
I 15
.Pp
For both
.Ar resource
names and scale factors, unambiguous prefixes
E 15
of the names suffice.
I 16
.Pp
E 16
D 15
.HP 5
.B  login
.br
E 15
I 15
D 18
.Dp Ic login
E 18
I 18
.It Ic login
E 18
E 15
Terminate a login shell, replacing it with an instance of
D 15
.B /bin/login.
E 15
I 15
.Pa /bin/login.
E 15
This is one way to log off, included for compatibility with
D 15
.IR sh (1).
.HP 5
.B  logout
.br
E 15
I 15
.Xr sh  1  .
I 16
.Pp
E 16
D 18
.Dp Ic logout
E 18
I 18
.It Ic logout
E 18
E 15
Terminate a login shell.
Especially useful if
D 15
.I ignoreeof
E 15
I 15
.Ic ignoreeof
E 15
is set.
I 16
.Pp
E 16
D 15
.HP 5
D 2
.B  newgrp
.br
Changes the group identification of the caller; for details see
.IR newgrp (1).
A new shell is executed by
.I newgrp
so that the shell state is lost.
.HP 5
E 2
.B  nice
.br
.ns
.HP 5
D 10
.BR nice " \+number"
E 10
I 10
.BR nice " +number"
E 10
.br
.ns
.HP 5
.BR nice " command"
.br
.ns
.HP 5
D 10
.BR nice " \+number command"
E 10
I 10
.BR nice " +number command"
E 10
.br
E 15
I 15
D 18
.Dp Ic nice
.Dp Cx Ic nice
.Cx \&\ \&
.Ar +number
.Cx
.Dp Cx Ic nice
.Cx \&\ \&
.Ar command
.Cx
.Dp Cx Ic nice
.Cx \&\ \&
.Ar +number command
.Cx
E 18
I 18
.It Ic nice
.It Ic nice Ar +number
.It Ic nice Ar command
.It Ic nice Ar +number command
E 18
E 15
The first form sets the
D 8
.I nice
E 8
I 8
scheduling priority
E 8
for this shell to 4.
The second form sets the
D 8
.I nice
E 8
I 8
priority
E 8
D 16
to the given number.
E 16
I 16
to the given
.Ar number .
E 16
The final two forms run command at priority 4 and
D 15
.I number
E 15
I 15
.Ar number
E 15
respectively.
D 8
The super-user may specify negative niceness by using `nice \-number ...'.
E 8
I 8
The greater the number, the less cpu the process will get.
The super-user may specify negative priority by using `nice \-number ...'.
E 8
D 27
Command is always executed in a sub-shell, and the restrictions
E 27
I 27
.Ar Command
is always executed in a sub-shell, and the restrictions
E 27
D 7
place on commands in simple
E 7
I 7
placed on commands in simple
E 7
D 15
.I if
E 15
I 15
.Ic if
E 15
statements apply.
I 16
.Pp
E 16
D 15
.HP 5
.B  nohup
.br
.ns
.HP 5
.BR "nohup" " command"
.br
E 15
I 15
D 18
.Dp Ic nohup
.Dp Cx Ic nohup
.Cx \&\ \&
.Ar command
.Cx
E 18
I 18
.It Ic nohup
.It Ic nohup Ar command
E 18
E 15
The first form can be used in shell scripts to cause hangups to be
ignored for the remainder of the script.
The second form causes the specified command to be run with hangups
ignored.
All processes detached with `&' are effectively
D 15
.I nohup'ed.
.HP 5
.B notify
.br
.ns
.HP 5
\fBnotify\ %\fRjob\ ...
.br
E 15
I 15
D 18
.Cx Ic nohup
.Cx \'ed .
.Cx
E 18
I 18
.Ic nohup Ns \'ed .
E 18
I 16
.Pp
E 16
D 18
.Dp Ic notify
.Dp Cx Ic notify %
.Cx \&\ \&
.Ar job ...
.Cx
E 18
I 18
.It Ic notify
D 27
.It Ic notify % Ar job ...
E 27
I 27
.It Ic notify % Ns Ar job ...
E 27
E 18
E 15
Causes the shell to notify the user asynchronously when the status of the
D 27
current or specified jobs changes; normally notification is presented
E 27
I 27
current or specified jobs change; normally notification is presented
E 27
before a prompt.  This is automatic if the shell variable
D 15
.I notify
E 15
I 15
.Ic notify
E 15
is set.
I 16
.Pp
E 16
D 15
.HP 5
.B  onintr
.br
.ns
.HP 5
.BR onintr "  \-"
.br
.ns
.HP 5
.BR onintr "  label"
.br
E 15
I 15
D 18
.Dp Ic onintr
.Dp Cx Ic onintr
.Cx \&\ \&
.Fl
.Cx
.Dp Cx Ic onintr
.Cx \&\ \&
.Ar label
.Cx
E 18
I 18
.It Ic onintr
.It Ic onintr Fl
.It Ic onintr Ar label
E 18
E 15
Control the action of the shell on interrupts.
The first form restores the default action of the shell on interrupts
which is to terminate shell scripts or to return to the terminal command
input level.
The second form `onintr \-' causes all interrupts to be ignored.
The final form causes the shell to execute a `goto label' when
an interrupt is received or a child process terminates because
it was interrupted.
D 15
.IP
E 15
I 15
.Pp
E 15
In any case, if the shell is running detached and interrupts are
being ignored, all forms of
D 15
.I onintr
E 15
I 15
.Ic onintr
E 15
have no meaning and interrupts
continue to be ignored by the shell and all invoked commands.
I 21
Finally
.Ic onintr 
D 27
statemements are ignored in the system startup files where interrupts
E 27
I 27
statements are ignored in the system startup files where interrupts
E 27
are disabled (/etc/csh.cshrc, /etc/csh.login).
E 21
I 16
.Pp
E 16
D 15
.HP 5
.BR "popd"
.br
.ns
.HP 5
.BR "popd" " +n"
.br
E 15
I 15
D 18
.Dp Ic popd
.Dp Cx Ic popd
.Cx \&\ \&
.Ar +n
.Cx
E 18
I 18
.It Ic popd
.It Ic popd Ar +n
E 18
E 15
Pops the directory stack, returning to the new top directory.
D 9
With a argument `+\fIn\fR' discards the \fIn\fR\|th
E 9
I 9
D 15
With an argument `+\fIn\fR' discards the \fIn\fR\|th
E 15
I 15
With an argument
D 18
.Cx `+
.Ar n
.Cx \'
.Cx
E 18
I 18
.Ns \`+ Ar n Ns \'
E 18
discards the
D 18
.Cx Ar n
.Cx \'
.Cx th
.Cx
E 18
I 18
.Ar n Ns \'th
E 18
E 15
E 9
entry in the stack.
D 27
The elements of the directory stack are numbered from 0 starting at the top.
E 27
I 27
The members of the directory stack are numbered from the top starting at 0.
I 31
.ne 1i
E 31
E 27
I 16
.Pp
E 16
D 15
.HP 5
.BR "pushd"
.br
.ns
.HP 5
.BR "pushd" " name"
.br
.ns
.HP 5
.BR "pushd" " +n"
.br
E 15
I 15
D 18
.Dp Ic pushd
.Dp Cx Ic pushd
.Cx \&\ \&
.Ar name
.Cx
.Dp Cx Ic pushd
.Cx \&\ \&
.Ar n
.Cx
E 18
I 18
.It Ic pushd
.It Ic pushd Ar name
.It Ic pushd Ar n
E 18
E 15
With no arguments,
D 15
.I pushd
E 15
I 15
.Ic pushd
E 15
exchanges the top two elements of the directory stack.
Given a
D 15
.I name
E 15
I 15
.Ar name
E 15
argument,
D 15
.I pushd
E 15
I 15
.Ic pushd
E 15
changes to the new directory (ala
D 15
.I cd)
E 15
I 15
.Ic cd )
E 15
and pushes the old current working directory
(as in
D 15
.I csw)
E 15
I 15
.Ic csw )
E 15
onto the directory stack.
D 15
With a numeric argument, rotates the \fIn\fR\|th argument of the directory
E 15
I 15
D 27
With a numeric argument, rotates the
E 27
I 27
With a numeric argument,
.Ic pushd
rotates the
E 27
D 18
.Cx Ar n
.Cx \'
.Cx th
.Cx
E 18
I 18
.Ar n Ns \'th
E 18
argument of the directory
E 15
stack around to be the top element and changes to it.  The members
of the directory stack are numbered from the top starting at 0.
I 16
.Pp
E 16
D 15
.HP 5
.BR rehash
.br
E 15
I 15
D 18
.Dp Ic rehash
E 18
I 18
.It Ic rehash
E 18
E 15
Causes the internal hash table of the contents of the directories in
the
D 15
.I path
E 15
I 15
.Ic path
E 15
variable to be recomputed.  This is needed if new commands are added
to directories in the
D 15
.I path
E 15
I 15
.Ic path
E 15
while you are logged in.  This should only be necessary if you add
commands to one of your own directories, or if a systems programmer
D 27
changes the contents of one of the system directories.
E 27
I 27
changes the contents of a system directory.
E 27
I 16
.Pp
E 16
D 15
.HP 5
.BR repeat " count command"
.br
The specified 
.I command
E 15
I 15
D 18
.Dp Cx Ic repeat
.Cx \&\ \&
.Ar count command
.Cx
E 18
I 18
.It Ic repeat Ar count command
E 18
The specified
.Ar command
E 15
which is subject to the same restrictions
as the
D 15
.I command
E 15
I 15
.Ar command
E 15
in the one line
D 15
.I if
E 15
I 15
.Ic if
E 15
statement above,
is executed
D 15
.I count
E 15
I 15
.Ar count
E 15
times.
I/O redirections occur exactly once, even if
D 15
.I count
E 15
I 15
.Ar count
E 15
is 0.
I 16
.Pp
E 16
D 15
.HP 5
.B  set
.br
.ns
.HP 5
.BR set " name"
.br
.ns
.HP 5
.BR set " name=word"
.br
.ns
.HP 5
.BR set " name[index]=word"
.br
.ns
.HP 5
.BR set " name=(wordlist)"
.br
E 15
I 15
D 18
.Dp Ic set
.Dp Cx Ic set
.Cx \&\ \&
.Ar name
.Cx
.Dp Cx Ic set
.Cx \&\ \&
.Ar name=word
.Cx
.Dp Cx Ic set
.Cx \&\ \&
.Ar name
.Op index
.Ar =word
.Cx
.Dp Cx Ic set
.Cx \&\ \&
.Ar name=(wordlist)
.Cx
E 18
I 18
.It Ic set
.It Ic set Ar name
.It Ic set Ar name Ns =word
.It Ic set Ar name[index] Ns =word
.It Ic set Ar name Ns =(wordlist)
E 18
E 15
The first form of the command shows the value of all shell variables.
D 27
Variables which have other than a single word as value print as a parenthesized
word list.
E 27
I 27
Variables that have other than a single word as their
value print as a parenthesized word list.
E 27
The second form sets
D 15
.I name
E 15
I 15
D 27
.Ic name
E 27
I 27
.Ar name
E 27
E 15
to the null string.
The third form sets
D 15
.I name
E 15
I 15
D 27
.Ic name
E 27
I 27
.Ar name
E 27
E 15
to the single
D 15
.I word.
E 15
I 15
D 27
.Ic word .
E 27
I 27
.Ar word .
E 27
E 15
The fourth form sets
the
D 15
.I index'th
E 15
I 15
D 18
.Cx Ar index
.Cx \'th
.Cx
E 18
I 18
.Ar index Ns 'th
E 18
E 15
D 27
component of name to word;
E 27
I 27
component of
.Ar name
to
.Ar word ;
E 27
this component must already exist.
The final form sets
D 15
.I name
E 15
I 15
.Ar name
E 15
to the list of words in
D 15
.I wordlist.
E 15
I 15
.Ar wordlist .
E 15
D 27
In all cases the value is command and filename expanded.
E 27
I 27
The value is always command and filename expanded.
E 27
D 15
.IP
E 15
I 15
.Pp
E 15
These arguments may be repeated to set multiple values in a single set command.
Note however, that variable expansion happens for all arguments before any
setting occurs.
I 16
.Pp
E 16
D 15
.HP 5
I 4
.BR setenv
.br
.ns
.HP 5
E 4
.BR setenv " name value"
.br
D 4
Sets the value of environment variable
E 4
I 4
.ns
.HP 5
.BR setenv " name"
.br
E 15
I 15
D 18
.Dp Ic setenv
.Dp Cx Ic setenv
.Cx \&\ \&
.Ar name value
.Cx
.Dp Cx Ic setenv
.Cx \&\ \&
.Ar name
.Cx
E 18
I 18
.It Ic setenv
D 27
.It Ic setenv Ar name value
E 27
.It Ic setenv Ar name
I 27
.It Ic setenv Ar name value
E 27
E 18
E 15
The first form lists all current environment variables.
I 27
It is equivalent to
.Xr printenv 1 .
E 27
The last form sets the value of environment variable
E 4
D 15
.I name
E 15
I 15
.Ar name
E 15
to be
D 15
.I value,
E 15
I 15
.Ar value ,
E 15
D 4
a single string.
E 4
I 4
a single string.  The second form sets
D 15
.I name
E 15
I 15
.Ar name
E 15
to an empty string.
E 4
D 16
The most commonly used environment variable USER, TERM, and PATH
E 16
I 16
D 27
The most commonly used environment variable
E 27
I 27
The most commonly used environment variables
E 27
.Ev USER ,
.Ev TERM ,
and
.Ev PATH
E 16
are automatically imported to and exported from the
D 15
.I csh
E 15
I 15
.Nm csh
E 15
variables
D 15
.I user,
.I term,
E 15
I 15
.Ar user ,
D 27
.Op Ar term ,
E 27
I 27
.Ar term ,
E 27
E 15
and
D 15
.I path;
E 15
I 15
.Ar path ;
E 15
there is no need to use
D 15
.I setenv
E 15
I 15
.Ic setenv
E 15
for these.
I 16
.Pp
E 16
D 15
.HP 5
.B  shift
.br
.ns
.HP 5
.BR shift " variable"
.br
E 15
I 15
D 18
.Dp Ic shift
.Dp Cx Ic shift
.Cx \&\ \&
.Ar variable
.Cx
E 18
I 18
.It Ic shift
.It Ic shift Ar variable
E 18
E 15
The members of
D 15
.I argv
E 15
I 15
.Ic argv
E 15
are shifted to the left, discarding
D 15
.I argv[1].
E 15
I 15
D 18
.Cx Ic argv
.Op 1  .
.Cx
E 18
I 18
D 27
.Ic argv Bq 1 .
E 27
I 27
.Ic argv Ns Bq 1 .
E 27
E 18
E 15
It is an error for
D 15
.I argv
E 15
I 15
.Ic argv
E 15
not to be set or to have less than one word as value.
The second form performs the same function on the specified variable.
I 16
.Pp
E 16
D 15
.HP 5
.BR source " name"
.br
I 2
.ns
.HP 5
.BR "source \-h" " name"
.br
E 15
I 15
D 18
.Dp Cx Ic source
.Cx \&\ \&
.Ar name
.Cx
.Dp Cx Ic source
.Cx \&\ \&
.Fl h
.Cx \&\ \&
.Ar name
.Cx
E 18
I 18
.It Ic source Ar name
.It Ic source Fl h Ar name
I 31
.pl -1
E 31
E 18
E 15
E 2
The shell reads commands from
D 15
.I name.
.I Source
E 15
I 15
D 27
.Ic name .
E 27
I 27
.Ar name .
E 27
.Ic Source
E 15
commands may be nested; if they are nested too deeply the shell may
run out of file descriptors.
An error in a
D 15
.I source
E 15
I 15
.Ic source
E 15
at any level terminates all nested
D 15
.I source
E 15
I 15
.Ic source
E 15
commands.
D 2
Input during 
E 2
I 2
D 15
Normally input during 
E 2
.I source
E 15
I 15
Normally input during
.Ic source
E 15
D 2
commands is
.B never
placed on the history list.
E 2
I 2
commands is not placed on the history list;
D 27
the \-h option causes the commands to be placed in the
E 27
I 27
the \-h option causes the commands to be placed on the
E 27
history list without being executed.
I 16
.Pp
E 16
E 2
D 15
.HP 5
.B stop
.br
.ns
.HP 5
\fBstop\ %\fRjob\ ...
.br
E 15
I 15
D 18
.Dp Ic stop
.Dp Cx Ic stop %
.Ar job ...
.Cx
E 18
I 18
.It Ic stop
.It Ic stop % Ns Ar job ...
E 18
E 15
D 27
Stops the current or specified job which is executing in the background.
E 27
I 27
Stops the current or specified jobs that are executing in the background.
E 27
I 16
.Pp
E 16
D 15
.HP 5
.B suspend
.br
.ns
E 15
I 15
D 18
.Dp Ic suspend
E 18
I 18
.It Ic suspend
E 18
E 15
Causes the shell to stop in its tracks, much as if it had been sent a stop
D 15
signal with \fB^Z\fR.  This is most often used to stop shells started by
.IR su (1).
.HP 5
.BR switch " (string)"
.br
.ns
.HP 5
.BR case " str1:"
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
\   
.B  breaksw
.br
.ns
.HP 5
\&...
.br
.ns
.HP 5
.B  default:
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
\   
.B  breaksw
.br
.ns
.HP 5
.B  endsw
.br
E 15
I 15
signal with
.Ic ^Z .
This is most often used to stop shells started by
D 16
.Xr su  1  .
E 16
I 16
.Xr su  1 .
.Pp
E 16
D 18
.Dp Cx Ic switch
.Cx \&\ \&
.Ar (string)
.Cx
.Dp Cx Ic case
.Cx \&\ \&
.Ar str1 :
.Cx
.Dp \&...
.Dp Ic breaksw
.Dp \&...
.Dp Ic default :
.Dp \&...
.Dp Ic breaksw
.Dp Ic endsw
E 18
I 18
.It Ic switch Ar (string)
.It Ic case Ar str1 :
.It \ \ \ \ \&...
.It Ic \ \ \ \ breaksw
.It \ \ \ \ \&...
.It Ic default :
.It \ \ \ \ \&...
.It Ic \ \ \ \ breaksw
.It Ic endsw
E 18
E 15
D 27
Each case label is successively matched, against the specified
E 27
I 27
Each case label is successively matched against the specified
E 27
D 15
.I string
E 15
I 15
.Ar string
E 15
which is first command and filename expanded.
D 15
The file metacharacters `*', `?' and `[...]' may be used in the case labels,
E 15
I 15
D 16
The file metacharacters `*', `?' and
.Cx \&\ \&
.Op \&...
.Cx \'
.Cx
E 16
I 16
The file metacharacters `*', `?' and `[...]'
E 16
may be used in the case labels,
E 15
which are variable expanded.
D 27
If none of the labels match before a `default' label is found, then
E 27
I 27
If none of the labels match before the `default' label is found, then
E 27
the execution begins after the default label.
Each case label and the default label must appear at the beginning of a line.
D 15
The command 
.I breaksw
E 15
I 15
The command
.Ic breaksw
E 15
causes execution to continue after the
D 15
.I endsw.
E 15
I 15
.Ic endsw .
E 15
D 27
Otherwise control may fall through case labels and default labels as in C.
E 27
I 27
Otherwise control may fall through case labels and the default label as in C.
E 27
If no label matches and there is no default, execution continues after
the
D 15
.I endsw.
.HP 5
.B  time
.br
.ns
.HP 5
.BR time " command"
.br
E 15
I 15
.Ic endsw .
I 16
.Pp
E 16
D 18
.Dp Ic time
.Dp Cx Ic time
.Cx \&\ \&
.Ar command
.Cx
E 18
I 18
.It Ic time
.It Ic time Ar command
E 18
E 15
With no argument, a summary of time used by this shell and its children
is printed.
If arguments are given
the specified simple command is timed and a time summary
as described under the
D 15
.I time
E 15
I 15
.Ic time
E 15
D 2
variable is printed.
If necessary, an extra shell is created to print the time
E 2
I 2
variable is printed.  If necessary, an extra shell is created to print the time
E 2
statistic when the command completes.
I 16
.Pp
E 16
D 15
.HP 5
.B umask
.br
.ns
.HP 5
.BR umask " value"
.br
E 15
I 15
D 18
.Dp Ic umask
.Dp Cx Ic umask
.Cx \&\ \&
.Ar value
.Cx
E 18
I 18
.It Ic umask
.It Ic umask Ar value
E 18
E 15
The file creation mask is displayed (first form) or set to the specified
value (second form).  The mask is given in octal.  Common values for
the mask are 002 giving all access to the group and read and execute
D 27
access to others or 022 giving all access except no write access for
E 27
I 27
access to others or 022 giving all access except write access for
E 27
users in the group or others.
I 16
.Pp
E 16
D 15
.HP 5
.BR unalias " pattern"
.br
E 15
I 15
D 18
.Dp Cx Ic unalias
.Cx \&\ \&
.Ar pattern
.Cx
E 18
I 18
.It Ic unalias Ar pattern
E 18
E 15
All aliases whose names match the specified pattern are discarded.
Thus all aliases are removed by `unalias *'.
It is not an error for nothing to be
D 15
.I unaliased.
.HP 5
.BR unhash
.br
E 15
I 15
.Ic unaliased .
I 16
.Pp
E 16
D 18
.Dp Ic unhash
E 18
I 18
.It Ic unhash
E 18
E 15
Use of the internal hash table to speed location of executed programs
is disabled.
I 16
.Pp
E 16
D 15
.HP 5
I 3
\fBunlimit\fR
.br
.ns
.HP 5
E 3
\fBunlimit\fR \fIresource\fR
.br
.ns
.HP 5
D 3
\fBunlimit\fR
E 3
I 3
\fBunlimit\ \-h\fR
E 3
.br
I 3
.ns
.HP 5
\fBunlimit\ \-h\fR \fIresource\fR
.br
E 3
Removes the limitation on \fIresource\fR.  If no \fIresource\fR
D 3
is specified, then all \fIresource\fR limitations are removed.
E 3
I 3
is specified, then all \fIresource\fR limitations are removed.  If
\fB\-h\fR is given, the corresponding hard limits are removed.  Only the
E 15
I 15
D 18
.Dp Ic unlimit
.Dp Cx Ic unlimit
.Cx \&\ \&
.Ar  resource
.Cx
.Dp Cx Ic unlimit 
.Cx \&\ \&
.Fl h
.Cx
.Dp Cx Ic unlimit 
.Cx \&\ \&
.Fl h
.Cx \&\ \&
.Ar resource
.Cx
E 18
I 18
.It Ic unlimit
.It Ic unlimit Ar  resource
.It Ic unlimit Fl h
.It Ic unlimit Fl h Ar resource
E 18
Removes the limitation on
.Ar resource  .
If no
.Ar resource
is specified, then all
.Ar resource
limitations are removed.  If
.Fl h
is given, the corresponding hard limits are removed.  Only the
E 15
super-user may do this.
I 16
.Pp
E 16
E 3
D 15
.HP 5
.BR unset " pattern"
.br
E 15
I 15
D 18
.Dp Cx Ic unset
.Cx \&\ \&
.Ar pattern 
.Cx
E 18
I 18
.It Ic unset Ar pattern
E 18
E 15
All variables whose names match the specified pattern are removed.
Thus all variables are removed by `unset *'; this has noticeably
distasteful side-effects.
It is not an error for nothing to be
D 15
.I unset.
.HP 5
.BR unsetenv " pattern"
.br
E 15
I 15
.Ic unset .
I 16
.Pp
E 16
D 18
.Dp Cx Ic unsetenv
.Cx \&\ \&
.Ar pattern
.Cx
E 18
I 18
.It Ic unsetenv Ar pattern
E 18
E 15
Removes all variables whose name match the specified pattern from the
environment.  See also the
D 15
.I setenv
E 15
I 15
.Ic setenv
E 15
command above and
D 15
.IR printenv (1).
.HP 5
.B  wait
.br
E 15
I 15
.Xr printenv  1  .
I 16
.Pp
E 16
D 18
.Dp Ic wait
E 18
I 18
.It Ic wait
E 18
E 15
D 27
All background jobs are waited for.
It the shell is interactive, then an interrupt can disrupt the wait,
at which time the shell prints names and job numbers of all jobs
E 27
I 27
Wait for all background jobs.
If the shell is interactive, then an interrupt can disrupt the wait.
After the interrupt, the shell prints names and job numbers of all jobs
E 27
known to be outstanding.
I 21
D 27
.It Ic which (command)
E 27
I 27
.It Ic which Ar command
E 27
Displays the resolved command that will be executed by the shell.
E 21
I 16
.Pp
E 16
D 15
.HP 5
.BR while " (expr)"
.br
.ns
.HP 5
\    ...
.br
.ns
.HP 5
.B  end
.br
E 15
I 15
D 18
.Dp Cx Ic while
.Cx \&\ \&
.Ar (expr)
.Cx
.Dp \&...
.Dp Ic end
E 18
I 18
.It Ic while Ar (expr)
.It \&...
.It Ic end
E 18
E 15
While the specified expression evaluates non-zero, the commands between
the
D 15
.I while
E 15
I 15
.Ic while
E 15
D 27
and the matching end are evaluated.
E 27
I 27
and the matching
.Ic end
are evaluated.
E 27
D 15
.I Break
E 15
I 15
.Ic Break
E 15
and
D 15
.I continue
E 15
I 15
.Ic continue
E 15
may be used to terminate or continue the loop prematurely.
(The
D 15
.I while
E 15
I 15
.Ic while
E 15
and
D 15
.I end
E 15
I 15
.Ic end
E 15
must appear alone on their input lines.)
Prompting occurs here the first time through the loop as for the
D 15
.I foreach
E 15
I 15
.Ic foreach
E 15
statement if the input is a terminal.
I 16
.Pp
E 16
D 15
.HP 5
\fB%\fRjob
.br
E 15
I 15
D 18
.Dp Cx Ic %
.Cx \&\ \&
.Ar job
.Cx
E 18
I 18
D 27
.It Ic % Ar job
E 27
I 27
.It Ic % Ns Ar job
E 27
E 18
E 15
Brings the specified job into the foreground.
I 16
.Pp
E 16
D 15
.HP 5
\fB%\fRjob \fB&\fR
.br
E 15
I 15
D 18
.Dp Cx Ic %
.Cx \&\ \&
.Ar job
.Cx \&\ \&
.Ic &
.Cx
E 18
I 18
D 27
.It Ic % Ar job Ic &
E 27
I 27
.It Ic % Ns Ar job Ic &
E 27
E 18
E 15
Continues the specified job in the background.
I 16
.Pp
E 16
D 15
.HP 5
.B "@"
.br
.ns
.HP 5
.BR "@" " name = expr"
.br
.ns
.HP 5
.BR "@" " name[index] = expr"
.br
E 15
I 15
D 18
.Dp Ic @
.Dp Cx Ic @
.Cx \&\ \&
.Ar name = expr
.Cx
.Dp Cx Ic @
.Cx \&\ \&
.Ar name
.Op index
.Cx\&\ = expr
.Cx
E 18
I 18
.It Ic @
.It Ic @ Ns Ar name Ns = expr
.It Ic @ Ns Ar name[index] Ns = expr
E 18
E 15
The first form prints the values of all the shell variables.
The second form sets the specified
D 15
.I name
E 15
I 15
.Ar name
E 15
to the value of
D 15
.I expr.
If the expression contains `<', `>', `&' or `|' then at least
E 15
I 15
.Ar expr .
D 27
If the expression contains `<', `>', `&' or `' then at least
E 27
I 27
If the expression contains `<', `>', `&' or `|' then at least
E 27
E 15
this part of the expression must be placed within `(' `)'.
The third form assigns the value of
D 15
.I expr
E 15
I 15
.Ar expr
E 15
to the
D 15
.I index'th
E 15
I 15
D 18
.Cx Ar index
.Cx \'th
.Cx
E 18
I 18
.Ar index Ns 'th
E 18
E 15
argument of
D 15
.I name.
Both 
.I name
E 15
I 15
.Ar name .
Both
.Ar name
E 15
and its
D 15
.I index'th
E 15
I 15
D 18
.Cx Ar index
.Cx \'th
.Cx
E 18
I 18
.Ar index Ns 'th
E 18
E 15
component must already exist.
D 15
.IP
E 15
I 15
D 18
.Cx \&\ \&
.Dp
E 18
I 18
.El
E 18
.Pp
E 15
The operators `*=', `+=', etc are available as in C.
The space separating the name from the assignment operator is optional.
Spaces are, however, mandatory in separating components of
D 15
.I expr
E 15
I 15
.Ar expr
E 15
which would otherwise be single words.
D 15
.IP
D 2
Special postfix `++' and `\-\-' operators increment and decrement
E 2
I 2
Special postfix `++' and `\-\|\-' operators increment and decrement
E 2
.I name
E 15
I 15
.Pp
D 16
Special postfix `++' and `\-\\-' operators increment and decrement
E 16
I 16
D 27
Special postfix `++' and `\-\-' operators increment and decrement
E 27
I 27
Special postfix `+\|+' and `\-\|\-' operators increment and decrement
E 27
E 16
.Ar name
E 15
D 27
respectively, i.e. `@  i++'.
E 27
I 27
respectively, i.e., `@  i++'.
E 27
D 15
.sh "Pre-defined and environment variables"
E 15
I 15
.Ss Pre-defined and environment variables
E 15
The following variables have special meaning to the shell.
Of these,
D 15
.I argv,
.I cwd,
.I home,
.I path,
.I prompt,
.I shell
E 15
I 15
.Ar argv ,
.Ar cwd,
.Ar home ,
.Ar path,
.Ar prompt ,
.Ar shell
E 15
and
D 15
.I status
E 15
I 15
.Ar status
E 15
are always set by the shell.
Except for
D 15
.I cwd
E 15
I 15
.Ar cwd
E 15
and
D 15
.I status
E 15
I 15
D 27
.Ar status
E 27
I 27
.Ar status ,
E 27
E 15
this setting occurs only at initialization;
D 27
these variables will not then be modified unless this is done
E 27
I 27
these variables will not then be modified unless done
E 27
explicitly by the user.
D 15
.PP
E 15
I 15
.Pp
E 15
D 16
This shell copies the environment variable USER into the variable
E 16
I 16
D 27
This shell copies the environment variable
E 27
I 27
The shell copies the environment variable
E 27
.Ev USER
into the variable
E 16
D 15
.I user,
E 15
I 15
.Ar user ,
E 15
D 16
TERM into
E 16
I 16
.Ev TERM
into
E 16
D 15
.I term,
E 15
I 15
.Ar term ,
E 15
and
D 16
HOME into
E 16
I 16
.Ev HOME
into
E 16
D 15
.I home,
E 15
I 15
.Ar home ,
E 15
and copies these back into the environment whenever the normal
shell variables are reset.
D 16
The environment variable PATH is likewise handled; it is not
E 16
I 16
The environment variable
.Ev PATH
is likewise handled; it is not
E 16
necessary to worry about its setting other than in the file
D 15
.I \&.cshrc
E 15
I 15
D 16
.Ar \& .cshrc
E 16
I 16
.Ar \&.cshrc
E 16
E 15
as inferior
D 15
.I csh
E 15
I 15
.Nm csh
E 15
processes will import the definition of
D 15
.I path
E 15
I 15
.Ar path
E 15
from the environment, and re-export it if you then change it.
I 31
.ne 1i
E 31
D 2
(It could be set once in the
.I \&.login
except that commands through
.IR net (1)
would not see the definition.)
E 2
D 15
.TP 15
.B argv
\c
E 15
I 15
D 18
.Tp Ic argv
E 18
I 18
.Bl -tag -width histchars
.It Ic argv
E 18
E 15
Set to the arguments to the shell, it is from this variable that
D 27
positional parameters are substituted, i.e. `$1' is replaced by
E 27
I 27
positional parameters are substituted, i.e., `$1' is replaced by
E 27
D 15
`$argv[1]', etc.
.TP 15
.B cdpath
\c
E 15
I 15
D 16
.Cx $argv
.Op 1
.Cx \' ,
.Cx
E 16
I 16
`$argv[1]',
E 16
etc.
D 18
.Tp Ic cdpath
E 18
I 18
.It Ic cdpath
E 18
E 15
Gives a list of alternate directories searched to find subdirectories
in
D 15
.I chdir
E 15
I 15
.Ar chdir
E 15
commands.
D 15
.TP 15
.B cwd
E 15
I 15
D 18
.Tp Ic cwd
E 18
I 18
.It Ic cwd
E 18
E 15
The full pathname of the current directory.
D 15
.TP 15
.B echo
\c
E 15
I 15
D 18
.Tp Ic echo
E 18
I 18
.It Ic echo
E 18
E 15
Set when the
D 15
.B \-x
E 15
I 15
.Fl x
E 15
command line option is given.
Causes each command and its arguments
to be echoed just before it is executed.
For non-builtin commands all expansions occur before echoing.
Builtin commands are echoed before command and filename substitution,
since these substitutions are then done selectively.
D 15
.TP 15
I 5
.B filec
E 15
I 15
D 18
.Tp Ic filec
E 18
I 18
.It Ic filec
E 18
E 15
Enable file name completion.
D 15
\c
.TP 15
E 5
.B histchars
\c
E 15
I 15
D 18
.Tp Ic histchars
E 18
I 18
.It Ic histchars
E 18
E 15
Can be given a string value to change the characters used in history
substitution.  The first character of its value is used as the
D 16
history substitution character, replacing the default character !.
The second character of its value replaces the character \(ua in
E 16
I 16
history substitution character, replacing the default character `!'.
The second character of its value replaces the character `\(ua' in
E 16
quick substitutions.
I 25
.It Ic histfile
Can be set to the pathname where history is going to be saved/restored.
E 25
D 15
.TP 15
.B history
\c
E 15
I 15
D 18
.Tp Ic history
E 18
I 18
.It Ic history
E 18
E 15
Can be given a numeric value to control the size of the history list.
D 27
Any command which has been referenced in this many events will not be
E 27
I 27
Any command that has been referenced in this many events will not be
E 27
discarded.
Too large values of
D 15
.I history
E 15
I 15
.Ar history
E 15
may run the shell out of memory.
The last executed command is always saved on the history list.
D 15
.TP 15
.B home
\c
E 15
I 15
D 18
.Tp Ic home
E 18
I 18
.It Ic home
E 18
E 15
The home directory of the invoker, initialized from the environment.
D 15
The filename expansion of `\fB~\fR' refers to this variable.
.TP 15
.B ignoreeof
\c
E 15
I 15
The filename expansion of
D 18
.Cx `
.Pa ~
.Cx \'
.Cx
E 18
I 18
.Sq Pa ~
E 18
refers to this variable.
D 18
.Tp Ic ignoreeof
E 18
I 18
.It Ic ignoreeof
E 18
E 15
If set the shell ignores
end-of-file from input devices which are terminals.
This prevents shells from accidentally being killed by control-D's.
D 15
.TP 15
.B mail
\c
E 15
I 15
D 18
.Tp Ic mail
E 18
I 18
.It Ic mail
E 18
E 15
The files where the shell checks for mail.
D 27
This is done after each command completion which will result in a prompt,
E 27
I 27
This checking is done after each command completion that will
result in a prompt,
E 27
if a specified interval has elapsed.
The shell says `You have new mail.'
if the file exists with an access time not greater than its modify time.
D 15
.IP
E 15
I 15
.Pp
E 15
If the first word of the value of
D 15
.I mail
E 15
I 15
.Ar mail
E 15
is numeric it specifies a different mail checking interval, in seconds,
than the default, which is 10 minutes.
D 15
.IP
E 15
I 15
.Pp
E 15
If multiple mail files are specified, then the shell says
`New mail in
D 15
.IR name '
E 15
I 15
D 18
.Cx Ar name
.Cx \'
.Cx
E 18
I 18
.Ar name Ns '
E 18
E 15
when there is mail in the file
D 15
.I name.
.TP 15
.B noclobber
\c
E 15
I 15
.Ar name .
D 18
.Tp Ic noclobber
E 18
I 18
.It Ic noclobber
E 18
E 15
As described in the section on
D 15
.I Input/output,
E 15
I 15
D 18
.Ar Input/output ,
E 18
I 18
D 27
.Sx Input/output ,
E 27
I 27
.Sx input/output ,
E 27
E 18
E 15
restrictions are placed on output redirection to insure that
files are not accidentally destroyed, and that `>>' redirections
refer to existing files.
D 15
.TP 15
.B noglob
\c
E 15
I 15
D 18
.Tp Ic noglob
E 18
I 18
.It Ic noglob
E 18
E 15
If set, filename expansion is inhibited.
D 27
This is most useful in shell scripts which are not dealing with filenames,
E 27
I 27
This inhibition is most useful in shell scripts that
 are not dealing with filenames,
E 27
or after a list of filenames has been obtained and further expansions
are not desirable.
D 15
.TP 15
.B nonomatch
\c
E 15
I 15
D 18
.Tp Ic nonomatch
E 18
I 18
.It Ic nonomatch
E 18
E 15
If set, it is not an error for a filename expansion to not match any
D 27
existing files; rather the primitive pattern is returned.
It is still an error for the primitive pattern to be malformed, i.e.
E 27
I 27
existing files; instead the primitive pattern is returned.
It is still an error for the primitive pattern to be malformed, i.e.,
E 27
D 15
`echo [' still gives an error.
.TP 15
.B notify
\c
E 15
I 15
`echo ['
still gives an error.
D 18
.Tp Ic notify
E 18
I 18
.It Ic notify
E 18
E 15
D 27
If set, the shell notifies asynchronously of job completions.  The
default is to rather present job completions just before printing
E 27
I 27
If set, the shell notifies asynchronously of job completions;
the default is to present job completions just before printing
E 27
a prompt.
D 15
.TP 15
.B path
\c
E 15
I 15
D 18
.Tp Ic path
E 18
I 18
.It Ic path
E 18
E 15
Each word of the path variable specifies a directory in which
commands are to be sought for execution.
A null word specifies the current directory.
If there is no
D 15
.I path
E 15
I 15
.Ar path
E 15
variable then only full path names will execute.
The usual search path is `.', `/bin' and `/usr/bin', but this
may vary from system to system.
For the super-user the default search path is `/etc', `/bin' and `/usr/bin'.
D 27
A shell which is given neither the
E 27
I 27
A shell that is given neither the
E 27
D 15
.B \-c
E 15
I 15
.Fl c
E 15
nor the
D 15
.B \-t
E 15
I 15
.Fl t
E 15
option will normally hash the contents of the directories in the
D 15
.I path
E 15
I 15
.Ar path
E 15
variable after reading
D 15
.I \&.cshrc,
E 15
I 15
D 16
.Ar \& .cshrc ,
E 16
I 16
.Ar \&.cshrc ,
E 16
E 15
and each time the
D 15
.I path
E 15
I 15
.Ar path
E 15
variable is reset.  If new commands are added to these directories
D 18
while the shell is active, it may be necessary to give the
D 15
.I rehash
E 15
I 15
.Ar rehash
E 18
I 18
while the shell is active, it may be necessary to do a
.Ic rehash
E 18
E 15
or the commands may not be found.
D 15
.TP 15
.B prompt
\c
E 15
I 15
D 18
.Tp Ic prompt
E 18
I 18
.It Ic prompt
E 18
E 15
D 27
The string which is printed before each command is read from
E 27
I 27
The string that is printed before each command is read from
E 27
an interactive terminal input.
If a `!' appears in the string it will be replaced by the current event number
unless a preceding `\e' is given.
Default is `% ', or `# ' for the super-user.
D 15
.TP 15
I 2
.B savehist
\c
E 15
I 15
D 18
.Tp Ic savehist
E 18
I 18
.It Ic savehist
E 18
E 15
D 16
is given a numeric value to control the number of entries of the
E 16
I 16
Is given a numeric value to control the number of entries of the
E 16
history list that are saved in ~/.history when the user logs out.
D 27
Any command which has been referenced in this many events will be saved.
E 27
I 27
Any command that has been referenced in this many events will be saved.
E 27
During start up the shell sources ~/.history into the history list
enabling history to be saved across logins.
Too large values of
D 15
.I savehist
E 15
I 15
.Ar savehist
E 15
will slow down the shell during start up.
I 25
If
.Ar savehist
is just set, the shell will use the value of
.Ar history.
E 25
D 15
.TP 15
E 2
.B shell
\c
E 15
I 15
D 18
.Tp Ic shell
E 18
I 18
.It Ic shell
E 18
E 15
The file in which the shell resides.
D 27
This is used in forking shells to interpret files which have execute
E 27
I 27
This variable is used in forking shells to interpret files that have execute
E 27
bits set, but which are not executable by the system.
(See the description of
D 15
.I "Non-builtin Command Execution"
E 15
I 15
D 18
.Em Non-builtin Command Execution
E 18
I 18
.Sx Non-builtin Command Execution
E 18
E 15
below.)
Initialized to the (system-dependent) home of the shell.
D 15
.TP 15
.B status
\c
E 15
I 15
D 18
.Tp Ic status
E 18
I 18
.It Ic status
E 18
E 15
The status returned by the last command.
If it terminated abnormally, then 0200 is added to the status.
D 27
Builtin commands which fail return exit status `1',
all other builtin commands set status `0'.
E 27
I 27
Builtin commands that fail return exit status `1',
all other builtin commands set status to `0'.
E 27
D 15
.TP 15
.B time
\c
E 15
I 15
D 18
.Tp Ic time
E 18
I 18
.It Ic time
E 18
E 15
Controls automatic timing of commands.
D 27
If set, then any command which takes more than this many cpu seconds
E 27
I 27
If set, then any command that takes more than this many cpu seconds
E 27
will cause a line giving user, system, and real times and a utilization
percentage which is the ratio of user plus system times to real time
to be printed when it terminates.
D 15
.TP 15
.B verbose
\c
E 15
I 15
D 18
.Tp Ic verbose
E 18
I 18
.It Ic verbose
E 18
E 15
Set by the
D 15
.B \-v
E 15
I 15
.Fl v
E 15
command line option, causes the words of each command to be printed
after history substitution.
D 15
.sh "Non-builtin command execution"
E 15
I 15
D 18
.Tp
E 18
I 18
.El
E 18
.Ss Non-builtin command execution
E 15
When a command to be executed is found to not be a builtin command
the shell attempts to execute the command via
D 2
.IR  exec (2).
E 2
I 2
D 15
.IR  execve (2).
E 15
I 15
.Xr execve  2  .
E 15
E 2
Each word in the variable
D 15
.I path
E 15
I 15
.Ar path
E 15
names a directory from which the shell will attempt to execute the command.
If it is given neither a
D 15
.B \-c
E 15
I 15
.Fl c
E 15
nor a
D 15
.B \-t
E 15
I 15
.Fl t
E 15
option, the shell will hash the names in these directories into an internal
table so that it will only try an
D 15
.I exec
E 15
I 15
.Ic exec
E 15
in a directory if there is a possibility that the command resides there.
D 27
This greatly speeds command location when a large number of directories
E 27
I 27
This shortcut greatly speeds command location when many directories
E 27
are present in the search path.
If this mechanism has been turned off (via
D 2
.I unhash),
E 2
I 2
D 15
.IR unhash ),
E 15
I 15
.Ic unhash ) ,
E 15
E 2
or if the shell was given a
D 15
.B \-c
E 15
I 15
.Fl c
E 15
or
D 15
.B \-t
E 15
I 15
.Fl t
E 15
argument, and in any case for each directory component of
D 15
.I path
E 15
I 15
.Ar path
E 15
D 27
which does not begin with a `/',
E 27
I 27
that does not begin with a `/',
E 27
the shell concatenates with the given command name to form a path name
of a file which it then attempts to execute.
D 15
.PP
E 15
I 15
.Pp
E 15
Parenthesized commands are always executed in a subshell.
D 16
Thus `(cd ; pwd) ; pwd' prints the
E 16
I 16
Thus
.Pp
.Dl (cd ; pwd) ; pwd
.Pp
prints the
E 16
D 15
.I home
E 15
I 15
.Ar home
E 15
directory; leaving you where you were (printing this after the home directory),
D 16
while `cd ; pwd' leaves you in the
E 16
I 16
while
.Pp
.Dl cd ; pwd
.Pp
leaves you in the
E 16
D 15
.I home
E 15
I 15
.Ar home
E 15
directory.
Parenthesized commands are most often used to prevent
D 15
.I chdir
E 15
I 15
.Ic chdir
E 15
from affecting the current shell.
D 15
.PP
E 15
I 15
.Pp
E 15
If the file has execute permissions but is not an
executable binary to the system, then it is assumed to be a
D 2
file containing shell commands an a new shell is spawned to read it.
E 2
I 2
file containing shell commands and a new shell is spawned to read it.
I 31
.pl +1
E 31
E 2
D 15
.PP
E 15
I 15
.Pp
E 15
If there is an
D 15
.I alias
E 15
I 15
.Ic alias
E 15
for
D 15
.I shell
E 15
I 15
.Ic shell
E 15
then the words of the alias will be prepended to the argument list to form
the shell command.
The first word of the
D 15
.I alias
E 15
I 15
.Ic alias
E 15
should be the full path name of the shell
D 27
(e.g. `$shell').
E 27
I 27
(e.g., `$shell').
E 27
Note that this is a special, late occurring, case of
D 15
.I alias
E 15
I 15
.Ic alias
E 15
substitution,
D 27
and only allows words to be prepended to the argument list without modification.
E 27
I 27
and only allows words to be prepended to the argument list without change.
I 31
.ne 1i
E 31
E 27
D 15
.sh "Argument list processing"
If argument 0 to the shell is `\-' then this
is a login shell.
The flag arguments are interpreted as follows:
I 7
.TP 5
.B  \-b
\c
This flag forces a ``break'' from option processing, causing any further
shell arguments to be treated as non-option arguments.
The remaining arguments will not be interpreted as shell options.
This may be used to pass options to a shell script without confusion
or possible subterfuge.
The shell will not run a set-user ID script without this option.
E 7
.TP 5
.B  \-c
\c
Commands are read from the (single) following argument which must
be present.
Any remaining arguments are placed in
.I argv.
.TP 5
.B  \-e
\c
The shell exits if any invoked command terminates abnormally
or yields a non-zero exit status.
.TP 5
.B  \-f
\c
The shell will start faster, because it will neither search for nor
execute commands from the file
D 9
`\&.cshrc' in the invokers home directory.
E 9
I 9
`\&.cshrc' in the invoker's home directory.
E 9
.TP 5
.B  \-i
\c
The shell is interactive and prompts for its top-level input,
even if it appears to not be a terminal.
Shells are interactive without this option if their inputs
and outputs are terminals.
.TP 5
.B  \-n
\c
Commands are parsed, but not executed.
D 2
This may aid in syntactic checking of shell scripts.
E 2
I 2
This aids in syntactic checking of shell scripts.
E 2
.TP 5
.B  \-s
\c
Command input is taken from the standard input.
.TP 5
.B  \-t
\c
A single line of input is read and executed.
A `\e' may be used to escape the newline at the end of this
line and continue onto another line.
.TP 5
.B  \-v
\c
Causes the
.I verbose
variable to be set, with the effect
that command input is echoed after history substitution.
.TP 5
.B  \-x
\c
Causes the 
.I echo
variable to be set, so that commands are echoed immediately before execution.
.TP 5
.B  \-V
\c
Causes the
.I verbose
variable to be set even before `\&.cshrc' is executed.
.TP 5
.B  \-X
\c
Is to
.B \-x
as
.B \-V
is to
.B \-v.
.PP
D 9
After processing of flag arguments if arguments remain but none of the
E 9
I 9
After processing of flag arguments, if arguments remain but none of the
E 9
.B \-c,
.B \-i,
.B \-s,
or
.B \-t
D 9
options was given the first argument is taken as the name of a file of
E 9
I 9
options was given, the first argument is taken as the name of a file of
E 9
commands to be executed.
The shell opens this file, and saves its name for possible resubstitution
by `$0'.
Since many systems use either the standard version 6 or version 7 shells
whose shell scripts are not compatible with this shell, the shell will
execute such a `standard' shell if the first character of a script
is not a `#', i.e. if the script does not start with a comment.
Remaining arguments initialize the variable
.I argv.
.sh "Signal handling"
E 15
I 15
.Ss Signal handling
E 15
The shell normally ignores
D 15
.I quit
E 15
I 15
.Ar quit
E 15
signals.
D 15
Jobs running detached (either by `&' or the \fIbg\fR or \fB%... &\fR
E 15
I 15
D 16
Jobs running detached (either by `&' or the
E 16
I 16
Jobs running detached (either by
.Ic \&&
or the
E 16
.Ic bg
or
.Ic %... &
E 15
commands) are immune to signals generated from the keyboard, including
hangups.
Other signals have the values which the shell inherited from its parent.
D 16
The shells handling of interrupts and terminate signals
E 16
I 16
The shell's handling of interrupts and terminate signals
E 16
in shell scripts can be controlled by
D 15
.I onintr.
E 15
I 15
.Ic onintr .
E 15
Login shells catch the
D 15
.I terminate
E 15
I 15
.Ar terminate
E 15
signal; otherwise this signal is passed on to children from the state in the
shell's parent.
D 27
In no case are interrupts allowed when a login shell is reading the file
E 27
I 27
Interrupts are not allowed when a login shell is reading the file
E 27
D 15
`\&.logout'.
.SH AUTHOR
E 15
I 15
.Pa \&.logout .
.Sh AUTHOR
E 15
William Joy.
Job control and directory stack features first implemented by J.E. Kulp of
D 19
I.I.A.S.A, Laxenburg, Austria,
D 5
with different syntax than that used now.
E 5
I 5
with different syntax than that used now.  File name completion
code written by Ken Greer, HP Labs.
E 19
I 19
IIASA, Laxenburg, Austria,
with different syntax than that used now.
File name completion code written by Ken Greer, HP Labs.
Eight-bit implementation Christos S. Zoulas, Cornell University.
E 19
E 5
D 15
.SH FILES
.ta 1.75i
.nf
~/.cshrc	Read at beginning of execution by each shell.
~/.login	Read by login shell, after `.cshrc' at login.
~/.logout	Read by login shell, at logout.
/bin/sh	Standard shell, for shell scripts not starting with a `#'.
/tmp/sh*	Temporary file for `<<'.
/etc/passwd	Source of home directories for `~name'.
.fi
.SH LIMITATIONS
E 15
I 15
.Sh FILES
D 18
.Dw /etc/passwd
.Di L
.Dp Pa ~/.cshrc
E 18
I 18
.Bl -tag -width /etc/passwd -compact
.It Pa ~/.cshrc
E 18
Read at beginning of execution by each shell.
D 18
.Dp Pa ~/.login
E 18
I 18
.It Pa ~/.login
E 18
Read by login shell, after `.cshrc' at login.
D 18
.Dp Pa ~/.logout
E 18
I 18
.It Pa ~/.logout
E 18
Read by login shell, at logout.
D 18
.Dp Pa /bin/sh
E 18
I 18
.It Pa /bin/sh
E 18
Standard shell, for shell scripts not starting with a `#'.
D 18
.Dp Pa /tmp/sh*
E 18
I 18
.It Pa /tmp/sh*
E 18
Temporary file for `<<'.
D 18
.Dp Pa /etc/passwd
E 18
I 18
.It Pa /etc/passwd
E 18
Source of home directories for `~name'.
D 18
.Dp
E 18
I 18
.El
E 18
.Sh LIMITATIONS
Word lengths \-
E 15
Words can be no longer than 1024 characters.
The system limits argument lists to 10240 characters.
D 27
The number of arguments to a command which involves filename expansion
E 27
I 27
The number of arguments to a command that involves filename expansion
E 27
is limited to 1/6'th the number of characters allowed in an argument list.
Command substitutions may substitute no more characters than are
allowed in an argument list.
To detect looping, the shell restricts the number of
D 15
.I alias
E 15
I 15
.Ic alias
E 15
D 2
substititutions on a single line to 20.
E 2
I 2
substitutions on a single line to 20.
E 2
D 15
.SH "SEE ALSO"
D 2
sh(1), newcsh(1), access(2), exec(2), fork(2), killpg(2), pipe(2), sigsys(2),
umask(2), vlimit(2), wait(2), jobs(3), sigset(3), tty(4), a.out(5), environ(5),
E 2
I 2
sh(1), access(2), execve(2), fork(2), killpg(2), pipe(2), sigvec(2),
umask(2), setrlimit(2), wait(2), tty(4), a.out(5), environ(7),
E 2
`An introduction to the C shell'
.SH BUGS
E 15
I 15
.Sh SEE ALSO
.Xr sh 1 ,
.Xr access 2 ,
.Xr execve 2 ,
.Xr fork 2 ,
.Xr killpg 2 ,
.Xr pipe 2 ,
.Xr sigvec 2 ,
.Xr umask 2 ,
.Xr setrlimit 2 ,
.Xr wait 2 ,
.Xr tty 4 ,
.Xr a.out 5 ,
.Xr environ 7 ,
.br
.Em An introduction to the C shell
.Sh HISTORY
.Nm Csh
D 18
Appeared in  3 BSD.  It
E 18
I 18
appeared in
.Bx 3 .
It
E 18
was a first implementation of a command language interpreter
incorporating a history mechanism (see
D 18
.Nm History Substitutions ) ,
E 18
I 18
.Sx History Substitutions ) ,
E 18
job control facilities (see
D 18
.Nm Jobs ) ,
E 18
I 18
.Sx Jobs ) ,
E 18
interactive file name
and user name completion (see
D 18
.Nm File Name Completion ) ,
E 18
I 18
.Sx File Name Completion ) ,
E 18
and a C-like syntax.
D 27
There are now many shells which also have these mechanisms, plus
D 18
a few more (and maybe some bugs too), which are available thru
the internet, or as contributed software such as the
E 18
I 18
a few more (and maybe some bugs too), which are available thru the
usenet, or with
.Bx
as contributed software like the
E 18
D 16
.Xr ksh (korn\ shell) .
E 16
I 16
.Xr ksh korn\ shell .
E 27
I 27
There are now many shells that also have these mechanisms, plus
a few more (and maybe some bugs too), which are available through the
usenet.
E 27
E 16
.Sh BUGS
E 15
When a command is restarted from a stop,
the shell prints the directory it started in if this is different
D 27
from the current directory; this can be misleading (i.e. wrong)
E 27
I 27
from the current directory; this can be misleading (i.e., wrong)
E 27
as the job may have changed directories internally.
D 15
.PP
E 15
I 15
.Pp
E 15
Shell builtin functions are not stoppable/restartable.
Command sequences of the form `a ; b ; c' are also not handled gracefully
D 27
when stopping is attempted.  If you suspend `b', the shell will then
E 27
I 27
when stopping is attempted.  If you suspend `b', the shell will
E 27
immediately execute `c'.  This is especially noticeable if this
expansion results from an
D 15
.I alias.
E 15
I 15
.Ar alias .
E 15
It suffices to place the sequence of commands in ()'s to force it to
D 27
a subshell, i.e. `( a ; b ; c )'.
E 27
I 27
a subshell, i.e., `( a ; b ; c )'.
E 27
D 15
.PP
E 15
I 15
.Pp
E 15
Control over tty output after processes are started is primitive;
perhaps this will inspire someone to work on a good virtual
terminal interface.  In a virtual terminal interface much more
interesting things could be done with output control.
D 15
.PP
E 15
I 15
.Pp
E 15
Alias substitution is most often used to clumsily simulate shell procedures;
D 27
shell procedures should be provided rather than aliases.
E 27
I 27
shell procedures should be provided instead of aliases.
E 27
D 15
.PP
E 15
I 15
.Pp
E 15
D 27
Commands within loops, prompted for by `?', are not placed in the
E 27
I 27
Commands within loops, prompted for by `?', are not placed on the
E 27
D 15
.I history
E 15
I 15
.Ic history
E 15
list.
D 27
Control structure should be parsed rather than being recognized as built-in
E 27
I 27
Control structure should be parsed instead of being recognized as built-in
E 27
commands.  This would allow control commands to be placed anywhere,
D 15
to be combined with `|', and to be used with `&' and `;' metasyntax.
.PP
E 15
I 15
D 16
to be combined with `', and to be used with `&' and `;' metasyntax.
E 16
I 16
to be combined with `\&|', and to be used with `&' and `;' metasyntax.
E 16
.Pp
E 15
It should be possible to use the `:' modifiers on the output of command
substitutions.
D 21
All and more than one `:' modifier should be allowed on `$' substitutions.
E 21
I 8
D 15
.PP
E 15
I 15
.Pp
E 15
The way the
D 15
.B filec
E 15
I 15
.Ic filec
E 15
facility is implemented is ugly and expensive.
E 8
I 2
D 5
.PP
Symbolic links fool the shell.  In particular,
.I dirs
and `cd ..' don't work properly once you've crossed through a symbolic
link.
E 5
E 2
E 1
