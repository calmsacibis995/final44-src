h15885
s 00063/00041/00306
d D 8.2 95/05/04 17:59:59 christos 5 4
c 
e
s 00005/00005/00342
d D 8.1 93/05/31 15:19:58 bostic 4 3
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00019/00002/00328
d D 5.3 92/04/30 15:10:35 marc 3 2
c add support for arithmetic (and tilde)
e
s 00002/00000/00328
d D 5.2 91/03/08 16:46:22 bostic 2 1
c make the world safe for pcc
e
s 00328/00000/00000
d D 5.1 91/03/07 20:27:46 bostic 1 0
c date and time created 91/03/07 20:27:46 by bostic
e
u
U
t
T
I 1
/*-
D 4
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
E 4
I 4
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
E 4
 *
 * This code is derived from software contributed to Berkeley by
 * Kenneth Almquist.
 *
 * %sccs.include.redist.c%
 */

#ifndef lint
D 4
char copyright[] =
"%Z% Copyright (c) 1991 The Regents of the University of California.\n\
 All rights reserved.\n";
E 4
I 4
static char copyright[] =
"%Z% Copyright (c) 1991, 1993\n\
	The Regents of the University of California.  All rights reserved.\n";
E 4
#endif /* not lint */

#ifndef lint
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* not lint */

/*
 * This program creates syntax.h and syntax.c.
 */

#include <stdio.h>
I 5
#include <string.h>
E 5
#include "parser.h"


struct synclass {
	char *name;
	char *comment;
};

/* Syntax classes */
struct synclass synclass[] = {
D 5
	"CWORD",		"character is nothing special",
	"CNL",		"newline character",
	"CBACK",		"a backslash character",
	"CSQUOTE",	"single quote",
	"CDQUOTE",	"double quote",
	"CENDQUOTE",	"a terminating quote",
	"CBQUOTE",	"backwards single quote",
	"CVAR",		"a dollar sign",
	"CENDVAR",	"a '}' character",
I 3
	"CLP",		"a left paren in arithmetic",
	"CRP",		"a right paren in arithmetic",
E 3
	"CEOF",		"end of file",
	"CCTL",		"like CWORD, except it must be escaped",
	"CSPCL",		"these terminate a word",
	NULL, NULL
E 5
I 5
	{ "CWORD",	"character is nothing special" },
	{ "CNL",	"newline character" },
	{ "CBACK",	"a backslash character" },
	{ "CSQUOTE",	"single quote" },
	{ "CDQUOTE",	"double quote" },
	{ "CENDQUOTE",	"a terminating quote" },
	{ "CBQUOTE",	"backwards single quote" },
	{ "CVAR",	"a dollar sign" },
	{ "CENDVAR",	"a '}' character" },
	{ "CLP",	"a left paren in arithmetic" },
	{ "CRP",	"a right paren in arithmetic" },
	{ "CEOF",	"end of file" },
	{ "CCTL",	"like CWORD, except it must be escaped" },
	{ "CSPCL",	"these terminate a word" },
	{ NULL,		NULL }
E 5
};


/*
 * Syntax classes for is_ functions.  Warning:  if you add new classes
 * you may have to change the definition of the is_in_name macro.
 */
struct synclass is_entry[] = {
D 5
	"ISDIGIT",	"a digit",
	"ISUPPER",	"an upper case letter",
	"ISLOWER",	"a lower case letter",
	"ISUNDER",	"an underscore",
	"ISSPECL",	"the name of a special parameter",
	NULL, NULL,
E 5
I 5
	{ "ISDIGIT",	"a digit" },
	{ "ISUPPER",	"an upper case letter" },
	{ "ISLOWER",	"a lower case letter" },
	{ "ISUNDER",	"an underscore" },
	{ "ISSPECL",	"the name of a special parameter" },
	{ NULL, 	NULL }
E 5
};

D 5
char writer[] = "\
E 5
I 5
static char writer[] = "\
E 5
/*\n\
 * This file was generated by the mksyntax program.\n\
 */\n\
\n";


D 5
FILE *cfile;
FILE *hfile;
char *syntax[513];
int base;
int size;		/* number of values which a char variable can have */
int nbits;		/* number of bits in a character */
int digit_contig;	/* true if digits are contiguous */
E 5
I 5
static FILE *cfile;
static FILE *hfile;
static char *syntax[513];
static int base;
static int size;	/* number of values which a char variable can have */
static int nbits;	/* number of bits in a character */
static int digit_contig;/* true if digits are contiguous */
E 5

I 5
static void filltable __P((char *));
static void init __P((void));
static void add __P((char *, char *));
static void print __P((char *));
static void output_type_macros __P((void));
static void digit_convert __P((void));
E 5

D 5
main() {
E 5
I 5
int
main(argc, argv)
	int argc;
	char **argv;
{
E 5
	char c;
	char d;
	int sign;
	int i;
	char buf[80];
	int pos;
	static char digit[] = "0123456789";

	/* Create output files */
	if ((cfile = fopen("syntax.c", "w")) == NULL) {
		perror("syntax.c");
		exit(2);
	}
	if ((hfile = fopen("syntax.h", "w")) == NULL) {
		perror("syntax.h");
		exit(2);
	}
	fputs(writer, hfile);
	fputs(writer, cfile);

	/* Determine the characteristics of chars. */
	c = -1;
	if (c < 0)
		sign = 1;
	else
		sign = 0;
	for (nbits = 1 ; ; nbits++) {
		d = (1 << nbits) - 1;
		if (d == c)
			break;
	}
	printf("%s %d bit chars\n", sign? "signed" : "unsigned", nbits);
	if (nbits > 9) {
		fputs("Characters can't have more than 9 bits\n", stderr);
		exit(2);
	}
	size = (1 << nbits) + 1;
	base = 1;
	if (sign)
		base += 1 << (nbits - 1);
	digit_contig = 1;
	for (i = 0 ; i < 10 ; i++) {
		if (digit[i] != '0' + i)
			digit_contig = 0;
	}

I 2
	fputs("#include <sys/cdefs.h>\n", hfile);

E 2
	/* Generate the #define statements in the header file */
	fputs("/* Syntax classes */\n", hfile);
	for (i = 0 ; synclass[i].name ; i++) {
		sprintf(buf, "#define %s %d", synclass[i].name, i);
		fputs(buf, hfile);
D 5
		for (pos = strlen(buf) ; pos < 32 ; pos = pos + 8 &~ 07)
E 5
I 5
		for (pos = strlen(buf) ; pos < 32 ; pos = (pos + 8) & ~07)
E 5
			putc('\t', hfile);
		fprintf(hfile, "/* %s */\n", synclass[i].comment);
	}
	putc('\n', hfile);
	fputs("/* Syntax classes for is_ functions */\n", hfile);
	for (i = 0 ; is_entry[i].name ; i++) {
		sprintf(buf, "#define %s %#o", is_entry[i].name, 1 << i);
		fputs(buf, hfile);
D 5
		for (pos = strlen(buf) ; pos < 32 ; pos = pos + 8 &~ 07)
E 5
I 5
		for (pos = strlen(buf) ; pos < 32 ; pos = (pos + 8) & ~07)
E 5
			putc('\t', hfile);
		fprintf(hfile, "/* %s */\n", is_entry[i].comment);
	}
	putc('\n', hfile);
	fprintf(hfile, "#define SYNBASE %d\n", base);
	fprintf(hfile, "#define PEOF %d\n\n", -base);
	putc('\n', hfile);
	fputs("#define BASESYNTAX (basesyntax + SYNBASE)\n", hfile);
	fputs("#define DQSYNTAX (dqsyntax + SYNBASE)\n", hfile);
	fputs("#define SQSYNTAX (sqsyntax + SYNBASE)\n", hfile);
I 3
	fputs("#define ARISYNTAX (arisyntax + SYNBASE)\n", hfile);
E 3
	putc('\n', hfile);
	output_type_macros();		/* is_digit, etc. */
	putc('\n', hfile);

	/* Generate the syntax tables. */
	fputs("#include \"shell.h\"\n", cfile);
	fputs("#include \"syntax.h\"\n\n", cfile);
	init();
	fputs("/* syntax table used when not in quotes */\n", cfile);
	add("\n", "CNL");
	add("\\", "CBACK");
	add("'", "CSQUOTE");
	add("\"", "CDQUOTE");
	add("`", "CBQUOTE");
	add("$", "CVAR");
	add("}", "CENDVAR");
	add("<>();&| \t", "CSPCL");
	print("basesyntax");
	init();
	fputs("\n/* syntax table used when in double quotes */\n", cfile);
	add("\n", "CNL");
	add("\\", "CBACK");
	add("\"", "CENDQUOTE");
	add("`", "CBQUOTE");
	add("$", "CVAR");
	add("}", "CENDVAR");
D 3
	add("!*?[=", "CCTL");
E 3
I 3
D 5
	add("!*?[=~:/", "CCTL");	/* ':/' for tilde - yuck */
E 5
I 5
	/* ':/' for tilde expansion, '-' for [a\-x] pattern ranges */
	add("!*?[=~:/-", "CCTL");
E 5
E 3
	print("dqsyntax");
	init();
	fputs("\n/* syntax table used when in single quotes */\n", cfile);
	add("\n", "CNL");
	add("'", "CENDQUOTE");
D 3
	add("!*?[=", "CCTL");
E 3
I 3
D 5
	add("!*?[=~:/", "CCTL");	/* ':/' for tilde - yuck */
E 5
I 5
	/* ':/' for tilde expansion, '-' for [a\-x] pattern ranges */
	add("!*?[=~:/-", "CCTL");
E 5
E 3
	print("sqsyntax");
I 3
	init();
	fputs("\n/* syntax table used when in arithmetic */\n", cfile);
	add("\n", "CNL");
	add("\\", "CBACK");
	add("`", "CBQUOTE");
	add("'", "CSQUOTE");
	add("\"", "CDQUOTE");
	add("$", "CVAR");
	add("}", "CENDVAR");
	add("(", "CLP");
	add(")", "CRP");
	print("arisyntax");
E 3
	filltable("0");
	fputs("\n/* character classification table */\n", cfile);
	add("0123456789", "ISDIGIT");
	add("abcdefghijklmnopqrstucvwxyz", "ISLOWER");
	add("ABCDEFGHIJKLMNOPQRSTUCVWXYZ", "ISUPPER");
	add("_", "ISUNDER");
	add("#?$!-*@", "ISSPECL");
	print("is_type");
	if (! digit_contig)
		digit_convert();
	exit(0);
}



/*
 * Clear the syntax table.
 */

I 5
static void
E 5
filltable(dftval)
	char *dftval;
D 5
	{
E 5
I 5
{
E 5
	int i;

	for (i = 0 ; i < size ; i++)
		syntax[i] = dftval;
}


/*
 * Initialize the syntax table with default values.
 */

D 5
init() {
E 5
I 5
static void
init()
{
E 5
	filltable("CWORD");
	syntax[0] = "CEOF";
	syntax[base + CTLESC] = "CCTL";
	syntax[base + CTLVAR] = "CCTL";
	syntax[base + CTLENDVAR] = "CCTL";
	syntax[base + CTLBACKQ] = "CCTL";
	syntax[base + CTLBACKQ + CTLQUOTE] = "CCTL";
I 3
	syntax[base + CTLARI] = "CCTL";
	syntax[base + CTLENDARI] = "CCTL";
E 3
}


/*
 * Add entries to the syntax table.
 */

I 5
static void
E 5
add(p, type)
	char *p, *type;
D 5
	{
E 5
I 5
{
E 5
	while (*p)
		syntax[*p++ + base] = type;
}



/*
 * Output the syntax table.
 */

I 5
static void
E 5
print(name)
	char *name;
D 5
	{
E 5
I 5
{
E 5
	int i;
	int col;

	fprintf(hfile, "extern const char %s[];\n", name);
	fprintf(cfile, "const char %s[%d] = {\n", name, size);
	col = 0;
	for (i = 0 ; i < size ; i++) {
		if (i == 0) {
			fputs("      ", cfile);
		} else if ((i & 03) == 0) {
			fputs(",\n      ", cfile);
			col = 0;
		} else {
			putc(',', cfile);
			while (++col < 9 * (i & 03))
				putc(' ', cfile);
		}
		fputs(syntax[i], cfile);
		col += strlen(syntax[i]);
	}
	fputs("\n};\n", cfile);
}



/*
 * Output character classification macros (e.g. is_digit).  If digits are
 * contiguous, we can test for them quickly.
 */

D 5
char *macro[] = {
E 5
I 5
static char *macro[] = {
E 5
	"#define is_digit(c)\t((is_type+SYNBASE)[c] & ISDIGIT)",
	"#define is_alpha(c)\t((is_type+SYNBASE)[c] & (ISUPPER|ISLOWER))",
	"#define is_name(c)\t((is_type+SYNBASE)[c] & (ISUPPER|ISLOWER|ISUNDER))",
	"#define is_in_name(c)\t((is_type+SYNBASE)[c] & (ISUPPER|ISLOWER|ISUNDER|ISDIGIT))",
	"#define is_special(c)\t((is_type+SYNBASE)[c] & (ISSPECL|ISDIGIT))",
	NULL
};

D 5
output_type_macros() {
E 5
I 5
static void
output_type_macros() 
{
E 5
	char **pp;

	if (digit_contig)
		macro[0] = "#define is_digit(c)\t((unsigned)((c) - '0') <= 9)";
	for (pp = macro ; *pp ; pp++)
		fprintf(hfile, "%s\n", *pp);
	if (digit_contig)
		fputs("#define digit_val(c)\t((c) - '0')\n", hfile);
	else
		fputs("#define digit_val(c)\t(digit_value[c])\n", hfile);
}



/*
 * Output digit conversion table (if digits are not contiguous).
 */

D 5
digit_convert() {
E 5
I 5
static void
digit_convert() 
{
E 5
	int maxdigit;
	static char digit[] = "0123456789";
	char *p;
	int i;

	maxdigit = 0;
	for (p = digit ; *p ; p++)
		if (*p > maxdigit)
			maxdigit = *p;
	fputs("extern const char digit_value[];\n", hfile);
	fputs("\n\nconst char digit_value[] = {\n", cfile);
	for (i = 0 ; i <= maxdigit ; i++) {
		for (p = digit ; *p && *p != i ; p++);
		if (*p == '\0')
			p = digit;
		fprintf(cfile, "      %d,\n", p - digit);
	}
	fputs("};\n", cfile);
}
E 1
