h40969
s 00002/00002/00133
d D 8.3 94/04/02 10:02:35 pendry 57 56
c add 1994 copyright
e
s 00002/00002/00133
d D 8.2 94/04/01 03:39:09 pendry 56 55
c prettyness police
e
s 00005/00005/00130
d D 8.1 93/06/03 17:52:46 bostic 55 54
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00001/00134
d D 5.34 93/06/03 17:52:38 bostic 54 52
c usage statement needs a newline
e
s 00005/00005/00130
d R 8.1 93/05/31 15:47:55 bostic 53 52
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00022/00011/00113
d D 5.33 93/04/29 15:18:18 bostic 52 51
c use C library err/warn routines
e
s 00003/00002/00121
d D 5.32 91/12/03 13:55:27 bostic 51 50
c don't indirect through null pointers
e
s 00001/00001/00122
d D 5.31 91/11/08 15:10:38 cael 50 49
c lets try that usage stmt again...
e
s 00001/00001/00122
d D 5.30 91/11/08 15:07:08 cael 49 48
c fix usage stmt, make clear flags and f are bsd extensions to posix
e
s 00001/00000/00122
d D 5.29 91/09/10 17:15:11 bostic 48 47
c speed change requires a tcsetattr
e
s 00011/00066/00111
d D 5.28 91/06/05 15:22:22 bostic 47 46
c distribute the rest of the main loop into the modes and cchars modules
c bsearch the cchars arrays, minor cleanups
e
s 00054/00180/00123
d D 5.27 91/06/05 08:04:20 bostic 46 45
c break out rest of keywords into function table that can be bsearch'd
e
s 00020/00005/00283
d D 5.26 91/06/04 13:52:54 bostic 45 44
c don't do a tcsetattr/window ioctl unless asked to
e
s 00003/00002/00285
d D 5.25 91/06/03 17:43:31 bostic 44 43
c fix error message on -f open failure; don't mistake -echo for -e
e
s 00001/00001/00286
d D 5.24 91/05/22 10:55:35 bostic 43 42
c delete "disable", it wasn't documented
c add "<undef>" so users can use the output to set the value
e
s 00001/00001/00286
d D 5.23 91/05/06 19:38:14 bostic 42 41
c new copyright; att/bsd/shared
e
s 00002/00003/00285
d D 5.22 91/05/03 10:19:51 bostic 41 40
c didn't get the argument parsing right; fix stty -tostop
e
s 00204/00698/00084
d D 5.21 91/05/02 13:35:49 bostic 40 39
c break up into multiple modules; redo the output formats, add -e
c option, make "all" and "everything" the same; massive reorganization, mostly
c to remove any AT&T proprietary code
e
s 00008/00007/00774
d D 5.20 91/04/08 14:56:14 bostic 39 38
c new copyright; att/bsd/shared
e
s 00008/00007/00773
d D 5.19 91/02/06 17:31:10 karels 38 37
c "stty new" and "stty old" should set TTYDISC; "stty tty" is set to standard ldisc
e
s 00014/00000/00766
d D 5.18 90/09/14 12:33:35 borman 37 36
c Add code for setting/clearing/reporting the
c EXTPROC and NOKERNINFO bits.
e
s 00007/00001/00759
d D 5.17 90/08/07 15:46:20 marc 36 35
c put in cbreak and -cbreak (fudge)
e
s 00000/00001/00760
d D 5.16 90/06/29 14:17:40 marc 35 34
c no erase2
e
s 00003/00002/00758
d D 5.15 90/06/26 10:41:13 marc 34 33
c add secondary erase; add "flush" as alias for discard; info -> status
e
s 00075/00007/00685
d D 5.14 90/06/20 18:06:13 marc 33 32
c add -g processing
e
s 00001/00001/00691
d D 5.13 90/06/15 14:02:51 marc 32 31
c VFLUSHO -> CDISCARD
e
s 00017/00017/00675
d D 5.12 90/06/15 13:58:29 bostic 31 30
c add braces (stylistic change)
e
s 00000/00003/00692
d D 5.11 90/05/17 17:49:35 bostic 30 29
c NOHANG is gone
e
s 00003/00001/00692
d D 5.10 90/02/23 09:58:14 marc 29 28
c clean up
e
s 00062/00074/00631
d D 5.9 90/02/20 16:00:52 marc 28 27
c cleanups
e
s 00031/00011/00674
d D 5.8 90/02/20 15:32:44 karels 27 26
c add some missing flags, also, comments for cleanups
e
s 00598/00492/00087
d D 5.7 89/08/19 12:48:25 marc 26 25
c checked in for marc (with a few mods by karels); posix
e
s 00004/00003/00575
d D 5.6 89/05/01 23:37:03 bostic 25 24
c pathnames.h
e
s 00002/00002/00576
d D 5.5 87/12/22 12:20:06 bostic 24 23
c make ANSI C compatible; use supplied defines
e
s 00001/00001/00577
d D 5.4 86/04/04 11:24:27 bloom 23 22
c make cols an alias for columns
e
s 00005/00000/00573
d D 5.3 86/01/09 19:56:30 karels 22 20
c add "stty size" ala "stty speed"
e
s 00004/00000/00573
d R 5.3 86/01/09 16:00:19 karels 21 20
c add "stty size" ala "stty speed"
e
s 00003/00000/00570
d D 5.2 85/08/13 05:38:51 lepreau 20 18
c add PASS8: pass all 8 bits of input
e
s 00002/00000/00570
d R 5.2 85/08/13 05:26:36 lepreau 19 18
c add PASS8: pass all 8 bits of input
e
s 00015/00002/00555
d D 5.1 85/05/02 14:46:09 dist 18 17
c Add copyright
e
s 00016/00001/00541
d D 4.15 85/02/20 11:27:28 bloom 17 16
c set and print window sizes
e
s 00006/00002/00536
d D 4.14 83/07/06 22:10:14 sam 16 13
c prettier
e
s 00002/00002/00536
d R 4.14 83/07/06 21:45:55 sam 15 13
c yet another old delta come back to haunt us
e
s 00003/00006/00532
d R 4.14 83/07/06 21:43:38 sam 14 13
c screwey
e
s 00275/00273/00263
d D 4.13 83/06/13 02:41:29 sam 13 12
c back to yesteryear (or how to go in a circle real hard)
e
s 00001/00002/00535
d D 4.12 83/02/08 12:38:32 mckusick 12 11
c fix as per Mike Odell
e
s 00001/00001/00536
d D 4.11 83/01/16 11:17:23 peter 11 10
c add space separating `crt' and `tostop' for `stty all'.
e
s 00276/00273/00261
d D 4.10 82/12/19 13:21:07 sam 10 9
c use new ioctl's
e
s 00003/00001/00531
d D 4.9 82/05/12 17:40:11 wnj 9 8
c added 9600 and 19200 to set and print
e
s 00000/00003/00532
d D 4.8 82/05/07 17:36:29 mckusick 8 7
c get rid of LINTRUP
e
s 00008/00000/00527
d D 4.7 81/07/18 16:46:36 root 7 6
c add decctq and noflsh printing and setting
e
s 00001/00001/00526
d D 4.6 81/07/08 18:48:39 root 6 5
c fix typo
e
s 00001/00001/00526
d D 4.5 81/07/08 18:46:08 root 5 4
c fix per reeves
e
s 00016/00001/00511
d D 4.4 81/05/18 11:57:28 root 4 3
c re-insert decctlq
e
s 00001/00001/00511
d D 4.3 81/05/18 01:23:42 wnj 3 2
c fix bug per hek
e
s 00002/00002/00510
d D 4.2 80/10/11 23:39:51 bill 2 1
c newcrt->crt
e
s 00512/00000/00000
d D 4.1 80/10/01 18:33:31 bill 1 0
c date and time created 80/10/01 18:33:31 by bill
e
u
U
t
T
I 18
D 39
/*
D 27
 * Copyright (c) 1980 Regents of the University of California.
E 27
I 27
D 38
 * Copyright (c) 1980, 1989 Regents of the University of California.
E 38
I 38
 * Copyright (c) 1980, 1989, 1991 Regents of the University of California.
E 38
E 27
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
E 39
I 39
/*-
D 40
 * Copyright (c) 1980, 1989, 1991 The Regents of the University of California.
E 40
I 40
D 55
 * Copyright (c) 1989, 1991 The Regents of the University of California.
E 40
 * All rights reserved.
E 55
I 55
D 57
 * Copyright (c) 1989, 1991, 1993
E 57
I 57
 * Copyright (c) 1989, 1991, 1993, 1994
E 57
 *	The Regents of the University of California.  All rights reserved.
E 55
 *
D 42
 * %sccs.include.proprietary.c%
E 42
I 42
 * %sccs.include.redist.c%
E 42
E 39
 */

E 18
I 13
#ifndef lint
E 13
I 1
D 18
static char *sccsid ="%W% (Berkeley) %G%";
I 13
#endif
E 18
I 18
D 55
char copyright[] =
D 27
"%Z% Copyright (c) 1980 Regents of the University of California.\n\
E 27
I 27
D 38
"%Z% Copyright (c) 1980, 1989 Regents of the University of California.\n\
E 38
I 38
D 39
"%Z% Copyright (c) 1980, 1989, 1991 Regents of the University of California.\n\
E 39
I 39
D 40
"%Z% Copyright (c) 1980, 1989, 1991 The Regents of the University of California.\n\
E 40
I 40
"%Z% Copyright (c) 1989, 1991 The Regents of the University of California.\n\
E 40
E 39
E 38
E 27
 All rights reserved.\n";
E 55
I 55
static char copyright[] =
D 57
"%Z% Copyright (c) 1989, 1991, 1993\n\
E 57
I 57
"%Z% Copyright (c) 1989, 1991, 1993, 1994\n\
E 57
	The Regents of the University of California.  All rights reserved.\n";
E 55
D 39
#endif not lint
E 39
I 39
#endif /* not lint */
E 39

#ifndef lint
static char sccsid[] = "%W% (Berkeley) %G%";
D 39
#endif not lint
E 39
I 39
#endif /* not lint */
E 39

E 18
E 13
D 40
/*
 * set teletype modes
 */

E 40
I 26
#include <sys/types.h>
D 40
#include <sys/stat.h>
E 40
E 26
D 25
#include <stdio.h>
E 25
D 17
#include <sgtty.h>
E 17
I 17
D 46
#include <sys/ioctl.h>
I 26
D 40
#include <sys/syslog.h>
#define KERNEL
#include <sys/tty.h>
#undef KERNEL
#include <sys/termios.h>
#include <sys/file.h>
E 40
I 40
#include <termios.h>
E 46
D 52
#include <fcntl.h>
E 52
I 52

#include <ctype.h>
#include <err.h>
E 52
E 40
#include <errno.h>
D 40
#include <ctype.h>
E 40
I 40
D 52
#include <unistd.h>
E 52
I 52
#include <fcntl.h>
E 52
E 40
E 26
I 25
#include <stdio.h>
I 40
D 52
#include <ctype.h>
E 52
#include <stdlib.h>
#include <string.h>
I 52
#include <unistd.h>

E 52
#include "stty.h"
#include "extern.h"
E 40
D 26
#include "pathnames.h"
E 26
E 25
E 17

D 10
struct
{
E 10
I 10
D 13
struct {
E 13
I 13
D 26
struct
{
E 13
E 10
	char	*string;
	int	speed;
} speeds[] = {
D 10
	"0",	B0,
	"50",	B50,
	"75",	B75,
	"110",	B110,
	"134",	B134,
	"134.5",B134,
	"150",	B150,
	"200",	B200,
	"300",	B300,
	"600",	B600,
	"1200",	B1200,
	"1800",	B1800,
	"2400",	B2400,
	"4800",	B4800,
	"9600",	B9600,
	"exta",	EXTA,
I 9
	"19200", EXTA,
E 9
	"extb",	EXTB,
I 9
	"38400", EXTB,
E 9
	0,
E 10
I 10
D 13
	{ "0",		B0 },
	{ "50",		B50 },
	{ "75",		B75 },
	{ "110",	B110 },
	{ "134",	B134 },
	{ "134.5",	B134 },
	{ "150",	B150 },
	{ "200",	B200 },
	{ "300",	B300 },
	{ "600",	B600 },
	{ "1200",	B1200 },
	{ "1800",	B1800 },
	{ "2400",	B2400 },
	{ "4800",	B4800 },
	{ "9600",	B9600 },
	{ "exta",	EXTA },
	{ "19200",	EXTA },
	{ "extb",	EXTB },
	{ "38400",	EXTB },
	{ 0 },
E 13
I 13
	"0",	B0,
	"50",	B50,
	"75",	B75,
	"110",	B110,
	"134",	B134,
	"134.5",B134,
	"150",	B150,
	"200",	B200,
	"300",	B300,
	"600",	B600,
	"1200",	B1200,
	"1800",	B1800,
	"2400",	B2400,
	"4800",	B4800,
	"9600",	B9600,
	"exta",	EXTA,
	"19200", EXTA,
	"extb",	EXTB,
	"38400", EXTB,
	0,
E 13
E 10
};
D 10
struct
{
E 10
I 10
D 13

struct {
E 13
I 13
struct
{
E 13
E 10
	char	*string;
D 10
	int	set;
	int	reset;
	int	lset;
	int	lreset;
E 10
I 10
D 13
	long	set;
	long	reset;
E 13
I 13
	int	set;
	int	reset;
	int	lset;
	int	lreset;
E 13
E 10
} modes[] = {
D 10
	"even",		EVENP, 0, 0, 0,
	"-even",	0, EVENP, 0, 0,
	"odd",		ODDP, 0, 0, 0,
	"-odd",		0, ODDP, 0, 0,
	"raw",		RAW, 0, 0, 0,
	"-raw",		0, RAW, 0, 0,
	"cooked",	0, RAW, 0, 0,
	"-nl",		CRMOD, 0, 0, 0,
	"nl",		0, CRMOD, 0, 0,
	"echo",		ECHO, 0, 0, 0,
	"-echo",	0, ECHO, 0, 0,
	"LCASE",	LCASE, 0, 0, 0,
	"lcase",	LCASE, 0, 0, 0,
	"-LCASE",	0, LCASE, 0, 0,
	"-lcase",	0, LCASE, 0, 0,
	"-tabs",	XTABS, 0, 0, 0,
	"tabs",		0, XTABS, 0, 0,
	"tandem",	TANDEM, 0, 0, 0,
	"-tandem",	0, TANDEM, 0, 0,
	"cbreak",	CBREAK, 0, 0, 0,
	"-cbreak",	0, CBREAK, 0, 0,
	"cr0",		CR0, CR3, 0, 0,
	"cr1",		CR1, CR3, 0, 0,
	"cr2",		CR2, CR3, 0, 0,
	"cr3",		CR3, CR3, 0, 0,
	"tab0",		TAB0, XTABS, 0, 0,
	"tab1",		TAB1, XTABS, 0, 0,
	"tab2",		TAB2, XTABS, 0, 0,
	"nl0",		NL0, NL3, 0, 0,
	"nl1",		NL1, NL3, 0, 0,
	"nl2",		NL2, NL3, 0, 0,
	"nl3",		NL3, NL3, 0, 0,
	"ff0",		FF0, FF1, 0, 0,
	"ff1",		FF1, FF1, 0, 0,
	"bs0",		BS0, BS1, 0, 0,
	"bs1",		BS1, BS1, 0, 0,
	"33",		CR1, ALLDELAY, 0, 0,
	"tty33",	CR1, ALLDELAY, 0, 0,
	"37",		FF1+CR2+TAB1+NL1, ALLDELAY, 0, 0,
	"tty37",	FF1+CR2+TAB1+NL1, ALLDELAY, 0, 0,
	"05",		NL2, ALLDELAY, 0, 0,
	"vt05",		NL2, ALLDELAY, 0, 0,
	"tn",		CR1, ALLDELAY, 0, 0,
	"tn300",	CR1, ALLDELAY, 0, 0,
	"ti",		CR2, ALLDELAY, 0, 0,
	"ti700",	CR2, ALLDELAY, 0, 0,
	"tek",		FF1, ALLDELAY, 0, 0,
	"crtbs",	0, 0, LCRTBS, LPRTERA,
	"-crtbs",	0, 0, 0, LCRTBS,
	"prterase",	0, 0, LPRTERA, LCRTBS+LCRTKIL+LCRTERA,
	"-prterase",	0, 0, 0, LPRTERA,
	"crterase",	0, 0, LCRTERA, LPRTERA,
	"-crterase",	0, 0, 0, LCRTERA,
	"crtkill",	0, 0, LCRTKIL, LPRTERA,
	"-crtkill",	0, 0, 0, LCRTKIL,
	"tilde",	0, 0, LTILDE, 0,
	"-tilde",	0, 0, 0, LTILDE,
	"mdmbuf",	0, 0, LMDMBUF, 0,
	"-mdmbuf",	0, 0, 0, LMDMBUF,
	"litout",	0, 0, LLITOUT, 0,
	"-litout",	0, 0, 0, LLITOUT,
	"tostop",	0, 0, LTOSTOP, 0,
	"-tostop",	0, 0, 0, LTOSTOP,
	"flusho",	0, 0, LFLUSHO, 0,
	"-flusho",	0, 0, 0, LFLUSHO,
	"nohang",	0, 0, LNOHANG, 0,
	"-nohang",	0, 0, 0, LNOHANG,
	"etxack",	0, 0, LETXACK, 0,
	"-etxack",	0, 0, 0, LETXACK,
D 8
	"intrup",	0, 0, LINTRUP, 0,
	"-intrup",	0, 0, 0, LINTRUP,
E 8
	"ctlecho",	0, 0, LCTLECH, 0,
	"-ctlecho",	0, 0, 0, LCTLECH,
	"pendin",	0, 0, LPENDIN, 0,
	"-pendin",	0, 0, 0, LPENDIN,
I 4
	"decctlq",	0, 0, LDECCTQ, 0,
	"-decctlq",	0, 0, 0, LDECCTQ,
I 7
	"noflsh",	0, 0, LNOFLSH, 0,
	"-noflsh",	0, 0, 0, LNOFLSH,
E 7
E 4
	0,
E 10
I 10
D 13
	{ "even",	EVENP,		0 },
	{ "-even",	0,		EVENP },
	{ "odd",	ODDP,		0 },
	{ "-odd",	0,		ODDP },
	{ "raw",	RAW,		0 },
	{ "-raw",	0,		RAW },
	{ "cooked",	0,		RAW },
	{ "-nl",	CRMOD,		0 },
	{ "nl",		0,		CRMOD },
	{ "echo",	ECHO,		0 },
	{ "-echo",	0,		ECHO },
	{ "LCASE",	LCASE,		0 },
	{ "lcase",	LCASE,		0 },
	{ "-LCASE",	0,		LCASE },
	{ "-lcase",	0,		LCASE },
	{ "-tabs",	XTABS,		0 },
	{ "tabs",	0,		XTABS },
	{ "tandem",	TANDEM,		0 },
	{ "-tandem",	0,		TANDEM },
	{ "cbreak",	CBREAK,		0 },
	{ "-cbreak",	0,		CBREAK },
	{ "cr0",	CR0,		CR3 },
	{ "cr1",	CR1,		CR3 },
	{ "cr2",	CR2,		CR3 },
	{ "cr3",	CR3,		CR3 },
	{ "tab0",	TAB0,		XTABS },
	{ "tab1",	TAB1,		XTABS },
	{ "tab2",	TAB2,		XTABS },
	{ "nl0",	NL0,		NL3 },
	{ "nl1",	NL1,		NL3 },
	{ "nl2",	NL2,		NL3 },
	{ "nl3",	NL3,		NL3 },
	{ "ff0",	FF0,		FF1 },
	{ "ff1",	FF1,		FF1 },
	{ "bs0",	BS0,		BS1 },
	{ "bs1",	BS1,		BS1 },
	{ "33",		CR1,		ALLDELAY },
	{ "tty33",	CR1,		ALLDELAY },
	{ "37",		FF1+CR2+TAB1+NL1, ALLDELAY },
	{ "tty37",	FF1+CR2+TAB1+NL1, ALLDELAY },
	{ "05",		NL2,		ALLDELAY },
	{ "vt05",	NL2,		ALLDELAY },
	{ "tn",		CR1,		ALLDELAY },
	{ "tn300",	CR1,		ALLDELAY },
	{ "ti",		CR2,		ALLDELAY },
	{ "ti700",	CR2,		ALLDELAY },
	{ "tek",	FF1,		ALLDELAY },
	{ "crtbs",	CRTBS,		PRTERA },
	{ "-crtbs",	0,		CRTBS },
	{ "prterase",	PRTERA,		CRTBS+CRTKIL+CRTERA },
	{ "-prterase",	0,		PRTERA },
	{ "crterase",	CRTERA,		PRTERA },
	{ "-crterase",	0,		CRTERA },
	{ "crtkill",	CRTKIL,		PRTERA },
	{ "-crtkill",	0,		CRTKIL },
	{ "tilde",	TILDE,		0 },
	{ "-tilde",	0,		TILDE },
	{ "mdmbuf",	MDMBUF,		0 },
	{ "-mdmbuf",	0,		MDMBUF },
	{ "litout",	LITOUT,		0 },
	{ "-litout",	0,		LITOUT },
	{ "tostop",	TOSTOP,		0 },
	{ "-tostop",	0,		TOSTOP },
	{ "flusho",	FLUSHO,		0 },
	{ "-flusho",	0,		FLUSHO },
	{ "nohang",	NOHANG,		0 },
	{ "-nohang",	0,		NOHANG },
E 13
I 13
	"even",		EVENP, 0, 0, 0,
	"-even",	0, EVENP, 0, 0,
	"odd",		ODDP, 0, 0, 0,
	"-odd",		0, ODDP, 0, 0,
	"raw",		RAW, 0, 0, 0,
	"-raw",		0, RAW, 0, 0,
	"cooked",	0, RAW, 0, 0,
	"-nl",		CRMOD, 0, 0, 0,
	"nl",		0, CRMOD, 0, 0,
	"echo",		ECHO, 0, 0, 0,
	"-echo",	0, ECHO, 0, 0,
	"LCASE",	LCASE, 0, 0, 0,
	"lcase",	LCASE, 0, 0, 0,
	"-LCASE",	0, LCASE, 0, 0,
	"-lcase",	0, LCASE, 0, 0,
	"-tabs",	XTABS, 0, 0, 0,
	"tabs",		0, XTABS, 0, 0,
	"tandem",	TANDEM, 0, 0, 0,
	"-tandem",	0, TANDEM, 0, 0,
	"cbreak",	CBREAK, 0, 0, 0,
	"-cbreak",	0, CBREAK, 0, 0,
	"cr0",		CR0, CR3, 0, 0,
	"cr1",		CR1, CR3, 0, 0,
	"cr2",		CR2, CR3, 0, 0,
	"cr3",		CR3, CR3, 0, 0,
	"tab0",		TAB0, XTABS, 0, 0,
	"tab1",		TAB1, XTABS, 0, 0,
	"tab2",		TAB2, XTABS, 0, 0,
	"nl0",		NL0, NL3, 0, 0,
	"nl1",		NL1, NL3, 0, 0,
	"nl2",		NL2, NL3, 0, 0,
	"nl3",		NL3, NL3, 0, 0,
	"ff0",		FF0, FF1, 0, 0,
	"ff1",		FF1, FF1, 0, 0,
	"bs0",		BS0, BS1, 0, 0,
	"bs1",		BS1, BS1, 0, 0,
	"33",		CR1, ALLDELAY, 0, 0,
	"tty33",	CR1, ALLDELAY, 0, 0,
	"37",		FF1+CR2+TAB1+NL1, ALLDELAY, 0, 0,
	"tty37",	FF1+CR2+TAB1+NL1, ALLDELAY, 0, 0,
	"05",		NL2, ALLDELAY, 0, 0,
	"vt05",		NL2, ALLDELAY, 0, 0,
	"tn",		CR1, ALLDELAY, 0, 0,
	"tn300",	CR1, ALLDELAY, 0, 0,
	"ti",		CR2, ALLDELAY, 0, 0,
	"ti700",	CR2, ALLDELAY, 0, 0,
	"tek",		FF1, ALLDELAY, 0, 0,
	"crtbs",	0, 0, LCRTBS, LPRTERA,
	"-crtbs",	0, 0, 0, LCRTBS,
	"prterase",	0, 0, LPRTERA, LCRTBS+LCRTKIL+LCRTERA,
	"-prterase",	0, 0, 0, LPRTERA,
	"crterase",	0, 0, LCRTERA, LPRTERA,
	"-crterase",	0, 0, 0, LCRTERA,
	"crtkill",	0, 0, LCRTKIL, LPRTERA,
	"-crtkill",	0, 0, 0, LCRTKIL,
	"tilde",	0, 0, LTILDE, 0,
	"-tilde",	0, 0, 0, LTILDE,
	"mdmbuf",	0, 0, LMDMBUF, 0,
	"-mdmbuf",	0, 0, 0, LMDMBUF,
	"litout",	0, 0, LLITOUT, 0,
	"-litout",	0, 0, 0, LLITOUT,
I 20
	"pass8",	0, 0, LPASS8, 0,
	"-pass8",	0, 0, 0, LPASS8,
E 20
	"tostop",	0, 0, LTOSTOP, 0,
	"-tostop",	0, 0, 0, LTOSTOP,
	"flusho",	0, 0, LFLUSHO, 0,
	"-flusho",	0, 0, 0, LFLUSHO,
	"nohang",	0, 0, LNOHANG, 0,
	"-nohang",	0, 0, 0, LNOHANG,
E 13
#ifdef notdef
D 13
	{ "etxack",	ETXACK,		0 },
	{ "-etxack",	0,		ETXACK },
E 13
I 13
	"etxack",	0, 0, LETXACK, 0,
	"-etxack",	0, 0, 0, LETXACK,
E 26
I 26
D 28
#ifndef STATIC
D 27
#define STATIC
E 27
I 27
#define STATIC	/* ??? */
E 27
E 26
E 13
#endif
D 13
	{ "ctlecho",	CTLECH,		0 },
	{ "-ctlecho",	0,		CTLECH },
	{ "pendin",	PENDIN,		0 },
	{ "-pendin",	0,		PENDIN },
	{ "decctlq",	DECCTQ,		0 },
	{ "-decctlq",	0,		DECCTQ },
	{ "noflsh",	NOFLSH,		0 },
	{ "-noflsh",	0,		NOFLSH },
	{ 0 },
E 13
I 13
D 26
	"ctlecho",	0, 0, LCTLECH, 0,
	"-ctlecho",	0, 0, 0, LCTLECH,
	"pendin",	0, 0, LPENDIN, 0,
	"-pendin",	0, 0, 0, LPENDIN,
	"decctlq",	0, 0, LDECCTQ, 0,
	"-decctlq",	0, 0, 0, LDECCTQ,
	"noflsh",	0, 0, LNOFLSH, 0,
	"-noflsh",	0, 0, 0, LNOFLSH,
	0,
E 26
I 26

#define eq(s1, s2)	(strcmp(s1, s2) == 0)
E 28
I 28
D 40
#define eq(s1, s2)	(strcmp((s1), (s2)) == 0)
E 28
#define WRAPCOL 65
E 40
I 40
D 46
static void usage __P((void));
E 46
I 46
D 47
static char usage[] = "usage: stty: [-eg] [-f file] [options]";
E 47
I 47
D 49
char *usage = "usage: stty: [-eg] [-f file] [options]";
E 49
I 49
D 50
char *usage = "usage: stty: [-aefg] [-f file] [options]";
E 50
I 50
D 52
char *usage = "usage: stty: [-a|-e|-g] [-f file] [options]";
E 50
E 49
E 47
E 46
E 40
D 28
#define COMPAT_43
E 28

E 52
I 52
int
E 52
D 28
STATIC struct modes {
E 28
I 28
D 40
struct modes {
E 28
	char *name;
	long set;
	long unset;
E 26
E 13
E 10
};

D 10
struct tchars tc;
struct ltchars ltc;
struct sgttyb mode;
int	lmode;
E 10
I 10
D 13
struct ttychars tc;
struct sgttyb sb;
long	flags;
E 13
I 13
D 26
struct tchars tc;
struct ltchars ltc;
struct sgttyb mode;
I 17
struct winsize win;
E 17
int	lmode;
E 13
E 10
int	oldisc, ldisc;
E 26
I 26
D 28
STATIC struct modes imodes[] = {
E 28
I 28
struct modes imodes[] = {
E 28
	"ignbrk",	IGNBRK, 0,
	"-ignbrk",	0, IGNBRK,
	"brkint",	BRKINT, 0,
	"-brkint",	0, BRKINT,
	"ignpar",	IGNPAR, 0,
	"-ignpar",	0, IGNPAR,
	"parmrk",	PARMRK, 0,
	"-parmrk",	0, PARMRK,
	"inpck",	INPCK, 0,
	"-inpck",	0, INPCK,
	"istrip",	ISTRIP, 0,
	"-istrip",	0, ISTRIP,
	"inlcr",	INLCR, 0,
	"-inlcr",	0, INLCR,
	"igncr",	IGNCR, 0,
	"-igncr",	0, IGNCR,
	"icrnl",	ICRNL, 0,
	"-icrnl",	0, ICRNL,
	"ixon",		IXON, 0,
	"-ixon",	0, IXON,
	"flow",		IXON, 0,
	"-flow",	0, IXON,
	"ixoff",	IXOFF, 0,
	"-ixoff",	0, IXOFF,
	"tandem",	IXOFF, 0,
	"-tandem",	0, IXOFF,
	"ixany",	IXANY, 0,
	"-ixany",	0, IXANY,
	"decctlq",	0, IXANY,
	"-decctlq",	IXANY, 0,
	"imaxbel",	IMAXBEL, 0,
	"-imaxbel",	0, IMAXBEL,
	0
};
E 26

D 10
#define	CTRL(x)		('x'&037)

E 10
D 26
struct	special {
	char	*name;
	char	*cp;
	char	def;
} special[] = {
D 10
	"erase",	&mode.sg_erase,		CTRL(h),
	"kill",		&mode.sg_kill,		'@',
	"intr",		&tc.t_intrc,		0177,
	"quit",		&tc.t_quitc,		CTRL(\\\\),
	"start",	&tc.t_startc,		CTRL(q),
	"stop",		&tc.t_stopc,		CTRL(s),
	"eof",		&tc.t_eofc,		CTRL(d),
	"brk",		&tc.t_brkc,		0377,
	"susp",		&ltc.t_suspc,		CTRL(z),
	"dsusp",	&ltc.t_dsuspc,		CTRL(y),
	"rprnt",	&ltc.t_rprntc,		CTRL(r),
	"flush",	&ltc.t_flushc,		CTRL(o),
	"werase",	&ltc.t_werasc,		CTRL(w),
	"lnext",	&ltc.t_lnextc,		CTRL(v),
E 10
I 10
D 13
	{ "erase",	&tc.tc_erase,		CERASE },
	{ "kill",	&tc.tc_kill,		CKILL },
	{ "intr",	&tc.tc_intrc,		CINTR },
	{ "quit",	&tc.tc_quitc,		CQUIT },
	{ "start",	&tc.tc_startc,		CSTART },
	{ "stop",	&tc.tc_stopc,		CSTOP },
	{ "eof",	&tc.tc_eofc,		CEOF },
	{ "brk",	&tc.tc_brkc,		CBRK },
	{ "susp",	&tc.tc_suspc,		CSUSP },
	{ "dsusp",	&tc.tc_dsuspc,		CDSUSP },
	{ "rprnt",	&tc.tc_rprntc,		CRPRNT },
	{ "flush",	&tc.tc_flushc,		CFLUSH },
	{ "werase",	&tc.tc_werasc,		CWERASE },
	{ "lnext",	&tc.tc_lnextc,		CLNEXT },
E 13
I 13
	"erase",	&mode.sg_erase,		CERASE,
	"kill",		&mode.sg_kill,		CKILL,
	"intr",		&tc.t_intrc,		CINTR,
	"quit",		&tc.t_quitc,		CQUIT,
	"start",	&tc.t_startc,		CSTART,
	"stop",		&tc.t_stopc,		CSTOP,
	"eof",		&tc.t_eofc,		CEOF,
	"brk",		&tc.t_brkc,		CBRK,
	"susp",		&ltc.t_suspc,		CSUSP,
	"dsusp",	&ltc.t_dsuspc,		CDSUSP,
	"rprnt",	&ltc.t_rprntc,		CRPRNT,
	"flush",	&ltc.t_flushc,		CFLUSH,
	"werase",	&ltc.t_werasc,		CWERASE,
	"lnext",	&ltc.t_lnextc,		CLNEXT,
E 26
I 26
D 28
STATIC struct modes omodes[] = {
E 28
I 28
struct modes omodes[] = {
E 28
	"opost",	OPOST, 0,
	"-opost",	0, OPOST,
	"-litout",	OPOST, 0,
	"litout",	0, OPOST,
	"onlcr",	ONLCR, 0,
	"-onlcr",	0, ONLCR,
	"tabs",		0, OXTABS,	/* "preserve" tabs */
	"-tabs",	OXTABS, 0,
I 29
	"xtabs",	OXTABS, 0,
	"-xtabs",	0, OXTABS,
E 29
D 27
	"xtabs",	OXTABS, 0,
	"-xtabs",	0, OXTABS,
E 27
I 27
D 28
	"xtabs",	OXTABS, 0,	/* ??? */
	"-xtabs",	0, OXTABS,	/* ??? */
E 28
E 27
	"oxtabs",	OXTABS, 0,
	"-oxtabs",	0, OXTABS,
E 26
E 13
E 10
	0
};
D 26
char	*arg;
E 26

D 26
int	argc;
char	**argv;
I 10
D 13

E 13
E 10
main(iargc, iargv)
D 10
char	**iargv;
E 10
I 10
D 13
	int iargc;
	char *iargv[];
E 13
I 13
char	**iargv;
E 26
I 26
D 28
STATIC struct modes cmodes[] = {
E 28
I 28
struct modes cmodes[] = {
E 28
	"cs5",		CS5, CSIZE,
	"cs6",		CS6, CSIZE,
	"cs7",		CS7, CSIZE,
	"cs8",		CS8, CSIZE,
	"cstopb",	CSTOPB, 0,
	"-cstopb",	0, CSTOPB,
	"cread",	CREAD, 0,
	"-cread",	0, CREAD,
	"parenb",	PARENB, 0,
	"-parenb",	0, PARENB,
	"parodd",	PARODD, 0,
	"-parodd",	0, PARODD,
	"parity",	PARENB | CS7, PARODD | CSIZE,
	"evenp",	PARENB | CS7, PARODD | CSIZE,
	"oddp",		PARENB | CS7 | PARODD, CSIZE,
	"-parity",	CS8, PARODD | PARENB | CSIZE,
I 27
	"pass8",	CS8, PARODD | PARENB | CSIZE,
E 27
	"-evenp",	CS8, PARODD | PARENB | CSIZE,
	"-oddp",	CS8, PARODD | PARENB | CSIZE,
	"hupcl",	HUPCL, 0,
	"-hupcl",	0, HUPCL,
	"hup",		HUPCL, 0,
	"-hup",		0, HUPCL,
	"clocal",	CLOCAL, 0,
	"-clocal",	0, CLOCAL,
	"crtscts",	CRTSCTS, 0,
	"-crtscts",	0, CRTSCTS,
	0
};

D 28
STATIC struct modes lmodes[] = {
E 28
I 28
struct modes lmodes[] = {
E 28
	"echo",		ECHO, 0,
	"-echo",	0, ECHO,
	"echoe",	ECHOE, 0,
	"-echoe",	0, ECHOE,
	"crterase",	ECHOE, 0,
	"-crterase",	0, ECHOE,
	"crtbs",	ECHOE, 0,   /* crtbs not supported, close enough */
	"-crtbs",	0, ECHOE,
	"echok",	ECHOK, 0,
	"-echok",	0, ECHOK,
	"echoke",	ECHOKE, 0,
	"-echoke",	0, ECHOKE,
	"crtkill",	ECHOKE, 0,
	"-crtkill",	0, ECHOKE,
	"altwerase",	ALTWERASE, 0,
	"-altwerase",	0, ALTWERASE,
	"iexten",	IEXTEN, 0,
	"-iexten",	0, IEXTEN,
	"echonl",	ECHONL, 0,
	"-echonl",	0, ECHONL,
	"echoctl",	ECHOCTL, 0,
	"-echoctl",	0, ECHOCTL,
	"ctlecho",	ECHOCTL, 0,
	"-ctlecho",	0, ECHOCTL,
	"echoprt",	ECHOPRT, 0,
	"-echoprt",	0, ECHOPRT,
	"prterase",	ECHOPRT, 0,
	"-prterase",	0, ECHOPRT,
	"isig",		ISIG, 0,
	"-isig",	0, ISIG,
	"icanon",	ICANON, 0,
	"-icanon",	0, ICANON,
	"noflsh",	NOFLSH, 0,
	"-noflsh",	0, NOFLSH,
	"tostop",	TOSTOP, 0,
	"-tostop",	0, TOSTOP,
	"mdmbuf",	MDMBUF, 0,
	"-mdmbuf",	0, MDMBUF,
D 30
	"nohang",	NOHANG, 0,
	"-nohang",	0, NOHANG,
E 30
	"flusho",	FLUSHO, 0,
	"-flusho",	0, FLUSHO,
	"pendin",	PENDIN, 0,
	"-pendin",	0, PENDIN,
	"crt",		ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT,
	"-crt",		ECHOK, ECHOE|ECHOKE|ECHOCTL,
	"newcrt",	ECHOE|ECHOKE|ECHOCTL, ECHOK|ECHOPRT,
	"-newcrt",	ECHOK, ECHOE|ECHOKE|ECHOCTL, 
I 37
	"nokerninfo",	NOKERNINFO, 0,
	"-nokerninfo",	0, NOKERNINFO,
	"kerninfo",	0, NOKERNINFO,
	"-kerninfo",	NOKERNINFO, 0,
E 37
	0
};

/*
 * Special control characters.
 *
 * Each entry has a list of names.  The first is the primary name
 * and is used when printing the control character in the "name = val;"
 * form.  The second is an abbreviation which is guaranteed to be less
 * than or equal to four characters in length and is primarily used
 * when printing the values in columunar form (guarantees all will
 * fit within 80 cols).  The rest are optional aliases.
 * All names are recognized on the command line.
 */
D 27
#define MAXNAMES 5
E 27
I 27
D 28
#define MAXNAMES 5	/* ??? */
E 27
STATIC struct {
D 27
	char	*names[MAXNAMES+1];
E 27
I 27
	char	*names[MAXNAMES+1];	/* ??? */
E 28
I 28
#define MAXNAMES 3
struct {
D 29
	char	*names[MAXNAMES];
E 29
I 29
	char	*names[MAXNAMES+1];
E 29
E 28
E 27
	int	sub;
	u_char	def;
} cchars[] = {
D 31
	{ "erase", "era" },		VERASE,	CERASE,
	{ "werase", "wera" },		VWERASE, CWERASE,
	{ "kill", "kill" },		VKILL,	CKILL,
	{ "intr", "int" },		VINTR,	CINTR,
	{ "quit", "quit" },		VQUIT,	CQUIT,
	{ "susp", "susp" },		VSUSP,	CSUSP,
	{ "dsusp", "dsus" },		VDSUSP,	CDSUSP,
	{ "eof", "eof" },		VEOF,	CEOF,
	{ "eol", "eol", "brk" },	VEOL,	CEOL,
	{ "eol2", "eol2" },		VEOL2,	CEOL,
	{ "stop", "stop", "xoff" },	VSTOP,	CSTOP,
	{ "start", "star", "xon" },	VSTART,	CSTART,
	{ "lnext", "lnxt" },		VLNEXT,	CLNEXT,
	{ "flusho", "fls", "flush" },	VFLUSHO, CFLUSHO,
	{ "reprint", "rpnt", "rprnt" },	VREPRINT, CREPRINT,
I 27
	{ "info", "info" },		VINFO, CINFO,
E 31
I 31
	{{ "erase", "era" },		VERASE,	CERASE, },
I 34
D 35
	{{ "erase2", "era2" },		VERASE2, _POSIX_VDISABLE, },
E 35
E 34
	{{ "werase", "wera" },		VWERASE, CWERASE, },
	{{ "kill", "kill" },		VKILL,	CKILL, },
	{{ "intr", "int" },		VINTR,	CINTR, },
	{{ "quit", "quit" },		VQUIT,	CQUIT, },
	{{ "susp", "susp" },		VSUSP,	CSUSP, },
	{{ "dsusp", "dsus" },		VDSUSP,	CDSUSP, },
	{{ "eof", "eof" },		VEOF,	CEOF, },
	{{ "eol", "eol", "brk" },	VEOL,	CEOL, },
	{{ "eol2", "eol2" },		VEOL2,	CEOL, },
	{{ "stop", "stop", "xoff" },	VSTOP,	CSTOP, },
	{{ "start", "star", "xon" },	VSTART,	CSTART, },
	{{ "lnext", "lnxt" },		VLNEXT,	CLNEXT, },
D 32
	{{ "flusho", "fls", "flush" },	VFLUSHO, CFLUSHO, },
E 32
I 32
D 34
	{{ "discard", "disc", },	VDISCARD, CDISCARD, },
E 34
I 34
	{{ "discard", "disc", "flush" },	VDISCARD, CDISCARD, },
E 34
E 32
	{{ "reprint", "rpnt", "rprnt" },	VREPRINT, CREPRINT, },
D 34
	{{ "info", "info" },		VINFO, CINFO, },
E 34
I 34
	{{ "status", "stat" },		VSTATUS, CSTATUS, },
E 34
E 31
E 27
	0
};
D 31
	
E 31
I 31

E 31
D 28
STATIC struct winsize win;
STATIC int ldisc;
STATIC int dodisc;
STATIC int debug = 0;
STATIC int trace, dotrace;
E 28
I 28
struct winsize win;
int ldisc;
D 38
int dodisc;
E 38
int debug = 0;
int trace, dotrace;
I 37
int extproc;
E 37
E 28

#define OUT	stdout		/* informational output stream */
#define ERR	stderr		/* error message stream */
#define CTL	0		/* default control descriptor */
D 28
STATIC int ctl = CTL;
E 28
I 28
int ctl = CTL;
E 28

extern errno;
D 28
extern char *sys_errlist[];
E 28

#define NORMAL	0	/* only print modes differing from defaults */
#define ALL	1	/* print all modes - POSIX standard format */
#define ALL_BSD	2	/* print all modes - using BSD shorthand for cc's */
D 33
#define GFMT	3	/* print modes in a form that can be re-input to stty */
E 33
I 33
#define	GFMT	3	/* print modes in form suitable to be re-input */
E 33

E 40
D 28
STATIC
E 28
I 28
D 33

E 33
E 28
main(argc, argv) 
D 40
	char *argv[];
E 40
I 40
	int argc;
D 51
	char **argv;
E 51
I 51
	char *argv[];
E 51
E 40
E 26
E 13
E 10
{
D 26
	int i;
	register struct special *sp;
	char obuf[BUFSIZ];
E 26
I 26
D 40
	struct termios t;
	int i, fmt = NORMAL;
E 40
D 46
	extern char *optarg;
D 41
	extern int optind;
E 41
I 41
	extern int opterr, optind;
E 41
D 40
	int ch;
E 40
I 40
	extern struct cchar cchars1[], cchars2[];
	extern struct modes cmodes[], imodes[], lmodes[], omodes[];
E 46
D 47
	register struct modes *mp;
	register struct cchar *cp;
E 47
D 46
	struct winsize win;
	struct termios t;
E 46
I 46
	struct info i;
D 47
	struct key *kp;
E 47
E 46
	enum FMT fmt;
D 45
	int ch, ctl, ldisc, tmp;
E 45
I 45
D 46
	int ch, ctl, ldisc, set, tmp, wset;
E 46
I 46
	int ch;
E 46
E 45
E 40
E 26

D 26
	setbuf(stderr, obuf);
	argc = iargc;
	argv = iargv;
D 10
	gtty(1, &mode);
E 10
I 10
D 13
	ioctl(1, TIOCCGET, (char *)&tc);
	ioctl(1, TIOCGET, (char *)&flags);
E 13
I 13
	ioctl(1, TIOCGETP, &mode);
E 13
E 10
	ioctl(1, TIOCGETD, &ldisc);
I 10
D 13
#ifndef notdef
	ioctl(1, TIOCGETP, (char *)&sb);
#endif
E 13
E 10
	oldisc = ldisc;
D 10
	ioctl(1, TIOCGETC, &tc);
	ioctl(1, TIOCLGET, &lmode);
	ioctl(1, TIOCGLTC, &ltc);
	if(argc == 1) {
E 10
I 10
D 13
	if (argc == 1) {
E 13
I 13
	ioctl(1, TIOCGETC, &tc);
	ioctl(1, TIOCLGET, &lmode);
	ioctl(1, TIOCGLTC, &ltc);
I 17
	ioctl(1, TIOCGWINSZ, &win);
E 17
	if(argc == 1) {
E 13
E 10
		prmodes(0);
		exit(0);
E 26
I 26
D 40
	argc--, argv++;
	if (argc > 0 && eq(argv[0], "-a")) {
		fmt = ALL;
		argc--, argv++;
E 26
	}
I 33
	if (argc > 0 && eq(argv[0], "-g")) {
		fmt = GFMT;
		argc--, argv++;
	}
E 33
D 26
	if (argc == 2 && !strcmp(argv[1], "all")) {
		prmodes(1);
		exit(0);
E 26
I 26
	if (argc > 0 && eq(argv[0], "-f")) {
		argc--, argv++;
		if ((ctl = open(argv[0], O_RDONLY | O_NONBLOCK)) < 0)
			syserrexit(*argv);
		argc--, argv++;
E 26
	}
E 40
I 40
D 46
	ctl = STDIN_FILENO;
E 46
	fmt = NOTSET;
I 46
	i.fd = STDIN_FILENO;

E 46
I 41
	opterr = 0;
E 41
D 44
	while ((ch = getopt(argc, argv, "aef:g")) != EOF)
E 44
I 44
D 51
	while (strspn(argv[optind], "-aefg") == strlen(argv[optind]) &&
E 51
I 51
	while (optind < argc &&
	    strspn(argv[optind], "-aefg") == strlen(argv[optind]) &&
E 51
	    (ch = getopt(argc, argv, "aef:g")) != EOF)
E 44
		switch(ch) {
		case 'a':		/* undocumented: POSIX compatibility */
			fmt = POSIX;
			break;
		case 'e':
			fmt = BSD;
			break;
		case 'f':
D 46
			if ((ctl = open(optarg, O_RDONLY | O_NONBLOCK)) < 0)
E 46
I 46
			if ((i.fd = open(optarg, O_RDONLY | O_NONBLOCK)) < 0)
E 46
D 44
				err(optarg);
E 44
I 44
D 52
				err("%s: %s", optarg, strerror(errno));
E 52
I 52
				err(1, "%s", optarg);
E 52
E 44
			break;
		case 'g':
			fmt = GFLAG;
			break;
		case '?':
D 41
			usage();
E 41
		default:
D 41
			--optind;
E 41
			goto args;
		}

args:	argc -= optind;
	argv += optind;

E 40
D 26
	if (argc == 2 && !strcmp(argv[1], "everything")) {
		prmodes(2);
E 26
I 26
D 28
#ifdef notyet
	while ((ch = getopt(argc, argv, "f:ga")) != EOF)
		switch((char)ch) {
		case 'f':
			if ((ctl = open(*optarg, O_RDONLY | O_NONBLOCK)) < 0)
				syserrexit(*argv);
			break;
		case 'a':
			fmt = ALL;
			break;
		case 'g':
			fmt = GFMT;
			break;
		case '?':
		default:
			fprintf(stderr, "usage: %s", *argv);
			exit(1);
		}
	argc -= optind;
	argv += optind;
#endif

E 28
D 46
	if (ioctl(ctl, TIOCGETD, &ldisc) < 0)
E 46
I 46
	if (ioctl(i.fd, TIOCGETD, &i.ldisc) < 0)
E 46
D 40
		syserrexit("TIOCGETD");
E 40
I 40
D 52
		err("TIOCGETD: %s", strerror(errno));
E 52
I 52
		err(1, "TIOCGETD");
E 52
E 40
D 46
	if (tcgetattr(ctl, &t) < 0)
E 46
I 46
	if (tcgetattr(i.fd, &i.t) < 0)
E 46
D 40
		syserrexit("tcgetattr");
E 40
I 40
D 52
		err("tcgetattr: %s", strerror(errno));
E 52
I 52
		err(1, "tcgetattr");
E 52
E 40
D 46
	if (ioctl(ctl, TIOCGWINSZ, &win) < 0)
E 46
I 46
	if (ioctl(i.fd, TIOCGWINSZ, &i.win) < 0)
E 46
D 28
		warning("TIOCGWINSZ: %s", sys_errlist[errno]);

#ifdef COMPAT_43
E 28
I 28
D 40
		warning("TIOCGWINSZ: %s", strerror(errno));
E 28
	checkredirect();	/* conversion aid */
E 40
I 40
		warn("TIOCGWINSZ: %s\n", strerror(errno));
E 40
D 28
#endif
E 28

D 40
	if (argc == 0 || fmt) {
		prmode(&t, ldisc, fmt);
E 26
		exit(0);
E 40
I 40
	checkredirect();			/* conversion aid */

	switch(fmt) {
	case NOTSET:
		if (*argv)
			break;
		/* FALLTHROUGH */
	case BSD:
	case POSIX:
D 46
		print(&t, &win, ldisc, fmt);
E 46
I 46
		print(&i.t, &i.win, i.ldisc, fmt);
E 46
		break;
	case GFLAG:
D 46
		gprint(&t, &win, ldisc);
E 46
I 46
		gprint(&i.t, &i.win, i.ldisc);
E 46
		break;
E 40
I 26
D 33
	} else if (argc == 1 && strlen(argv[0]) > 2 && *(argv[0]+2) == ':') {
		gfmtset(argv[0]);
		goto setit;
E 33
E 26
	}
D 10
/*
	if (argc == 2 && !strcmp(argv[1], "all")) {
		prmodes(2);
		exit(0);
	}
*/
	while(--argc > 0) {
E 10
I 10
D 13
	while (--argc > 0) {
E 13
I 13
D 26
/*
	if (argc == 2 && !strcmp(argv[1], "all")) {
		prmodes(2);
		exit(0);
	}
*/
	while(--argc > 0) {
E 13
E 10
		arg = *++argv;
D 10
		if (eq("ek")){
			mode.sg_erase = '#';
			mode.sg_kill = '@';
E 10
I 10
D 13
		if (eq("ek")) {
			tc.tc_erase = '#';
			tc.tc_kill = '@';
E 13
I 13
		if (eq("ek")){
			mode.sg_erase = '#';
			mode.sg_kill = '@';
E 13
E 10
			continue;
E 26
I 26
	
D 40
	while (*argv) {
		if (eq("everything", *argv)) {
			prmode(&t, ldisc, ALL_BSD);
			exit(0);
E 40
I 40
D 46
#define	CHK(s)	(**argv == s[0] && !strcmp(*argv, s))

D 45
	for (; *argv; ++argv) {
E 45
I 45
	for (set = wset = 0; *argv; ++argv) {
E 45
		if (CHK("-nl")) {
			t.c_iflag |= ICRNL;
			t.c_oflag |= ONLCR;
I 45
			set = 1;
E 46
I 46
	for (i.set = i.wset = 0; *argv; ++argv) {
D 47
		i.off = **argv == '-';
		if (kp = ksearch(i.off ? *argv + 1 : *argv)) {
			if (!(kp->flags & F_OFFOK) && i.off)
				err("illegal option -- %s\n%s", *argv, usage);
			if (kp->flags & F_NEEDARG && !(i.arg = *++argv))
				err("option requires an argument -- %s\n%s",
				    kp->name, usage);
			kp->f(&i);
E 47
I 47
		if (ksearch(&argv, &i))
E 47
E 46
E 45
			continue;
E 40
E 26
D 47
		}
D 10
		if (eq("new")){
E 10
I 10
D 13
		if (eq("new")) {
E 13
I 13
D 26
		if (eq("new")){
E 13
E 10
			ldisc = NTTYDISC;
D 10
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 10
I 10
D 13
			if (ioctl(1, TIOCSETD, &ldisc) < 0)
E 13
I 13
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 13
E 10
				perror("ioctl");
			continue;
E 26
I 26
D 40
		if (eq("all", *argv)) {
			prmode(&t, ldisc, ALL);
			exit(0);
E 40
I 40
D 46
		if (CHK("all")) {
			print(&t, &win, ldisc, BSD);
			continue;
E 40
E 26
		}
D 10
		if (eq("newcrt")){
E 10
I 10
D 13
		if (eq("newcrt")) {
E 13
I 13
D 26
		if (eq("newcrt")){
E 13
E 10
			ldisc = NTTYDISC;
D 10
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 10
I 10
D 13
			flags &= ~PRTERA;
			flags |= CRTBS|CTLECH;
			if (sb.sg_ospeed >= B1200)
				flags |= CRTERA|CRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc) < 0)
E 13
I 13
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 13
E 10
				perror("ioctl");
			continue;
E 26
I 26
D 38
		if (eq("old", *argv)) {
E 38
I 38
D 40
		if (eq("tty", *argv) || eq("old", *argv) || eq("new", *argv)) {
			int nldisc = TTYDISC;

			if (ioctl(0, TIOCSETD, &nldisc) < 0)
				syserrexit("TIOCSETD");
E 38
			goto next;
E 40
I 40
		if (CHK("-cbreak"))
			goto reset;
		if (CHK("cbreak")) {
			t.c_iflag | BRKINT|IXON|IMAXBEL;
			t.c_oflag |= OPOST;
			t.c_lflag |= ISIG|IEXTEN;
			t.c_lflag &= ~ICANON;
I 45
			set = 1;
E 45
			continue;
E 40
E 26
		}
D 10
		if (eq("crt")){
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
E 10
I 10
D 13
		if (eq("crt")) {
			flags &= ~PRTERA;
			flags |= CRTBS|CTLECH;
			if (sb.sg_ospeed >= B1200)
				flags |= CRTERA|CRTKIL;
E 13
I 13
D 26
		if (eq("crt")){
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
E 13
E 10
			continue;
E 26
I 26
D 38
		if (eq("new", *argv)) {
			goto next;
E 26
		}
E 38
D 10
		if (eq("old")){
			ldisc = 0;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 10
I 10
D 13
		if (eq("old")) {
			ldisc = OTTYDISC;
			if (ioctl(1, TIOCSETD, &ldisc) < 0)
E 13
I 13
D 26
		if (eq("old")){
			ldisc = 0;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 13
E 10
				perror("ioctl");
			continue;
E 26
I 26
D 40
		if (eq("nl", *argv)) {
			t.c_iflag &= ~ICRNL;
			t.c_oflag &= ~ONLCR;
			goto next;
E 40
I 40
		if (CHK("cols")) {
			if (!*++argv)
				err("option requires an argument -- cols");
			goto columns;
E 40
E 26
		}
I 4
D 10
		if (eq("dec")){
			mode.sg_erase = 0177;
			mode.sg_kill = CTRL(u);
			tc.t_intrc = CTRL(c);
E 10
I 10
D 13
		if (eq("dec")) {
			tc.tc_erase = 0177;
			tc.tc_kill = CTRL(u);
			tc.tc_intrc = CTRL(c);
E 13
I 13
D 26
		if (eq("dec")){
			mode.sg_erase = 0177;
D 24
			mode.sg_kill = CTRL(u);
			tc.t_intrc = CTRL(c);
E 24
I 24
			mode.sg_kill = CKILL;
			tc.t_intrc = CINTR;
E 24
E 13
E 10
			ldisc = NTTYDISC;
D 10
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH|LDECCTQ;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 10
I 10
D 13
			flags &= ~PRTERA;
			flags |= CRTBS|CTLECH|DECCTQ;
			if (sb.sg_ospeed >= B1200)
				flags |= CRTERA|CRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc) < 0)
E 13
I 13
			lmode &= ~LPRTERA;
			lmode |= LCRTBS|LCTLECH|LDECCTQ;
			if (mode.sg_ospeed >= B1200)
				lmode |= LCRTERA|LCRTKIL;
			if (ioctl(1, TIOCSETD, &ldisc)<0)
E 13
E 10
				perror("ioctl");
			continue;
E 26
I 26
D 40
		if (eq("-nl", *argv)) {
			t.c_iflag |= ICRNL;
			t.c_oflag |= ONLCR;
			goto next;
E 40
I 40
		if (CHK("columns")) {
			if (!*++argv)
				err("option requires an argument -- columns");
columns:		win.ws_col = atoi(*argv);
I 45
			wset = 1;
E 45
			continue;
E 40
E 26
		}
E 4
D 26
		for (sp = special; sp->name; sp++)
			if (eq(sp->name)) {
				if (--argc == 0)
					goto done;
				if (**++argv == 'u')
					*sp->cp = 0377;
				else if (**argv == '^')
D 3
					*sp->cp = (*(argv[1]) == '?') ?
E 3
I 3
D 4
					*sp->cp = ((*argv)[1] == '?') ?
E 4
I 4
D 5
					*sp->cp = (*(argv[1]) == '?') ?
E 5
I 5
D 6
					*sp->cp = (*argv)[1] == '?') ?
E 6
I 6
					*sp->cp = ((*argv)[1] == '?') ?
E 6
E 5
E 4
E 3
					    0177 : (*argv)[1] & 037;
				else
					*sp->cp = **argv;
				goto cont;
			}
		if (eq("gspeed")) {
D 10
			mode.sg_ispeed = B300;
			mode.sg_ospeed = B9600;
E 10
I 10
D 13
			sb.sg_ispeed = B300;
			sb.sg_ospeed = B9600;
E 13
I 13
			mode.sg_ispeed = B300;
			mode.sg_ospeed = B9600;
E 13
E 10
			continue;
E 26
I 26
D 40
		if (eq("dec", *argv)){
E 40
I 40
		if (CHK("cooked"))
			goto reset;
		if (CHK("dec")) {
E 40
			t.c_cc[VERASE] = (u_char)0177;
			t.c_cc[VKILL] = CTRL('u');
			t.c_cc[VINTR] = CTRL('c');
			t.c_lflag &= ~ECHOPRT;
			t.c_lflag |= ECHOE|ECHOKE|ECHOCTL;
			t.c_iflag &= ~IXANY;
I 45
			set = 1;
E 45
D 40
			goto next;
E 40
I 40
			continue;
E 40
E 26
		}
I 27
D 40
		if (eq("raw", *argv)) {
E 40
I 40
		if (CHK("everything")) {
			print(&t, &win, ldisc, BSD);
			continue;
		}
		if (CHK("-extproc")) {
			tmp = 0;
			ioctl(ctl, TIOCEXT, &tmp);
			continue;
		}
D 45
		if (CHK("extrpc")) {
E 45
I 45
		if (CHK("extproc")) {
E 45
			tmp = 1;
			ioctl(ctl, TIOCEXT, &tmp);
			continue;
		}
		if (CHK("ispeed")) {
			if (!*++argv)
				err("option requires an argument -- ispeed");
			cfsetispeed(&t, atoi(*argv));
I 45
			set = 1;
E 45
			continue;
		}
		if (CHK("new"))
			goto tty;
		if (CHK("nl")) {
			t.c_iflag &= ~ICRNL;
			t.c_oflag &= ~ONLCR;
I 45
			set = 1;
E 45
			continue;
		}
		if (CHK("old"))
			goto tty;
		if (CHK("ospeed")) {
			if (!*++argv)
				err("option requires an argument -- ospeed");
			cfsetospeed(&t, atoi(*argv));
I 45
			set = 1;
E 45
			continue;
		}
		if (CHK("-raw"))
			goto reset;
		if (CHK("raw")) {
E 40
			cfmakeraw(&t);
			t.c_cflag &= ~(CSIZE|PARENB);
			t.c_cflag |= CS8;
I 45
			set = 1;
E 45
D 40
			goto next;
E 40
I 40
			continue;
E 40
		}
I 36
D 40
		if (eq("cbreak", *argv)) {
			t.c_iflag |  BRKINT|IXON|IMAXBEL;
			t.c_oflag |= OPOST;
			t.c_lflag |= ISIG|IEXTEN;
			t.c_lflag &= ~ICANON;
E 40
I 40
		if (CHK("rows")) {
			if (!*++argv)
				err("option requires an argument -- rows");
			win.ws_row = atoi(*argv);
I 45
			wset = 1;
E 45
			continue;
E 40
		}
E 36
D 40
		if (eq("cooked", *argv) || eq("-raw", *argv) ||
D 36
		    eq("sane", *argv)) {
E 36
I 36
		    eq("sane", *argv) || eq("-cbreak", *argv)) {
E 36
			t.c_cflag = TTYDEF_CFLAG | (t.c_cflag & CLOCAL);
E 40
I 40
		if (CHK("sane")) {
reset:			t.c_cflag = TTYDEF_CFLAG | (t.c_cflag & CLOCAL);
E 40
			t.c_iflag = TTYDEF_IFLAG;
			t.c_iflag |= ICRNL;
			/* preserve user-preference flags in lflag */
#define	LKEEP	(ECHOKE|ECHOE|ECHOK|ECHOPRT|ECHOCTL|ALTWERASE|TOSTOP|NOFLSH)
			t.c_lflag = TTYDEF_LFLAG | (t.c_lflag & LKEEP);
			t.c_oflag = TTYDEF_OFLAG;
I 45
			set = 1;
E 45
D 28
			t.c_oflag |= (OPOST|ONLCR);	/* XXX */
E 28
D 40
			goto next;
E 40
I 40
			continue;
E 40
		}
E 27
D 26
		if (eq("hup")) {
D 10
			ioctl(1, TIOCHPCL, NULL);
E 10
I 10
D 13
			if (ioctl(1, TIOCHPCL, NULL) < 0)
				perror("ioctl");
E 13
I 13
			ioctl(1, TIOCHPCL, NULL);
E 13
E 10
			continue;
		}
I 17
		if (eq("rows")) {
			if (--argc == 0)
				goto done;
E 26
I 26
D 40
		if (eq("rows", *argv)) {
			if (*(argv+1) == 0)
				goto setit;
E 26
			win.ws_row = atoi(*++argv);
I 26
			goto next;
E 40
I 40
		if (CHK("size")) {
			(void)printf("%d %d\n", win.ws_row, win.ws_col);
			continue;
E 40
E 26
		}
D 23
		if (eq("columns")) {
E 23
I 23
D 26
		if (eq("cols") || eq("columns")) {
E 23
			if (--argc == 0)
				goto done;
E 26
I 26
D 40
		if (eq("ispeed", *argv)) {
			int code;
			if (*(argv+1) == 0)
				errexit("missing ispeed");
			cfsetispeed(&t, atoi(*++argv));
			goto next;
E 40
I 40
		if (CHK("speed")) {
			(void)printf("%d\n", cfgetospeed(&t));
			continue;
E 40
		}
D 40
		if (eq("ospeed", *argv)) {
D 28
			int code;
E 28
			if (*(argv+1) == 0)
				errexit("missing ospeed");
			cfsetospeed(&t, atoi(*++argv));
			goto next;
E 40
I 40
		if (CHK("tty")) {
tty:			tmp = TTYDISC;
			if (ioctl(0, TIOCSETD, &tmp) < 0)
				err("TIOCSETD: %s", strerror(errno));
			continue;
E 40
		}
E 46
D 40
		if (eq("cols", *argv) || eq("columns", *argv)) {
			if (*(argv+1) == 0)
				goto setit;
E 26
			win.ws_col = atoi(*++argv);
I 26
			goto next;
E 26
		}
I 22
D 26
		if (eq("size")) {
D 25
			ioctl(open("/dev/tty", 0), TIOCGWINSZ, &win);
E 25
I 25
			ioctl(open(_PATH_DEVTTY, 0), TIOCGWINSZ, &win);
E 25
			printf("%d %d\n", win.ws_row, win.ws_col);
E 26
I 26
		if (eq("size", *argv)) {
			put("%d %d\n", win.ws_row, win.ws_col);
E 26
			exit(0);
		}
I 37
		if (eq("extrpc", *argv) || eq("-extproc", *argv)) {
			if (**argv == '-')
				extproc = 0;
			else
				extproc = 1;
			ioctl(ctl, TIOCEXT, &extproc);
		}
E 37
E 22
E 17
D 10
		for(i=0; speeds[i].string; i++)
			if(eq(speeds[i].string)) {
				mode.sg_ispeed = mode.sg_ospeed = speeds[i].speed;
E 10
I 10
D 13
		for (i = 0; speeds[i].string; i++)
			if (eq(speeds[i].string)) {
				sb.sg_ispeed = sb.sg_ospeed = speeds[i].speed;
E 13
I 13
D 26
		for(i=0; speeds[i].string; i++)
			if(eq(speeds[i].string)) {
				mode.sg_ispeed = mode.sg_ospeed = speeds[i].speed;
E 13
E 10
				goto cont;
E 26
I 26
		if (eq("speed", *argv)) {
			put("%d\n", cfgetospeed(&t));
			exit(0);
		}
		for (i=0; imodes[i].name; i++)
			if (eq(imodes[i].name, *argv)) {
				t.c_iflag &= ~imodes[i].unset;
				t.c_iflag |= imodes[i].set;
E 40
I 40
		
E 47
I 46

D 47
#define	CHK(s)	(**argv == s[0] && !strcmp(*argv, s))
E 46
		for (mp = cmodes; mp->name; ++mp)
			if (CHK(mp->name)) {
D 46
				t.c_cflag &= ~mp->unset;
				t.c_cflag |= mp->set;
I 45
				set = 1;
E 46
I 46
				i.t.c_cflag &= ~mp->unset;
				i.t.c_cflag |= mp->set;
				i.set = 1;
E 46
E 45
E 40
				goto next;
E 26
			}
D 26
		if (eq("speed")) {
D 10
			gtty(open("/dev/tty", 0), &mode);
			for(i=0; speeds[i].string; i++)
				if (mode.sg_ospeed == speeds[i].speed) {
E 10
I 10
D 13
			int fd = open("/dev/tty", 0);

			if (fd < 0) {
				perror("open");
				exit(1);
			}
			ioctl(fd, TIOCGETP, &sb);
			for (i = 0; speeds[i].string; i++)
				if (sb.sg_ospeed == speeds[i].speed) {
E 13
I 13
D 25
			ioctl(open("/dev/tty", 0), TIOCGETP, &mode);
E 25
I 25
			ioctl(open(_PATH_DEVTTY, 0), TIOCGETP, &mode);
E 25
			for(i=0; speeds[i].string; i++)
				if (mode.sg_ospeed == speeds[i].speed) {
E 13
E 10
					printf("%s\n", speeds[i].string);
					exit(0);
E 26
I 26
D 40
		for (i=0; omodes[i].name; i++)
			if (eq(omodes[i].name, *argv)) {
				t.c_oflag &= ~omodes[i].unset;
				t.c_oflag |= omodes[i].set;
E 40
I 40
		for (mp = imodes; mp->name; ++mp)
			if (CHK(mp->name)) {
D 46
				t.c_iflag &= ~mp->unset;
				t.c_iflag |= mp->set;
I 45
				set = 1;
E 46
I 46
				i.t.c_iflag &= ~mp->unset;
				i.t.c_iflag |= mp->set;
				i.set = 1;
E 46
E 45
E 40
				goto next;
			}
D 40
		for (i=0; cmodes[i].name; i++)
			if (eq(cmodes[i].name, *argv)) {
				t.c_cflag &= ~cmodes[i].unset;
				t.c_cflag |= cmodes[i].set;
E 40
I 40
		for (mp = lmodes; mp->name; ++mp)
			if (CHK(mp->name)) {
D 46
				t.c_lflag &= ~mp->unset;
				t.c_lflag |= mp->set;
I 45
				set = 1;
E 46
I 46
				i.t.c_lflag &= ~mp->unset;
				i.t.c_lflag |= mp->set;
				i.set = 1;
E 46
E 45
E 40
				goto next;
			}
D 40
		for (i=0; lmodes[i].name; i++)
			if (eq(lmodes[i].name, *argv)) {
				t.c_lflag &= ~lmodes[i].unset;
				t.c_lflag |= lmodes[i].set;
E 40
I 40
		for (mp = omodes; mp->name; ++mp)
			if (CHK(mp->name)) {
D 46
				t.c_oflag &= ~mp->unset;
				t.c_oflag |= mp->set;
I 45
				set = 1;
E 46
I 46
				i.t.c_oflag &= ~mp->unset;
				i.t.c_oflag |= mp->set;
				i.set = 1;
E 46
E 45
E 40
				goto next;
			}
E 47
I 47
		if (csearch(&argv, &i))
			continue;
E 47
D 40
		for (i=0; *cchars[i].names; i++) {
			char **cp = cchars[i].names;
			while (*cp) {
				if (eq(*cp, *argv)) {
					if (*++argv == 0)
						goto setit;
					if (eq(*argv, "undef") || 
					    eq(*argv, "disable"))
						t.c_cc[cchars[i].sub] = 
						   _POSIX_VDISABLE;
					else if (**argv == '^')
						t.c_cc[cchars[i].sub] = 
						    ((*argv)[1] == '?') ? 0177 :
						    ((*argv)[1] == '-') ?
						     _POSIX_VDISABLE :
						     (*argv)[1] & 037;
					else
						t.c_cc[cchars[i].sub] = **argv;
					goto next;
E 26
				}
D 26
			printf("unknown\n");
			exit(1);
		}
D 10
		for(i=0; modes[i].string; i++)
			if(eq(modes[i].string)) {
				mode.sg_flags &= ~modes[i].reset;
				mode.sg_flags |= modes[i].set;
				lmode &= ~modes[i].lreset;
				lmode |= modes[i].lset;
E 10
I 10
D 13
		for (i = 0; modes[i].string; i++)
			if (eq(modes[i].string)) {
				flags &= ~modes[i].reset;
				flags |= modes[i].set;
E 13
I 13
		for(i=0; modes[i].string; i++)
			if(eq(modes[i].string)) {
				mode.sg_flags &= ~modes[i].reset;
				mode.sg_flags |= modes[i].set;
				lmode &= ~modes[i].lreset;
				lmode |= modes[i].lset;
E 26
I 26
				cp++;
E 26
E 13
E 10
			}
E 40
I 40
D 46
		for (cp = cchars1; cp->name; ++cp) {
			if (!CHK(cp->name))
				continue;
			goto ccfound;
E 40
D 10
		if(arg)
E 10
I 10
D 13
		if (arg)
E 13
I 13
D 26
		if(arg)
E 13
E 10
			fprintf(stderr,"unknown mode: %s\n", arg);
cont:
		;
E 26
I 26
		}
E 46
I 46

D 47
		for (cp = cchars1; cp->name; ++cp)
			if (CHK(cp->name))
				goto ccfound;
E 46
I 40
		for (cp = cchars2; cp->name; ++cp) {
			if (!CHK(cp->name))
				continue;
ccfound:		if (!*++argv)
D 46
				err("option requires an argument -- %s",
				    cp->name);
E 46
I 46
				err("option requires an argument -- %s\n%s",
				    cp->name, usage);
E 46
D 43
			if (CHK("undef") || CHK("disable"))
E 43
I 43
			if (CHK("undef") || CHK("<undef>"))
E 43
D 46
				t.c_cc[cp->sub] = _POSIX_VDISABLE;
E 46
I 46
				i.t.c_cc[cp->sub] = _POSIX_VDISABLE;
E 46
			else if (**argv == '^')
D 46
				t.c_cc[cp->sub] = 
E 46
I 46
				i.t.c_cc[cp->sub] = 
E 46
				    ((*argv)[1] == '?') ? 0177 :
				    ((*argv)[1] == '-') ? _POSIX_VDISABLE :
				    (*argv)[1] & 037;
			else
D 46
				t.c_cc[cp->sub] = **argv;
I 45
			set = 1;
E 45
			goto next;
E 46
I 46
				i.t.c_cc[cp->sub] = **argv;
			i.set = 1;
E 47
I 47
		if (msearch(&argv, &i))
E 47
			continue;
E 46
D 47
		}
E 47

E 40
		if (isdigit(**argv)) {
D 46
			cfsetospeed(&t, atoi(*argv));
			cfsetispeed(&t, atoi(*argv));
			goto next;
E 46
I 46
D 47
			cfsetospeed(&i.t, atoi(*argv));
			cfsetispeed(&i.t, atoi(*argv));
E 47
I 47
			int speed;

			speed = atoi(*argv);
			cfsetospeed(&i.t, speed);
			cfsetispeed(&i.t, speed);
I 48
			i.set = 1;
E 48
E 47
			continue;
E 46
		}
I 47

E 47
I 33
D 40
		if (strncmp(*argv, "-gfmt", sizeof ("-gfmt") - 1) == 0) {
			gfmtset(&t, *argv);
E 40
I 40
		if (!strncmp(*argv, "gfmt1", sizeof("gfmt1") - 1)) {
D 46
			gread(&t, *argv + sizeof("gfmt1") - 1);
E 40
			goto next;
E 46
I 46
			gread(&i.t, *argv + sizeof("gfmt1") - 1);
			continue;
E 46
		}
E 33
D 40
		/* didn't match anything */
		errexit("unknown option: %s", *argv);
		exit(1);
next:
		argv++;
E 40
I 40

D 46
		err("illegal option -- %s", *argv);
E 46
I 46
D 52
		err("illegal option -- %s\n%s", *argv, usage);
E 52
I 52
		warnx("illegal option -- %s", *argv);
		usage();
E 52
E 46
D 47
next:		continue;
E 47
E 40
E 26
	}
D 26
done:
D 10
	ioctl(1, TIOCSETN, &mode);
	ioctl(1, TIOCSETC, &tc);
	ioctl(1, TIOCSLTC, &ltc);
	ioctl(1, TIOCLSET, &lmode);
E 10
I 10
D 13
#ifndef notdef
	ioctl(1, TIOCSETN, &sb);
#endif
	ioctl(1, TIOCSET, &flags);
	ioctl(1, TIOCCSET, &tc);
E 13
I 13
	ioctl(1, TIOCSETN, &mode);
	ioctl(1, TIOCSETC, &tc);
	ioctl(1, TIOCSLTC, &ltc);
	ioctl(1, TIOCLSET, &lmode);
I 17
	ioctl(1, TIOCSWINSZ, &win);
E 26
I 26
D 40
setit:
E 40
I 40

E 40
D 45
	if (tcsetattr(ctl, 0, &t) < 0)
E 45
I 45
D 46
	if (set && tcsetattr(ctl, 0, &t) < 0)
E 46
I 46
	if (i.set && tcsetattr(i.fd, 0, &i.t) < 0)
E 46
E 45
D 40
		syserrexit("tcsetattr");
E 40
I 40
D 52
		err("tcsetattr: %s", strerror(errno));
E 52
I 52
		err(1, "tcsetattr");
E 52
E 40
D 45
	if (ioctl(ctl, TIOCSWINSZ, &win) < 0)
E 45
I 45
D 46
	if (wset && ioctl(ctl, TIOCSWINSZ, &win) < 0)
E 46
I 46
	if (i.wset && ioctl(i.fd, TIOCSWINSZ, &i.win) < 0)
E 46
E 45
D 40
		warning("can't set window size");

E 40
I 40
D 52
		warn("TIOCSWINSZ: %s", strerror(errno));
E 52
I 52
		warn("TIOCSWINSZ");
E 52
E 40
	exit(0);
I 52
}

void
usage()
{
D 56
	(void)fprintf(stderr,
D 54
	    "usage: stty: [-a|-e|-g] [-f file] [options]");
E 54
I 54
	    "usage: stty: [-a|-e|-g] [-f file] [options]\n");
E 56
I 56

	(void)fprintf(stderr, "usage: stty: [-a|-e|-g] [-f file] [options]\n");
E 56
E 54
	exit (1);
E 52
E 26
E 17
E 13
E 10
D 46
}

D 26
eq(string)
D 10
char *string;
E 10
I 10
D 13
	char *string;
E 13
I 13
char *string;
E 13
E 10
{
	int i;

D 10
	if(!arg)
		return(0);
E 10
I 10
D 13
	if (!arg)
		return (0);
E 13
I 13
	if(!arg)
		return(0);
E 13
E 10
	i = 0;
loop:
D 10
	if(arg[i] != string[i])
E 10
I 10
D 13
	if (arg[i] != string[i])
E 13
I 13
	if(arg[i] != string[i])
E 13
E 10
		return(0);
D 10
	if(arg[i++] != '\0')
E 10
I 10
D 13
	if (arg[i++] != '\0')
E 13
I 13
	if(arg[i++] != '\0')
E 13
E 10
		goto loop;
	arg = 0;
D 10
	return(1);
E 10
I 10
D 13
	return (1);
E 13
I 13
	return(1);
E 26
I 26
D 33
gfmtset() {
E 33
I 33
D 40
gfmtset(tp, s) 
	register struct termios *tp;
	char *s;
E 40
I 40
static void
usage()
E 40
{
D 40
	register int cnt;
	char sep;
	char *saves = s;
	int cval;
#define advance(c)	while (*(s) && *(s) != (c)) (s)++; if (*s) (s)++ ; \
				else \
					errexit("bad gfmt operand: %s", saves)
#define chkeq(string)	if (strncmp(s, (string), strlen(string))) \
				errexit("bad gfmt operand: %s", saves)

	if (s == NULL)
		errexit("missing gfmt string");
	advance(':');
	chkeq("iflag=");
	advance('=');
	sscanf(s, "%x", &tp->c_iflag);

	advance(':');
	chkeq("oflag");
	advance('=');
	sscanf(s, "%x", &tp->c_oflag);

	advance(':');
	chkeq("cflag");
	advance('=');
	sscanf(s, "%x", &tp->c_cflag);

	advance(':');
	chkeq("lflag");
	advance('=');
	sscanf(s, "%x", &tp->c_lflag);

	advance(':');
	chkeq("cc=");

	for (cnt = 0, sep = '='; cnt < NCCS; cnt++, sep = ',') {
		advance(sep);
		sscanf(s, "%o", &cval);
		tp->c_cc[cnt] = cval;
	}

	advance(':');
	chkeq("ispeed=");
	advance('=');
	sscanf(s, "%d", &tp->c_ispeed);

	advance(':');
	chkeq("ospeed=");
	advance('=');
	sscanf(s, "%d", &tp->c_ospeed);
E 33
E 26
E 13
E 10
}

D 26
prmodes(all)
E 26
I 26
prmode(tp, ldisc, fmt)
	struct termios *tp;
E 26
I 10
D 13
	int all;
E 13
E 10
{
D 26
	register m;
	int any;
E 26
I 26
	long	i = tp->c_iflag,
		o = tp->c_oflag,
		c = tp->c_cflag,
		l = tp->c_lflag;
	u_char	*cc = tp->c_cc;
	int	ispeed = cfgetispeed(tp),
		ospeed = cfgetospeed(tp);
	char	unknown[32],
		*ld;
	char *ccval();
D 33
	
E 33
E 26

I 33
	if (fmt == GFMT) {
		int	cnt;
		char	sep;

		printf("-gfmt:iflag=%x:oflag=%x:cflag=%x:lflag=%x:cc",
			i, o, c, l);
		for (cnt = 0, sep = '='; cnt < NCCS; cnt++, sep = ',')
			printf("%c%o", sep, cc[cnt]);
		printf(":ispeed=%d:ospeed=%d:\n", ispeed, ospeed);
		return;
	}
	
E 33
D 10
	if(ldisc==NETLDISC)
E 10
I 10
D 13
	if (ldisc == NETLDISC)
E 13
I 13
D 26
	if(ldisc==NETLDISC)
E 13
E 10
		fprintf(stderr, "net discipline, ");
D 10
	else if(ldisc==NTTYDISC)
E 10
I 10
D 13
	else if (ldisc == NTTYDISC)
E 13
I 13
	else if(ldisc==NTTYDISC)
E 13
E 10
		fprintf(stderr, "new tty, ");
D 10
	else if(all==2)
E 10
I 10
D 13
	else if (all == 2)
E 13
I 13
	else if(all==2)
E 13
E 10
		fprintf(stderr, "old tty, ");
D 10
	if(mode.sg_ispeed != mode.sg_ospeed) {
		prspeed("input speed ", mode.sg_ispeed);
		prspeed("output speed ", mode.sg_ospeed);
E 10
I 10
D 13
	if(sb.sg_ispeed != sb.sg_ospeed) {
		prspeed("input speed ", sb.sg_ispeed);
		prspeed("output speed ", sb.sg_ospeed);
E 13
I 13
	if(mode.sg_ispeed != mode.sg_ospeed) {
		prspeed("input speed ", mode.sg_ispeed);
		prspeed("output speed ", mode.sg_ospeed);
E 13
E 10
	} else
D 10
		prspeed("speed ", mode.sg_ispeed);
	fprintf(stderr, all==2 ? "\n" : "; ");
	m = mode.sg_flags;
	if(all==2 || (m&(EVENP|ODDP))!=(EVENP|ODDP)) {
		if(m & EVENP)	fprintf(stderr,"even ");
		if(m & ODDP)	fprintf(stderr,"odd ");
E 10
I 10
D 13
		prspeed("speed ", sb.sg_ispeed);
	fprintf(stderr, all == 2 ? "\n" : "; ");
	m = flags;
	if (all == 2 || (m&(EVENP|ODDP)) != (EVENP|ODDP)) {
		if (m & EVENP)
			fprintf(stderr,"even ");
		if (m & ODDP)
			fprintf(stderr,"odd ");
E 13
I 13
		prspeed("speed ", mode.sg_ispeed);
I 17
	if (all)
		fprintf(stderr, ", %d rows, %d columns", win.ws_row, win.ws_col);
E 17
	fprintf(stderr, all==2 ? "\n" : "; ");
	m = mode.sg_flags;
	if(all==2 || (m&(EVENP|ODDP))!=(EVENP|ODDP)) {
		if(m & EVENP)	fprintf(stderr,"even ");
		if(m & ODDP)	fprintf(stderr,"odd ");
E 13
E 10
	}
D 10
	if(all==2 || m&RAW)
		fprintf(stderr,"-raw "+((m&RAW)!=0));
	if(all==2 || (m&CRMOD)==0)
		fprintf(stderr,"-nl "+((m&CRMOD)==0));
	if(all==2 || (m&ECHO)==0)
		fprintf(stderr,"-echo "+((m&ECHO)!=0));
	if(all==2 || (m&LCASE))
		fprintf(stderr,"-lcase "+((m&LCASE)!=0));
	if(all==2 || (m&TANDEM))
		fprintf(stderr,"-tandem "+((m&TANDEM)!=0));
	fprintf(stderr,"-tabs "+((m&XTABS)!=XTABS));
	if(all==2 || (m&CBREAK))
		fprintf(stderr,"-cbreak "+((m&CBREAK)!=0));
	if(all==2 || (m&NLDELAY))
		delay((m&NLDELAY)/NL1,	"nl");
	if ((m&TBDELAY)!=XTABS)
		delay((m&TBDELAY)/TAB1,	"tab");
	if(all==2 || (m&CRDELAY))
		delay((m&CRDELAY)/CR1,	"cr");
	if(all==2 || (m&VTDELAY))
		delay((m&VTDELAY)/FF1,	"ff");
	if(all==2 || (m&BSDELAY))
		delay((m&BSDELAY)/BS1,	"bs");
E 10
I 10
D 13
	if (all == 2 || m&RAW)
		fprintf(stderr,"-raw " + ((m&RAW) != 0));
	if (all == 2 || (m&CRMOD) == 0)
		fprintf(stderr,"-nl " + ((m&CRMOD) == 0));
	if (all == 2 || (m&ECHO) == 0)
		fprintf(stderr,"-echo " + ((m&ECHO) != 0));
	if (all == 2 || m&LCASE)
		fprintf(stderr,"-lcase " + ((m&LCASE) != 0));
	if (all == 2 || m&TANDEM)
		fprintf(stderr,"-tandem " + ((m&TANDEM) != 0));
	fprintf(stderr,"-tabs " + ((m&XTABS) != XTABS));
	if (all == 2 || m&CBREAK)
		fprintf(stderr,"-cbreak " + ((m&CBREAK) != 0));
	if (all == 2 || m&NLDELAY)
		delay((m&NLDELAY) / NL1, "nl");
	if ((m&TBDELAY) != XTABS)
		delay((m&TBDELAY)/ TAB1, "tab");
	if (all == 2 || m&CRDELAY)
		delay((m&CRDELAY) / CR1, "cr");
	if (all == 2 || m&VTDELAY)
		delay((m&VTDELAY) / FF1, "ff");
	if (all == 2 || m&BSDELAY)
		delay((m&BSDELAY) / BS1, "bs");
E 13
I 13
	if(all==2 || m&RAW)
		fprintf(stderr,"-raw "+((m&RAW)!=0));
	if(all==2 || (m&CRMOD)==0)
		fprintf(stderr,"-nl "+((m&CRMOD)==0));
	if(all==2 || (m&ECHO)==0)
		fprintf(stderr,"-echo "+((m&ECHO)!=0));
	if(all==2 || (m&LCASE))
		fprintf(stderr,"-lcase "+((m&LCASE)!=0));
	if(all==2 || (m&TANDEM))
		fprintf(stderr,"-tandem "+((m&TANDEM)!=0));
	fprintf(stderr,"-tabs "+((m&XTABS)!=XTABS));
	if(all==2 || (m&CBREAK))
		fprintf(stderr,"-cbreak "+((m&CBREAK)!=0));
	if(all==2 || (m&NLDELAY))
		delay((m&NLDELAY)/NL1,	"nl");
	if ((m&TBDELAY)!=XTABS)
		delay((m&TBDELAY)/TAB1,	"tab");
	if(all==2 || (m&CRDELAY))
		delay((m&CRDELAY)/CR1,	"cr");
	if(all==2 || (m&VTDELAY))
		delay((m&VTDELAY)/FF1,	"ff");
	if(all==2 || (m&BSDELAY))
		delay((m&BSDELAY)/BS1,	"bs");
E 13
E 10
	if (all)
		fprintf(stderr,"\n");
#define	lpit(what,str) \
D 10
	if (all==2||(lmode&what)) { \
		fprintf(stderr,str+((lmode&what)!=0)); any++; \
E 10
I 10
D 13
	if (all == 2 || flags&what) { \
		fprintf(stderr,str + ((flags&what) != 0)); any++; \
E 13
I 13
	if (all==2||(lmode&what)) { \
		fprintf(stderr,str+((lmode&what)!=0)); any++; \
E 13
E 10
	}
	if (ldisc == NTTYDISC) {
D 10
		int newcrt = (lmode&(LCTLECH|LCRTBS)) == (LCTLECH|LCRTBS) &&
		    (lmode&(LCRTERA|LCRTKIL)) ==
		      ((mode.sg_ospeed > B300) ? LCRTERA|LCRTKIL : 0);
E 10
I 10
D 13
		int newcrt = (flags&(CTLECH|CRTBS)) == (CTLECH|CRTBS) &&
		    (flags&(CRTERA|CRTKIL)) ==
		      ((sb.sg_ospeed > B300) ? CRTERA|CRTKIL : 0);
E 13
I 13
		int newcrt = (lmode&(LCTLECH|LCRTBS)) == (LCTLECH|LCRTBS) &&
		    (lmode&(LCRTERA|LCRTKIL)) ==
		      ((mode.sg_ospeed > B300) ? LCRTERA|LCRTKIL : 0);
I 16
		int nothing = 1;
E 16
E 13
E 10
		if (newcrt) {
D 10
			if (all==2)
D 2
				fprintf(stderr, "newcrt: (crtbs crterase crtkill ctlecho) ");
E 2
I 2
				fprintf(stderr, "crt: (crtbs crterase crtkill ctlecho) ");
E 2
			else
D 2
				fprintf(stderr, "newcrt ");
E 2
I 2
				fprintf(stderr, "crt ");
E 10
I 10
D 11
			fprintf(stderr, all != 2 ? "crt" :
E 11
I 11
D 13
			fprintf(stderr, all != 2 ? "crt " :
E 11
				 "crt: (crtbs crterase crtkill ctlecho) ");
E 13
I 13
			if (all==2)
				fprintf(stderr, "crt: (crtbs crterase crtkill ctlecho) ");
			else
				fprintf(stderr, "crt ");
E 13
E 10
E 2
			any++;
		} else {
D 10
			lpit(LCRTBS, "-crtbs ");
			lpit(LCRTERA, "-crterase ");
			lpit(LCRTKIL, "-crtkill ");
			lpit(LCTLECH, "-ctlecho ");
			lpit(LPRTERA, "-prterase ");
E 10
I 10
D 13
			lpit(CRTBS, "-crtbs ");
			lpit(CRTERA, "-crterase ");
			lpit(CRTKIL, "-crtkill ");
			lpit(CTLECH, "-ctlecho ");
			lpit(PRTERA, "-prterase ");
E 13
I 13
			lpit(LCRTBS, "-crtbs ");
			lpit(LCRTERA, "-crterase ");
			lpit(LCRTKIL, "-crtkill ");
			lpit(LCTLECH, "-ctlecho ");
			lpit(LPRTERA, "-prterase ");
E 13
E 10
		}
D 10
		lpit(LTOSTOP, "-tostop ");
D 8
		lpit(LINTRUP, "-intrup ");
E 8
		if (all==2) {
E 10
I 10
D 13
		lpit(TOSTOP, "-tostop ");
		if (all == 2) {
E 13
I 13
		lpit(LTOSTOP, "-tostop ");
		if (all==2) {
E 13
E 10
			fprintf(stderr, "\n");
			any = 0;
I 16
			nothing = 0;
E 16
		}
D 10
		lpit(LTILDE, "-tilde ");
		lpit(LFLUSHO, "-flusho ");
		lpit(LMDMBUF, "-mdmbuf ");
		lpit(LLITOUT, "-litout ");
		lpit(LNOHANG, "-nohang ");
E 10
I 10
D 13
		lpit(TILDE, "-tilde ");
		lpit(FLUSHO, "-flusho ");
		lpit(MDMBUF, "-mdmbuf ");
		lpit(LITOUT, "-litout ");
		lpit(NOHANG, "-nohang ");
E 13
I 13
		lpit(LTILDE, "-tilde ");
		lpit(LFLUSHO, "-flusho ");
		lpit(LMDMBUF, "-mdmbuf ");
		lpit(LLITOUT, "-litout ");
I 20
		lpit(LPASS8, "-pass8 ");
E 20
		lpit(LNOHANG, "-nohang ");
E 13
E 10
I 7
		if (any) {
			fprintf(stderr,"\n");
			any = 0;
I 16
			nothing = 0;
E 16
		}
E 7
D 10
		lpit(LETXACK, "-etxack ");
		lpit(LPENDIN, "-pendin ");
I 7
		lpit(LDECCTQ, "-decctlq ");
		lpit(LNOFLSH, "-noflsh ");
E 10
I 10
#ifdef notdef
D 13
		lpit(ETXACK, "-etxack ");
E 13
I 13
		lpit(LETXACK, "-etxack ");
E 13
#endif
D 13
		lpit(PENDIN, "-pendin ");
		lpit(DECCTQ, "-decctlq ");
		lpit(NOFLSH, "-noflsh ");
E 13
I 13
		lpit(LPENDIN, "-pendin ");
		lpit(LDECCTQ, "-decctlq ");
		lpit(LNOFLSH, "-noflsh ");
E 13
E 10
E 7
D 16
		if (any)
E 16
I 16
		if (any || nothing)
E 16
			fprintf(stderr,"\n");
	} else if (!all)
		fprintf(stderr,"\n");
	if (all) {
		switch (ldisc) {

		case 0:
			fprintf(stderr,"\
erase  kill   intr   quit   stop   eof\
\n");
D 10
			pcol(mode.sg_erase, -1);
			pcol(mode.sg_kill, -1);
			pcol(tc.t_intrc, -1);
			pcol(tc.t_quitc, -1);
			pcol(tc.t_stopc, tc.t_startc);
			pcol(tc.t_eofc, tc.t_brkc);
E 10
I 10
D 13
			pcol(tc.tc_erase, -1);
			pcol(tc.tc_kill, -1);
			pcol(tc.tc_intrc, -1);
			pcol(tc.tc_quitc, -1);
			pcol(tc.tc_stopc, tc.tc_startc);
			pcol(tc.tc_eofc, tc.tc_brkc);
E 13
I 13
			pcol(mode.sg_erase, -1);
			pcol(mode.sg_kill, -1);
			pcol(tc.t_intrc, -1);
			pcol(tc.t_quitc, -1);
			pcol(tc.t_stopc, tc.t_startc);
			pcol(tc.t_eofc, tc.t_brkc);
E 13
E 10
			fprintf(stderr,"\n");
E 26
I 26
	/*
	 * line discipline
	 */
	if (ldisc != TTYDISC) {
		switch(ldisc) {
		case TABLDISC:	
			ld = "tablet"; 
E 26
			break;
D 26

		case NTTYDISC:
			fprintf(stderr,"\
erase  kill   werase rprnt  flush  lnext  susp   intr   quit   stop   eof\
\n"); 
D 10
			pcol(mode.sg_erase, -1);
			pcol(mode.sg_kill, -1);
			pcol(ltc.t_werasc, -1);
			pcol(ltc.t_rprntc, -1);
			pcol(ltc.t_flushc, -1);
			pcol(ltc.t_lnextc, -1);
			pcol(ltc.t_suspc, ltc.t_dsuspc);
			pcol(tc.t_intrc, -1);
			pcol(tc.t_quitc, -1);
			pcol(tc.t_stopc, tc.t_startc);
			pcol(tc.t_eofc, tc.t_brkc);
E 10
I 10
D 13
			pcol(tc.tc_erase, -1);
			pcol(tc.tc_kill, -1);
			pcol(tc.tc_werasc, -1);
			pcol(tc.tc_rprntc, -1);
			pcol(tc.tc_flushc, -1);
			pcol(tc.tc_lnextc, -1);
			pcol(tc.tc_suspc, tc.tc_dsuspc);
			pcol(tc.tc_intrc, -1);
			pcol(tc.tc_quitc, -1);
			pcol(tc.tc_stopc, tc.tc_startc);
			pcol(tc.tc_eofc, tc.tc_brkc);
E 13
I 13
			pcol(mode.sg_erase, -1);
			pcol(mode.sg_kill, -1);
			pcol(ltc.t_werasc, -1);
			pcol(ltc.t_rprntc, -1);
			pcol(ltc.t_flushc, -1);
			pcol(ltc.t_lnextc, -1);
			pcol(ltc.t_suspc, ltc.t_dsuspc);
			pcol(tc.t_intrc, -1);
			pcol(tc.t_quitc, -1);
			pcol(tc.t_stopc, tc.t_startc);
			pcol(tc.t_eofc, tc.t_brkc);
E 13
E 10
			fprintf(stderr,"\n");
E 26
I 26
		case SLIPDISC:	
D 28
			ld = "slip(ed)"; 
E 28
I 28
			ld = "slip"; 
E 28
E 26
			break;
I 26
		default:	
			sprintf(unknown, "#%d", ldisc);
			ld = unknown;
I 38
			break;
E 38
E 26
		}
D 26
	} else if (ldisc != NETLDISC) {
		register struct special *sp;
		int first = 1;
E 26
I 26
		put("%s disc; ", ld);
	}
	/*
	 * line speed
	 */
	if (ispeed != ospeed)
		put("ispeed %d baud; ospeed %d baud;",
		     ispeed, ospeed);
	else
		put("speed %d baud;", ispeed);
	if (fmt) 
		put(" %d rows; %d columns;", win.ws_row, win.ws_col);
	put("\n");
E 26
I 16

E 16
I 10
D 13

E 13
E 10
D 26
		for (sp = special; sp->name; sp++) {
			if ((*sp->cp&0377) != (sp->def&0377)) {
				pit(*sp->cp, sp->name, first ? "" : ", ");
				first = 0;
			};
D 10
			if (sp->cp == &tc.t_brkc && ldisc == 0)
E 10
I 10
D 13
			if (sp->cp == &tc.tc_brkc && ldisc == 0)
E 13
I 13
			if (sp->cp == &tc.t_brkc && ldisc == 0)
E 13
E 10
				break;
E 26
I 26
#define lput(n, f, d) if (fmt || on(f) != d) mdput(n+on(f))
	/*
	 * "local" flags
	 */
#define on(f)	((l&f) != 0)
	if (debug) mdput("LFLAG: ");
	lput("-icanon ",ICANON, 1);
	lput("-isig ", ISIG, 1);
	lput("-iexten ", IEXTEN, 1);
	lput("-echo ",ECHO, 1);
	lput("-echoe ",ECHOE, 0);
	lput("-echok ",ECHOK, 0);
	lput("-echoke ",ECHOKE, 0);
	lput("-echonl ",ECHONL, 0);
	lput("-echoctl ",ECHOCTL, 0);
	lput("-echoprt ",ECHOPRT, 0);
	lput("-altwerase ",ALTWERASE, 0);
	lput("-noflsh ",NOFLSH, 0);
	lput("-tostop ",TOSTOP, 0);
	lput("-mdmbuf ",MDMBUF, 0);
D 30
	lput("-nohang ",NOHANG, 0);
E 30
	lput("-flusho ",FLUSHO, 0);
	lput("-pendin ",PENDIN, 0);
I 37
	lput("-nokerninfo ",NOKERNINFO, 0);
	lput("-extproc ",EXTPROC, 0);
E 37
	/*
	 * input flags
	 */
#undef on
#define on(f)	((i&f) != 0)
	mdput(0);
	if (debug) mdput("IFLAG: ");
	lput("-istrip ", ISTRIP, 0);
	lput("-icrnl ", ICRNL, 1);
	lput("-inlcr ", INLCR, 0);
	lput("-igncr ", IGNCR, 0);
	lput("-ixon ", IXON, 1);
	lput("-ixoff ", IXOFF, 0);
	lput("-ixany ", IXANY, 1);
	lput("-imaxbel ", IMAXBEL, 1);
	lput("-ignbrk ", IGNBRK, 0);
	lput("-brkint ", BRKINT, 1);
	lput("-inpck ", INPCK, 0);
	lput("-ignpar ", IGNPAR, 0);
	lput("-parmrk ", PARMRK, 0);
#undef on
	/*
	 * output flags
	 */
#define on(f)	((o&f) != 0)
	mdput(0);
	if (debug) mdput("OFLAG: ");
	lput("-opost ", OPOST, 1);
	lput("-onlcr ", ONLCR, 1);
	lput("-oxtabs ", OXTABS, 1);
#undef on
	/*
	 * control flags (hardware state)
	 */
#define on(f)	((c&f) != 0)
	mdput(0);
	if (debug) mdput("CFLAG: ");
	lput("-cread ", CREAD, 1);
	switch(c&CSIZE) {
	case CS5: mdput("cs5 "); break;
	case CS6: mdput("cs6 "); break;
	case CS7: mdput("cs7 "); break;
	case CS8: mdput("cs8 "); break;
	}
	mdput("-parenb "+on(PARENB));
	lput("-parodd ", PARODD, 0);
	lput("-hupcl ", HUPCL, 1);
	lput("-clocal ", CLOCAL, 0);
	lput("-cstopb ", CSTOPB, 0);
	lput("-crtscts ", CRTSCTS, 0);
	mdput(0);
#undef on
	/*
	 * special control characters
	 */
	if (debug) mdput("CCHARS: ");
	if (fmt != 2) {
		for (i=0; *cchars[i].names; i++) {
			char temp[64];

			if (fmt || cc[cchars[i].sub] != cchars[i].def) {
				sprintf(temp, "%s = %s; ", *cchars[i].names,
					ccval(cc[cchars[i].sub]), fmt);
				mdput(temp);
			}
E 26
		}
D 12
		if (first == 0)
			fprintf(stderr, "\n");
E 12
I 12
D 13
		fprintf(stderr, "\n");
E 13
I 13
D 16
		if (first == 0)
E 16
I 16
D 26
		if (!first)
E 16
			fprintf(stderr, "\n");
E 26
I 26
		mdput(0);
	} else {
		for (i=0; *cchars[i].names; i++)
			put("%*s", strlen(*(cchars[i].names+1)) + (i>0?1:0),
				*(cchars[i].names+1));
		printf("\n");
		for (i=0; *cchars[i].names; i++)
			put("%*s", strlen(*(cchars[i].names+1)) + (i>0?1:0),
				ccval(cc[cchars[i].sub], fmt));
		printf("\n");
E 26
E 13
E 12
	}
}

D 26
pcol(ch1, ch2)
	int ch1, ch2;
E 26
I 26
D 28
#ifdef COMPAT_43
E 28
/*
 * gross, but since we're changing the control descriptor
 * from 1 to 0, most users will be probably be doing
 * "stty > /dev/sometty" by accident. If 1 and 2 are both ttys, 
 * but not the same, assume that 1 was incorrectly redirected.
 */
checkredirect() {
	struct stat st1, st2;

	if (isatty(1) && isatty(2) && fstat(1, &st1) != -1 && 
	    fstat(2, &st2) != -1 && (st1.st_rdev != st2.st_rdev))
warning("stdout appears redirected, but stdin is the control descriptor");
}
D 28
#endif
E 28

D 28
STATIC char *
E 28
I 28
char *
E 28
ccval(c, fmt)
	unsigned char c;
E 26
{
D 26
	int nout = 0;
E 26
I 26
	static char buf[128];
	char *bp;
E 26

D 26
	ch1 &= 0377;
	ch2 &= 0377;
	if (ch1 == ch2)
		ch2 = 0377;
	for (; ch1 != 0377 || ch2 != 0377; ch1 = ch2, ch2 = 0377) {
		if (ch1 == 0377)
			continue;
		if (ch1 & 0200) {
			fprintf(stderr, "M-");
			nout += 2;
			ch1 &= ~ 0200;
		}
		if (ch1 == 0177) {
			fprintf(stderr, "^");
			nout++;
			ch1 = '?';
		} else if (ch1 < ' ') {
			fprintf(stderr, "^");
			nout++;
			ch1 += '@';
		}
		fprintf(stderr, "%c", ch1);
		nout++;
		if (ch2 != 0377) {
			fprintf(stderr, "/");
			nout++;
		}
E 26
I 26
	*buf = 0, bp = buf;
	if (c == _POSIX_VDISABLE)
		if (fmt == 2)
			return("<u>");
		else
			return("<undef>");
	if (c & 0200) {
		strcat(buf, "M-");
		*bp++ = 'M';
		*bp++ = '-';
		c &= 0177;
E 26
	}
D 26
	while (nout < 7) {
		fprintf(stderr, " ");
		nout++;
E 26
I 26
	if (c == 0177) {
		*bp++ = '^';
		*bp++ = '?';
E 26
	}
I 26
	else if (c < 040) {
		*bp++ = '^';
		*bp++ = c + '@';
	}
	else
		*bp++ = c;
	*bp = 0;
	return(buf);
E 26
}

D 26
pit(what, itsname, sep)
	unsigned what;
	char *itsname, *sep;
E 26
I 26
D 28
STATIC
E 28
I 28

E 28
mdput(s)
	char *s;
E 26
{
I 26
	static int col = 0;
E 26

D 26
	what &= 0377;
	fprintf(stderr, "%s%s", sep, itsname);
	if (what == 0377) {
		fprintf(stderr, " <undef>");
E 26
I 26
	if (s == (char *)0) {
		if (col) {
			put("\n");
			col = 0;
		}
E 26
		return;
	}
D 26
	fprintf(stderr, " = ");
	if (what & 0200) {
		fprintf(stderr, "M-");
		what &= ~ 0200;
E 26
I 26
	if ((col += strlen(s)) > WRAPCOL) {
		put("\n");
		col = strlen(s);
E 26
	}
D 26
	if (what == 0177) {
		fprintf(stderr, "^");
		what = '?';
	} else if (what < ' ') {
		fprintf(stderr, "^");
		what += '@';
	}
	fprintf(stderr, "%c", what);
E 26
I 26
	put(s);
E 26
}

D 26
delay(m, s)
D 10
char *s;
E 10
I 10
D 13
	char *s;
E 13
I 13
char *s;
E 26
I 26
D 28
STATIC
D 27
put(f, a)
E 27
I 27
put(f, a)	/* ??? */
E 27
	char *f;
E 28
I 28
#include <varargs.h>

put(va_alist)
	va_dcl
E 28
E 26
E 13
E 10
{
I 26
D 28
	_doprnt(f, &a, OUT);
E 28
I 28
	char *fmt;
	va_list ap;

	va_start(ap);
	fmt = va_arg(ap, char *);
	(void) vfprintf(OUT, fmt, ap);
	va_end(ap);
E 28
}
E 26

D 10
	if(m)
E 10
I 10
D 13
	if (m)
E 13
I 13
D 26
	if(m)
E 13
E 10
		fprintf(stderr,"%s%d ", s, m);
E 26
I 26
D 28
STATIC
warning(s, a)
	char *s;
E 28
I 28

warning(va_alist)
	va_dcl
E 28
{
I 28
	char *fmt;
	va_list ap;

E 28
	fprintf(ERR, "stty: warning: ");
D 27
	_doprnt(s, &a, ERR);
E 27
I 27
D 28
	_doprnt(s, &a, ERR);	/* ??? */
E 28
I 28
	va_start(ap);
	fmt = va_arg(ap, char *);
	(void) vfprintf(ERR, fmt, ap);
	va_end(ap);
E 28
E 27
	fprintf(ERR, "\n");
E 26
}

D 26
int	speed[] = {
D 9
	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,0,0
E 9
I 9
	0,50,75,110,134,150,200,300,600,1200,1800,2400,4800,9600,19200,38400
E 9
};

prspeed(c, s)
char *c;
E 26
I 26
D 28
STATIC
errexit(s, a)
	char *s;
E 28
I 28

errexit(va_alist)
	va_dcl
E 28
E 26
{
I 28
	char *fmt;
	va_list ap;

E 28
I 26
	fprintf(ERR, "stty: ");
D 27
	_doprnt(s, &a, ERR);
E 27
I 27
D 28
	_doprnt(s, &a, ERR);	/* ??? */
E 28
I 28
	va_start(ap);
	fmt = va_arg(ap, char *);
	(void) vfprintf(ERR, fmt, ap);
	va_end(ap);
E 28
E 27
	fprintf(ERR, "\n");
	exit(1);
}
E 26

D 26
	fprintf(stderr,"%s%d baud",  c, speed[s]);
E 26
I 26
D 28
STATIC
D 27
syserrexit(s, a)
E 27
I 27
syserrexit(s, a)	/* ??? */
E 27
	char *s;
E 28
I 28

syserrexit(va_alist)
	va_dcl
E 28
{
I 28
	char *fmt;
	va_list ap;

E 28
	fprintf(ERR, "stty: ");
D 28
	_doprnt(s, &a, ERR);
	fprintf(ERR, ": %s\n", sys_errlist[errno]);
E 28
I 28
	va_start(ap);
	fmt = va_arg(ap, char *);
	(void) vfprintf(ERR, fmt, ap);
	va_end(ap);
	fprintf(ERR, ": %s\n", strerror(errno));
E 40
I 40
	(void)fprintf(stderr, "usage: stty: [-eg] [-f file] [options]\n");
E 40
E 28
	exit(1);
E 46
E 26
}
E 1
