h55480
s 00001/00001/00449
d D 8.5 94/01/02 11:40:02 bostic 33 32
c copyediting for Usenix manuals
e
s 00002/00002/00448
d D 8.4 93/09/13 20:51:58 bostic 32 31
c O_NONBLOCK is reasonable for an open(2) flag
e
s 00020/00000/00430
d D 8.3 93/09/06 13:08:32 bostic 31 30
c document DB_LOCK, DB_SHMEM and DB_TXN for later use
e
s 00003/00000/00427
d D 8.2 93/08/17 10:18:32 bostic 30 29
c add LIBTP reference, clean up additional reference spacing
e
s 00002/00002/00425
d D 8.1 93/06/04 15:22:28 bostic 29 28
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00032/00000/00395
d D 5.26 93/05/24 09:48:28 bostic 28 27
c add fd routine, to return a file descriptor
e
s 00016/00001/00379
d D 5.25 93/05/16 16:17:57 bostic 27 26
c add a flags argument to the sync call, add R_RECNOSYNC for RECNO
e
s 00001/00014/00379
d D 5.24 93/05/10 12:19:58 bostic 26 25
c delete R_CURSORLOG from the interface (and the code)
e
s 00053/00039/00340
d D 5.23 92/12/04 19:15:05 bostic 25 24
c R_APPEND -> R_CURSORLOG, add R_SETCURSOR
e
s 00002/00001/00377
d D 5.22 92/10/04 16:48:10 bostic 24 23
c document that O_WRONLY isn't doable
e
s 00002/00002/00376
d D 5.21 92/05/15 16:18:57 bostic 23 22
c add O_EXLOCK and O_SHLOCK to open flags
e
s 00001/00001/00377
d D 5.20 91/09/12 11:54:35 bostic 22 21
c db.3 -> dbopen.3
e
s 00031/00021/00347
d D 5.19 91/09/08 11:27:18 bostic 21 20
c add R_APPEND, R_CURSOR to put routine; seq call now returns <= for
c btrees; minor reorg
e
s 00003/00000/00365
d D 5.18 91/09/04 15:19:44 bostic 20 19
c document that the key gets set on a "get" as well as the data
e
s 00085/00415/00280
d D 5.17 91/09/04 11:36:03 bostic 19 17
c break db(3) up into multiple manual pages
e
s 00015/00003/00692
d R 5.17 91/04/20 10:14:37 cael 18 17
c text changes or conversion to -mdoc (version 3)
e
s 00017/00012/00678
d D 5.16 91/04/02 08:39:20 bostic 17 16
c add DB.type field to reflect type of underlying database
e
s 00004/00004/00686
d D 5.15 91/03/11 16:04:41 bostic 16 15
c flag fields are u_int's
e
s 00022/00018/00668
d D 5.14 91/02/23 09:23:40 bostic 15 13
c minor wordsmithing, make flags right
e
s 00007/00002/00684
d R 5.14 91/02/14 16:27:25 bostic 14 13
c add O_CLEXEC for close-on-exec semantics
e
s 00011/00009/00675
d D 5.13 91/01/07 12:30:13 bostic 13 12
c cleanup from Mike Olson for btrees
e
s 00011/00009/00673
d D 5.12 90/12/29 17:26:46 bostic 12 11
c fix byte order
e
s 00039/00016/00643
d D 5.11 90/12/19 15:44:11 bostic 11 10
c add byte-order, minor cleanups
e
s 00032/00030/00627
d D 5.10 90/11/27 16:45:58 bostic 10 9
c fix cursor movement to work with insertions/deletions, minor hash fixes
e
s 00016/00010/00641
d D 5.9 90/11/21 10:53:25 bostic 9 8
c move R_PUT to BTREEINFO structure
e
s 00210/00162/00441
d D 5.8 90/11/12 15:15:51 bostic 8 7
c cleanup, change exit status, lots of rewrite for style
e
s 00218/00085/00384
d D 5.7 90/11/08 10:52:13 bostic 7 6
c checkpoint, add various flags, add btree stuff consistently
e
s 00035/00034/00434
d D 5.6 90/10/30 14:32:24 bostic 6 5
c minor whacks, try to get to format right
e
s 00004/00004/00464
d D 5.5 90/10/24 13:41:50 bostic 5 4
c VALUe -> DBT
e
s 00003/00002/00465
d D 5.4 90/10/24 10:59:40 bostic 4 3
c change "unlimited" to requires real memeory
e
s 00040/00066/00427
d D 5.3 90/10/24 10:22:20 bostic 3 2
c checkpoint
e
s 00052/00037/00441
d D 5.2 90/10/24 09:56:00 bostic 2 1
c checkpoint
e
s 00478/00000/00000
d D 5.1 90/08/27 12:40:39 bostic 1 0
c date and time created 90/08/27 12:40:39 by bostic
e
u
U
t
T
I 1
D 29
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
E 29
I 29
.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 29
.\"
.\" %sccs.include.redist.man%
.\"
.\"	%W% (Berkeley) %G%
.\"
D 19
.TH DB 3  "%Q%"
E 19
I 19
D 22
.TH DB 3 "%Q%"
E 22
I 22
.TH DBOPEN 3 "%Q%"
E 22
E 19
.UC 7
.SH NAME
D 2
btree_open, flat_open, hash_open \- database manipulation routines
E 2
I 2
D 8
btree_open, hash_open, recno_open \- database manipulation routines
E 8
I 8
D 19
btree_open, hash_open, recno_open \- database access methods
E 19
I 19
dbopen \- database access methods
E 19
E 8
E 2
.SH SYNOPSIS
.nf
.ft B
I 7
#include <sys/types.h>
I 19
#include <limits.h>
E 19
E 7
#include <db.h>

DB *
D 8
btree_open(const char *file, int flags, int mode, const BTREEINFO * private);
E 8
I 8
D 15
btree_open(const char *file, int flags, int mode, const BTREEINFO * openinfo);
E 15
I 15
D 19
btree_open(const char *file, int flags, int mode,
E 19
I 19
dbopen(const char *file, int flags, int mode, DBTYPE type,
E 19
.ti +5
D 19
const BTREEINFO * openinfo);
E 15
E 8

DB *
D 2
flat_open(const char *file, int flags, int mode, const FLATINFO * private);
E 2
I 2
D 8
hash_open(const char *file, int flags, int mode, const HASHINFO * private);
E 8
I 8
D 15
hash_open(const char *file, int flags, int mode, const HASHINFO * openinfo);
E 15
I 15
hash_open(const char *file, int flags, int mode,
.ti +5
const HASHINFO * openinfo);
E 15
E 8
E 2

DB *
D 2
hash_open(const char *file, int flags, int mode, const HASHINFO * private);
E 2
I 2
D 8
recno_open(const char *file, int flags, int mode, const RECNOINFO * private);
E 8
I 8
D 15
recno_open(const char *file, int flags, int mode, const RECNOINFO * openinfo);
E 15
I 15
recno_open(const char *file, int flags, int mode,
.ti +5
const RECNOINFO * openinfo);
E 19
I 19
const void *openinfo);
E 19
E 15
E 8
E 2
.ft R
.fi
.SH DESCRIPTION
D 19
.IR Btree_open ,
D 2
.IR flat_open ,
E 2
I 2
.IR hash_open ,
E 2
and
D 2
.I hash_open
are interfaces, respectively, to database files in btree, flat,
and hashed record formats.
Access to all file types is based on key/data pairs, where both keys
and data are of essentially unlimited size.
E 2
I 2
.I recno_open
D 8
are interfaces, respectively, to database files in btree, hashed, and
flat-file record formats.
E 8
I 8
are access method interfaces to database files in btree, hashed, and
flat-file formats, respectively.
E 19
I 19
.IR Dbopen
is the library interface to database files.
D 25
The supported file formats are btree, hashed and record oriented.
E 25
I 25
The supported file formats are btree, hashed and UNIX file oriented.
E 25
E 19
The btree format is a representation of a sorted, balanced tree structure.
The hashed format is an extensible, dynamic hashing scheme.
D 19
The flat-file format is a UNIX file with fixed or variable length
lines.
These formats are described in more detail below.
E 19
I 19
The flat-file format is a byte stream file with fixed or variable length
records.
The formats and file format specific information are described in detail
in their respective manual pages
.IR btree (3),
.IR hash (3)
and
.IR recno (3).
E 19
.PP
E 8
D 19
Access to all file types is based on key/data pairs.
E 2
.PP
I 7
D 11
All access methods store any database metadata in architecture-independent
D 8
ormats.
E 8
I 8
formats.
E 8
(Obviously, portability of the data forming the key/data pairs is the
concern of the application program.)
.PP
E 11
E 7
Each routine opens
E 19
I 19
Dbopen opens
E 19
.I file
for reading and/or writing.
I 7
D 19
Databases never intended to be preserved on disk may be created by setting
E 19
I 19
Files never intended to be preserved on disk may be created by setting
E 19
the file parameter to NULL.
I 19
.PP
E 19
E 7
The
.I flags
and
.I mode arguments
are as specified to the
.IR open (2)
D 7
routine, however only the O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC
E 7
I 7
D 23
routine, however, only the O_CREAT, O_EXCL, O_RDONLY, O_RDWR, O_TRUNC
E 7
and O_WRONLY flags are meaningful.
E 23
I 23
D 32
routine, however, only the O_CREAT, O_EXCL, O_EXLOCK, O_RDONLY, O_RDWR,
D 24
O_SHLOCK, O_TRUNC and O_WRONLY flags are meaningful.
E 24
I 24
O_SHLOCK and O_TRUNC flags are meaningful.
E 32
I 32
routine, however, only the O_CREAT, O_EXCL, O_EXLOCK, O_NONBLOCK,
O_RDONLY, O_RDWR, O_SHLOCK and O_TRUNC flags are meaningful.
E 32
(Note, opening a database file O_WRONLY is not possible.)
I 31
.\"Three additional options may be specified by
.\".IR or 'ing
.\"them into the
.\".I flags
.\"argument.
.\".TP
.\"DB_LOCK
.\"Do the necessary locking in the database to support concurrent access.
.\"If concurrent access isn't needed or the database is read-only this
.\"flag should not be set, as it tends to have an associated performance
.\"penalty.
.\".TP
.\"DB_SHMEM
.\"Place the underlying memory pool used by the database in shared
.\"memory.
.\"Necessary for concurrent access.
.\".TP
.\"DB_TXN
.\"Support transactions in the database.
.\"The DB_LOCK and DB_SHMEM flags must be set as well.
E 31
E 24
E 23
D 7
Databases which are temporary, i.e. not intended to be preserved
on disk, may be created by setting the file parameter to NULL.
E 7
I 7
D 10
If entries are to be inserted into or deleted from a database file, it
must be opened with the O_RDWR flag.
E 10
E 7
D 19
The argument
E 19
I 19
.PP
The
.I type
argument is of type DBTYPE (as defined in the <db.h> include file) and
may be set to DB_BTREE, DB_HASH or DB_RECNO.
.PP
The
E 19
D 8
.I private
is a pointer to a private, access-method specific structure described
below.
E 8
I 8
.I openinfo
D 11
is a pointer to a access method specific structure described below.
E 11
I 11
D 19
is a pointer to an access method specific structure described below.
E 19
I 19
argument is a pointer to an access method specific structure described
in the access method's manual page.
If
.I openinfo
is NULL, each access method will use defaults appropriate for the system
and the access method.
E 19
E 11
E 8
.PP
D 2
The open routines return a pointer to a structure representing the
database on success and NULL on error.
This structure is as follows:
E 2
I 2
D 7
The open routines return a pointer to a structure on success and NULL
E 7
I 7
D 19
The open routines return a pointer to a DB structure on success and NULL
E 7
on error.
D 3
This structure is defined as follows:
E 3
I 3
D 7
This structure contains at least the following fields:
E 3
E 2
.sp
E 7
I 7
D 8
The DB contains at least the following fields:
E 8
I 8
The DB structure contains at least the following fields:
E 19
I 19
.I Dbopen
returns a pointer to a DB structure on success and NULL on error.
The DB structure is defined in the <db.h> include file, and contains at
least the following fields:
E 19
E 8
D 15
.PP
E 15
I 15
.sp
.nf
E 15
E 7
typedef struct {
.RS
I 19
DBTYPE type;
E 19
D 2
void *internal;
E 2
I 2
D 8
void *private;
E 8
I 8
D 15
void *openinfo;
E 8
E 2
.br
E 15
I 2
D 3
int cachesize;
.br
E 3
E 2
D 8
int (*close)(), (*delete)(), (*get)(), (*put)(), (*seq)(), (*sync)();
E 8
I 8
int (*close)(const DB *db);
D 15
.br
D 13
int (*delete)(const DB *db, const DBT *key);
E 13
I 13
int (*delete)(const DB *db, const DBT *key, u_long flag);
E 13
.br
D 13
int (*get)(const DB *db, DBT *key, DBT *data);
E 13
I 13
int (*get)(const DB *db, DBT *key, DBT *data, u_long flag);
E 13
.br
int (*put)(const DB *db, const DBT *key, const DBT *data, u_long flag);
.br
int (*seq)(const DB *db, DBT *key, DBT *data, u_long flag);
.br
E 15
D 19
int (*sync)(const DB *db);
E 19
I 15
D 16
int (*del)(const DB *db, const DBT *key, u_long flags);
int (*get)(const DB *db, DBT *key, DBT *data, u_long flags);
E 16
I 16
int (*del)(const DB *db, const DBT *key, u_int flags);
I 28
int (*fd)(const DB *db);
E 28
int (*get)(const DB *db, DBT *key, DBT *data, u_int flags);
E 16
D 25
int (*put)(const DB *db, const DBT *key, const DBT *data,
E 25
I 25
int (*put)(const DB *db, DBT *key, const DBT *data,
E 25
.ti +5
D 16
u_long flags);
int (*seq)(const DB *db, DBT *key, DBT *data, u_long flags);
E 16
I 16
u_int flags);
I 19
D 27
int (*sync)(const DB *db);
E 27
I 27
int (*sync)(const DB *db, u_int flags);
E 27
E 19
int (*seq)(const DB *db, DBT *key, DBT *data, u_int flags);
I 17
D 19
int type;
E 17
E 16
void *openinfo;
E 19
E 15
E 8
.RE
} DB;
I 15
.fi
E 15
D 7
.sp
E 7
.PP
D 2
This structure is as follows:
E 2
I 2
D 7
The elements of this structure are defined as follows:
E 7
I 7
D 8
The elements of this structure consist of a pointer to a private, access
method dependent structure and a set of routines which perform various
functions.
E 8
I 8
D 11
The elements of this structure consist of a pointer to a access method
E 11
I 11
D 19
The elements of this structure consist of a pointer to an access method
E 11
specific structure and a set of routines which perform various functions.
E 8
All of these routines take a pointer to a structure as returned by
one of the open routines, one or more pointers to key/data structures,
and, optionally, a flag value.
E 19
I 19
D 25
These elements a database type and a set of functions performing various
actions.
E 25
I 25
These elements describe a database type and a set of functions performing
various actions.
E 25
These functions take a pointer to a structure as returned by
.IR dbopen ,
and sometimes one or more pointers to key/data structures and a flag value.
E 19
E 7
E 2
.TP
D 2
internal
E 2
I 2
D 8
private
E 2
A pointer to an internal structure private to the access method.
E 8
I 8
D 19
openinfo
A pointer to an internal structure specific to the access method.
E 8
.TP
E 19
I 17
type
D 19
The type of the underlying access method; either DB_BTREE, DB_HASH
or DB_RECNO.
E 19
I 19
The type of the underlying access method (and file format).
E 19
.TP
E 17
I 2
D 3
cachesize;
A suggested maximum size of the memory cache used by the access method.
Access methods are
.B not
constrained by this value.
.TP
E 3
E 2
close
A pointer to a routine to flush any cached information to disk, free any
D 2
allocated resources, and close the database file, whose function prototype
is:
E 2
I 2
D 19
allocated resources, and close the database file.
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
E 6
I 6
.in +5
E 7
I 7
.sp .4
.in +4
E 7
E 6
E 3
close(const DB *db);
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
D 7
.in -5
E 6
E 3
.sp
E 7
I 7
.in -4
.sp .4
E 8
E 7
Since key/data pairs may be cached in memory, failing to close the
D 8
file with the
E 8
I 8
file with a
E 19
I 19
allocated resources, and close the underlying file(s).
Since key/data pairs may be cached in memory, failing to sync the file
with a
E 19
E 8
.I close
D 19
routine may result in inconsistent or lost information.
E 19
I 19
or
.I sync
function may result in inconsistent or lost information.
E 19
D 8
The
.I close
routine returns 0 on error and 1 on success.
E 8
I 8
.I Close
routines return -1 on error (setting
.IR errno )
and 0 on success.
E 8
.TP
D 15
delete
E 15
I 15
del
E 15
D 2
A pointer to a routine to remove key/data pairs from the database,
whose function prototype is:
E 2
I 2
A pointer to a routine to remove key/data pairs from the database.
I 19
.IP
The parameter
.I flag
may be set to the following value:
.RS
.TP
R_CURSOR
Delete the record referenced by the cursor.
I 25
The cursor must have previously been initialized.
E 25
.RE
.IP
E 19
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
E 6
I 6
.in +5
E 7
I 7
.sp .4
.in +4
E 7
E 6
E 3
D 5
delete(const DB *db, const VALUE *key);
E 5
I 5
delete(const DB *db, const DBT *key);
E 5
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
D 7
.in -5
E 6
E 3
.sp
E 7
I 7
.in -4
.sp .4
E 7
The
.I delete
routine returns 0 on error, 1 on success, and -1 if the specified
E 8
I 8
.I Delete
routines return -1 on error (setting
.IR errno ),
0 on success, and 1 if the specified
E 8
.I key
was not in the file.
.TP
I 28
fd
A pointer to a routine which returns a file descriptor representative
of the underlying database.
A file descriptor referencing the same file will be returned to all
processes which call
.I dbopen
with the same
.I file
name.
D 33
This file descriptor may be safely used as a argument to the
E 33
I 33
This file descriptor may be safely used as an argument to the
E 33
.IR fcntl (2)
and
.IR flock (2)
locking functions.
The file descriptor is not necessarily associated with any of the
underlying files used by the access method.
No file descriptor is available for in memory databases.
.I Fd
routines return -1 on error (setting
.IR errno ),
and the file descriptor on success.
.TP
E 28
get
A pointer to a routine which is the interface for keyed retrieval from
D 2
the database, whose function prototype is:
E 2
I 2
the database.
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
E 6
I 6
.in +5
E 6
E 3
D 5
get(const DB *db, const VALUE *key, VALUE *data);
E 5
I 5
get(const DB *db, const DBT *key, DBT *data);
E 5
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
.in -5
E 6
E 3
.sp
E 7
I 7
.sp .4
.in +4
get(const DB *db, DBT *key, DBT *data);
.in -4
.sp .4
E 8
E 7
The address and length of the data associated with the specified
.I key
are returned in the structure referenced by
.IR data .
I 20
D 21
The address and length of the key used to enter the data into the database
are returned in the structure referenced by
.IR key .
E 21
E 20
D 8
The
.I get
routine returns 0 on error, 1 on success, and -1 if the
E 8
I 8
.I Get
routines return -1 on error (setting
.IR errno ),
0 on success, and 1 if the
E 8
.I key
was not in the file.
.TP
put
D 2
A pointer to a routine to store key/data pairs in the database,
whose function prototype is:
E 2
I 2
A pointer to a routine to store key/data pairs in the database.
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
.RS
E 6
I 6
.in +5
E 7
I 7
.sp .4
.in +4
E 7
E 6
E 3
D 5
put(const DB *db, const VALUE *key, const VALUE *data, u_long flag);
E 5
I 5
put(const DB *db, const DBT *key, const DBT *data, u_long flag);
E 5
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
D 7
.in -5
E 6
E 3
.sp
I 6
The
.I put
routine returns 0 on error, 1 on success, and -1 if the R_NOOVERWRITE
.I flag
is set and the key already exists in the file.
.sp
E 7
I 7
.in -4
.sp .4
By default, if the key already exists in the file, it is replaced.
E 8
.IP
E 7
The parameter
.I flag
D 8
may be set to one of the following values:
E 8
I 8
D 21
must be set to one of the following values:
E 21
I 21
may be set to one of the following values:
E 21
E 8
.RS
E 6
D 3
The parameter flag, if set, should be either R_APPEND or R_INSERT,
optionally
.IR or 'ed
with R_NOOVERWRITE.
.RS
E 3
.TP
I 21
D 25
R_APPEND
Append the data to the tree, creating a new key/data pair.
(Applicable only to the DB_RECNO access method.)
.TP
E 25
R_CURSOR
Replace the key/data pair referenced by the cursor.
I 25
The cursor must have previously been initialized.
E 25
.TP
I 25
D 26
R_CURSORLOG
Store the data into the tree after the record referenced by the cursor,
creating a new key/data pair if the database is empty or if the cursor
references the last entry in the database, otherwise overwriting the
record after the cursor.
If the cursor is unitialized, the first record in the database is
created or overwritten.
In any case, the cursor is set to reference the stored record, and the
record number of the stored record is returned in the
.I key
structure.
(Applicable only to the DB_RECNO access method.)
.TP
E 26
E 25
E 21
D 8
R_APPEND
E 8
I 8
D 9
R_DUP
If the key already exists in the file, create an entry with a duplicate
key, i.e. one with the same key and different data as another entry.
(This implies that keys are not required to be unique.
Applicable only to the
.B BTREE
access method.)
.TP
E 9
R_IAFTER
E 8
Append the data immediately after the data referenced by
.IR key ,
D 8
creating a new record.
(This implies that the access method is able to create new keys itself,
E 8
I 8
creating a new key/data pair.
I 25
The record number of the appended key/data pair is returned in the
.I key
structure.
E 25
D 21
(This implies that the access method is able to create new keys,
E 8
i.e. the keys are ordered and independent, for example, record numbers.
D 2
Currently applicable only to the flat file access method.)
E 2
I 2
D 3
Currently applicable only to the recno access method.)
E 3
I 3
D 7
Currently applicable only to the RECNO access method.)
E 7
I 7
D 19
Applicable only to the
.B RECNO
access method.)
E 19
I 19
Applicable only to the DB_RECNO access method.)
E 21
I 21
(Applicable only to the DB_RECNO access method.)
E 21
E 19
E 7
E 3
E 2
.TP
I 7
D 8
R_DUP
If the key already exists in the file, create a duplicate key/data pair.
(This implies that keys are not required to be unique.
Applicable only to the
.B BTREE
access method.)
.TP
E 7
R_INSERT
E 8
I 8
R_IBEFORE
E 8
Insert the data immediately before the data referenced by
.IR key ,
D 8
creating a new record.
(This implies that the access method is able to create new keys itself,
E 8
I 8
creating a new key/data pair.
I 25
The record number of the inserted key/data pair is returned in the
.I key
structure.
E 25
D 21
(This implies that the access method is able to create new keys,
E 8
i.e. the keys are ordered and independent, for example, record numbers.
D 2
Currently applicable only to the flat file access method.)
E 2
I 2
D 3
Currently applicable only to the recno access method.)
E 3
I 3
D 7
Currently applicable only to the RECNO access method.)
E 7
I 7
D 19
Applicable only to the
.B RECNO
access method.)
E 19
I 19
Applicable only to the DB_RECNO access method.)
E 21
I 21
(Applicable only to the DB_RECNO access method.)
E 21
E 19
E 7
E 3
E 2
.TP
R_NOOVERWRITE
Enter the new key/data pair only if the key does not previously exist.
I 25
.TP
R_SETCURSOR
Store the key/data pair, setting or initializing the position of the
cursor to reference it.
(Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 25
I 8
D 19
.TP
R_PUT
Enter the new key/data pair and replace any previously existing key.
E 19
E 8
.RE
I 7
.IP
I 21
D 25
R_APPEND, R_IAFTER and R_IBEFORE are available only for the DB_RECNO access
method because they each imply that the access method is able to create new
keys.
E 25
I 25
R_SETCURSOR is available only for the DB_BTREE and DB_RECNO access
methods because it implies that the keys have an inherent order
which does not change.
.IP
D 26
R_CURSORLOG, R_IAFTER and R_IBEFORE are available only for the DB_RECNO
E 26
I 26
R_IAFTER and R_IBEFORE are available only for the DB_RECNO
E 26
access method because they each imply that the access method is able to
create new keys.
E 25
This is only true if the keys are ordered and independent, record numbers
for example.
.IP
E 21
I 19
The default behavior of the
.I put
routines is to enter the new key/data pair, replacing any previously
existing key.
.IP
E 19
D 8
The
.I put
routine returns 0 on error, 1 on success, and -1 if the R_NOOVERWRITE
E 8
I 8
.I Put
routines return -1 on error (setting
.IR errno ),
0 on success, and 1 if the R_NOOVERWRITE
E 8
.I flag
D 8
is set and the key already exists in the file.
E 8
I 8
was set and the key already exists in the file.
E 8
E 7
D 6
.PP
The
.I put
routine returns 0 on error, 1 on success, and -1 if the
R_NOOVERWRITE
.I flag
is set and the key already exists in the file.
E 6
.TP
seq
A pointer to a routine which is the interface for sequential
D 2
retrieval from the database, whose function prototype is:
E 2
I 2
retrieval from the database.
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
E 6
I 6
.in +5
E 6
E 3
D 5
seq(const DB *db, VALUE *key, VALUE *data, int flag);
E 5
I 5
seq(const DB *db, DBT *key, DBT *data, int flag);
E 5
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
.in -5
E 6
E 3
.sp
E 7
I 7
.sp .4
.in +4
seq(const DB *db, DBT *key, DBT *data, u_long flag);
.in -4
.sp .4
E 8
E 7
The address and length of the key are returned in the structure
referenced by
.IR key ,
and the address and length of the data are returned in the
structure referenced
by
.IR data .
D 6
.PP
E 6
I 6
D 7
The first time the
.I seq
routine is called, the first record of the database is returned
if
.I flag
is not set or is set to R_FIRST or R_NEXT.
.sp
The
.I seq
routine returns 0 on error, 1 on success, -1 if end-of-file is reached,
and -2 if the input is a character device and no complete records are
available.
.sp
E 6
The flag value, if set, should be one of the following values:
E 7
I 7
.IP
I 10
Sequential key/data pair retrieval may begin at any time, and the
position of the ``cursor'' is not affected by calls to the
D 15
.IR delete ,
E 15
I 15
.IR del ,
E 15
.IR get ,
.IR put ,
or
.I sync
routines.
Modifications to the database during a sequential scan will be reflected
in the scan, i.e. records inserted behind the cursor will not be returned
while records inserted in front of the cursor will be returned.
.IP
E 10
D 21
The flag value must be set to one of the following values:
E 21
I 21
The flag value
.B must
be set to one of the following values:
E 21
E 7
.RS
.TP
I 7
R_CURSOR
D 8
Set the ``cursor'' to the location of the specified key.
E 8
I 8
The data associated with the specified key is returned.
This differs from the
.I get
D 25
routines in that it sets the ``cursor'' to the location of the
key as well.
E 25
I 25
routines in that it sets or initializes the cursor to the location of
the key as well.
E 25
E 8
D 21
(This implies that the access method has a implicit order which does
not change.
D 19
Applicable only to the
.B BTREE
and
.B RECNO
access methods.)
E 19
I 19
Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 21
I 21
(Note, for the DB_BTREE access method, the returned key is not necessarily an
exact match for the specified key.
The returned key is the smallest key greater than or equal to the specified
key, permitting partial key matches and range searches.)
E 21
E 19
.TP
E 7
R_FIRST
D 8
The first key of the hash table is returned.
E 8
I 8
D 25
The first key/data pair of the database is returned.
E 25
I 25
The first key/data pair of the database is returned, and the cursor
is set or initialized to reference it.
E 25
E 8
.TP
R_LAST
D 8
The last key of the hash table is returned.
E 8
I 8
D 25
The last key/data pair of the database is returned.
E 25
I 25
The last key/data pair of the database is returned, and the cursor
is set or initialized to reference it.
E 25
E 8
I 7
D 21
(This implies that the access method has a implicit order which does
not change.
D 19
Applicable only to the
.B BTREE
and
.B RECNO
access methods.)
E 19
I 19
Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 21
I 21
(Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 21
E 19
E 7
.TP
R_NEXT
D 8
Retrieve the record immediately after the most recently requested
record.
I 7
The order of retrieval of duplicate records is undefined.
E 8
I 8
D 25
Retrieve the key/data pair immediately after the key/data pair most recently
retrieved using the
.I seq
routine.
The cursor is moved to the returned key/data pair.
If
.I flag
is set to R_NEXT the first time the
.I seq
routine is called, the first key/data pair of the database is returned.
E 25
I 25
Retrieve the key/data pair immediately after the cursor.
If the cursor is not yet set, this is the same as the R_FIRST flag.
E 25
D 10
The order of retrieval of key/data pairs with duplicate keys is undefined.
E 10
E 8
E 7
.TP
R_PREV
D 8
Retrieve the record immediately before the most recently requested
record.
I 7
The order of retrieval of duplicate records is undefined.
E 8
I 8
D 25
Retrieve the key/data pair immediately before the key/data pair most recently
retrieved using the
.I seq
routine.
The cursor is moved to the returned key/data pair.
D 10
The order of retrieval of key/data pairs with duplicate keys is undefined.
E 10
I 10
If
.I flag
is set to R_PREV the first time the
.I seq
routine is called, the last key/data pair of the database is returned.
E 25
I 25
Retrieve the key/data pair immediately before the cursor.
If the cursor is not yet set, this is the same as the R_LAST flag.
E 25
E 10
E 8
D 21
(This implies that the access method has a implicit order which does
not change.
D 19
Applicable only to the
.B BTREE
and
.B RECNO
access methods.)
E 19
I 19
Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 21
I 21
(Applicable only to the DB_BTREE and DB_RECNO access methods.)
E 21
E 19
E 7
.RE
I 7
.IP
I 21
R_LAST and R_PREV are available only for the DB_BTREE and DB_RECNO
D 25
access methods because they each imply that the keys have an inherent order
which does not change.
E 25
I 25
access methods because they each imply that the keys have an inherent
order which does not change.
E 25
.IP
E 21
D 8
If
.I flag
is set to R_NEXT the first time the
.I seq
routine is called, the first record of
the database is returned.
.IP
Sequential record retrieval may begin at any time, and the position of
the ``cursor'' is not affected by calls to the
E 8
I 8
D 10
Sequential key/data pair retrieval may begin at any time.
The position of the ``cursor'' is not affected by calls to the
E 8
.IR delete ,
.IR get ,
.IR put ,
or
.I sync
D 8
routines, although it is undefined whether records inserted into the
database during a sequential scan will be returned.
E 8
I 8
routines.
It is undefined whether any modifications of the database during a
sequential scan will be reflected in the scan.
E 8
.IP
E 10
D 8
The
.I seq
routine returns 0 on error, 1 on success, -1 if the database file is a
character special file and end-of-file has been reached, and -2 if the
database file is a character special file and no complete records are
available.
E 8
I 8
.I Seq
routines return -1 on error (setting
.IR errno ),
D 10
0 on success, 1 if there are no more key/data pairs available and 2 if
the database file is a character special file and no complete key/data
pairs are currently available.
E 10
I 10
D 21
0 on success, 1 if there are no more key/data pairs available.
E 21
I 21
0 on success and 1 if there are no key/data pairs less than or greater
than the specified or current key.
E 21
D 19
If the
.B RECNO
access method is being used, and if the database file is a character special
file and no complete key/data pairs are currently available, the
E 19
I 19
If the DB_RECNO access method is being used, and if the database file
is a character special file and no complete key/data pairs are currently
available, the
E 19
.I seq
routines return 2.
E 10
E 8
E 7
D 6
.PP
The first time the
.I seq
routine is called, the first record of the database is returned
if
.I flag
is not set or is set to R_FIRST or R_NEXT.
.PP
The
.I seq
routine returns 0 on error, 1 on success, -1 if end-of-file is reached,
and -2 if the input is a character device and no complete records are
available.
E 6
.TP
sync
D 2
A pointer to a routine to flush any cached information to disk,
whose function prototype is:
E 2
I 2
A pointer to a routine to flush any cached information to disk.
D 8
Its function prototype is:
E 2
D 7
.sp
D 3
.in +5
E 3
I 3
D 6
.RS
E 6
I 6
.in +5
E 7
I 7
.sp .4
.in +4
E 7
E 6
E 3
sync(const DB *db);
D 3
.in -5
E 3
I 3
D 6
.RE
E 6
I 6
D 7
.in -5
E 6
E 3
.sp
E 7
I 7
.in -4
.sp .4
E 8
E 7
If the database is in memory only, the
.I sync
D 8
routine is a no-op.
The
.I sync
routine returns 0 on error and 1 on success.
E 8
I 8
routine has no effect and will always succeed.
I 27
.IP
The flag value may be set to the following value:
.RS
.TP
R_RECNOSYNC
If the DB_RECNO access method is being used, this flag causes
the sync routine to apply to the btree file which underlies the
recno file, not the recno file itself.
(See the
.I bfname
field of the
.IR recno (3)
manual page for more information.)
.RE
.IP
E 27
.I Sync
routines return -1 on error (setting
.IR errno )
and 0 on success.
E 8
I 7
.SH "KEY/DATA PAIRS"
I 8
Access to all file types is based on key/data pairs.
E 8
Both keys and data are represented by the following data structure:
E 7
.PP
D 7
Each of the routines take a pointer to a structure as returned by
the open routine, one or more pointers to key/data structures, and,
optionally, a flag value.
.PP
Keys (and data) are represented by the following data structure:
.sp
E 7
typedef struct {
.RS
D 17
u_char *data;
E 17
I 17
void *data;
E 17
.br
size_t size;
.RE
D 2
} ENTRY;
E 2
I 2
} DBT;
E 2
.PP
D 2
The elements of this structure are as follows:
E 2
I 2
D 7
The elements of this structure are defined as follows:
E 7
I 7
The elements of the DBT structure are defined as follows:
E 7
E 2
.TP
data
A pointer to a byte string.
.TP
size
The length of the byte string.
I 7
.PP
D 19
Key/data strings must fit into available memory.
E 7
.SH BTREE
D 7
One of the access methods is a btree: a sorted, balanced
tree structure with associated key and data pairs.
E 7
I 7
One of the access methods is a btree: a sorted, balanced tree structure
with associated key/data pairs.
E 7
.PP
D 3
<Mike fill this in?>
.PP
E 3
D 8
The private data structure provided to
E 8
I 8
The access method specific data structure provided to
E 8
.I btree_open
is as follows:
D 7
.sp
E 7
I 7
.PP
E 7
typedef struct {
.RS
I 9
u_long flags;
.br
E 9
D 3
u_long flags;
.br
E 3
D 7
int cachesize;
E 7
I 7
u_int psize;
.br
u_int cachesize;
.br
int (*compare)(const void *, const void *);
I 11
.br
D 12
char *lorder;
E 12
I 12
int lorder;
E 12
E 11
E 7
D 3
.br
int pagesize;
E 3
.RE
} BTREEINFO;
.PP
D 2
The elements of this structure are as follows:
E 2
I 2
The elements of this structure are defined as follows:
E 2
D 3
.TP
flags
The flag value is specified by
.IR or 'ing
the following values:
.RS
.TP
R_SMALLCACHE
A flag informing the routines that they are not expected to be
the primary data cache, and to minimize any caching they do.
E 3
D 7
.RE
E 7
.TP
I 9
flags
The flag value is specified by
.IR or 'ing
any of the following values:
.RS
.TP
R_DUP
D 13
If the key already exists in the file, create an entry with a duplicate
key, i.e. one with the same key and different data as another entry.
(This implies that keys are not required to be unique.)
E 13
I 13
On insertion,
if the key to be inserted already exists,
permit insertion anyway.
This flag permits duplicate keys in the tree.
By default,
duplicates are not permitted,
and attempts to insert them will fail.
E 13
I 10
Note, the order of retrieval of key/data pairs with duplicate keys is
undefined.
E 10
.RE
.TP
E 9
I 7
D 11
psize
Page size is the size in bytes of the pages used for nodes in the tree.
If the  file already exists, the specified value is ignored and the
value specified when the tree was created is used.
If
.I psize
is zero, an appropriate page size is chosen (based on the system memory
and/or file system constraints), but will never be less than 512 bytes.
.TP
E 11
E 7
cachesize
D 3
.TP
pagesize
E 3
I 3
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
I 7
Since every search examines the root page of the tree, caching the most
recently used pages substantially improves access time.
In addition, physical writes are delayed as long as possible, so a moderate
cache can reduce the number of I/O operations significantly.
Obviously, using a cache increases the likelihood of corruption or lost data
D 13
if the system crashes while a tree is being modified, however, caching 10
E 13
I 13
if the system crashes while a tree is being modified.
However, caching 10
E 13
D 9
pages decreases by between two and three orders of magnitude the creation
E 9
I 9
D 10
pages decreases (by between two and three orders of magnitude) the creation
E 9
time of a large tree.
E 10
I 10
pages decreases the creation time of a large tree by between two and three
orders of magnitude.
E 10
.TP
compare
Compare is a user defined comparison function.
It must return an integer less than, equal to, or greater than zero if the
first argument is considered to be respectively less than, equal to, or
greater than the second.
The same comparison function must be used on a given tree every time it
is opened.
If no comparison function is specified,
.IR strcmp (3)
is used.
I 11
.TP
lorder
The byte order for 4-byte integers in the stored database metadata.
D 12
Each character of the string represents a byte and should be one of the
characters '1', '2', '3' or '4'.
E 12
I 12
The number should represent the order as an integer; for example, 
big endian order would be the number 4,321.
E 12
If
.I lorder
D 12
is NULL (no order is specified) network order (``4321'') is used.
E 12
I 12
is 0 (no order is specified) the current host order is used.
E 12
If the  file already exists, the specified value is ignored and the
value specified when the tree was created is used.
(Obviously, portability of the data forming the key/data pairs is the
concern of the application program.)
.TP
psize
Page size is the size in bytes of the pages used for nodes in the tree.
If the  file already exists, the specified value is ignored and the
value specified when the tree was created is used.
If
.I psize
is zero, an appropriate page size is chosen (based on the system memory
and/or file system constraints), but will never be less than 512 bytes.
E 11
.PP
D 8
If the pointer to the private data structure is NULL, the
E 8
I 8
If the pointer to the
.I openinfo
data structure is NULL, the
E 8
.I btree_open
routine will use appropriate values.
.PP
If the database file already exists, and the O_TRUNC flag is not specified
to
.IR btree_open ,
the parameter
.I psize
ignored.
.PP
Key structures may reference byte strings of slightly less than one-half the
tree's page size only (see
.IR psize ).
Data structures may reference byte strings of essentially unlimited length.
.PP
D 8
Searches, insertions, and deletions in a btree are all guaranteed to
complete in logarithmic time.
E 8
I 8
Searches, insertions, and deletions in a btree will all complete in
D 9
O lg N time.
E 9
I 9
O lg N.
E 9
E 8
.PP
Forward sequential scans of a tree are from the least key to the greatest.
.PP
D 8
Space freed up by deleting records from a btree is never reclaimed,
although it is made available for reuse.
The only exception to this is that space occupied by large data items
(those greater than one quarter the size of a page) is neither reclaimed
nor reused.
E 8
I 8
Space freed up by deleting key/data pairs from a btree is never reclaimed,
although it is normally made available for reuse.
The exception to this is that space occupied by large data items (those
greater than one quarter the size of a page) is neither reclaimed nor reused.
E 8
This means that the btree storage structure is grow-only.
The only solutions are to avoid excessive deletions, or to create a fresh
tree periodically from a scan of an existing one.
E 7
E 3
.SH HASH
One of the access methods is hashed access and storage.
D 8
The private data structure provided to
E 8
I 8
The access method specific data structure provided to
E 8
.I hash_open
is as follows:
.sp
typedef struct {
.RS
D 3
u_long flags;
.br
E 3
D 17
int bsize;
E 17
I 17
u_long (*hash)(const void *, const size_t);
E 17
.br
I 3
D 7
int cachesize;
E 7
I 7
u_int cachesize;
E 7
.br
I 17
int bsize;
.br
E 17
E 3
int ffactor;
.br
D 17
int nelem;
.br
u_long (*hash)(const void *, const size_t);
I 11
.br
E 17
D 12
char *lorder;
E 12
I 12
int lorder;
I 17
.br
int nelem;
E 17
E 12
E 11
.RE
} HASHINFO;
.PP
D 2
The elements of this structure are as follows:
E 2
I 2
The elements of this structure are defined as follows:
E 2
.TP
D 3
flags
The flag value is specified by
.IR or 'ing
the following values:
.RS
.TP
R_SMALLCACHE
A flag informing the routines that they are not expected to be
the primary cache, and to minimize any caching they do.
.RE
.TP
E 3
bsize
.I Bsize
D 7
defines the hash table bucket size, and is, by default 1024, bytes.
E 7
I 7
D 10
defines the hash table bucket size, and is, by default, 1024 bytes.
E 7
For tables with large data items, it may be preferable to increase the
page size, and, conversely, applications doing exclusively in-memory hashing
may want to use a very small bucket size, for example, 256, to minimize
hash chain collisions.
E 10
I 10
defines the hash table bucket size, and is, by default, 256 bytes.
It may be preferable to increase the page size for disk-resident tables and
tables with large data items.
E 10
.TP
I 3
cachesize
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
.TP
E 3
ffactor
.I Ffactor
indicates a desired density within the hash table.
It is an approximation of the number of keys allowed to accumulate in any
one bucket, determining when the hash table grows or shrinks.
D 10
The default value is 5.
E 10
I 10
The default value is 8.
E 10
.TP
hash
.I Hash
is a user defined hash function.
Since no hash function performs equally well on all possible data, the
user may find that the built-in hash function does poorly on a particular
data set.
D 8
Any user specified hash function should take two arguments, a pointer to
D 7
a byte string and a length, and return an unsigned long to be used as
E 7
I 7
a byte string and a length, and return an u_long to be used as
E 7
the hash value.
E 8
I 8
User specified hash functions must take two arguments (a pointer to a byte
string and a length) and return an u_long to be used as the hash value.
I 11
.TP
lorder
The byte order for 4-byte integers in the stored database metadata.
D 12
Each character of the string represents a byte and should be one of the
characters '1', '2', '3' or '4'.
E 12
I 12
The number should represent the order as an integer; for example, 
big endian order would be the number 4,321.
E 12
If
.I lorder
D 12
is NULL (no order is specified) network order (``4321'') is used.
E 12
I 12
is 0 (no order is specified) the current host order is used.
E 12
If the  file already exists, the specified value is ignored and the
value specified when the tree was created is used.
(Obviously, portability of the data forming the key/data pairs is the
concern of the application program.)
E 11
E 8
.TP
nelem
.I Nelem
is an estimate of the final size of the hash table.
If not set, the default value is 1.
If not set or set too low, hash tables will expand gracefully as keys
are entered, although a slight performance degradation may be noticed.
.PP
I 3
D 7
If the pointer to the private data structure is NULL, the open routine
will use appropriate values.
E 7
I 7
D 8
If the pointer to the private data structure is NULL, the
E 8
I 8
If the pointer to the
.I openinfo
data structure is NULL, the
E 8
.I hash_open
routine will use appropriate values.
E 7
.PP
E 3
If the hash table already exists, and the O_TRUNC flag is not
D 7
specified to 
E 7
I 7
specified to
E 7
.IR hash_open ,
the parameters
.IR bsize ,
.IR ffactor ,
and
.I nelem
D 7
are ignored. 
E 7
I 7
are ignored.
E 7
.PP
D 7
If a hash function is specified, 
E 7
I 7
If a hash function is specified,
E 7
.I hash_open
will attempt to determine if the hash function specified is the same as
the one with which the database was created, and will fail if it is not.
.PP
I 2
Both key and data structures may reference byte strings of essentially
D 4
unlimited length.
E 4
I 4
D 7
unlimited length, however, the strings must fit into available memory.
E 7
I 7
unlimited length.
E 7
E 4
.PP
E 2
Backward compatible interfaces to the routines described in
.IR dbm (3),
.IR hsearch (3),
and
.IR ndbm (3)
D 7
are provided as part of the compatibility library, ``libcompat.a''.
E 7
I 7
are provided, however, these interfaces are not compatible with
previous file formats.
E 7
D 2
.SH "FLAT FILES"
E 2
I 2
.SH RECNO
E 2
One of the access methods is either variable or fixed-length records,
the former delimited by a specific byte value.
D 8
The private data structure provided to
E 8
I 8
The access method specific data structure provided to
E 8
D 2
.I flat_open
E 2
I 2
.I recno_open
E 2
is as follows:
.sp
typedef struct {
.RS
u_long flags;
.br
D 2
int cachesize;
E 2
I 2
D 3
u_int cachesize;
E 3
I 3
D 7
int cachesize;
E 7
I 7
u_int cachesize;
E 7
E 3
E 2
.br
size_t reclen;
.br
u_char bval;
.RE
D 2
} VLENINFO;
E 2
I 2
} RECNOINFO;
E 2
.PP
D 2
The elements of this structure are as follows:
E 2
I 2
The elements of this structure are defined as follows:
E 2
.TP
flags
The flag value is specified by
.IR or 'ing
D 7
the following values:
E 7
I 7
any of the following values:
E 7
.RS
.TP
R_FIXEDLEN
The records are fixed-length, not byte delimited.
The structure element
.I reclen
specifies the length of the record, and the structure element
.I bval
is used as the pad character.
I 8
.TP
R_SNAPSHOT
This flag requires that a snapshot of the file be taken when
.I recno_open
is called, instead of permitting any unmodified records to be
read from the original file.
E 8
D 3
.TP
R_SMALLCACHE
A flag informing the routines that they are not expected to be
the primary cache, and to minimize any caching they do.
E 3
.RE
.TP
cachesize
D 2
The amount of memory to be used as a data cache.
E 2
I 2
D 3
The amount of memory to be used as a data cache, expressed as a number
of bytes.
E 3
I 3
A suggested maximum size, in bytes, of the memory cache.
Setting this value to zero specifies that an appropriate amount of memory
should be used.
E 3
E 2
.TP
reclen
The length of a fixed-length record.
.TP
bval
The delimiting byte to be used to mark the end of a record for
variable-length records, and the pad character for fixed-length
records.
.PP
D 7
Variable-length and fixed-length data files require
E 7
I 7
D 8
Variable-length and fixed-length data files require retrieval
E 8
I 8
Variable-length and fixed-length data files require
E 8
E 7
.I key
D 7
structures to reference a byte followed by three unsigned longs.
E 7
I 7
D 8
structures to reference a byte followed by three u_long numbers.
E 7
The numbers are used as a record number, a byte offset and a record length,
respectively, and the byte is a flag value which indicates the validity
of the other fields.
D 7
These access methods do no validity checking as to the correctness of any
of these values, nor are they constrained to use the values provided.
E 7
I 7
This access method does no validity checking as to the correctness of any
of these values, nor is it constrained to use the values provided.
E 7
If any of the record number, byte offset or record length are not specified
by the calling routine, and the record retrieval is successful, the correct
values are copied into the caller's
.I key
E 8
I 8
structures to reference the following structure:
.sp
typedef struct {
.RS
u_long length;
.br
u_long number;
.br
u_long offset;
.br
u_char valid;
.RE
} RECNOKEY;
.PP
The elements of this structure are defined as follows:
.TP
length
The length of the record.
.TP
number
The record number.
.TP
offset
The offset in the file at which the record is located.
.TP
valid
A flag value which indicates the validity of the other fields in the
E 8
structure.
The flag value is specified by
.IR or 'ing
D 8
the following values:
E 8
I 8
one or more of the following values:
.RS
E 8
.TP
R_LENGTH
The record length is valid.
.TP
I 8
R_NUMBER
The record number is valid.
.TP
E 8
R_OFFSET
The byte offset is valid.
D 8
.TP
R_RECNO
The record number is valid.
E 8
I 8
.RE
E 8
I 2
.PP
D 4
Data structures may reference byte strings of essentially unlimited length.
E 4
I 4
D 8
Data structures may reference byte strings of essentially
unlimited length, however, the strings must fit into available memory.
E 8
I 8
If the record retrieval is successful, the record number, byte offset and
record length are set in the RECNOKEY structure referenced by the caller's
.I key
structure.
.PP
Data structures may reference byte strings of essentially unlimited length.
E 19
I 19
Key and data byte strings may reference strings of essentially unlimited
length although any two of them must fit into available memory at the same
time.
It should be noted that the access methods provide no guarantees about
byte string alignment.
E 19
E 8
E 4
E 2
.SH ERRORS
The
D 19
.I open
D 8
routines may fail and set errno for any of the errors specified for the
library routines
E 8
I 8
routines may fail and set
E 19
I 19
.I dbopen
routine may fail and set
E 19
.I errno
for any of the errors specified for the library routines
E 8
.IR open (2)
and
.IR malloc (3)
or the following:
.TP
I 17
[EFTYPE]
D 19
A file used by one of the
.I open
routines is incorrectly formatted.
E 19
I 19
A file is incorrectly formatted.
E 19
.TP
E 17
[EINVAL]
A parameter has been specified (hash function, pad byte etc.) that is
D 25
incompatible with the current file specification or there is a mismatch
between the version number of file and the software.
E 25
I 25
incompatible with the current file specification or which is not
meaningful for the function (for example, use of the cursor without
prior initialization) or there is a mismatch between the version
number of file and the software.
E 25
I 3
D 17
.TP
D 7
[EOPNOTSUPP]
E 7
I 7
[EBADFORMAT]
E 7
D 8
A file used by an open routine is incorrectly formatted, corrupted,
or otherwise unusable.
E 8
I 8
A file used by one of the
.I open
routines is incorrectly formatted.
E 17
E 8
I 7
D 10
.br
D 8
<Note, this
E 8
I 8
<This
E 8
.I errno
does not currently exist.>
E 10
E 7
E 3
.PP
The
D 8
.I get
routines may fail and set errno for any of the errors specified for the
library routine
.IR malloc (3).
.PP
The
E 8
.I close
D 8
routines may fail and set errno for any of the errors specified for the
library routines
E 8
I 8
routines may fail and set
.I errno
for any of the errors specified for the library routines
E 8
.IR close (2),
I 8
.IR read (2),
.IR write (2),
E 8
.IR free (3),
or
.IR fsync (2).
.PP
The
I 8
D 15
.IR delete ,
E 15
I 15
.IR del ,
E 15
.IR get ,
.I put
and
.I seq
routines may fail and set
.I errno
for any of the errors specified for the library routines
.IR read (2),
.IR write (2),
.IR free (3)
or
.IR malloc (3).
.PP
The
I 28
.I fd
routines will fail and set
.I errno
to ENOENT for in memory databases.
.PP
The
E 28
E 8
.I sync
D 8
routines may fail and set errno for any of the errors specified for the
library routine
E 8
I 8
routines may fail and set
.I errno
for any of the errors specified for the library routine
E 8
.IR fsync (2).
I 8
.SH "SEE ALSO"
D 19
.IR "Dynamic Hash Tables" ,
Per-Ake Larson, Communications of the ACM, April 1988.
D 17
.sp
E 17
I 17
.br
E 17
.IR "A New Hash Package for UNIX" ,
Margo Seltzer, USENIX Proceedings, Winter 1991.
E 19
I 19
.IR btree (3),
.IR hash (3),
.IR mpool (3),
.IR recno (3)
I 30
.sp
.IR "LIBTP: Portable, Modular Transactions for UNIX" ,
Margo Seltzer, Michael Olson, USENIX proceedings, Winter 1992.
E 30
E 19
E 8
I 3
.SH BUGS
The typedef DBT is a mnemonic for ``data base thang'', and was used
D 12
because all of the reasonable names were taken.
E 12
I 12
because noone could think of a reasonable name that wasn't already used.
I 28
.PP
The file descriptor interface is a kluge and will be deleted in a
future version of the interface.
E 28
E 12
I 7
D 13
.PP
Btrees should reclaim unused pages automatically, and key lengths should
be unbounded.
E 13
.PP
D 8
Currently, none of the access methods provide any control for concurrent
access, locking, or transactions.
E 8
I 8
None of the access methods provide any form of concurrent access,
locking, or transactions.
I 12
D 19
.PP
Only big and little endian byte order is supported.
E 19
E 12
E 8
E 7
E 3
E 1
