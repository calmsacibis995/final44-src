h58934
s 00001/00001/01064
d D 8.5 94/03/20 14:35:03 bostic 10 9
c delete UofT; requested change from Henry Spencer <henry@zoo.toronto.edu>
e
s 00009/00009/01056
d D 8.4 94/03/19 08:21:55 bostic 9 8
c make prototypes __P style
e
s 00031/00015/01034
d D 8.3 94/03/16 12:42:55 bostic 8 7
c alpha3.3
e
s 00012/00012/01037
d D 8.2 94/01/02 14:30:40 bostic 7 6
c Henry Spencer's fix for end-of-word matching
c Word matching considers '_' to terminate a word, i.e. vm_page_free\>
c matches vm_page_free_count.  This isn't historic vi practice.
e
s 00002/00002/01047
d D 8.1 93/06/04 12:57:47 bostic 6 5
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00232/00205/00817
d D 5.5 93/05/21 16:06:48 bostic 5 4
c Henry Spencer's Alpha 3.0 regex release
e
s 00018/00029/01004
d D 5.4 92/09/30 14:30:43 bostic 4 3
c convert to 4BSD style prototypes, includes
e
s 00116/00039/00917
d D 5.3 92/09/30 12:58:03 bostic 3 2
c alpha2.1 release from Henry Spencer
e
s 00010/00000/00946
d D 5.2 92/08/10 09:05:55 bostic 2 1
c speedup for grep(1), from Henry Spencer
e
s 00946/00000/00000
d D 5.1 92/08/06 11:58:03 bostic 1 0
c date and time created 92/08/06 11:58:03 by bostic
e
u
U
t
T
I 1
/*-
D 8
 * Copyright (c) 1992 Henry Spencer.
D 6
 * Copyright (c) 1992 The Regents of the University of California.
 * All rights reserved.
E 6
I 6
 * Copyright (c) 1992, 1993
E 8
I 8
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
E 8
 *	The Regents of the University of California.  All rights reserved.
E 6
 *
 * This code is derived from software contributed to Berkeley by
D 10
 * Henry Spencer of the University of Toronto.
E 10
I 10
 * Henry Spencer.
E 10
 *
 * %sccs.include.redist.c%
 *
 *	%W% (Berkeley) %G%
 */

/*
 * The matching engine and friends.  This file is #included by regexec.c
 * after suitable #defines of a variety of macros used herein, so that
 * different state representations can be used without duplicating masses
 * of code.
 */

#ifdef SNAMES
#define	matcher	smatcher
#define	fast	sfast
#define	slow	sslow
#define	dissect	sdissect
#define	backref	sbackref
D 5
#define	expand	sexpand
E 5
#define	step	sstep
#define	print	sprint
I 3
#define	at	sat
E 3
#define	match	smat
#endif
#ifdef LNAMES
#define	matcher	lmatcher
#define	fast	lfast
#define	slow	lslow
#define	dissect	ldissect
#define	backref	lbackref
D 5
#define	expand	lexpand
E 5
#define	step	lstep
#define	print	lprint
I 3
#define	at	lat
E 3
#define	match	lmat
#endif

/* another structure passed up and down to avoid zillions of parameters */
struct match {
	struct re_guts *g;
	int eflags;
	regmatch_t *pmatch;	/* [nsub+1] (0 element unused) */
D 5
	uchar *offp;		/* offsets work from here */
	uchar *beginp;		/* start of string -- virtual NUL precedes */
	uchar *endp;		/* end of string -- virtual NUL here */
	uchar *coldp;		/* can be no match starting before here */
	uchar **lastpos;	/* [nplus+1] */
E 5
I 5
	char *offp;		/* offsets work from here */
	char *beginp;		/* start of string -- virtual NUL precedes */
	char *endp;		/* end of string -- virtual NUL here */
	char *coldp;		/* can be no match starting before here */
	char **lastpos;		/* [nplus+1] */
E 5
	STATEVARS;
	states st;		/* current states */
	states fresh;		/* states for a fresh start */
	states tmp;		/* temporary */
	states empty;		/* empty set of states */
};

I 5
D 8
static int matcher(/*register struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags*/);
static char *dissect(/*register struct match *m, char *start, char *stop, sopno startst, sopno stopst*/);
static char *backref(/*register struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev*/);
static char *fast(/*register struct match *m, char *start, char *stop, sopno startst, sopno stopst*/);
static char *slow(/*register struct match *m, char *start, char *stop, sopno startst, sopno stopst*/);
static states step(/*register struct re_guts *g, int start, int stop, register states bef, int ch, register states aft*/);
E 8
I 8
/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif

/* === engine.c === */
D 9
static int matcher(register struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags);
static char *dissect(register struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static char *backref(register struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev);
static char *fast(register struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static char *slow(register struct match *m, char *start, char *stop, sopno startst, sopno stopst);
static states step(register struct re_guts *g, sopno start, sopno stop, register states bef, int ch, register states aft);
E 9
I 9
static int matcher __P((struct re_guts *g, char *string, size_t nmatch, regmatch_t pmatch[], int eflags));
static char *dissect __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static char *backref __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst, sopno lev));
static char *fast __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static char *slow __P((struct match *m, char *start, char *stop, sopno startst, sopno stopst));
static states step __P((struct re_guts *g, sopno start, sopno stop, states bef, int ch, states aft));
E 9
E 8
#define	BOL	(OUT+1)
#define	EOL	(BOL+1)
#define	BOLEOL	(BOL+2)
#define	NOTHING	(BOL+3)
#define	BOW	(BOL+4)
#define	EOW	(BOL+5)
#define	CODEMAX	(BOL+5)		/* highest code used */
#define	NONCHAR(c)	((c) > CHAR_MAX)
#define	NNONCHAR	(CODEMAX-CHAR_MAX)
E 5
D 3
#ifndef NDEBUG
STATIC void print();
extern char *regchar();
#define	SP(t, s, c)	{ if (m->eflags&REG_TRACE) print(m->g, t, s, c, stdout); }
#define	DO(t, p1, p2, s1, s2)	{ if (m->eflags&REG_TRACE) { \
					printf("%s %s-", t, regchar(*(p1))); \
					printf("%s ", regchar(*(p2))); \
					printf("%ld-%ld\n", s1, s2); } }
E 3
I 3
D 4
#include "engine.ih"

E 4
#ifdef REDEBUG
I 5
D 8
static void print(/*struct match *m, char *caption, states st, int ch, FILE *d*/);
E 8
I 8
D 9
static void print(struct match *m, char *caption, states st, int ch, FILE *d);
E 9
I 9
static void print __P((struct match *m, char *caption, states st, int ch, FILE *d));
E 9
E 8
#endif
#ifdef REDEBUG
D 8
static void at(/*struct match *m, char *title, char *start, char *stop, sopno startst, stopno stopst*/);
E 8
I 8
D 9
static void at(struct match *m, char *title, char *start, char *stop, sopno startst, sopno stopst);
E 9
I 9
static void at __P((struct match *m, char *title, char *start, char *stop, sopno startst, sopno stopst));
E 9
E 8
#endif
#ifdef REDEBUG
D 8
static char *pchar(/*int ch*/);
E 8
I 8
D 9
static char *pchar(int ch);
E 9
I 9
static char *pchar __P((int ch));
E 9
E 8
#endif

I 8
#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */

E 8
#ifdef REDEBUG
E 5
#define	SP(t, s, c)	print(m, t, s, c, stdout)
#define	AT(t, p1, p2, s1, s2)	at(m, t, p1, p2, s1, s2)
#define	NOTE(str)	{ if (m->eflags&REG_TRACE) printf("=%s\n", (str)); }
E 3
#else
#define	SP(t, s, c)	/* nothing */
D 3
#define	DO(t, p1, p2, s1, s2)	/* nothing */
E 3
I 3
#define	AT(t, p1, p2, s1, s2)	/* nothing */
#define	NOTE(s)	/* nothing */
E 3
#endif

I 4
D 5
static uchar	*backref
	__P((struct match *, uchar *, uchar *, sopno, sopno, sopno));
static uchar	*dissect __P((struct match *, uchar *, uchar *, sopno, sopno));
static states	 expand __P((struct re_guts *, int, int, states, int, int));
static uchar	*fast __P((struct match *, uchar *, uchar *, sopno, sopno));
static int	 matcher
	__P((struct re_guts *, uchar *, size_t, regmatch_t[], int));
static uchar	*slow __P((struct match *, uchar *, uchar *, sopno, sopno));
static states	 step __P((struct re_guts *, int, int, states, u_int, states));

#ifdef REDEBUG
static void  at __P((struct match *, char *, uchar *, uchar *, sopno, stopno));
static char *pchar __P((int));
static void  print __P((struct match *, char *, states, u_int, FILE *));
#endif

E 5
E 4
D 3
STATIC uchar *fast();
STATIC uchar *slow();
STATIC uchar *dissect();
STATIC uchar *backref();
STATIC states expand();
STATIC states step();

E 3
/*
 - matcher - the actual matching engine
I 5
 == static int matcher(register struct re_guts *g, char *string, \
 ==	size_t nmatch, regmatch_t pmatch[], int eflags);
E 5
I 3
D 4
 == static int matcher(register struct re_guts *g, uchar *string, \
 ==	size_t nmatch, regmatch_t pmatch[], int eflags);
E 4
E 3
 */
static int			/* 0 success, REG_NOMATCH failure */
matcher(g, string, nmatch, pmatch, eflags)
register struct re_guts *g;
D 5
uchar *string;
E 5
I 5
char *string;
E 5
size_t nmatch;
regmatch_t pmatch[];
int eflags;
{
D 5
	register uchar *endp;
E 5
I 5
	register char *endp;
E 5
	register int i;
	struct match mv;
	register struct match *m = &mv;
D 5
	register uchar *dp;
E 5
I 5
	register char *dp;
E 5
	const register sopno gf = g->firststate+1;	/* +1 for OEND */
	const register sopno gl = g->laststate;
D 5
	uchar *start;
	uchar *stop;
E 5
I 5
	char *start;
	char *stop;
E 5

I 3
	/* simplify the situation where possible */
E 3
	if (g->cflags&REG_NOSUB)
D 3
		nmatch = 0;		/* simplify tests */
E 3
I 3
		nmatch = 0;
E 3
	if (eflags&REG_STARTEND) {
		start = string + pmatch[0].rm_so;
		stop = string + pmatch[0].rm_eo;
	} else {
		start = string;
D 5
		stop = start + strlen((char *)start);
E 5
I 5
		stop = start + strlen(start);
E 5
	}
I 5
	if (stop < start)
		return(REG_INVARG);
E 5

I 2
	/* prescreening; this does wonders for this rather slow code */
	if (g->must != NULL) {
		for (dp = start; dp < stop; dp++)
D 5
			if (*dp == (uchar)g->must[0] && stop - dp >= g->mlen &&
			strncmp((char *)dp, g->must, (size_t)g->mlen) == 0)
E 5
I 5
			if (*dp == g->must[0] && stop - dp >= g->mlen &&
				memcmp(dp, g->must, (size_t)g->mlen) == 0)
E 5
				break;
		if (dp == stop)		/* we didn't find g->must */
			return(REG_NOMATCH);
	}

E 2
	/* match struct setup */
	m->g = g;
	m->eflags = eflags;
	m->pmatch = NULL;
	m->lastpos = NULL;
	m->offp = string;
	m->beginp = start;
	m->endp = stop;
	STATESETUP(m, 4);
	SETUP(m->st);
	SETUP(m->fresh);
	SETUP(m->tmp);
	SETUP(m->empty);
	CLEAR(m->empty);

	/* this loop does only one repetition except for backrefs */
	for (;;) {
		endp = fast(m, start, stop, gf, gl);
		if (endp == NULL) {		/* a miss */
			STATETEARDOWN(m);
			return(REG_NOMATCH);
		}
		if (nmatch == 0 && !g->backrefs)
			break;		/* no further info needed */

		/* where? */
		assert(m->coldp != NULL);
		for (;;) {
I 3
			NOTE("finding start");
E 3
			endp = slow(m, m->coldp, stop, gf, gl);
			if (endp != NULL)
				break;
D 3
			assert(*m->coldp != '\0');
E 3
I 3
			assert(m->coldp < m->endp);
E 3
			m->coldp++;
		}
		if (nmatch == 1 && !g->backrefs)
			break;		/* no further info needed */

		/* oh my, he wants the subexpressions... */
		if (m->pmatch == NULL)
			m->pmatch = (regmatch_t *)malloc((m->g->nsub + 1) *
							sizeof(regmatch_t));
		if (m->pmatch == NULL) {
			STATETEARDOWN(m);
			return(REG_ESPACE);
		}
D 3
		for (i = 1; i <= m->g->nsub; i++) {
			m->pmatch[i].rm_so = -1;
			m->pmatch[i].rm_eo = -1;
		}
		if (!g->backrefs)
E 3
I 3
		for (i = 1; i <= m->g->nsub; i++)
			m->pmatch[i].rm_so = m->pmatch[i].rm_eo = -1;
		if (!g->backrefs && !(m->eflags&REG_BACKR)) {
			NOTE("dissecting");
E 3
			dp = dissect(m, m->coldp, endp, gf, gl);
D 3
		else {
E 3
I 3
		} else {
E 3
			if (g->nplus > 0 && m->lastpos == NULL)
D 5
				m->lastpos = (uchar **)malloc((g->nplus+1) *
							sizeof(uchar *));
E 5
I 5
				m->lastpos = (char **)malloc((g->nplus+1) *
							sizeof(char *));
E 5
			if (g->nplus > 0 && m->lastpos == NULL) {
				free(m->pmatch);
				STATETEARDOWN(m);
				return(REG_ESPACE);
			}
I 3
			NOTE("backref dissect");
E 3
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
		}
		if (dp != NULL)
			break;

		/* uh-oh... we couldn't find a subexpression-level match */
		assert(g->backrefs);	/* must be back references doing it */
		assert(g->nplus == 0 || m->lastpos != NULL);
D 3
		while (dp == NULL && endp > m->coldp &&
			(endp = slow(m, m->coldp, endp-1, gf, gl)) != NULL) {
E 3
I 3
		for (;;) {
			if (dp != NULL || endp <= m->coldp)
				break;		/* defeat */
			NOTE("backoff");
			endp = slow(m, m->coldp, endp-1, gf, gl);
			if (endp == NULL)
				break;		/* defeat */
E 3
			/* try it on a shorter possibility */
I 3
#ifndef NDEBUG
E 3
			for (i = 1; i <= m->g->nsub; i++) {
D 3
				m->pmatch[i].rm_so = -1;
				m->pmatch[i].rm_eo = -1;
E 3
I 3
				assert(m->pmatch[i].rm_so == -1);
				assert(m->pmatch[i].rm_eo == -1);
E 3
			}
I 3
#endif
			NOTE("backoff dissect");
E 3
			dp = backref(m, m->coldp, endp, gf, gl, (sopno)0);
		}
		assert(dp == NULL || dp == endp);
		if (dp != NULL)		/* found a shorter one */
			break;

		/* despite initial appearances, there is no match here */
I 3
		NOTE("false alarm");
E 3
		start = m->coldp + 1;	/* recycle starting later */
		assert(start <= stop);
	}

	/* fill in the details if requested */
	if (nmatch > 0) {
		pmatch[0].rm_so = m->coldp - m->offp;
		pmatch[0].rm_eo = endp - m->offp;
	}
	if (nmatch > 1) {
		assert(m->pmatch != NULL);
		for (i = 1; i < nmatch; i++)
			if (i <= m->g->nsub)
				pmatch[i] = m->pmatch[i];
			else {
				pmatch[i].rm_so = -1;
				pmatch[i].rm_eo = -1;
			}
	}

	if (m->pmatch != NULL)
		free((char *)m->pmatch);
	if (m->lastpos != NULL)
		free((char *)m->lastpos);
	STATETEARDOWN(m);
	return(0);
}

/*
 - dissect - figure out what matched what, no back references
I 5
 == static char *dissect(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
E 5
I 3
D 4
 == static uchar *dissect(register struct match *m, uchar *start, \
 ==	uchar *stop, sopno startst, sopno stopst);
E 4
E 3
 */
D 5
static uchar *			/* == stop (success) always */
E 5
I 5
static char *			/* == stop (success) always */
E 5
dissect(m, start, stop, startst, stopst)
register struct match *m;
D 5
uchar *start;
uchar *stop;
E 5
I 5
char *start;
char *stop;
E 5
sopno startst;
sopno stopst;
{
	register int i;
	register sopno ss;	/* start sop of current subRE */
	register sopno es;	/* end sop of current subRE */
D 5
	register uchar *sp;	/* start of string matched by it */
	register uchar *stp;	/* string matched by it cannot pass here */
	register uchar *rest;	/* start of rest of string */
	register uchar *tail;	/* string unmatched by rest of RE */
E 5
I 5
	register char *sp;	/* start of string matched by it */
	register char *stp;	/* string matched by it cannot pass here */
	register char *rest;	/* start of rest of string */
	register char *tail;	/* string unmatched by rest of RE */
E 5
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
D 5
	register uchar *ssp;	/* start of string matched by subsubRE */
	register uchar *sep;	/* end of string matched by subsubRE */
	register uchar *oldssp;	/* previous ssp */
	register uchar *dp;
E 5
I 5
	register char *ssp;	/* start of string matched by subsubRE */
	register char *sep;	/* end of string matched by subsubRE */
	register char *oldssp;	/* previous ssp */
	register char *dp;
E 5
D 3
	register size_t len;
E 3

D 3
	DO("diss", start, stop, startst, stopst);
E 3
I 3
	AT("diss", start, stop, startst, stopst);
E 3
	sp = start;
	for (ss = startst; ss < stopst; ss = es) {
		/* identify end of subRE */
		es = ss;
		switch (OP(m->g->strip[es])) {
		case OPLUS_:
		case OQUEST_:
			es += OPND(m->g->strip[es]);
			break;
		case OCH_:
			while (OP(m->g->strip[es]) != O_CH)
				es += OPND(m->g->strip[es]);
			break;
		}
		es++;

		/* figure out what it matched */
		switch (OP(m->g->strip[ss])) {
		case OEND:
D 5
			assert(0);
E 5
I 5
			assert(nope);
E 5
			break;
		case OCHAR:
			sp++;
			break;
		case OBOL:
		case OEOL:
I 5
		case OBOW:
		case OEOW:
E 5
			break;
		case OANY:
		case OANYOF:
			sp++;
			break;
		case OBACK_:
		case O_BACK:
D 5
			assert(0);
E 5
I 5
			assert(nope);
E 5
			break;
		/* cases where length of match is hard to find */
		case OQUEST_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			/* did innards match? */
			if (slow(m, sp, rest, ssub, esub) != NULL) {
				dp = dissect(m, sp, rest, ssub, esub);
				assert(dp == rest);
			} else		/* no */
				assert(sp == rest);
			sp = rest;
			break;
		case OPLUS_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = es - 1;
			ssp = sp;
			oldssp = ssp;
			for (;;) {	/* find last match of innards */
				sep = slow(m, ssp, rest, ssub, esub);
				if (sep == NULL || sep == ssp)
					break;	/* failed or matched null */
				oldssp = ssp;	/* on to next try */
				ssp = sep;
			}
			if (sep == NULL) {
				/* last successful match */
				sep = ssp;
				ssp = oldssp;
			}
			assert(sep == rest);	/* must exhaust substring */
			assert(slow(m, ssp, sep, ssub, esub) == rest);
			dp = dissect(m, ssp, sep, ssub, esub);
			assert(dp == sep);
			sp = rest;
			break;
		case OCH_:
			stp = stop;
			for (;;) {
				/* how long could this one be? */
				rest = slow(m, sp, stp, ss, es);
				assert(rest != NULL);	/* it did match */
				/* could the rest match the rest? */
				tail = slow(m, rest, stop, es, stopst);
				if (tail == stop)
					break;		/* yes! */
				/* no -- try a shorter match for this one */
				stp = rest - 1;
				assert(stp >= sp);	/* it did work */
			}
			ssub = ss + 1;
			esub = ss + OPND(m->g->strip[ss]) - 1;
			assert(OP(m->g->strip[esub]) == OOR1);
			for (;;) {	/* find first matching branch */
				if (slow(m, sp, rest, ssub, esub) == rest)
					break;	/* it matched all of it */
				/* that one missed, try next one */
				assert(OP(m->g->strip[esub]) == OOR1);
				esub++;
				assert(OP(m->g->strip[esub]) == OOR2);
				ssub = esub + 1;
				esub += OPND(m->g->strip[esub]);
				if (OP(m->g->strip[esub]) == OOR2)
					esub--;
				else
					assert(OP(m->g->strip[esub]) == O_CH);
			}
			dp = dissect(m, sp, rest, ssub, esub);
			assert(dp == rest);
			sp = rest;
			break;
		case O_PLUS:
		case O_QUEST:
		case OOR1:
		case OOR2:
		case O_CH:
D 5
			assert(0);
E 5
I 5
			assert(nope);
E 5
			break;
		case OLPAREN:
			i = OPND(m->g->strip[ss]);
I 8
			assert(0 < i && i <= m->g->nsub);
E 8
			m->pmatch[i].rm_so = sp - m->offp;
			break;
		case ORPAREN:
			i = OPND(m->g->strip[ss]);
I 8
			assert(0 < i && i <= m->g->nsub);
E 8
			m->pmatch[i].rm_eo = sp - m->offp;
			break;
		default:		/* uh oh */
D 5
			assert(0);
E 5
I 5
			assert(nope);
E 5
			break;
		}
	}

	assert(sp == stop);
	return(sp);
}

/*
 - backref - figure out what matched what, figuring in back references
I 5
 == static char *backref(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst, sopno lev);
E 5
I 3
D 4
 == static uchar *backref(register struct match *m, uchar *start, \
 ==	uchar *stop, sopno startst, sopno stopst, sopno lev);
E 4
E 3
 */
D 5
static uchar *			/* == stop (success) or NULL (failure) */
E 5
I 5
static char *			/* == stop (success) or NULL (failure) */
E 5
backref(m, start, stop, startst, stopst, lev)
register struct match *m;
D 5
uchar *start;
uchar *stop;
E 5
I 5
char *start;
char *stop;
E 5
sopno startst;
sopno stopst;
sopno lev;			/* PLUS nesting level */
{
	register int i;
	register sopno ss;	/* start sop of current subRE */
D 5
	register uchar *sp;	/* start of string matched by it */
E 5
I 5
	register char *sp;	/* start of string matched by it */
E 5
	register sopno ssub;	/* start sop of subsubRE */
	register sopno esub;	/* end sop of subsubRE */
D 5
	register uchar *ssp;	/* start of string matched by subsubRE */
	register uchar *dp;
E 5
I 5
	register char *ssp;	/* start of string matched by subsubRE */
	register char *dp;
E 5
	register size_t len;
	register int hard;
	register sop s;
	register regoff_t offsave;
	register cset *cs;

D 3
	DO("back", start, stop, startst, stopst);
E 3
I 3
	AT("back", start, stop, startst, stopst);
E 3
	sp = start;

	/* get as far as we can with easy stuff */
	hard = 0;
	for (ss = startst; !hard && ss < stopst; ss++)
		switch (OP(s = m->g->strip[ss])) {
		case OCHAR:
D 5
			if (sp == stop || *sp++ != OPND(s))
E 5
I 5
			if (sp == stop || *sp++ != (char)OPND(s))
E 5
				return(NULL);
			break;
		case OANY:
			if (sp == stop)
				return(NULL);
			sp++;
			break;
		case OANYOF:
			cs = &m->g->sets[OPND(s)];
			if (sp == stop || !CHIN(cs, *sp++))
				return(NULL);
			break;
		case OBOL:
			if ( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOL:
			if ( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) )
				{ /* yes */ }
			else
				return(NULL);
			break;
I 5
		case OBOW:
			if (( (sp == m->beginp && !(m->eflags&REG_NOTBOL)) ||
					(sp < m->endp && *(sp-1) == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
					(sp > m->beginp &&
D 7
							!isalnum(*(sp-1))) ) &&
					(sp < m->endp && isalnum(*sp)) )
E 7
I 7
							!ISWORD(*(sp-1))) ) &&
					(sp < m->endp && ISWORD(*sp)) )
E 7
				{ /* yes */ }
			else
				return(NULL);
			break;
		case OEOW:
			if (( (sp == m->endp && !(m->eflags&REG_NOTEOL)) ||
					(sp < m->endp && *sp == '\n' &&
						(m->g->cflags&REG_NEWLINE)) ||
D 7
					(sp < m->endp && !isalnum(*sp)) ) &&
					(sp > m->beginp && isalnum(*(sp-1))) )
E 7
I 7
					(sp < m->endp && !ISWORD(*sp)) ) &&
					(sp > m->beginp && ISWORD(*(sp-1))) )
E 7
				{ /* yes */ }
			else
				return(NULL);
			break;
E 5
		case O_QUEST:
			break;
		case OOR1:	/* matches null but needs to skip */
			ss++;
			s = m->g->strip[ss];
			do {
				assert(OP(s) == OOR2);
				ss += OPND(s);
			} while (OP(s = m->g->strip[ss]) != O_CH);
			/* note that the ss++ gets us past the O_CH */
			break;
		default:	/* have to make a choice */
			hard = 1;
			break;
		}
	if (!hard) {		/* that was it! */
		if (sp != stop)
			return(NULL);
		return(sp);
	}
	ss--;			/* adjust for the for's final increment */

	/* the hard stuff */
D 3
	DO("hard", sp, stop, ss, stopst);
E 3
I 3
	AT("hard", sp, stop, ss, stopst);
E 3
	s = m->g->strip[ss];
	switch (OP(s)) {
	case OBACK_:		/* the vilest depths */
		i = OPND(s);
I 8
		assert(0 < i && i <= m->g->nsub);
E 8
		if (m->pmatch[i].rm_eo == -1)
			return(NULL);
		assert(m->pmatch[i].rm_so != -1);
		len = m->pmatch[i].rm_eo - m->pmatch[i].rm_so;
		assert(stop - m->beginp >= len);
		if (sp > stop - len)
			return(NULL);	/* not enough left to match */
		ssp = m->offp + m->pmatch[i].rm_so;
D 5
		if (strncmp((char *)sp, (char *)ssp, len) != 0)
E 5
I 5
		if (memcmp(sp, ssp, len) != 0)
E 5
			return(NULL);
		while (m->g->strip[ss] != SOP(O_BACK, i))
			ss++;
		return(backref(m, sp+len, stop, ss+1, stopst, lev));
		break;
	case OQUEST_:		/* to null or not */
		dp = backref(m, sp, stop, ss+1, stopst, lev);
		if (dp != NULL)
			return(dp);	/* not */
		return(backref(m, sp, stop, ss+OPND(s)+1, stopst, lev));
		break;
	case OPLUS_:
		assert(m->lastpos != NULL);
		assert(lev+1 <= m->g->nplus);
		m->lastpos[lev+1] = sp;
		return(backref(m, sp, stop, ss+1, stopst, lev+1));
		break;
	case O_PLUS:
		if (sp == m->lastpos[lev])	/* last pass matched null */
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
		/* try another pass */
		m->lastpos[lev] = sp;
		dp = backref(m, sp, stop, ss-OPND(s)+1, stopst, lev);
		if (dp == NULL)
			return(backref(m, sp, stop, ss+1, stopst, lev-1));
		else
			return(dp);
		break;
	case OCH_:		/* find the right one, if any */
		ssub = ss + 1;
		esub = ss + OPND(s) - 1;
		assert(OP(m->g->strip[esub]) == OOR1);
		for (;;) {	/* find first matching branch */
			dp = backref(m, sp, stop, ssub, esub, lev);
			if (dp != NULL)
				return(dp);
			/* that one missed, try next one */
			if (OP(m->g->strip[esub]) == O_CH)
				return(NULL);	/* there is none */
			esub++;
			assert(OP(m->g->strip[esub]) == OOR2);
			ssub = esub + 1;
			esub += OPND(m->g->strip[esub]);
			if (OP(m->g->strip[esub]) == OOR2)
				esub--;
			else
				assert(OP(m->g->strip[esub]) == O_CH);
		}
		break;
	case OLPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
I 8
		assert(0 < i && i <= m->g->nsub);
E 8
		offsave = m->pmatch[i].rm_so;
		m->pmatch[i].rm_so = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_so = offsave;
		return(NULL);
		break;
	case ORPAREN:		/* must undo assignment if rest fails */
		i = OPND(s);
I 8
		assert(0 < i && i <= m->g->nsub);
E 8
		offsave = m->pmatch[i].rm_eo;
		m->pmatch[i].rm_eo = sp - m->offp;
		dp = backref(m, sp, stop, ss+1, stopst, lev);
		if (dp != NULL)
			return(dp);
		m->pmatch[i].rm_eo = offsave;
		return(NULL);
		break;
	default:		/* uh oh */
D 5
		assert(0);
E 5
I 5
		assert(nope);
E 5
		break;
	}

	/* "can't happen" */
D 5
	assert(0);
E 5
I 5
	assert(nope);
E 5
	/* NOTREACHED */
}

/*
 - fast - step through the string at top speed
I 5
 == static char *fast(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
E 5
I 3
D 4
 == static uchar *fast(register struct match *m, uchar *start, \
 ==	uchar *stop, sopno startst, sopno stopst);
E 4
E 3
 */
D 5
static uchar *			/* where tentative match ended, or NULL */
E 5
I 5
static char *			/* where tentative match ended, or NULL */
E 5
fast(m, start, stop, startst, stopst)
register struct match *m;
D 5
uchar *start;
uchar *stop;
E 5
I 5
char *start;
char *stop;
E 5
sopno startst;
sopno stopst;
{
	register states st = m->st;
	register states fresh = m->fresh;
	register states tmp = m->tmp;
D 5
	register uchar *p = start;
D 3
	register uchar c;
E 3
I 3
	register uchar c = (start == m->beginp) ? '\0' : *(start-1);
E 3
	register uchar lastc;	/* previous c */
	register int atbol;
	register int ateol;
	register uchar *coldp;	/* last p after which no match was underway */
E 5
I 5
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *coldp;	/* last p after which no match was underway */
E 5

	CLEAR(st);
	SET1(st, startst);
D 5
	st = expand(m->g, startst, stopst, st, 0, 0);
E 5
I 5
	st = step(m->g, startst, stopst, st, NOTHING, st);
E 5
	ASSIGN(fresh, st);
	SP("start", st, *p);
D 3
	c = '\0';
E 3
	coldp = NULL;
	for (;;) {
		/* next character */
		lastc = c;
D 5
		c = (p == m->endp) ? '\0' : *p;
E 5
I 5
		c = (p == m->endp) ? OUT : *p;
E 5
		if (EQ(st, fresh))
			coldp = p;

		/* is there an EOL and/or BOL between lastc and c? */
D 5
		atbol = ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == '\0' && !(m->eflags&REG_NOTBOL)) );
		ateol = ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == '\0' && !(m->eflags&REG_NOTEOL)) );
		if (atbol || ateol) {
			st = expand(m->g, startst, stopst, st, atbol, ateol);
			SP("bef", st, c);
E 5
I 5
		flagch = '\0';
		i = 0;
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
E 5
		}
I 5
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst, st, flagch, st);
			SP("boleol", st, c);
		}
E 5

I 5
		/* how about a word boundary? */
D 7
		if ( (flagch == BOL || (lastc != OUT && !isalnum(lastc))) &&
					(c != OUT && isalnum(c)) ) {
E 7
I 7
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
E 7
			flagch = BOW;
		}
D 7
		if ( (lastc != OUT && isalnum(lastc)) &&
				(flagch == EOL || (c != OUT && !isalnum(c))) ) {
E 7
I 7
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
E 7
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("boweow", st, c);
		}

E 5
		/* are we done? */
		if (ISSET(st, stopst) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, fresh);
I 5
		assert(c != OUT);
E 5
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("aft", st, c);
D 5
		assert(EQ(expand(m->g, startst, stopst, st, 0, 0), st));
E 5
I 5
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
E 5
		p++;
	}

	assert(coldp != NULL);
	m->coldp = coldp;
	if (ISSET(st, stopst))
		return(p+1);
	else
		return(NULL);
}

/*
 - slow - step through the string more deliberately
I 5
 == static char *slow(register struct match *m, char *start, \
 ==	char *stop, sopno startst, sopno stopst);
E 5
I 3
D 4
 == static uchar *slow(register struct match *m, uchar *start, \
 ==	uchar *stop, sopno startst, sopno stopst);
E 4
E 3
 */
D 5
static uchar *			/* where it ended */
E 5
I 5
static char *			/* where it ended */
E 5
slow(m, start, stop, startst, stopst)
register struct match *m;
D 5
uchar *start;
uchar *stop;
E 5
I 5
char *start;
char *stop;
E 5
sopno startst;
sopno stopst;
{
	register states st = m->st;
	register states empty = m->empty;
	register states tmp = m->tmp;
D 5
	register uchar *p = start;
	register uchar c = (start == m->beginp) ? '\0' : *(start-1);
	register uchar lastc;	/* previous c */
	register int atbol;
	register int ateol;
	register uchar *matchp;	/* last p at which a match ended */
E 5
I 5
	register char *p = start;
	register int c = (start == m->beginp) ? OUT : *(start-1);
	register int lastc;	/* previous c */
	register int flagch;
	register int i;
	register char *matchp;	/* last p at which a match ended */
E 5

D 3
	DO("slow", start, stop, startst, stopst);
E 3
I 3
	AT("slow", start, stop, startst, stopst);
E 3
	CLEAR(st);
	SET1(st, startst);
	SP("sstart", st, *p);
I 5
	st = step(m->g, startst, stopst, st, NOTHING, st);
E 5
	matchp = NULL;
	for (;;) {
		/* next character */
		lastc = c;
D 5
		c = (p == m->endp) ? '\0' : *p;
E 5
I 5
		c = (p == m->endp) ? OUT : *p;
E 5

		/* is there an EOL and/or BOL between lastc and c? */
D 5
		atbol = ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == '\0' && !(m->eflags&REG_NOTBOL)) );
		ateol = ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == '\0' && !(m->eflags&REG_NOTEOL)) );
E 5
I 5
		flagch = '\0';
		i = 0;
		if ( (lastc == '\n' && m->g->cflags&REG_NEWLINE) ||
				(lastc == OUT && !(m->eflags&REG_NOTBOL)) ) {
			flagch = BOL;
			i = m->g->nbol;
		}
		if ( (c == '\n' && m->g->cflags&REG_NEWLINE) ||
				(c == OUT && !(m->eflags&REG_NOTEOL)) ) {
			flagch = (flagch == BOL) ? BOLEOL : EOL;
			i += m->g->neol;
		}
		if (i != 0) {
			for (; i > 0; i--)
				st = step(m->g, startst, stopst, st, flagch, st);
			SP("sboleol", st, c);
		}
E 5

D 5
		/* do we need an expansion before looking at the char? */
		if (p == start || atbol || ateol) {
			st = expand(m->g, startst, stopst, st, atbol, ateol);
			SP("sbef", st, c);
E 5
I 5
		/* how about a word boundary? */
D 7
		if ( (flagch == BOL || (lastc != OUT && !isalnum(lastc))) &&
					(c != OUT && isalnum(c)) ) {
E 7
I 7
		if ( (flagch == BOL || (lastc != OUT && !ISWORD(lastc))) &&
					(c != OUT && ISWORD(c)) ) {
E 7
			flagch = BOW;
E 5
		}
I 5
D 7
		if ( (lastc != OUT && isalnum(lastc)) &&
				(flagch == EOL || (c != OUT && !isalnum(c))) ) {
E 7
I 7
		if ( (lastc != OUT && ISWORD(lastc)) &&
				(flagch == EOL || (c != OUT && !ISWORD(c))) ) {
E 7
			flagch = EOW;
		}
		if (flagch == BOW || flagch == EOW) {
			st = step(m->g, startst, stopst, st, flagch, st);
			SP("sboweow", st, c);
		}
E 5

		/* are we done? */
		if (ISSET(st, stopst))
			matchp = p;
		if (EQ(st, empty) || p == stop)
			break;		/* NOTE BREAK OUT */

		/* no, we must deal with this character */
		ASSIGN(tmp, st);
		ASSIGN(st, empty);
I 5
		assert(c != OUT);
E 5
		st = step(m->g, startst, stopst, tmp, c, st);
		SP("saft", st, c);
D 5
		assert(EQ(expand(m->g, startst, stopst, st, 0, 0), st));
E 5
I 5
		assert(EQ(step(m->g, startst, stopst, st, NOTHING, st), st));
E 5
		p++;
	}

	return(matchp);
}


/*
D 5
 - expand - return set of states reachable from an initial set
I 3
D 4
 == static states expand(register struct re_guts *g, int start, \
 ==	int stop, register states st, int atbol, int ateol);
E 4
E 3
 */
static states
expand(g, start, stop, st, atbol, ateol)
register struct re_guts *g;
int start;			/* start state within strip */
int stop;			/* state after stop state within strip */
register states st;
int atbol;			/* at start or just after \n? (for BOL) */
int ateol;			/* just before \n or \0? (for EOL) */
{
	register sop s;
	register sopno pc;
	register onestate here;		/* note, macros know this name */
	register sopno look;
	register int i;

	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
		s = g->strip[pc];
		switch (OP(s)) {
		case OEND:
			assert(pc == stop-1);
			break;
		case OCHAR:		/* can't get past this */
			break;
		case OBOL:
			if (atbol)
				FWD(st, st, 1);
			break;
		case OEOL:
			if (ateol)
				FWD(st, st, 1);
			break;
		case OANY:		/* can't get past this either */
			break;
		case OANYOF:		/* or this */
			break;
		case OBACK_:		/* not significant here */
		case O_BACK:
			FWD(st, st, 1);
			break;
		case OPLUS_:		/* forward, this is just an empty */
			FWD(st, st, 1);
			break;
		case O_PLUS:		/* both forward and back */
			FWD(st, st, 1);
			i = ISSETBACK(st, OPND(s));
			BACK(st, st, OPND(s));
			if (!i && ISSETBACK(st, OPND(s))) {
				/* oho, must reconsider loop body */
				pc -= OPND(s) + 1;
				INIT(here, pc);
			}
			break;
		case OQUEST_:		/* two branches, both forward */
			FWD(st, st, 1);
			FWD(st, st, OPND(s));
			break;
		case O_QUEST:		/* just an empty */
			FWD(st, st, 1);
			break;
		case OLPAREN:		/* not significant here */
		case ORPAREN:
			FWD(st, st, 1);
			break;
		case OCH_:		/* mark the first two branches */
			FWD(st, st, 1);
			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
			FWD(st, st, OPND(s));
			break;
		case OOR1:		/* done a branch, find the O_CH */
			if (ISSTATEIN(st, here)) {
				for (look = 1;
						OP(s = g->strip[pc+look]) != O_CH;
						look += OPND(s))
					assert(OP(s) == OOR2);
				FWD(st, st, look);
			}
			break;
		case OOR2:		/* propagate OCH_'s marking onward */
			FWD(st, st, 1);
			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
				FWD(st, st, OPND(s));
			}
			break;
		case O_CH:		/* just an empty */
			FWD(st, st, 1);
			break;
		default:		/* ooooops... */
			assert(0);
			break;
		}
	}

	return(st);
}

/*
E 5
 - step - map set of states reachable before char to set reachable after
I 5
D 8
 == static states step(register struct re_guts *g, int start, int stop, \
E 8
I 8
 == static states step(register struct re_guts *g, sopno start, sopno stop, \
E 8
 ==	register states bef, int ch, register states aft);
 == #define	BOL	(OUT+1)
 == #define	EOL	(BOL+1)
 == #define	BOLEOL	(BOL+2)
 == #define	NOTHING	(BOL+3)
 == #define	BOW	(BOL+4)
 == #define	EOW	(BOL+5)
 == #define	CODEMAX	(BOL+5)		// highest code used
 == #define	NONCHAR(c)	((c) > CHAR_MAX)
 == #define	NNONCHAR	(CODEMAX-CHAR_MAX)
E 5
I 3
D 4
 == static states step(register struct re_guts *g, int start, int stop, \
 ==	register states bef, uchar ch, register states aft);
E 4
E 3
 */
static states
step(g, start, stop, bef, ch, aft)
register struct re_guts *g;
D 8
int start;			/* start state within strip */
int stop;			/* state after stop state within strip */
E 8
I 8
sopno start;			/* start state within strip */
sopno stop;			/* state after stop state within strip */
E 8
register states bef;		/* states reachable before */
D 4
uchar ch;
E 4
I 4
D 5
u_int ch;
E 5
I 5
int ch;				/* character or NONCHAR code */
E 5
E 4
register states aft;		/* states already known reachable after */
{
	register cset *cs;
	register sop s;
	register sopno pc;
	register onestate here;		/* note, macros know this name */
	register sopno look;
	register int i;

	for (pc = start, INIT(here, pc); pc != stop; pc++, INC(here)) {
		s = g->strip[pc];
		switch (OP(s)) {
		case OEND:
			assert(pc == stop-1);
			break;
		case OCHAR:
D 5
			if (ch == OPND(s))
E 5
I 5
			/* only characters can match */
			assert(!NONCHAR(ch) || ch != (char)OPND(s));
			if (ch == (char)OPND(s))
E 5
				FWD(aft, bef, 1);
			break;
D 5
		case OBOL:	/* these are looked after by expand() */
E 5
I 5
		case OBOL:
			if (ch == BOL || ch == BOLEOL)
				FWD(aft, bef, 1);
			break;
E 5
		case OEOL:
I 5
			if (ch == EOL || ch == BOLEOL)
				FWD(aft, bef, 1);
E 5
			break;
I 5
		case OBOW:
			if (ch == BOW)
				FWD(aft, bef, 1);
			break;
		case OEOW:
			if (ch == EOW)
				FWD(aft, bef, 1);
			break;
E 5
		case OANY:
D 5
			FWD(aft, bef, 1);
E 5
I 5
			if (!NONCHAR(ch))
				FWD(aft, bef, 1);
E 5
			break;
		case OANYOF:
			cs = &g->sets[OPND(s)];
D 5
			if (CHIN(cs, ch))
E 5
I 5
			if (!NONCHAR(ch) && CHIN(cs, ch))
E 5
				FWD(aft, bef, 1);
			break;
		case OBACK_:		/* ignored here */
		case O_BACK:
			FWD(aft, aft, 1);
			break;
		case OPLUS_:		/* forward, this is just an empty */
			FWD(aft, aft, 1);
			break;
		case O_PLUS:		/* both forward and back */
			FWD(aft, aft, 1);
			i = ISSETBACK(aft, OPND(s));
			BACK(aft, aft, OPND(s));
			if (!i && ISSETBACK(aft, OPND(s))) {
				/* oho, must reconsider loop body */
				pc -= OPND(s) + 1;
				INIT(here, pc);
			}
			break;
		case OQUEST_:		/* two branches, both forward */
			FWD(aft, aft, 1);
			FWD(aft, aft, OPND(s));
			break;
		case O_QUEST:		/* just an empty */
			FWD(aft, aft, 1);
			break;
		case OLPAREN:		/* not significant here */
		case ORPAREN:
			FWD(aft, aft, 1);
			break;
		case OCH_:		/* mark the first two branches */
			FWD(aft, aft, 1);
			assert(OP(g->strip[pc+OPND(s)]) == OOR2);
			FWD(aft, aft, OPND(s));
			break;
		case OOR1:		/* done a branch, find the O_CH */
			if (ISSTATEIN(aft, here)) {
				for (look = 1;
						OP(s = g->strip[pc+look]) != O_CH;
						look += OPND(s))
					assert(OP(s) == OOR2);
				FWD(aft, aft, look);
			}
			break;
		case OOR2:		/* propagate OCH_'s marking */
			FWD(aft, aft, 1);
			if (OP(g->strip[pc+OPND(s)]) != O_CH) {
				assert(OP(g->strip[pc+OPND(s)]) == OOR2);
				FWD(aft, aft, OPND(s));
			}
			break;
		case O_CH:		/* just empty */
			FWD(aft, aft, 1);
			break;
		default:		/* ooooops... */
D 5
			assert(0);
E 5
I 5
			assert(nope);
E 5
			break;
		}
	}

	return(aft);
}

D 3
#ifndef NDEBUG
E 3
I 3
#ifdef REDEBUG
E 3
/*
 - print - print a set of states
I 5
 == #ifdef REDEBUG
 == static void print(struct match *m, char *caption, states st, \
 ==	int ch, FILE *d);
 == #endif
E 5
I 3
D 4
 == #ifdef REDEBUG
 == static void print(struct match *m, char *caption, states st, \
 ==	uchar ch, FILE *d);
 == #endif
E 4
E 3
 */
static void
D 3
print(g, caption, st, ch, d)
struct re_guts *g;
E 3
I 3
print(m, caption, st, ch, d)
struct match *m;
E 3
char *caption;
states st;
D 4
uchar ch;
E 4
I 4
D 5
u_int ch;
E 5
I 5
int ch;
E 5
E 4
FILE *d;
{
I 3
	register struct re_guts *g = m->g;
E 3
	register int i;
	register int first = 1;

I 3
	if (!(m->eflags&REG_TRACE))
		return;

E 3
	fprintf(d, "%s", caption);
	if (ch != '\0')
D 3
		fprintf(d, " %s", regchar(ch));
E 3
I 3
		fprintf(d, " %s", pchar(ch));
E 3
	for (i = 0; i < g->nstates; i++)
		if (ISSET(st, i)) {
			fprintf(d, "%s%d", (first) ? "\t" : ", ", i);
			first = 0;
		}
	fprintf(d, "\n");
}
I 3

/* 
 - at - print current situation
I 5
 == #ifdef REDEBUG
 == static void at(struct match *m, char *title, char *start, char *stop, \
D 8
 ==						sopno startst, stopno stopst);
E 8
I 8
 ==						sopno startst, sopno stopst);
E 8
 == #endif
E 5
D 4
 == #ifdef REDEBUG
 == static void at(struct match *m, char *title, uchar *start, uchar *stop, \
 ==						sopno startst, stopno stopst);
 == #endif
E 4
 */
static void
at(m, title, start, stop, startst, stopst)
struct match *m;
char *title;
D 5
uchar *start;
uchar *stop;
E 5
I 5
char *start;
char *stop;
E 5
sopno startst;
sopno stopst;
{
	if (!(m->eflags&REG_TRACE))
		return;

	printf("%s %s-", title, pchar(*start));
	printf("%s ", pchar(*stop));
	printf("%ld-%ld\n", (long)startst, (long)stopst);
}

#ifndef PCHARDONE
#define	PCHARDONE	/* never again */
/*
 - pchar - make a character printable
I 5
 == #ifdef REDEBUG
 == static char *pchar(int ch);
 == #endif
E 5
D 4
 == #ifdef REDEBUG
 == static char *pchar(int ch);
 == #endif
E 4
 *
 * Is this identical to regchar() over in debug.c?  Well, yes.  But a
 * duplicate here avoids having a debugging-capable regexec.o tied to
 * a matching debug.o, and this is convenient.  It all disappears in
 * the non-debug compilation anyway, so it doesn't matter much.
 */
static char *			/* -> representation */
pchar(ch)
int ch;
{
	static char pbuf[10];

	if (isprint(ch) || ch == ' ')
		sprintf(pbuf, "%c", ch);
	else
		sprintf(pbuf, "\\%o", ch);
	return(pbuf);
}
E 3
#endif
I 3
#endif
E 3

#undef	matcher
#undef	fast
#undef	slow
#undef	dissect
#undef	backref
D 5
#undef	expand
E 5
#undef	step
#undef	print
I 3
#undef	at
E 3
#undef	match
E 1
