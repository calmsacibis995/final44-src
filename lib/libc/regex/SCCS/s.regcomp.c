h48201
s 00001/00001/01671
d D 8.5 94/03/20 14:35:05 bostic 12 11
c delete UofT; requested change from Henry Spencer <henry@zoo.toronto.edu>
e
s 00040/00040/01632
d D 8.4 94/03/19 08:21:57 bostic 11 10
c make prototypes __P style
e
s 00024/00007/01648
d D 8.3 94/03/18 06:46:08 bostic 10 9
c upgrade to alpha3.4
c fixes a?b matching ab matches b, not ab
c From: Henry Spencer <henry@zoo.toronto.edu>
e
s 00084/00057/01571
d D 8.2 94/03/16 12:42:57 bostic 9 8
c alpha3.3
e
s 00002/00002/01626
d D 8.1 93/06/04 12:57:58 bostic 8 7
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00001/01627
d D 5.7 93/05/30 12:06:34 bostic 7 6
c protect against systems that use negative numbers for CHAR_MIN
e
s 00407/00232/01221
d D 5.6 93/05/21 16:06:51 bostic 6 5
c Henry Spencer's Alpha 3.0 regex release
e
s 00002/00000/01451
d D 5.5 92/10/23 15:08:43 bostic 5 4
c patch for leading '-' in ranges (sed fix from Henry)
e
s 00002/00002/01449
d D 5.4 92/10/01 10:17:45 bostic 4 3
c from Henry Spencer; fix for "\\$" pattern in BRE's
e
s 00049/00059/01402
d D 5.3 92/09/30 14:30:45 bostic 3 2
c convert to 4BSD style prototypes, includes
e
s 00071/00068/01390
d D 5.2 92/09/30 12:58:04 bostic 2 1
c alpha2.1 release from Henry Spencer
e
s 01458/00000/00000
d D 5.1 92/08/06 11:58:05 bostic 1 0
c date and time created 92/08/06 11:58:05 by bostic
e
u
U
t
T
I 1
/*-
D 9
 * Copyright (c) 1992 Henry Spencer.
D 8
 * Copyright (c) 1992 The Regents of the University of California.
 * All rights reserved.
E 8
I 8
 * Copyright (c) 1992, 1993
E 9
I 9
 * Copyright (c) 1992, 1993, 1994 Henry Spencer.
 * Copyright (c) 1992, 1993, 1994
E 9
 *	The Regents of the University of California.  All rights reserved.
E 8
 *
 * This code is derived from software contributed to Berkeley by
D 12
 * Henry Spencer of the University of Toronto.
E 12
I 12
 * Henry Spencer.
E 12
 *
 * %sccs.include.redist.c%
 *
 *	%W% (Berkeley) %G%
 */

#if defined(LIBC_SCCS) && !defined(lint)
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* LIBC_SCCS and not lint */

#include <sys/types.h>
D 2

E 2
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <limits.h>
#include <stdlib.h>
D 2
#include <assert.h>
E 2
#include <regex.h>

#include "utils.h"
#include "regex2.h"

#include "cclass.h"
#include "cname.h"

D 2
static uchar nuls[10];		/* place to point scanner in event of error */

E 2
/*
 * parse structure, passed up and down to avoid global variables and
 * other clumsinesses
 */
struct parse {
D 6
	uchar *next;		/* next character in RE */
E 6
I 6
	char *next;		/* next character in RE */
	char *end;		/* end of string (-> NUL normally) */
E 6
	int error;		/* has an error been seen? */
	sop *strip;		/* malloced strip */
	sopno ssize;		/* malloced strip size (allocated) */
	sopno slen;		/* malloced strip length (used) */
	int ncsalloc;		/* number of csets allocated */
	struct re_guts *g;
#	define	NPAREN	10	/* we need to remember () 1-9 for back refs */
	sopno pbegin[NPAREN];	/* -> ( ([0] unused) */
	sopno pend[NPAREN];	/* -> ) ([0] unused) */
};

I 9
/* ========= begin header generated by ./mkh ========= */
#ifdef __cplusplus
extern "C" {
#endif
E 9
D 2
STATIC void	 doemit __P((struct parse *, sop, size_t));
STATIC void	 dofwd __P((struct parse *, sopno, sop));
STATIC void	 doinsert __P((struct parse *, sop, size_t, sopno));
STATIC sopno	 dupl __P((struct parse *, sopno, sopno));
STATIC void	 enlarge __P((struct parse *, sopno));
STATIC void	 mcadd __P((struct parse *, cset *, uchar *));
STATIC uchar	*mcfind __P((cset *, uchar *));
STATIC int	 mcin __P((struct parse *, cset *, uchar *));
STATIC void	 mcinvert __P((struct parse *, cset *));
STATIC void	 mcsub __P((struct parse *, cset *, uchar *));
STATIC int	 seterr __P((struct parse *, int));
E 2
I 2
D 3
#include "regcomp.ih"
E 2

E 3
I 2
D 6
static uchar nuls[10];		/* place to point scanner in event of error */
E 6

I 6
D 9
static void p_ere(/*register struct parse *p, int stop*/);
static void p_ere_exp(/*register struct parse *p*/);
static void p_str(/*register struct parse *p*/);
static void p_bre(/*register struct parse *p, register int end1, register int end2*/);
static int p_simp_re(/*register struct parse *p, int starordinary*/);
static int p_count(/*register struct parse *p*/);
static void p_bracket(/*register struct parse *p*/);
static void p_b_term(/*register struct parse *p, register cset *cs*/);
static void p_b_cclass(/*register struct parse *p, register cset *cs*/);
static void p_b_eclass(/*register struct parse *p, register cset *cs*/);
static char p_b_symbol(/*register struct parse *p*/);
static char p_b_coll_elem(/*register struct parse *p, int endc*/);
static char othercase(/*int ch*/);
static void bothcases(/*register struct parse *p, int ch*/);
static void ordinary(/*register struct parse *p, register int ch*/);
static void nonnewline(/*register struct parse *p*/);
static void repeat(/*register struct parse *p, sopno start, int from, int to*/);
static int seterr(/*register struct parse *p, int e*/);
static cset *allocset(/*register struct parse *p*/);
static void freeset(/*register struct parse *p, register cset *cs*/);
static int freezeset(/*register struct parse *p, register cset *cs*/);
static int firstch(/*register struct parse *p, register cset *cs*/);
static int nch(/*register struct parse *p, register cset *cs*/);
static void mcadd(/*register struct parse *p, register cset *cs, register char *cp*/);
static void mcsub(/*register cset *cs, register char *cp*/);
static int mcin(/*register cset *cs, register char *cp*/);
static char *mcfind(/*register cset *cs, register char *cp*/);
static void mcinvert(/*register cset *cs*/);
static void mccase(/*register cset *cs*/);
static int isinsets(/*register struct re_guts *g, int c*/);
static int samesets(/*register struct re_guts *g, int c1, int c2*/);
static void categorize(/*struct parse *p, register struct re_guts *g*/);
static sopno dupl(/*register struct parse *p, sopno start, sopno finish*/);
static void doemit(/*register struct parse *p, sop op, size_t opnd*/);
static void doinsert(/*register struct parse *p, sop op, size_t opnd, sopno pos*/);
static void dofwd(/*register struct parse *p, sopno pos, sop value*/);
static void enlarge(/*register struct parse *p, sopno size*/);
static void stripsnug(/*register struct parse *p, register struct re_guts *g*/);
static void findmust(/*register struct parse *p, register struct re_guts *g*/);
static sopno pluscount(/*register struct parse *p, register struct re_guts *g*/);
E 9
I 9
/* === regcomp.c === */
D 11
static void p_ere(register struct parse *p, int stop);
static void p_ere_exp(register struct parse *p);
static void p_str(register struct parse *p);
static void p_bre(register struct parse *p, register int end1, register int end2);
static int p_simp_re(register struct parse *p, int starordinary);
static int p_count(register struct parse *p);
static void p_bracket(register struct parse *p);
static void p_b_term(register struct parse *p, register cset *cs);
static void p_b_cclass(register struct parse *p, register cset *cs);
static void p_b_eclass(register struct parse *p, register cset *cs);
static char p_b_symbol(register struct parse *p);
static char p_b_coll_elem(register struct parse *p, int endc);
static char othercase(int ch);
static void bothcases(register struct parse *p, int ch);
static void ordinary(register struct parse *p, register int ch);
static void nonnewline(register struct parse *p);
static void repeat(register struct parse *p, sopno start, int from, int to);
static int seterr(register struct parse *p, int e);
static cset *allocset(register struct parse *p);
static void freeset(register struct parse *p, register cset *cs);
static int freezeset(register struct parse *p, register cset *cs);
static int firstch(register struct parse *p, register cset *cs);
static int nch(register struct parse *p, register cset *cs);
static void mcadd(register struct parse *p, register cset *cs, register char *cp);
static void mcsub(register cset *cs, register char *cp);
static int mcin(register cset *cs, register char *cp);
static char *mcfind(register cset *cs, register char *cp);
static void mcinvert(register struct parse *p, register cset *cs);
static void mccase(register struct parse *p, register cset *cs);
static int isinsets(register struct re_guts *g, int c);
static int samesets(register struct re_guts *g, int c1, int c2);
static void categorize(struct parse *p, register struct re_guts *g);
static sopno dupl(register struct parse *p, sopno start, sopno finish);
static void doemit(register struct parse *p, sop op, size_t opnd);
static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);
static void dofwd(register struct parse *p, sopno pos, sop value);
static void enlarge(register struct parse *p, sopno size);
static void stripsnug(register struct parse *p, register struct re_guts *g);
static void findmust(register struct parse *p, register struct re_guts *g);
static sopno pluscount(register struct parse *p, register struct re_guts *g);
E 11
I 11
static void p_ere __P((struct parse *p, int stop));
static void p_ere_exp __P((struct parse *p));
static void p_str __P((struct parse *p));
static void p_bre __P((struct parse *p, int end1, int end2));
static int p_simp_re __P((struct parse *p, int starordinary));
static int p_count __P((struct parse *p));
static void p_bracket __P((struct parse *p));
static void p_b_term __P((struct parse *p, cset *cs));
static void p_b_cclass __P((struct parse *p, cset *cs));
static void p_b_eclass __P((struct parse *p, cset *cs));
static char p_b_symbol __P((struct parse *p));
static char p_b_coll_elem __P((struct parse *p, int endc));
static char othercase __P((int ch));
static void bothcases __P((struct parse *p, int ch));
static void ordinary __P((struct parse *p, int ch));
static void nonnewline __P((struct parse *p));
static void repeat __P((struct parse *p, sopno start, int from, int to));
static int seterr __P((struct parse *p, int e));
static cset *allocset __P((struct parse *p));
static void freeset __P((struct parse *p, cset *cs));
static int freezeset __P((struct parse *p, cset *cs));
static int firstch __P((struct parse *p, cset *cs));
static int nch __P((struct parse *p, cset *cs));
static void mcadd __P((struct parse *p, cset *cs, char *cp));
static void mcsub __P((cset *cs, char *cp));
static int mcin __P((cset *cs, char *cp));
static char *mcfind __P((cset *cs, char *cp));
static void mcinvert __P((struct parse *p, cset *cs));
static void mccase __P((struct parse *p, cset *cs));
static int isinsets __P((struct re_guts *g, int c));
static int samesets __P((struct re_guts *g, int c1, int c2));
static void categorize __P((struct parse *p, struct re_guts *g));
static sopno dupl __P((struct parse *p, sopno start, sopno finish));
static void doemit __P((struct parse *p, sop op, size_t opnd));
static void doinsert __P((struct parse *p, sop op, size_t opnd, sopno pos));
static void dofwd __P((struct parse *p, sopno pos, sop value));
static void enlarge __P((struct parse *p, sopno size));
static void stripsnug __P((struct parse *p, struct re_guts *g));
static void findmust __P((struct parse *p, struct re_guts *g));
static sopno pluscount __P((struct parse *p, struct re_guts *g));
E 11
E 9

I 9
#ifdef __cplusplus
}
#endif
/* ========= end header generated by ./mkh ========= */

E 9
static char nuls[10];		/* place to point scanner in event of error */

E 6
E 2
/*
 * macros for use with parse structure
 * BEWARE:  these know that the parse structure is named `p' !!!
 */
D 6
#define	PEEK()	((uchar)*p->next)
#define	PEEK2()	((uchar)*(p->next+1))
#define	SEE(c)	(PEEK() == (c))
#define	SEETWO(a, b)	(PEEK() == (a) && PEEK2() == (b))
E 6
I 6
#define	PEEK()	(*p->next)
#define	PEEK2()	(*(p->next+1))
#define	MORE()	(p->next < p->end)
#define	MORE2()	(p->next+1 < p->end)
#define	SEE(c)	(MORE() && PEEK() == (c))
#define	SEETWO(a, b)	(MORE() && MORE2() && PEEK() == (a) && PEEK2() == (b))
E 6
#define	EAT(c)	((SEE(c)) ? (NEXT(), 1) : 0)
#define	EATTWO(a, b)	((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
#define	NEXT()	(p->next++)
#define	NEXT2()	(p->next += 2)
#define	NEXTn(n)	(p->next += (n))
D 6
#define	GETNEXT()	((uchar)*p->next++)
E 6
I 6
#define	GETNEXT()	(*p->next++)
E 6
#define	SETERROR(e)	seterr(p, (e))
#define	REQUIRE(co, e)	((co) || SETERROR(e))
D 6
#define	MUSTSEE(c, e)	(REQUIRE(PEEK() == (c), e))
#define	MUSTEAT(c, e)	(REQUIRE(GETNEXT() == (c), e))
#define	MUSTNOTSEE(c, e)	(REQUIRE(PEEK() != (c), e))
E 6
I 6
#define	MUSTSEE(c, e)	(REQUIRE(MORE() && PEEK() == (c), e))
#define	MUSTEAT(c, e)	(REQUIRE(MORE() && GETNEXT() == (c), e))
#define	MUSTNOTSEE(c, e)	(REQUIRE(!MORE() || PEEK() != (c), e))
E 6
D 9
#define	EMIT(sop, sopnd)	doemit(p, sop, (size_t)(sopnd))
#define	INSERT(sop, pos)	doinsert(p, sop, HERE()-(pos)+1, pos)
E 9
I 9
#define	EMIT(op, sopnd)	doemit(p, (sop)(op), (size_t)(sopnd))
#define	INSERT(op, pos)	doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
E 9
D 6
#define	FWD(pos)		dofwd(p, pos, HERE()-(pos))
#define	BACK(sop, pos)		EMIT(sop, HERE()-pos)
E 6
I 6
#define	AHEAD(pos)		dofwd(p, pos, HERE()-(pos))
#define	ASTERN(sop, pos)	EMIT(sop, HERE()-pos)
E 6
#define	HERE()		(p->slen)
#define	THERE()		(p->slen - 1)
I 10
#define	THERETHERE()	(p->slen - 2)
E 10
#define	DROP(n)	(p->slen -= (n))

I 3
D 6
static cset	*allocset __P((struct parse *));
static void	 bothcases __P((struct parse *, u_int));
static void	 categorize __P((struct parse *, struct re_guts *));
static void	 doemit __P((struct parse *, sop, size_t));
static void	 dofwd __P((struct parse *, sopno, sop));
static void	 doinsert __P((struct parse *, sop, size_t, sopno));
static sopno	 dupl __P((struct parse *, sopno, sopno));
static void	 enlarge __P((struct parse *, sopno));
static void	 findmust __P((struct parse *, struct re_guts *));
static int	 freezeset __P((struct parse *, cset *));
static int	 isinsets __P((struct re_guts *, u_int));
static void	 mcadd __P((struct parse *, cset *, uchar *));
static uchar	*mcfind __P((cset *, u_int *));
static int	 mcin __P((struct parse *, cset *, u_int *));
static void	 mcinvert __P((struct parse *, cset *));
static void	 mcsub __P((struct parse *, cset *, u_int *));
static void	 nonnewline __P((struct parse *));
static void	 ordinary __P((struct parse *, u_int));
static uchar	 othercase __P((u_int));
static void	 p_b_cclass __P((struct parse *, cset *));
static uchar	 p_b_coll_elem __P((struct parse *, u_int));
static void	 p_b_eclass __P((struct parse *, cset *));
static uchar	 p_b_symbol __P((struct parse *));
static void	 p_b_term __P((struct parse *, cset *));
static void	 p_bracket __P((struct parse *));
static void	 p_bre  __P((struct parse *, u_int, u_int));
static int	 p_count __P((struct parse *));
static void	 p_ere  __P((struct parse *, u_int));
static void	 p_ere_exp  __P((struct parse *));
static int	 p_simp_re __P((struct parse *, int));
static sopno	 pluscount __P((struct parse *, struct re_guts *));
static void	 repeat __P((struct parse *, sopno, int, int));
static int	 samesets __P((struct re_guts *, u_int, u_int));
static int	 seterr __P((struct parse *, int));
static void	 stripsnug __P((struct parse *, struct re_guts *));
E 6
I 6
#ifndef NDEBUG
static int never = 0;		/* for use in asserts; shuts lint up */
I 9
#else
#define	never	0		/* some <assert.h>s have bugs too */
E 9
#endif
E 6

E 3
/*
 - regcomp - interface for parser and compilation
I 6
D 9
 = extern int regcomp(regex_t *preg, const char *pattern, int cflags);
E 9
I 9
 = extern int regcomp(regex_t *, const char *, int);
E 9
 = #define	REG_BASIC	0000
 = #define	REG_EXTENDED	0001
 = #define	REG_ICASE	0002
 = #define	REG_NOSUB	0004
 = #define	REG_NEWLINE	0010
 = #define	REG_NOSPEC	0020
 = #define	REG_PEND	0040
 = #define	REG_DUMP	0200
E 6
I 2
D 3
 = extern int regcomp(regex_t *preg, const char *pattern, int cflags);
 = #define	REG_EXTENDED	001
 = #define	REG_ICASE	002
 = #define	REG_NOSUB	004
 = #define	REG_NEWLINE	010
E 3
E 2
 */
int				/* 0 success, otherwise REG_something */
regcomp(preg, pattern, cflags)
regex_t *preg;
const char *pattern;
int cflags;
{
	struct parse pa;
	register struct re_guts *g;
	register struct parse *p = &pa;
D 2
	sopno nstates;
E 2
	register int i;
I 6
	register size_t len;
I 9
#ifdef REDEBUG
#	define	GOODFLAGS(f)	(f)
#else
#	define	GOODFLAGS(f)	((f)&~REG_DUMP)
#endif
E 9
E 6
D 2
	STATIC void p_ere();
	STATIC void p_bre();
	STATIC void stripsnug();
	STATIC void categorize();
	STATIC void findmust();
	STATIC sopno pluscount();
E 2

I 9
	cflags = GOODFLAGS(cflags);
E 9
I 6
	if ((cflags&REG_EXTENDED) && (cflags&REG_NOSPEC))
		return(REG_INVARG);

	if (cflags&REG_PEND) {
		if (preg->re_endp < pattern)
			return(REG_INVARG);
		len = preg->re_endp - pattern;
	} else
		len = strlen((char *)pattern);

E 6
	/* do the mallocs early so failure handling is easy */
D 6
	/* the +NUC here is for the category table */
	g = (struct re_guts *)malloc(sizeof(struct re_guts) + NUC);
E 6
I 6
	g = (struct re_guts *)malloc(sizeof(struct re_guts) +
							(NC-1)*sizeof(cat_t));
E 6
	if (g == NULL)
		return(REG_ESPACE);
D 6
	p->ssize = strlen(pattern)/2*3 + 1;
E 6
I 6
	p->ssize = len/(size_t)2*(size_t)3 + (size_t)1;	/* ugh */
E 6
	p->strip = (sop *)malloc(p->ssize * sizeof(sop));
	p->slen = 0;
	if (p->strip == NULL) {
		free((char *)g);
		return(REG_ESPACE);
	}

	/* set things up */
	p->g = g;
D 6
	p->next = (uchar *)pattern;
E 6
I 6
	p->next = (char *)pattern;	/* convenience; we do not modify it */
	p->end = p->next + len;
E 6
	p->error = 0;
	p->ncsalloc = 0;
	for (i = 0; i < NPAREN; i++) {
		p->pbegin[i] = 0;
		p->pend[i] = 0;
	}
D 6
	g->csetsize = NUC;
E 6
I 6
	g->csetsize = NC;
E 6
	g->sets = NULL;
	g->setbits = NULL;
	g->ncsets = 0;
	g->cflags = cflags;
	g->iflags = 0;
I 6
	g->nbol = 0;
	g->neol = 0;
E 6
	g->must = NULL;
	g->mlen = 0;
	g->nsub = 0;
	g->ncategories = 1;	/* category 0 is "everything else" */
D 6
	g->categories = (uchar *)g + sizeof(struct re_guts);
	(void) memset((char *)g->categories, 0, NUC);
E 6
I 6
D 7
	g->categories = &g->catspace[-CHAR_MIN];
E 7
I 7
	g->categories = &g->catspace[-(CHAR_MIN)];
E 7
	(void) memset((char *)g->catspace, 0, NC*sizeof(cat_t));
E 6
	g->backrefs = 0;
D 6
	g->nplus = 0;
E 6

	/* do it */
	EMIT(OEND, 0);
	g->firststate = THERE();
	if (cflags&REG_EXTENDED)
D 6
		p_ere(p, '\0');
E 6
I 6
		p_ere(p, OUT);
	else if (cflags&REG_NOSPEC)
		p_str(p);
E 6
	else
D 6
		p_bre(p, '\0', '\0');
E 6
I 6
		p_bre(p, OUT, OUT);
E 6
	EMIT(OEND, 0);
	g->laststate = THERE();

	/* tidy up loose ends and fill things in */
	categorize(p, g);
	stripsnug(p, g);
	findmust(p, g);
	g->nplus = pluscount(p, g);
	g->magic = MAGIC2;
	preg->re_nsub = g->nsub;
	preg->re_g = g;
	preg->re_magic = MAGIC1;
D 2
#ifdef NDEBUG
E 2
I 2
#ifndef REDEBUG
E 2
	/* not debugging, so can't rely on the assert() in regexec() */
	if (g->iflags&BAD)
		SETERROR(REG_ASSERT);
#endif

	/* win or lose, we're done */
	if (p->error != 0)	/* lose */
		regfree(preg);
	return(p->error);
}

/*
 - p_ere - ERE parser top level, concatenation and alternation
I 6
 == static void p_ere(register struct parse *p, int stop);
E 6
I 2
D 3
 == static void p_ere(register struct parse *p, uchar stop);
E 3
E 2
 */
static void
p_ere(p, stop)
register struct parse *p;
D 3
uchar stop;			/* character this ERE should end at */
E 3
I 3
D 6
u_int stop;			/* character this ERE should end at */
E 6
I 6
int stop;			/* character this ERE should end at */
E 6
E 3
{
D 2
	STATIC void p_ere_exp();
E 2
D 6
	register uchar c;
E 6
I 6
	register char c;
E 6
	register sopno prevback;
	register sopno prevfwd;
	register sopno conc;
	register int first = 1;		/* is this the first alternative? */

	for (;;) {
		/* do a bunch of concatenated expressions */
		conc = HERE();
D 6
		while ((c = PEEK()) != '|' && c != stop && c != '\0')
E 6
I 6
		while (MORE() && (c = PEEK()) != '|' && c != stop)
E 6
			p_ere_exp(p);
		REQUIRE(HERE() != conc, REG_EMPTY);	/* require nonempty */

		if (!EAT('|'))
			break;		/* NOTE BREAK OUT */

		if (first) {
			INSERT(OCH_, conc);	/* offset is wrong */
			prevfwd = conc;
			prevback = conc;
			first = 0;
		}
D 6
		BACK(OOR1, prevback);
E 6
I 6
		ASTERN(OOR1, prevback);
E 6
		prevback = THERE();
D 6
		FWD(prevfwd);			/* fix previous offset */
E 6
I 6
		AHEAD(prevfwd);			/* fix previous offset */
E 6
		prevfwd = HERE();
		EMIT(OOR2, 0);			/* offset is very wrong */
	}

	if (!first) {		/* tail-end fixups */
D 6
		FWD(prevfwd);
		BACK(O_CH, prevback);
E 6
I 6
		AHEAD(prevfwd);
		ASTERN(O_CH, prevback);
E 6
	}

D 6
	assert(SEE(stop) || SEE('\0'));
E 6
I 6
	assert(!MORE() || SEE(stop));
E 6
}

/*
 - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op
I 6
 == static void p_ere_exp(register struct parse *p);
E 6
I 2
D 3
 == static void p_ere_exp(register struct parse *p);
E 3
E 2
 */
static void
p_ere_exp(p)
register struct parse *p;
{
D 2
	STATIC int p_count();
	STATIC void p_bracket();
	STATIC void ordinary();
	STATIC void nonnewline();
	STATIC void repeat();
E 2
D 6
	register uchar c;
E 6
I 6
	register char c;
E 6
	register sopno pos;
D 2
	register sopno sub;
E 2
	register int count;
	register int count2;
	register sopno subno;
	int wascaret = 0;
D 6
	/* we call { a repetition if followed by a digit */
#	define	ISRPT(c1, c2)	(c1 == '*' || c1 == '+' || c1 == '?' || \
						(c1 == '{' && isdigit(c2)))
E 6

I 6
	assert(MORE());		/* caller should have ensured this */
E 6
	c = GETNEXT();
D 6
	assert(c != '\0');	/* caller should have ensured this */
E 6

	pos = HERE();
	switch (c) {
	case '(':
D 6
		MUSTNOTSEE('\0', REG_EPAREN);
E 6
I 6
		REQUIRE(MORE(), REG_EPAREN);
E 6
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
		if (!SEE(')'))
			p_ere(p, ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		MUSTEAT(')', REG_EPAREN);
		break;
#ifndef POSIX_MISTAKE
	case ')':		/* happens only if no current unmatched ( */
		/*
		 * You may ask, why the ifndef?  Because I didn't notice
		 * this until slightly too late for 1003.2, and none of the
		 * other 1003.2 regular-expression reviewers noticed it at
		 * all.  So an unmatched ) is legal POSIX, at least until
		 * we can get it fixed.
		 */
		SETERROR(REG_EPAREN);
		break;
#endif
	case '^':
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
I 6
		p->g->nbol++;
E 6
		wascaret = 1;
		break;
	case '$':
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
I 6
		p->g->neol++;
E 6
		break;
	case '|':
		SETERROR(REG_EMPTY);
		break;
	case '*':
	case '+':
	case '?':
		SETERROR(REG_BADRPT);
		break;
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
	case '\\':
I 6
		REQUIRE(MORE(), REG_EESCAPE);
E 6
		c = GETNEXT();
I 2
D 6
#ifdef xxx
E 2
		if (c == '^' || c == '.' || c == '[' || c == '$' ||
				c == '(' || c == ')' || c == '|' ||
				c == '*' || c == '+' || c == '?' ||
				c == '{' || c == '\\')
I 2
#else
		if (c != '\0')
#endif
E 2
			ordinary(p, c);
		else
			SETERROR(REG_EESCAPE);
E 6
I 6
		ordinary(p, c);
E 6
		break;
	case '{':		/* okay as ordinary except if digit follows */
D 6
		REQUIRE(!isdigit(PEEK()), REG_BADRPT);
E 6
I 6
		REQUIRE(!MORE() || !isdigit(PEEK()), REG_BADRPT);
E 6
		/* FALLTHROUGH */
	default:
		ordinary(p, c);
		break;
	}

I 6
	if (!MORE())
		return;
E 6
	c = PEEK();
D 6
	if (!ISRPT(c, PEEK2()))
E 6
I 6
	/* we call { a repetition if followed by a digit */
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit(PEEK2())) ))
E 6
		return;		/* no repetition, we're done */
	NEXT();

	REQUIRE(!wascaret, REG_BADRPT);
	switch (c) {
	case '*':	/* implemented as +? */
I 10
		/* this case does not require the (y|) trick, noKLUDGE */
E 10
		INSERT(OPLUS_, pos);
D 6
		BACK(O_PLUS, pos);
E 6
I 6
		ASTERN(O_PLUS, pos);
E 6
		INSERT(OQUEST_, pos);
D 6
		BACK(O_QUEST, pos);
E 6
I 6
		ASTERN(O_QUEST, pos);
E 6
		break;
	case '+':
		INSERT(OPLUS_, pos);
D 6
		BACK(O_PLUS, pos);
E 6
I 6
		ASTERN(O_PLUS, pos);
E 6
		break;
	case '?':
D 10
		INSERT(OQUEST_, pos);
D 6
		BACK(O_QUEST, pos);
E 6
I 6
		ASTERN(O_QUEST, pos);
E 10
I 10
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, pos);		/* offset slightly wrong */
		ASTERN(OOR1, pos);		/* this one's right */
		AHEAD(pos);			/* fix the OCH_ */
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
E 10
E 6
		break;
	case '{':
		count = p_count(p);
		if (EAT(',')) {
			if (isdigit(PEEK())) {
				count2 = p_count(p);
				REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EAT('}')) {	/* error heuristics */
D 6
			while ((c = PEEK()) != '\0' && c != '}')
E 6
I 6
			while (MORE() && PEEK() != '}')
E 6
				NEXT();
D 6
			if (c == '\0')
				SETERROR(REG_EBRACE);
			else
				SETERROR(REG_BADBR);
E 6
I 6
			REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
E 6
		}
		break;
	}

I 6
	if (!MORE())
		return;
E 6
	c = PEEK();
D 6
	REQUIRE(!ISRPT(c, PEEK2()), REG_BADRPT);
E 6
I 6
	if (!( c == '*' || c == '+' || c == '?' ||
				(c == '{' && MORE2() && isdigit(PEEK2())) ) )
		return;
	SETERROR(REG_BADRPT);
E 6
}

/*
I 6
 - p_str - string (no metacharacters) "parser"
 == static void p_str(register struct parse *p);
 */
static void
p_str(p)
register struct parse *p;
{
	REQUIRE(MORE(), REG_EMPTY);
	while (MORE())
		ordinary(p, GETNEXT());
}

/*
E 6
 - p_bre - BRE parser top level, anchoring and concatenation
D 2
 *
E 2
I 2
D 3
 == static void p_bre(register struct parse *p, register uchar end1, \
 ==	register uchar end2);
E 3
E 2
D 6
 * Giving end1 as '\0' essentially eliminates the end1/end2 check.
E 6
I 6
 == static void p_bre(register struct parse *p, register int end1, \
 ==	register int end2);
 * Giving end1 as OUT essentially eliminates the end1/end2 check.
E 6
I 2
 *
 * This implementation is a bit of a kludge, in that a trailing $ is first
 * taken as an ordinary character and then revised to be an anchor.  The
 * only undesirable side effect is that '$' gets included as a character
 * category in such cases.  This is fairly harmless; not worth fixing.
D 6
 * The amount of lookahead needed to avoid this kludge is excessive,
 * especially since things like "$*" appear to be legal. xxx
E 6
I 6
 * The amount of lookahead needed to avoid this kludge is excessive.
E 6
E 2
 */
static void
p_bre(p, end1, end2)
register struct parse *p;
D 3
register uchar end1;		/* first terminating character */
register uchar end2;		/* second terminating character */
E 3
I 3
D 6
register u_int end1;		/* first terminating character */
register u_int end2;		/* second terminating character */
E 6
I 6
register int end1;		/* first terminating character */
register int end2;		/* second terminating character */
E 6
E 3
{
D 2
	STATIC int p_simp_re();
E 2
	register sopno start = HERE();
	register int first = 1;			/* first subexpression? */
D 2
	register int wasdollar;
E 2
I 2
	register int wasdollar = 0;
E 2

	if (EAT('^')) {
		EMIT(OBOL, 0);
		p->g->iflags |= USEBOL;
I 6
		p->g->nbol++;
E 6
	}
D 6
	while (!SEE('\0') && !SEETWO(end1, end2)) {
E 6
I 6
	while (MORE() && !SEETWO(end1, end2)) {
E 6
		wasdollar = p_simp_re(p, first);
		first = 0;
	}
	if (wasdollar) {	/* oops, that was a trailing anchor */
		DROP(1);
		EMIT(OEOL, 0);
		p->g->iflags |= USEEOL;
I 6
		p->g->neol++;
E 6
	}

	REQUIRE(HERE() != start, REG_EMPTY);	/* require nonempty */
}

/*
 - p_simp_re - parse a simple RE, an atom possibly followed by a repetition
I 6
 == static int p_simp_re(register struct parse *p, int starordinary);
E 6
I 2
D 3
 == static int p_simp_re(register struct parse *p, int starordinary);
E 3
E 2
 */
static int			/* was the simple RE an unbackslashed $? */
p_simp_re(p, starordinary)
register struct parse *p;
int starordinary;		/* is a leading * an ordinary character? */
{
D 2
	STATIC int p_count();
	STATIC void p_bracket();
	STATIC void ordinary();
	STATIC void nonnewline();
	STATIC void repeat();
E 2
	register int c;
	register int count;
	register int count2;
	register sopno pos;
D 2
	register sopno sub;
E 2
	register int i;
	register sopno subno;
#	define	BACKSL	(1<<CHAR_BIT)

	pos = HERE();		/* repetion op, if any, covers from here */

I 6
	assert(MORE());		/* caller should have ensured this */
E 6
	c = GETNEXT();
D 6
	assert(c != '\0');	/* caller should have ensured this */
	if (c == '\\')
		c = BACKSL | PEEK();
E 6
I 6
	if (c == '\\') {
		REQUIRE(MORE(), REG_EESCAPE);
		c = BACKSL | (unsigned char)GETNEXT();
	}
E 6
	switch (c) {
	case '.':
		if (p->g->cflags&REG_NEWLINE)
			nonnewline(p);
		else
			EMIT(OANY, 0);
		break;
	case '[':
		p_bracket(p);
		break;
D 2
	case BACKSL|'^':
	case BACKSL|'.':
	case BACKSL|'*':
	case BACKSL|'[':
	case BACKSL|'$':
	case BACKSL|'\\':
		ordinary(p, c&~BACKSL);
		NEXT();
		break;
E 2
	case BACKSL|'{':
		SETERROR(REG_BADRPT);
		break;
	case BACKSL|'(':
D 6
		NEXT();
E 6
		p->g->nsub++;
		subno = p->g->nsub;
		if (subno < NPAREN)
			p->pbegin[subno] = HERE();
		EMIT(OLPAREN, subno);
D 6
		/* the SEE here is an error heuristic */
		if (!SEE('\0') && !SEETWO('\\', ')'))
E 6
I 6
		/* the MORE here is an error heuristic */
		if (MORE() && !SEETWO('\\', ')'))
E 6
			p_bre(p, '\\', ')');
		if (subno < NPAREN) {
			p->pend[subno] = HERE();
			assert(p->pend[subno] != 0);
		}
		EMIT(ORPAREN, subno);
		REQUIRE(EATTWO('\\', ')'), REG_EPAREN);
		break;
	case BACKSL|')':	/* should not get here -- must be user */
	case BACKSL|'}':
		SETERROR(REG_EPAREN);
		break;
	case BACKSL|'1':
	case BACKSL|'2':
	case BACKSL|'3':
	case BACKSL|'4':
	case BACKSL|'5':
	case BACKSL|'6':
	case BACKSL|'7':
	case BACKSL|'8':
	case BACKSL|'9':
		i = (c&~BACKSL) - '0';
		assert(i < NPAREN);
		if (p->pend[i] != 0) {
			assert(i <= p->g->nsub);
			EMIT(OBACK_, i);
			assert(p->pbegin[i] != 0);
			assert(OP(p->strip[p->pbegin[i]]) == OLPAREN);
			assert(OP(p->strip[p->pend[i]]) == ORPAREN);
			(void) dupl(p, p->pbegin[i]+1, p->pend[i]);
			EMIT(O_BACK, i);
		} else
			SETERROR(REG_ESUBREG);
		p->g->backrefs = 1;
D 6
		NEXT();
E 6
		break;
I 2
D 6
	case BACKSL|'\0':
		SETERROR(REG_EESCAPE);
		break;
E 6
E 2
	case '*':
		REQUIRE(starordinary, REG_BADRPT);
		/* FALLTHROUGH */
	default:
D 2
		if (c & BACKSL) {
			SETERROR(REG_EESCAPE);
			c &= ~BACKSL;
		}
E 2
I 2
D 6
		if (c & BACKSL)
D 4
			c = GETNEXT();
E 2
		ordinary(p, (uchar)c);
E 4
I 4
			NEXT();
		ordinary(p, (uchar)(c &~ BACKSL));
E 6
I 6
		ordinary(p, c &~ BACKSL);
E 6
E 4
		break;
	}

	if (EAT('*')) {		/* implemented as +? */
I 10
		/* this case does not require the (y|) trick, noKLUDGE */
E 10
		INSERT(OPLUS_, pos);
D 6
		BACK(O_PLUS, pos);
E 6
I 6
		ASTERN(O_PLUS, pos);
E 6
		INSERT(OQUEST_, pos);
D 6
		BACK(O_QUEST, pos);
E 6
I 6
		ASTERN(O_QUEST, pos);
E 6
	} else if (EATTWO('\\', '{')) {
		count = p_count(p);
		if (EAT(',')) {
D 6
			if (isdigit(PEEK())) {
E 6
I 6
			if (MORE() && isdigit(PEEK())) {
E 6
				count2 = p_count(p);
				REQUIRE(count <= count2, REG_BADBR);
			} else		/* single number with comma */
				count2 = INFINITY;
		} else		/* just a single number */
			count2 = count;
		repeat(p, pos, count, count2);
		if (!EATTWO('\\', '}')) {	/* error heuristics */
D 6
			while (!SEE('\0') && !SEETWO('\\', '}'))
E 6
I 6
			while (MORE() && !SEETWO('\\', '}'))
E 6
				NEXT();
D 6
			if (SEE('\0'))
				SETERROR(REG_EBRACE);
			else
				SETERROR(REG_BADBR);
E 6
I 6
			REQUIRE(MORE(), REG_EBRACE);
			SETERROR(REG_BADBR);
E 6
		}
D 6
	} else if (c == '$')	/* unbackslashed $ not followed by reptn */
E 6
I 6
	} else if (c == (unsigned char)'$')	/* $ (but not \$) ends it */
E 6
		return(1);

	return(0);
}

/*
 - p_count - parse a repetition count
I 6
 == static int p_count(register struct parse *p);
E 6
I 2
D 3
 == static int p_count(register struct parse *p);
E 3
E 2
 */
static int			/* the value */
p_count(p)
register struct parse *p;
{
	register int count = 0;
	register int ndigits = 0;

D 6
	while (isdigit(PEEK()) && count <= DUPMAX) {
E 6
I 6
	while (MORE() && isdigit(PEEK()) && count <= DUPMAX) {
E 6
		count = count*10 + (GETNEXT() - '0');
		ndigits++;
	}

	REQUIRE(ndigits > 0 && count <= DUPMAX, REG_BADBR);
	return(count);
}

/*
 - p_bracket - parse a bracketed character list
I 6
 == static void p_bracket(register struct parse *p);
E 6
I 2
D 3
 == static void p_bracket(register struct parse *p);
E 3
E 2
 *
 * Note a significant property of this code:  if the allocset() did SETERROR,
 * no set operations are done.
 */
static void
p_bracket(p)
register struct parse *p;
{
D 2
	STATIC void p_b_term();
	STATIC cset *allocset();
	STATIC int freezeset();
E 2
D 6
	register uchar c;
E 6
I 6
	register char c;
E 6
	register cset *cs = allocset(p);
	register int invert = 0;

I 6
	/* Dept of Truly Sickening Special-Case Kludges */
	if (p->next + 5 < p->end && strncmp(p->next, "[:<:]]", 6) == 0) {
		EMIT(OBOW, 0);
		NEXTn(6);
		return;
	}
	if (p->next + 5 < p->end && strncmp(p->next, "[:>:]]", 6) == 0) {
		EMIT(OEOW, 0);
		NEXTn(6);
		return;
	}

E 6
	if (EAT('^'))
		invert++;	/* make note to invert set at end */
	if (EAT(']'))
		CHadd(cs, ']');
I 5
	else if (EAT('-'))
		CHadd(cs, '-');
E 5
D 6
	while ((c = PEEK()) != '\0' && c != ']' && !SEETWO('-', ']'))
E 6
I 6
	while (MORE() && PEEK() != ']' && !SEETWO('-', ']'))
E 6
		p_b_term(p, cs);
	if (EAT('-'))
		CHadd(cs, '-');
	MUSTEAT(']', REG_EBRACK);

D 6
	if (invert && p->error == 0) {
E 6
I 6
	if (p->error != 0)	/* don't mess things up further */
		return;

	if (p->g->cflags&REG_ICASE) {
E 6
		register int i;
I 6
		register int ci;
E 6

		for (i = p->g->csetsize - 1; i >= 0; i--)
I 6
			if (CHIN(cs, i) && isalpha(i)) {
				ci = othercase(i);
				if (ci != i)
					CHadd(cs, ci);
			}
		if (cs->multis != NULL)
			mccase(p, cs);
	}
	if (invert) {
		register int i;

		for (i = p->g->csetsize - 1; i >= 0; i--)
E 6
			if (CHIN(cs, i))
				CHsub(cs, i);
			else
				CHadd(cs, i);
		if (p->g->cflags&REG_NEWLINE)
			CHsub(cs, '\n');
		if (cs->multis != NULL)
			mcinvert(p, cs);
	}
I 6

E 6
	assert(cs->multis == NULL);		/* xxx */
D 6
	EMIT(OANYOF, freezeset(p, cs));
E 6
I 6

	if (nch(p, cs) == 1) {		/* optimize singleton sets */
		ordinary(p, firstch(p, cs));
		freeset(p, cs);
	} else
		EMIT(OANYOF, freezeset(p, cs));
E 6
}

/*
 - p_b_term - parse one term of a bracketed character list
I 6
 == static void p_b_term(register struct parse *p, register cset *cs);
E 6
I 2
D 3
 == static void p_b_term(register struct parse *p, register cset *cs);
E 3
E 2
 */
static void
p_b_term(p, cs)
register struct parse *p;
register cset *cs;
{
D 2
	STATIC uchar p_b_symbol();
	STATIC void p_b_cclass();
	STATIC void p_b_eclass();
	STATIC uchar othercase();
E 2
D 6
	register uchar c;
	register uchar start, finish;
E 6
I 6
	register char c;
	register char start, finish;
E 6
	register int i;

	/* classify what we've got */
D 6
	switch (PEEK()) {
E 6
I 6
	switch ((MORE()) ? PEEK() : '\0') {
E 6
	case '[':
D 6
		c = PEEK2();
E 6
I 6
		c = (MORE2()) ? PEEK2() : '\0';
E 6
		break;
	case '-':
		SETERROR(REG_ERANGE);
		return;			/* NOTE RETURN */
		break;
	default:
		c = '\0';
		break;
	}

	switch (c) {
	case ':':		/* character class */
		NEXT2();
I 6
		REQUIRE(MORE(), REG_EBRACK);
E 6
		c = PEEK();
D 6
		REQUIRE(c != '\0', REG_EBRACK);
E 6
		REQUIRE(c != '-' && c != ']', REG_ECTYPE);
		p_b_cclass(p, cs);
D 6
		MUSTNOTSEE('\0', REG_EBRACK);
E 6
I 6
		REQUIRE(MORE(), REG_EBRACK);
E 6
		REQUIRE(EATTWO(':', ']'), REG_ECTYPE);
		break;
	case '=':		/* equivalence class */
		NEXT2();
I 6
		REQUIRE(MORE(), REG_EBRACK);
E 6
		c = PEEK();
D 6
		REQUIRE(c != '\0', REG_EBRACK);
E 6
		REQUIRE(c != '-' && c != ']', REG_ECOLLATE);
		p_b_eclass(p, cs);
D 6
		MUSTNOTSEE('\0', REG_EBRACK);
E 6
I 6
		REQUIRE(MORE(), REG_EBRACK);
E 6
		REQUIRE(EATTWO('=', ']'), REG_ECOLLATE);
		break;
	default:		/* symbol, ordinary character, or range */
/* xxx revision needed for multichar stuff */
		start = p_b_symbol(p);
D 6
		if (PEEK() == '-' && (c = PEEK2()) != ']' && c != '\0') {
E 6
I 6
		if (SEE('-') && MORE2() && PEEK2() != ']') {
E 6
			/* range */
			NEXT();
			if (EAT('-'))
				finish = '-';
			else
				finish = p_b_symbol(p);
		} else
			finish = start;
I 6
/* xxx what about signed chars here... */
E 6
		REQUIRE(start <= finish, REG_ERANGE);
D 6
		for (i = start; i <= finish; i++) {
E 6
I 6
		for (i = start; i <= finish; i++)
E 6
			CHadd(cs, i);
D 6
			if ((p->g->cflags&REG_ICASE) && isalpha(i)) {
				c = othercase((uchar)i);
				CHadd(cs, c);
			}
		}
E 6
		break;
	}
}

/*
 - p_b_cclass - parse a character-class name and deal with it
I 6
 == static void p_b_cclass(register struct parse *p, register cset *cs);
E 6
I 2
D 3
 == static void p_b_cclass(register struct parse *p, register cset *cs);
E 3
E 2
 */
static void
p_b_cclass(p, cs)
register struct parse *p;
register cset *cs;
{
D 6
	register uchar *sb = p->next;
	register uchar *se = sb;
E 6
I 6
	register char *sp = p->next;
E 6
	register struct cclass *cp;
D 6
	register int len;
	register uchar *u;
	register uchar c;
E 6
I 6
	register size_t len;
	register char *u;
	register char c;
E 6

D 6
	while (isalpha(*se))
		se++;
	len = se - sb;
	NEXTn(len);
E 6
I 6
	while (MORE() && isalpha(PEEK()))
		NEXT();
	len = p->next - sp;
E 6
	for (cp = cclasses; cp->name != NULL; cp++)
D 6
		if (strncmp(cp->name, (char *)sb, len) == 0 &&
D 2
		    cp->name[len] == '\0')
E 2
I 2
							cp->name[len] == '\0')
E 6
I 6
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
E 6
E 2
			break;
	if (cp->name == NULL) {
		/* oops, didn't find it */
		SETERROR(REG_ECTYPE);
		return;
	}

D 6
	u = (uchar *)cp->chars;
E 6
I 6
	u = cp->chars;
E 6
	while ((c = *u++) != '\0')
		CHadd(cs, c);
D 6
	for (u = (uchar *)cp->multis; *u != '\0'; u += strlen((char *)u) + 1)
E 6
I 6
	for (u = cp->multis; *u != '\0'; u += strlen(u) + 1)
E 6
D 9
		MCadd(cs, u);
E 9
I 9
		MCadd(p, cs, u);
E 9
}

/*
 - p_b_eclass - parse an equivalence-class name and deal with it
I 6
 == static void p_b_eclass(register struct parse *p, register cset *cs);
E 6
I 2
D 3
 == static void p_b_eclass(register struct parse *p, register cset *cs);
E 3
E 2
 *
 * This implementation is incomplete. xxx
 */
static void
p_b_eclass(p, cs)
register struct parse *p;
register cset *cs;
{
D 6
	register uchar c;
E 6
I 6
	register char c;
E 6
D 2
	STATIC uchar p_b_coll_elem();
E 2

	c = p_b_coll_elem(p, '=');
	CHadd(cs, c);
}

/*
 - p_b_symbol - parse a character or [..]ed multicharacter collating symbol
I 6
 == static char p_b_symbol(register struct parse *p);
E 6
I 2
D 3
 == static uchar p_b_symbol(register struct parse *p);
E 3
E 2
 */
D 6
static uchar			/* value of symbol */
E 6
I 6
static char			/* value of symbol */
E 6
p_b_symbol(p)
register struct parse *p;
{
D 2
	STATIC uchar p_b_coll_elem();
E 2
D 6
	register uchar value;
E 6
I 6
	register char value;
E 6

D 6
	if (!EATTWO('[', '.')) {
		MUSTNOTSEE('\0', REG_EBRACK);
E 6
I 6
	REQUIRE(MORE(), REG_EBRACK);
	if (!EATTWO('[', '.'))
E 6
		return(GETNEXT());
D 6
	}
E 6

	/* collating symbol */
D 6
	MUSTNOTSEE('\0', REG_EBRACK);
E 6
	value = p_b_coll_elem(p, '.');
	REQUIRE(EATTWO('.', ']'), REG_ECOLLATE);
	return(value);
}

/*
 - p_b_coll_elem - parse a collating-element name and look it up
I 6
 == static char p_b_coll_elem(register struct parse *p, int endc);
E 6
I 2
D 3
 == static uchar p_b_coll_elem(register struct parse *p, uchar endc);
E 3
E 2
 */
D 6
static uchar			/* value of collating element */
E 6
I 6
static char			/* value of collating element */
E 6
p_b_coll_elem(p, endc)
register struct parse *p;
D 3
uchar endc;			/* name ended by endc,']' */
E 3
I 3
D 6
u_int endc;			/* name ended by endc,']' */
E 6
I 6
int endc;			/* name ended by endc,']' */
E 6
E 3
{
D 6
	register uchar *sp = p->next;
E 6
I 6
	register char *sp = p->next;
E 6
	register struct cname *cp;
	register int len;
D 6
	register uchar c;
E 6
I 6
	register char c;
E 6

D 6
	while ((c = PEEK()) != '\0' && !SEETWO(endc, ']'))
E 6
I 6
	while (MORE() && !SEETWO(endc, ']'))
E 6
		NEXT();
D 6
	if (c == '\0') {
E 6
I 6
	if (!MORE()) {
E 6
		SETERROR(REG_EBRACK);
		return(0);
	}
	len = p->next - sp;
	for (cp = cnames; cp->name != NULL; cp++)
D 6
		if (strncmp(cp->name, (char *)sp, len) == 0 &&
D 2
		    cp->name[len] == '\0')
E 2
I 2
							cp->name[len] == '\0')
E 6
I 6
		if (strncmp(cp->name, sp, len) == 0 && cp->name[len] == '\0')
E 6
E 2
			return(cp->code);	/* known name */
	if (len == 1)
		return(*sp);	/* single character */
	SETERROR(REG_ECOLLATE);			/* neither */
	return(0);
}

/*
 - othercase - return the case counterpart of an alphabetic
I 6
 == static char othercase(int ch);
E 6
I 2
D 3
 == static uchar othercase(uchar ch);
E 3
E 2
 */
D 6
static uchar
E 6
I 6
static char			/* if no counterpart, return ch */
E 6
othercase(ch)
D 3
uchar ch;
E 3
I 3
D 6
u_int ch;
E 6
I 6
int ch;
E 6
E 3
{
	assert(isalpha(ch));
	if (isupper(ch))
		return(tolower(ch));
	else if (islower(ch))
		return(toupper(ch));
	else			/* peculiar, but could happen */
		return(ch);
}

/*
D 6
 - bothcases - emit a dualcase version of a character
E 6
I 6
 - bothcases - emit a dualcase version of a two-case character
 == static void bothcases(register struct parse *p, int ch);
E 6
I 2
D 3
 == static void bothcases(register struct parse *p, uchar ch);
E 3
 *
E 2
 * Boy, is this implementation ever a kludge...
 */
static void
bothcases(p, ch)
register struct parse *p;
D 3
uchar ch;
E 3
I 3
D 6
u_int ch;
E 6
I 6
int ch;
E 6
E 3
{
D 6
	register uchar *oldnext;
	uchar bracket[3];
E 6
I 6
	register char *oldnext = p->next;
	register char *oldend = p->end;
	char bracket[3];
E 6

D 6
	oldnext = p->next;
E 6
I 6
	assert(othercase(ch) != ch);	/* p_bracket() would recurse */
E 6
	p->next = bracket;
I 6
	p->end = bracket+2;
E 6
	bracket[0] = ch;
	bracket[1] = ']';
	bracket[2] = '\0';
	p_bracket(p);
	assert(p->next == bracket+2);
	p->next = oldnext;
I 6
	p->end = oldend;
E 6
}

/*
 - ordinary - emit an ordinary character
I 6
 == static void ordinary(register struct parse *p, register int ch);
E 6
I 2
D 3
 == static void ordinary(register struct parse *p, register uchar ch);
E 3
E 2
 */
static void
ordinary(p, ch)
register struct parse *p;
D 3
register uchar ch;
E 3
I 3
D 6
register u_int ch;
E 6
I 6
register int ch;
E 6
E 3
{
D 6
	register uchar *cap = p->g->categories;
E 6
I 6
	register cat_t *cap = p->g->categories;
E 6

D 6
	if ((p->g->cflags&REG_ICASE) && isalpha(ch)) {
E 6
I 6
	if ((p->g->cflags&REG_ICASE) && isalpha(ch) && othercase(ch) != ch)
E 6
		bothcases(p, ch);
D 6
		return;
E 6
I 6
	else {
		EMIT(OCHAR, (unsigned char)ch);
		if (cap[ch] == 0)
			cap[ch] = p->g->ncategories++;
E 6
	}
D 6

	EMIT(OCHAR, ch);
	if (cap[ch] == 0)
		cap[ch] = p->g->ncategories++;
E 6
}

/*
 - nonnewline - emit REG_NEWLINE version of OANY
I 6
 == static void nonnewline(register struct parse *p);
E 6
I 2
D 3
 == static void nonnewline(register struct parse *p);
E 3
 *
E 2
 * Boy, is this implementation ever a kludge...
 */
static void
nonnewline(p)
register struct parse *p;
{
D 6
	register uchar *oldnext;
	uchar bracket[4];
E 6
I 6
	register char *oldnext = p->next;
	register char *oldend = p->end;
	char bracket[4];
E 6

D 6
	oldnext = p->next;
E 6
	p->next = bracket;
I 6
	p->end = bracket+3;
E 6
	bracket[0] = '^';
	bracket[1] = '\n';
	bracket[2] = ']';
	bracket[3] = '\0';
	p_bracket(p);
	assert(p->next == bracket+3);
	p->next = oldnext;
I 6
	p->end = oldend;
E 6
}

/*
 - repeat - generate code for a bounded repetition, recursively if needed
I 6
 == static void repeat(register struct parse *p, sopno start, int from, int to);
E 6
I 2
D 3
 == static void repeat(register struct parse *p, sopno start, int from, int to);
E 3
E 2
 */
static void
repeat(p, start, from, to)
register struct parse *p;
sopno start;			/* operand from here to end of strip */
int from;			/* repeated from this number */
int to;				/* to this number of times (maybe INFINITY) */
{
	register sopno finish = HERE();
#	define	N	2
#	define	INF	3
#	define	REP(f, t)	((f)*8 + (t))
#	define	MAP(n)	(((n) <= 1) ? (n) : ((n) == INFINITY) ? INF : N)
	register sopno copy;

	if (p->error != 0)	/* head off possible runaway recursion */
		return;

	assert(from <= to);

	switch (REP(MAP(from), MAP(to))) {
	case REP(0, 0):			/* must be user doing this */
		DROP(finish-start);	/* drop the operand */
		break;
	case REP(0, 1):			/* as x{1,1}? */
	case REP(0, N):			/* as x{1,n}? */
	case REP(0, INF):		/* as x{1,}? */
D 10
		INSERT(OQUEST_, start);		/* offset is wrong... */
E 10
I 10
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);		/* offset is wrong... */
E 10
		repeat(p, start+1, 1, to);
I 10
		ASTERN(OOR1, start);
E 10
D 6
		FWD(start);			/* ... fix it */
		BACK(O_QUEST, start);
E 6
I 6
		AHEAD(start);			/* ... fix it */
D 10
		ASTERN(O_QUEST, start);
E 10
I 10
		EMIT(OOR2, 0);
		AHEAD(THERE());
		ASTERN(O_CH, THERETHERE());
E 10
E 6
		break;
	case REP(1, 1):			/* trivial case */
		/* done */
		break;
	case REP(1, N):			/* as x?x{1,n-1} */
D 10
		INSERT(OQUEST_, start);
D 6
		BACK(O_QUEST, start);
E 6
I 6
		ASTERN(O_QUEST, start);
E 10
I 10
		/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
		INSERT(OCH_, start);
		ASTERN(OOR1, start);
		AHEAD(start);
		EMIT(OOR2, 0);			/* offset very wrong... */
		AHEAD(THERE());			/* ...so fix it */
		ASTERN(O_CH, THERETHERE());
E 10
E 6
		copy = dupl(p, start+1, finish+1);
D 10
		assert(copy == finish+2);
E 10
I 10
		assert(copy == finish+4);
E 10
		repeat(p, copy, 1, to-1);
		break;
	case REP(1, INF):		/* as x+ */
		INSERT(OPLUS_, start);
D 6
		BACK(O_PLUS, start);
E 6
I 6
		ASTERN(O_PLUS, start);
E 6
		break;
	case REP(N, N):			/* as xx{m-1,n-1} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to-1);
		break;
	case REP(N, INF):		/* as xx{n-1,INF} */
		copy = dupl(p, start, finish);
		repeat(p, copy, from-1, to);
		break;
	default:			/* "can't happen" */
		SETERROR(REG_ASSERT);	/* just in case */
		break;
	}
}

/*
 - seterr - set an error condition
I 6
 == static int seterr(register struct parse *p, int e);
E 6
I 2
D 3
 == static int seterr(register struct parse *p, int e);
E 3
E 2
 */
static int			/* useless but makes type checking happy */
seterr(p, e)
register struct parse *p;
int e;
{
	if (p->error == 0)	/* keep earliest error condition */
		p->error = e;
	p->next = nuls;		/* try to bring things to a halt */
I 6
	p->end = nuls;
E 6
	return(0);		/* make the return value well-defined */
}

/*
 - allocset - allocate a set of characters for []
I 6
 == static cset *allocset(register struct parse *p);
E 6
I 2
D 3
 == static cset *allocset(register struct parse *p);
E 3
E 2
 */
static cset *
allocset(p)
register struct parse *p;
{
	register int no = p->g->ncsets++;
	register size_t nc;
	register size_t nbytes;
	register cset *cs;
D 2
	register int i;
E 2
	register size_t css = (size_t)p->g->csetsize;
I 9
	register int i;
E 9

	if (no >= p->ncsalloc) {	/* need another column of space */
		p->ncsalloc += CHAR_BIT;
		nc = p->ncsalloc;
		assert(nc % CHAR_BIT == 0);
		nbytes = nc / CHAR_BIT * css;
		if (p->g->sets == NULL)
			p->g->sets = (cset *)malloc(nc * sizeof(cset));
		else
			p->g->sets = (cset *)realloc((char *)p->g->sets,
							nc * sizeof(cset));
		if (p->g->setbits == NULL)
D 9
			p->g->setbits = (uchar *)malloc(nbytes);
		else
			p->g->setbits = (uchar *)realloc((char *)p->g->setbits,
E 9
I 9
			p->g->setbits = (uch *)malloc(nbytes);
		else {
			p->g->setbits = (uch *)realloc((char *)p->g->setbits,
E 9
								nbytes);
I 9
			/* xxx this isn't right if setbits is now NULL */
			for (i = 0; i < no; i++)
				p->g->sets[i].ptr = p->g->setbits + css*(i/CHAR_BIT);
		}
E 9
		if (p->g->sets != NULL && p->g->setbits != NULL)
			(void) memset((char *)p->g->setbits + (nbytes - css),
								0, css);
		else {
			no = 0;
			SETERROR(REG_ESPACE);
			/* caller's responsibility not to do set ops */
		}
	}

	assert(p->g->sets != NULL);	/* xxx */
	cs = &p->g->sets[no];
	cs->ptr = p->g->setbits + css*((no)/CHAR_BIT);
	cs->mask = 1 << ((no) % CHAR_BIT);
	cs->hash = 0;
	cs->smultis = 0;
	cs->multis = NULL;

	return(cs);
}

/*
I 6
 - freeset - free a now-unused set
 == static void freeset(register struct parse *p, register cset *cs);
 */
static void
freeset(p, cs)
register struct parse *p;
register cset *cs;
{
	register int i;
	register cset *top = &p->g->sets[p->g->ncsets];
	register size_t css = (size_t)p->g->csetsize;

	for (i = 0; i < css; i++)
		CHsub(cs, i);
	if (cs == top-1)	/* recover only the easy case */
		p->g->ncsets--;
}

/*
E 6
 - freezeset - final processing on a set of characters
I 6
 == static int freezeset(register struct parse *p, register cset *cs);
E 6
I 2
D 3
 == static int freezeset(register struct parse *p, register cset *cs);
E 3
E 2
 *
 * The main task here is merging identical sets.  This is usually a waste
 * of time (although the hash code minimizes the overhead), but can win
 * big if REG_ICASE is being used.  REG_ICASE, by the way, is why the hash
 * is done using addition rather than xor -- all ASCII [aA] sets xor to
 * the same value!
 */
static int			/* set number */
freezeset(p, cs)
register struct parse *p;
register cset *cs;
{
D 9
	register uchar h = cs->hash;
E 9
I 9
	register uch h = cs->hash;
E 9
	register int i;
	register cset *top = &p->g->sets[p->g->ncsets];
D 2
	register uchar c;
E 2
	register cset *cs2;
	register size_t css = (size_t)p->g->csetsize;

	/* look for an earlier one which is the same */
	for (cs2 = &p->g->sets[0]; cs2 < top; cs2++)
		if (cs2->hash == h && cs2 != cs) {
			/* maybe */
			for (i = 0; i < css; i++)
				if (!!CHIN(cs2, i) != !!CHIN(cs, i))
					break;		/* no */
			if (i == css)
				break;			/* yes */
		}

	if (cs2 < top) {	/* found one */
D 6
		assert(cs == top-1);
		p->g->ncsets--;
		for (i = 0; i < css; i++)
			CHsub(cs, i);
E 6
I 6
		freeset(p, cs);
E 6
		cs = cs2;
	}

	return((int)(cs - p->g->sets));
}

/*
I 6
 - firstch - return first character in a set (which must have at least one)
 == static int firstch(register struct parse *p, register cset *cs);
 */
static int			/* character; there is no "none" value */
firstch(p, cs)
register struct parse *p;
register cset *cs;
{
	register int i;
	register size_t css = (size_t)p->g->csetsize;

	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
			return((char)i);
	assert(never);
	return(0);		/* arbitrary */
}

/*
 - nch - number of characters in a set
 == static int nch(register struct parse *p, register cset *cs);
 */
static int
nch(p, cs)
register struct parse *p;
register cset *cs;
{
	register int i;
	register size_t css = (size_t)p->g->csetsize;
	register int n = 0;

	for (i = 0; i < css; i++)
		if (CHIN(cs, i))
			n++;
	return(n);
}

/*
E 6
 - mcadd - add a collating element to a cset
I 6
 == static void mcadd(register struct parse *p, register cset *cs, \
 ==	register char *cp);
E 6
I 2
D 3
 == static void mcadd(register struct parse *p, register cset *cs, \
 ==	register uchar *cp);
E 3
E 2
 */
static void
mcadd(p, cs, cp)
register struct parse *p;
register cset *cs;
D 6
register uchar *cp;
E 6
I 6
register char *cp;
E 6
{
	register size_t oldend = cs->smultis;

D 6
	cs->smultis += strlen((char *)cp) + 1;
E 6
I 6
	cs->smultis += strlen(cp) + 1;
E 6
	if (cs->multis == NULL)
D 6
		cs->multis = (uchar *)malloc(cs->smultis);
E 6
I 6
		cs->multis = malloc(cs->smultis);
E 6
	else
D 6
		cs->multis = (uchar *)realloc(cs->multis, cs->smultis);
E 6
I 6
		cs->multis = realloc(cs->multis, cs->smultis);
E 6
	if (cs->multis == NULL) {
		SETERROR(REG_ESPACE);
		return;
	}

D 6
	(void) strcpy((char *)(cs->multis + oldend - 1), (char *)cp);
E 6
I 6
	(void) strcpy(cs->multis + oldend - 1, cp);
E 6
	cs->multis[cs->smultis - 1] = '\0';
}

/*
 - mcsub - subtract a collating element from a cset
I 6
 == static void mcsub(register cset *cs, register char *cp);
E 6
I 2
D 3
 == static void mcsub(register struct parse *p, register cset *cs, \
 ==	register uchar *cp);
E 3
E 2
 */
static void
D 6
mcsub(p, cs, cp)
register struct parse *p;
E 6
I 6
mcsub(cs, cp)
E 6
register cset *cs;
D 3
register uchar *cp;
E 3
I 3
D 6
register u_int *cp;
E 6
I 6
register char *cp;
E 6
E 3
{
D 6
	register uchar *fp = mcfind(cs, cp);
	register size_t len = strlen((char *)fp);
E 6
I 6
	register char *fp = mcfind(cs, cp);
	register size_t len = strlen(fp);
E 6

D 6
	assert(p != NULL);
	(void) memmove((char *)fp, (char *)(fp + len + 1),
E 6
I 6
	assert(fp != NULL);
	(void) memmove(fp, fp + len + 1,
E 6
				cs->smultis - (fp + len + 1 - cs->multis));
	cs->smultis -= len;

	if (cs->smultis == 0) {
D 6
		free((char *)cs->multis);
E 6
I 6
		free(cs->multis);
E 6
		cs->multis = NULL;
		return;
	}

D 6
	cs->multis = (uchar *)realloc(cs->multis, cs->smultis);
E 6
I 6
	cs->multis = realloc(cs->multis, cs->smultis);
E 6
	assert(cs->multis != NULL);
}

/*
 - mcin - is a collating element in a cset?
I 6
 == static int mcin(register cset *cs, register char *cp);
E 6
I 2
D 3
 == static int mcin(register struct parse *p, register cset *cs, \
 ==	register uchar *cp);
E 3
E 2
 */
static int
D 6
mcin(p, cs, cp)
register struct parse *p;
E 6
I 6
mcin(cs, cp)
E 6
register cset *cs;
D 3
register uchar *cp;
E 3
I 3
D 6
register u_int *cp;
E 6
I 6
register char *cp;
E 6
E 3
{
	return(mcfind(cs, cp) != NULL);
}

/*
 - mcfind - find a collating element in a cset
I 6
 == static char *mcfind(register cset *cs, register char *cp);
E 6
I 2
D 3
 == static uchar *mcfind(register cset *cs, register uchar *cp);
E 3
E 2
 */
D 6
static uchar *
E 6
I 6
static char *
E 6
mcfind(cs, cp)
register cset *cs;
D 3
register uchar *cp;
E 3
I 3
D 6
register u_int *cp;
E 6
I 6
register char *cp;
E 6
E 3
{
D 6
	register uchar *p;
E 6
I 6
	register char *p;
E 6

	if (cs->multis == NULL)
		return(NULL);
D 6
	for (p = cs->multis; *p != '\0'; p += strlen((char *)p) + 1)
		if (strcmp((char *)cp, (char *)p) == 0)
E 6
I 6
	for (p = cs->multis; *p != '\0'; p += strlen(p) + 1)
		if (strcmp(cp, p) == 0)
E 6
			return(p);
	return(NULL);
}

/*
 - mcinvert - invert the list of collating elements in a cset
I 6
D 9
 == static void mcinvert(register cset *cs);
E 9
I 9
 == static void mcinvert(register struct parse *p, register cset *cs);
E 9
E 6
I 2
D 3
 == static void mcinvert(register struct parse *p, register cset *cs);
E 3
E 2
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
 */
static void
D 6
mcinvert(p, cs)
register struct parse *p;
E 6
I 6
D 9
mcinvert(cs)
E 9
I 9
mcinvert(p, cs)
register struct parse *p;
E 9
E 6
register cset *cs;
{
	assert(cs->multis == NULL);	/* xxx */
}

/*
I 6
 - mccase - add case counterparts of the list of collating elements in a cset
D 9
 == static void mccase(register cset *cs);
E 9
I 9
 == static void mccase(register struct parse *p, register cset *cs);
E 9
 *
 * This would have to know the set of possibilities.  Implementation
 * is deferred.
 */
static void
D 9
mccase(cs)
E 9
I 9
mccase(p, cs)
register struct parse *p;
E 9
register cset *cs;
{
	assert(cs->multis == NULL);	/* xxx */
}

/*
E 6
 - isinsets - is this character in any sets?
I 6
 == static int isinsets(register struct re_guts *g, int c);
E 6
I 2
D 3
 == static int isinsets(register struct re_guts *g, uchar c);
E 3
E 2
 */
static int			/* predicate */
isinsets(g, c)
register struct re_guts *g;
D 3
uchar c;
E 3
I 3
D 6
u_int c;
E 6
I 6
int c;
E 6
E 3
{
D 9
	register uchar *col;
E 9
I 9
	register uch *col;
E 9
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
I 6
	register unsigned uc = (unsigned char)c;
E 6

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
D 6
		if (col[c] != 0)
E 6
I 6
		if (col[uc] != 0)
E 6
			return(1);
	return(0);
}

/*
 - samesets - are these two characters in exactly the same sets?
I 6
 == static int samesets(register struct re_guts *g, int c1, int c2);
E 6
I 2
D 3
 == static int samesets(register struct re_guts *g, uchar c1, uchar c2);
E 3
E 2
 */
static int			/* predicate */
samesets(g, c1, c2)
register struct re_guts *g;
D 3
register uchar c1;
register uchar c2;
E 3
I 3
D 6
register u_int c1;
register u_int c2;
E 6
I 6
int c1;
int c2;
E 6
E 3
{
D 9
	register uchar *col;
E 9
I 9
	register uch *col;
E 9
	register int i;
	register int ncols = (g->ncsets+(CHAR_BIT-1)) / CHAR_BIT;
I 6
	register unsigned uc1 = (unsigned char)c1;
	register unsigned uc2 = (unsigned char)c2;
E 6

	for (i = 0, col = g->setbits; i < ncols; i++, col += g->csetsize)
D 6
		if (col[c1] != col[c2])
E 6
I 6
		if (col[uc1] != col[uc2])
E 6
			return(0);
	return(1);
}

/*
 - categorize - sort out character categories
I 6
 == static void categorize(struct parse *p, register struct re_guts *g);
E 6
I 2
D 3
 == static void categorize(struct parse *p, register struct re_guts *g);
E 3
E 2
 */
static void
categorize(p, g)
struct parse *p;
register struct re_guts *g;
{
D 6
	register uchar *cats = g->categories;
	register unsigned c;
	register unsigned c2;
	register uchar cat;
E 6
I 6
	register cat_t *cats = g->categories;
	register int c;
	register int c2;
	register cat_t cat;
E 6

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

D 6
	for (c = 0; c < g->csetsize; c++)
E 6
I 6
	for (c = CHAR_MIN; c <= CHAR_MAX; c++)
E 6
		if (cats[c] == 0 && isinsets(g, c)) {
			cat = g->ncategories++;
			cats[c] = cat;
D 6
			for (c2 = c+1; c2 < g->csetsize; c2++)
E 6
I 6
			for (c2 = c+1; c2 <= CHAR_MAX; c2++)
E 6
				if (cats[c2] == 0 && samesets(g, c, c2))
					cats[c2] = cat;
		}
}

/*
 - dupl - emit a duplicate of a bunch of sops
I 6
 == static sopno dupl(register struct parse *p, sopno start, sopno finish);
E 6
I 2
D 3
 == static sopno dupl(register struct parse *p, sopno start, sopno finish);
E 3
E 2
 */
static sopno			/* start of duplicate */
dupl(p, start, finish)
register struct parse *p;
sopno start;			/* from here */
sopno finish;			/* to this less one */
{
D 2
	register int i;
E 2
	register sopno ret = HERE();
	register sopno len = finish - start;

	assert(finish >= start);
	if (len == 0)
		return(ret);
	enlarge(p, p->ssize + len);	/* this many unexpected additions */
	assert(p->ssize >= p->slen + len);
	(void) memcpy((char *)(p->strip + p->slen),
		(char *)(p->strip + start), (size_t)len*sizeof(sop));
	p->slen += len;
	return(ret);
}

/*
 - doemit - emit a strip operator
I 6
 == static void doemit(register struct parse *p, sop op, size_t opnd);
E 6
I 2
D 3
 == static void doemit(register struct parse *p, sop op, size_t opnd);
E 3
E 2
 *
 * It might seem better to implement this as a macro with a function as
 * hard-case backup, but it's just too big and messy unless there are
 * some changes to the data structures.  Maybe later.
 */
static void
doemit(p, op, opnd)
register struct parse *p;
sop op;
size_t opnd;
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/* deal with oversize operands ("can't happen", more or less) */
	assert(opnd < 1<<OPSHIFT);

	/* deal with undersized strip */
	if (p->slen >= p->ssize)
		enlarge(p, (p->ssize+1) / 2 * 3);	/* +50% */
	assert(p->slen < p->ssize);

	/* finally, it's all reduced to the easy case */
	p->strip[p->slen++] = SOP(op, opnd);
}

/*
 - doinsert - insert a sop into the strip
I 6
 == static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);
E 6
I 2
D 3
 == static void doinsert(register struct parse *p, sop op, size_t opnd, sopno pos);
E 3
E 2
 */
static void
doinsert(p, op, opnd, pos)
register struct parse *p;
sop op;
size_t opnd;
sopno pos;
{
	register sopno sn;
	register sop s;
	register int i;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	sn = HERE();
	EMIT(op, opnd);		/* do checks, ensure space */
	assert(HERE() == sn+1);
	s = p->strip[sn];

	/* adjust paren pointers */
	assert(pos > 0);
	for (i = 1; i < NPAREN; i++) {
		if (p->pbegin[i] >= pos) {
			p->pbegin[i]++;
		}
		if (p->pend[i] >= pos) {
			p->pend[i]++;
		}
	}

	memmove((char *)&p->strip[pos+1], (char *)&p->strip[pos],
						(HERE()-pos-1)*sizeof(sop));
	p->strip[pos] = s;
}

/*
 - dofwd - complete a forward reference
I 6
 == static void dofwd(register struct parse *p, sopno pos, sop value);
E 6
I 2
D 3
 == static void dofwd(register struct parse *p, sopno pos, sop value);
E 3
E 2
 */
static void
dofwd(p, pos, value)
register struct parse *p;
register sopno pos;
sop value;
{
	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	assert(value < 1<<OPSHIFT);
	p->strip[pos] = OP(p->strip[pos]) | value;
}

/*
 - enlarge - enlarge the strip
I 6
 == static void enlarge(register struct parse *p, sopno size);
E 6
I 2
D 3
 == static void enlarge(register struct parse *p, sopno size);
E 3
E 2
 */
static void
enlarge(p, size)
register struct parse *p;
register sopno size;
{
	register sop *sp;

	if (p->ssize >= size)
		return;

	sp = (sop *)realloc(p->strip, size*sizeof(sop));
	if (sp == NULL) {
		SETERROR(REG_ESPACE);
		return;
	}
	p->strip = sp;
	p->ssize = size;
}

/*
 - stripsnug - compact the strip
I 6
 == static void stripsnug(register struct parse *p, register struct re_guts *g);
E 6
I 2
D 3
 == static void stripsnug(register struct parse *p, register struct re_guts *g);
E 3
E 2
 */
static void
stripsnug(p, g)
register struct parse *p;
register struct re_guts *g;
{
	g->nstates = p->slen;
D 9
	g->strip = (sop *)realloc((sop *)p->strip, p->slen * sizeof(sop));
E 9
I 9
	g->strip = (sop *)realloc((char *)p->strip, p->slen * sizeof(sop));
E 9
	if (g->strip == NULL) {
		SETERROR(REG_ESPACE);
		g->strip = p->strip;
	}
}

/*
 - findmust - fill in must and mlen with longest mandatory literal string
I 6
 == static void findmust(register struct parse *p, register struct re_guts *g);
E 6
I 2
D 3
 == static void findmust(register struct parse *p, register struct re_guts *g);
E 3
E 2
 *
 * This algorithm could do fancy things like analyzing the operands of |
 * for common subsequences.  Someday.  This code is simple and finds most
 * of the interesting cases.
 *
 * Note that must and mlen got initialized during setup.
 */
D 2
STATIC void
E 2
I 2
static void
E 2
findmust(p, g)
struct parse *p;
register struct re_guts *g;
{
	register sop *scan;
	sop *start;
	register sop *newstart;
	register sopno newlen;
	register sop s;
	register char *cp;
	register sopno i;

	/* avoid making error situations worse */
	if (p->error != 0)
		return;

	/* find the longest OCHAR sequence in strip */
	newlen = 0;
	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OCHAR:		/* sequence member */
			if (newlen == 0)		/* new sequence */
				newstart = scan - 1;
			newlen++;
			break;
		case OPLUS_:		/* things that don't break one */
		case OLPAREN:
		case ORPAREN:
			break;
		case OQUEST_:		/* things that must be skipped */
		case OCH_:
			scan--;
			do {
				scan += OPND(s);
				s = *scan;
				/* assert() interferes w debug printouts */
				if (OP(s) != O_QUEST && OP(s) != O_CH &&
							OP(s) != OOR2) {
					g->iflags |= BAD;
					return;
				}
			} while (OP(s) != O_QUEST && OP(s) != O_CH);
			/* fallthrough */
		default:		/* things that break a sequence */
			if (newlen > g->mlen) {		/* ends one */
				start = newstart;
				g->mlen = newlen;
			}
			newlen = 0;
			break;
		}
	} while (OP(s) != OEND);

	if (g->mlen == 0)		/* there isn't one */
		return;

	/* turn it into a character string */
	g->must = malloc((size_t)g->mlen + 1);
	if (g->must == NULL) {		/* argh; just forget it */
		g->mlen = 0;
		return;
	}
	cp = g->must;
	scan = start;
	for (i = g->mlen; i > 0; i--) {
		while (OP(s = *scan++) != OCHAR)
			continue;
I 9
		assert(cp < g->must + g->mlen);
E 9
D 6
		*cp++ = OPND(s);
E 6
I 6
		*cp++ = (char)OPND(s);
E 6
	}
I 9
	assert(cp == g->must + g->mlen);
E 9
	*cp++ = '\0';		/* just on general principles */
}

/*
 - pluscount - count + nesting
I 6
 == static sopno pluscount(register struct parse *p, register struct re_guts *g);
E 6
I 2
D 3
 == static sopno pluscount(register struct parse *p, register struct re_guts *g);
E 3
E 2
 */
D 2
STATIC sopno			/* nesting depth */
E 2
I 2
static sopno			/* nesting depth */
E 2
pluscount(p, g)
struct parse *p;
register struct re_guts *g;
{
	register sop *scan;
	register sop s;
	register sopno plusnest = 0;
	register sopno maxnest = 0;

	if (p->error != 0)
		return(0);	/* there may not be an OEND */

	scan = g->strip + 1;
	do {
		s = *scan++;
		switch (OP(s)) {
		case OPLUS_:
			plusnest++;
			break;
		case O_PLUS:
			if (plusnest > maxnest)
				maxnest = plusnest;
			plusnest--;
			break;
		}
	} while (OP(s) != OEND);
	if (plusnest != 0)
		g->iflags |= BAD;
	return(maxnest);
}
E 1
