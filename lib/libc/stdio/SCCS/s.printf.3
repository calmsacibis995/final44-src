h26600
s 00002/00002/00610
d D 8.1 93/06/04 13:08:18 bostic 19 18
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00001/00611
d D 6.16 92/07/23 17:02:57 bostic 18 17
c spell
e
s 00023/00003/00589
d D 6.15 92/06/02 16:05:34 bostic 17 16
c Quad support in printf(3) family
e
s 00002/00002/00590
d D 6.14 91/07/30 21:50:19 cael 16 15
c add escape char (\&) to make groff happy
e
s 00003/00001/00589
d D 6.13 91/06/29 14:26:34 bostic 15 14
c add ANSI contribution notice
e
s 00018/00015/00572
d D 6.12 91/04/26 09:36:41 donn 14 13
c (1) Use stdarg.h instead of varargs.h; (2) make it clear that snprintf() and
c vsnprintf() are not ANSI; (3) clean up the example; (4) (chris) fix '\n's.
e
s 00396/00378/00191
d D 6.11 91/04/19 14:46:34 cael 13 12
c macro and text revision (-mdoc version 3)
e
s 00000/00000/00569
d D 6.10 91/04/19 14:41:30 cael 12 11
c macro and text revision (-mdoc version 3)
e
s 00001/00001/00568
d D 6.9 91/03/05 14:54:37 bostic 11 10
c man page pass, minor cleanups
e
s 00187/00096/00382
d D 6.8 91/01/20 21:25:26 bostic 10 9
c new stdio
e
s 00316/00175/00162
d D 6.7 89/04/14 09:31:37 bostic 9 8
c update for ANSI printf, plus some reworking; from Chris Torek
e
s 00003/00003/00334
d D 6.6 89/04/01 15:14:56 bostic 8 7
c remove subsection designations
e
s 00100/00041/00237
d D 6.5 88/06/05 11:32:54 bostic 7 6
c update from Chris for ANSI _doprnt; add BUGS section mentioning
c %D, %O, and %U, and that they should be going away soon
e
s 00005/00001/00274
d D 6.4 87/10/22 19:58:58 bostic 6 5
c ANSI C; sprintf now returns an int; document all return values
e
s 00001/00001/00274
d D 6.3 86/06/05 18:33:20 bloom 5 4
c fix plus because cfo decide to chang things
e
s 00040/00028/00235
d D 6.2 86/05/14 12:24:56 bloom 4 3
c rearrange the order of the conversion string and specify the order
e
s 00001/00001/00262
d D 6.1 85/05/15 15:02:59 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00073/00043/00190
d D 5.1 85/05/15 15:02:48 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00233/00000/00000
d D 4.1 85/05/15 15:02:41 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 10
D 13
.\" Copyright (c) 1990 The Regents of the University of California.
E 13
I 13
D 19
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
E 13
.\" All rights reserved.
E 19
I 19
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 19
.\"
.\" This code is derived from software contributed to Berkeley by
D 15
.\" Chris Torek.
E 15
I 15
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
E 15
D 13
.\"
E 13
.\" %sccs.include.redist.man%
.\"
E 10
I 1
D 13
.\"	%W% (Berkeley) %G%
E 13
I 13
.\"     %W% (Berkeley) %G%
E 13
.\"
D 2
.TH PRINTF 3S 4/1/81
E 2
I 2
D 3
.TH PRINTF 3S "1 April 1981"
E 3
I 3
D 7
.TH PRINTF 3S "%Q%"
E 7
I 7
D 8
.TH PRINTF 3S "October 22, 1987"
E 8
I 8
D 10
.TH PRINTF 3 "October 22, 1987"
E 8
E 7
E 3
E 2
.AT 3
E 10
I 10
D 13
.TH PRINTF 3 "%Q%"
.UC 7
E 10
.SH NAME
D 9
printf, fprintf, sprintf \- formatted output conversion
E 9
I 9
D 10
fprintf, printf, sprintf, vprintf, vfprintf, vsprintf - formatted
output conversion
E 10
I 10
printf, fprintf, sprintf, snprintf, vprintf, vfprintf,
vsprintf, vsnprintf \- formatted output conversion
E 10
E 9
.SH SYNOPSIS
.B #include <stdio.h>
.PP
.B printf(format
D 10
.RB [ ,
arg ] ...
E 10
I 10
[ , arg ... ]
E 10
.B )
.br
.B char *format;
.PP
.B fprintf(stream, format
D 10
.RB [ ,
arg ] ...
E 10
I 10
[ , arg ... ]
E 10
.B )
.br
.SM
.B FILE
.B *stream;
.br
.B char *format;
.PP
D 10
.B sprintf(s, format
.RB [ ,
arg ] ...
E 10
I 10
.B sprintf(str, format
[ , arg ... ]
E 10
.B )
.br
D 7
.B char *s, format;
E 7
I 7
D 10
.B char *s, *format;
E 10
I 10
.B char *str, *format;
E 10
E 7
I 2
.PP
D 10
.B #include <varargs.h>
E 10
I 10
.B snprintf(str, size, format
[ , arg ... ]
.B )
E 10
.br
D 7
.B _doprnt(format, args, stream)
E 7
I 7
D 10
.B vprintf(format, args)
E 10
I 10
.B char *str;
E 10
E 7
.br
I 10
.B size_t size;
.br
E 10
.B char *format;
I 10
.\" .PP
.\" .B char *smprintf(format
.\" [ , arg ... ]
.\" .B )
.PP
.B #include <varargs.h>
.PP
.B vprintf(format, ap)
E 10
.br
D 7
.B va_list *args;
E 7
I 7
D 10
.B va_list args;
E 10
I 10
.B char *format;
.br
.B va_list ap;
E 10
.PP
D 10
.B vfprintf(stream, format, args)
E 10
I 10
.B vfprintf(stream, format, ap)
E 10
E 7
.br
D 10
.B FILE *stream;
E 10
I 10
.SM
.B FILE
.B *stream;
E 10
I 7
.br
.B char *format;
.br
D 10
.B va_list args;
E 10
I 10
.B va_list ap;
E 10
.PP
D 10
.B vsprintf(s, format, args)
E 10
I 10
.B vsprintf(str, format, ap)
E 10
.br
D 10
.B char *s, *format;
E 10
I 10
.B char *str, *format;
E 10
.br
D 10
.B va_list args;
E 10
I 10
.B va_list ap;
.PP
.B vsnprintf(str, size, format, ap)
.br
.B char *str;
.br
.B size_t size;
.br
.B char *format;
.br
.B va_list ap;
.\" .PP
.\" .B char *vsmprintf(format, ap)
.\" .br
.\" .B char *format;
.\" .br
.\" .B va_list ap;
E 10
E 7
E 2
.SH DESCRIPTION
E 13
I 13
.Dd %Q%
.Dt PRINTF 3
.Os
.Sh NAME
.Nm printf ,
.Nm fprintf ,
.Nm sprintf ,
.Nm snprintf ,
.Nm vprintf ,
.Nm vfprintf,
.Nm vsprintf ,
.Nm vsnprintf
.Nd formatted output conversion
.Sh SYNOPSIS
.Fd #include <stdio.h>
.Ft int
.Fn printf "const char *format" ...
.Ft int
.Fn fprintf "FILE *stream" "const char *format" ...
.Ft int
.Fn sprintf "char *str" "const char *format" ...
.Ft int
.Fn snprintf "char *str" "size_t size" "const char *format" ...
.\" .Ft int
.\" .Fn smprintf "const char *format" ...
D 14
.Fd #include <varargs.h>
E 14
I 14
.Fd #include <stdarg.h>
E 14
.Ft int
.Fn vprintf "const char *format" "va_list ap"
.Ft int
.Fn vfprintf "FILE *stream" "const char *format" "va_list ap"
.Ft int
.Fn vsprintf "char *str" "char *format" "va_list ap"
.Ft int
.Fn vsnprintf "char *str" "size_t size" "const char *format" "va_list ap"
.\" .Ft int
.\" .Fn vsmprintf "const char *format" "va_list ap"
.Sh DESCRIPTION
E 13
I 10
The
D 13
.I printf
E 13
I 13
.Fn printf
E 13
family of functions produces output according to a
D 13
.I format
E 13
I 13
.Fa format
E 13
as described below.
E 10
D 13
.I Printf
E 13
I 13
.Fn Printf
E 13
D 9
places output on the standard output stream
E 9
I 9
and
D 13
.I vprintf
D 10
place output on the standard output stream
E 9
D 2
.IR stdout .
E 2
I 2
.BR stdout .
E 2
.I Fprintf
E 10
I 10
write the standard output stream
.BR stdout ;
.I fprintf
E 13
I 13
.Fn vprintf
write output to
.Em stdout,
the standard output stream;
.Fn fprintf
E 13
E 10
D 9
places output on the named output
E 9
I 9
and
D 13
.I vfprintf
D 10
place output on the named output
E 9
.IR stream .
.I Sprintf
E 10
I 10
write the named output
.IR stream ;
.IR sprintf ,
.IR snprintf ,
.IR vsprintf ,
E 13
I 13
.Fn vfprintf
write output to the given output
.Fa stream ;
.Fn sprintf ,
.Fn snprintf ,
.Fn vsprintf ,
E 13
E 10
D 9
places `output' in the string
E 9
I 9
and
D 10
.I vsprintf
copy into the string
E 9
D 2
.I s,
E 2
I 2
.IR s ,
E 2
D 9
followed by the character `\\0'.
I 2
D 7
All of these routines work by calling the internal
routine
.B _doprnt,
using the variable-length argument facilities of
.IR varargs (3).
E 7
I 7
Alternate forms, in which the arguments have already been
captured using the variable-length argument facilities of
.IR varargs (3),
are available under the names
E 9
I 9
followed by the character `\e0'.
.IR Printf ,
.IR fprintf ,
and
.I sprintf
take variadic argument lists directly, while
E 9
.IR vprintf ,
.IR vfprintf ,
and
D 9
.IR vsprintf .
E 9
I 9
.I vsprintf
use the variable-length argument facilities of
.IR varargs (3)
and hence may be called indirectly (see examples).
E 9
E 7
E 2
.PP
D 2
Each of these functions 
converts, formats, and prints its arguments after the first
under control of the first argument.
The first argument is a character string
which contains
two types of objects:
plain characters, which are simply copied to the
output stream,
and conversion specifications,
each of which causes conversion and printing
E 2
I 2
D 9
Each of these functions converts, formats, and prints its arguments after
the first under control of the first argument.
The first argument is a character string which contains two types of objects:
plain characters, which are simply copied to the output stream,
and conversion specifications, each of which causes conversion and printing
E 2
of the next successive
.I arg
.IR printf .
E 9
I 9
Each function converts, formats, and prints its arguments after the
E 10
I 10
D 13
.I vsnprintf
E 13
I 13
.Fn vsnprintf
E 13
write to the character string
D 13
.IR str .
E 13
I 13
.Fa str .
E 13
.\" .IR str ;
.\" and
.\" .I smprintf
.\" and
.\" .I vsmprintf
.\" dynamically allocate a new string with
.\" .IR malloc .
D 13
Each function converts, formats, and prints the arguments following the
E 10
.I format
I 10
(or accessed via the variable-length argument facilities of
.IR varargs (3))
E 10
under control of the
.I format
D 10
argument; each returns the the total number of characters printed (not
including the trailing `\e0' in
.I sprintf
E 10
I 10
argument.
E 13
I 13
These functions write the output under the control of a
.Fa format
string that specifies how subsequent arguments
(or arguments accessed via the variable-length argument facilities of
D 14
.Xr varargs 3 )
E 14
I 14
.Xr stdarg 3 )
E 14
are converted for output.
E 13
.\" Except for
.\" .I smprintf
.\" and
.\" .IR vsmprintf ,
.\" all of these functions return
D 13
Each function returns
E 13
I 13
These functions return
E 13
the number of characters printed
D 13
(not including the trailing `\e0' used to end output to strings).
E 13
I 13
(not including the trailing
.Ql \e0
used to end output to strings).
E 13
.\" .I Smprintf
.\" and
.\" .I vsmprintf
.\" return a pointer to a string of an appropriate length;
.\" this pointer should be passed to
.\" .I free
.\" to release the associated storage
.\" when it is no longer needed.
.\" If sufficient space is not avaliable,
.\" .I smprintf
.\" and
.\" .I vsmprintf
.\" will return
.\" .SM
D 13
.\" .BR NULL .
.I Snprintf
E 13
I 13
.\" .BR
.Fn Snprintf
E 13
E 10
and
D 10
.IR vsprintf ).
.I Format
is a character string which contains two types of objects: plain characters,
which are simply copied to the output stream, and conversion specifications,
E 10
I 10
D 13
.I vsnprintf
E 13
I 13
.Fn vsnprintf
E 13
will write at most
D 13
.IR size \-1
E 13
I 13
.Fa size Ns \-1
E 13
of the characters printed into the output string
(the
D 13
.IR size 'th
character then gets the terminating `\e0');
E 13
I 13
.Fa size Ns 'th
character then gets the terminating
.Ql \e0 ) ;
E 13
if the return value is greater than or equal to the
D 13
.I size
E 13
I 13
.Fa size
E 13
argument, the string was too short
and some of the printed characters were discarded.
D 13
.I Sprintf
E 13
I 13
.Fn Sprintf
E 13
and
D 13
.I vsprintf
E 13
I 13
.Fn vsprintf
E 13
D 18
effectively assume an infinte
E 18
I 18
effectively assume an infinite
E 18
D 13
.IR size .
.PP
The format is a string comprised of two types of objects:
plain characters, which are simply copied to the output stream,
and conversion specifications,
E 10
each of which causes conversion and printing of the next successive
.IR arg .
E 9
D 10
.PP
D 2
Each conversion specification is introduced by
the character
E 2
I 2
D 9
Each conversion specification is introduced by the character
E 2
.BR % .
D 4
Following the
.BR % ,
there may be
E 4
I 4
The remainder of the conversion specification includes
in the following order
E 9
I 9
Each conversion specification is introduced by the percent character (``%'').
The remainder of the conversion specification includes, in the following
order,
E 9
E 4
.TP
E 10
I 10
These arguments must correspond properly (after type promotion)
E 13
I 13
.Fa size .
.Pp
The format string is composed of zero or more directives:
ordinary
.\" multibyte
characters (not
.Cm % ) ,
which are copied unchanged to the output stream;
and conversion specifications, each of which results
in fetching zero or more subsequent arguments.
Each conversion specification is introduced by
the character
.Cm % .
The arguments must correspond properly (after type promotion)
E 13
with the conversion specifier.
D 13
Each conversion is introduced by the
.B %
(percent sign) character.
The rest of the conversion includes, in the following order,
.TP 4
E 10
D 2
\-
E 2
I 2
.B \(bu
E 13
I 13
After the
.Cm % ,
the following appear in sequence:
.Bl -bullet
.It
E 13
E 2
D 4
an optional minus sign `\-' which specifies
.I "left adjustment"
D 2
of the converted value
in the
indicated field;
E 2
I 2
of the converted value in the indicated field;
E 4
I 4
D 7
Zero or more of following flags:
E 7
I 7
Zero or more of the following flags:
E 7
D 13
.RS
E 4
E 2
D 10
.TP
E 10
I 10
.TP 4
E 10
D 2
\-
E 2
I 2
.B \(bu
E 2
D 4
an optional digit string specifying a
.I "field width;"
D 2
if the converted value has fewer characters
than the field width
E 2
I 2
if the converted value has fewer characters than the field width
E 2
it will be blank-padded on the left (or right,
D 2
if the left-adjustment indicator has been
given) to make up the field width;
E 2
I 2
if the left-adjustment indicator has been given) to make up the field width;
E 2
if the field width begins with a zero,
zero-padding will be done instead of blank-padding;
.TP
D 2
\-
E 2
I 2
.B \(bu
E 2
an optional period
.RB ` . '
D 2
which serves to
separate the field width from the
next digit string;
E 2
I 2
which serves to separate the field width from the next digit string;
E 2
.TP
D 2
\-
an optional digit string
specifying a
E 2
I 2
.B \(bu
an optional digit string specifying a
E 2
.I precision
D 2
which specifies
the number of digits to appear after the
decimal point, for e- and f-conversion,
or the maximum number of characters
E 2
I 2
which specifies the number of digits to appear after the
decimal point, for e- and f-conversion, or the maximum number of characters
E 2
to be printed from a string;
.TP
D 2
\-
E 2
I 2
.B \(bu
an optional `#' character
E 4
I 4
a `#' character
E 13
I 13
D 17
.Bl -hyphen -offset indent
E 17
I 17
.Bl -hyphen
E 17
.It
D 17
a
E 17
I 17
A
E 17
.Cm #
character
E 13
E 4
specifying that the value should be converted to an ``alternate form''.
For 
D 13
.BR c ,
.BR d ,
I 9
.BR i ,
.BR n ,
.BR p ,
E 9
.BR s ,
E 13
I 13
.Cm c ,
.Cm d ,
.Cm i ,
.Cm n ,
.Cm p ,
.Cm s ,
E 13
and
D 13
.BR u ,
E 13
I 13
.Cm u ,
E 13
D 9
conversions, this option has no effect.  For 
E 9
I 9
conversions, this option has no effect.
For 
E 9
D 13
.B o
E 13
I 13
.Cm o
E 13
conversions, the precision of the number is increased to force the first
D 9
character of the output string to a zero.  For 
.BR x ( X )
conversion, a non-zero result has the string 
.BR 0x ( 0X )
prepended to it.  For 
E 9
I 9
character of the output string to a zero (except if a zero value is printed
with an explicit precision of zero).
For
D 13
.B x
E 13
I 13
.Cm x
E 13
and
D 13
.B X
E 13
I 13
.Cm X
E 13
conversions, a non-zero result has the string
D 13
.B 0x
E 13
I 13
.Ql 0x
E 13
(or
D 13
.B 0X
E 13
I 13
.Ql 0X
E 13
for
D 13
.B X
E 13
I 13
.Cm X
E 13
conversions) prepended to it.
For
E 9
D 13
.BR e ,
.BR E ,
.BR f ,
.BR g ,
E 13
I 13
.Cm e ,
.Cm E ,
.Cm f ,
.Cm g ,
E 13
and
D 13
.BR G ,
E 13
I 13
.Cm G ,
E 13
conversions, the result will always contain a decimal point, even if no
D 9
digits follow the point (normally, a decimal point only appears in the
results of those conversions if a digit follows the decimal point).  For
E 9
I 9
digits follow it (normally, a decimal point appears in the results of
those conversions only if a digit follows).
For
E 9
D 13
.B g
E 13
I 13
.Cm g
E 13
and
D 13
.B G
E 13
I 13
.Cm G
E 13
conversions, trailing zeros are not removed from the result as they
D 7
would otherwise be.
E 7
I 7
D 9
would otherwise be;
E 9
I 9
would otherwise be.
E 9
E 7
I 4
D 10
.TP
E 10
I 10
D 13
.TP 4
E 10
.B \(bu
D 9
a minus sign `\-' which specifies
.I "left adjustment"
of the converted value in the indicated field;
E 9
I 9
D 10
A zero ``0'' character specifying zero padding.
E 10
I 10
A zero `0' character specifying zero padding.
E 13
I 13
.It
A zero
.Sq Cm \&0
character specifying zero padding.
E 13
E 10
For all conversions except
D 13
.BR n ,
E 13
I 13
.Cm n ,
E 13
the converted value is padded on the left with zeros rather than blanks.
D 10
If a precision is given with a numeric conversion (
.BR d ,
E 10
I 10
If a precision is given with a numeric conversion
D 13
.RB ( d ,
E 10
.BR i ,
.BR o ,
.BR u ,
.BR i ,
.BR x ,
E 13
I 13
.Pf ( Mc d ,
.Cm i ,
.Cm o ,
.Cm u ,
.Cm i ,
.Cm x ,
E 13
and
D 13
.BR X ),
D 10
the ``0'' flag is ignored.
E 9
.TP
E 10
I 10
the `0' flag is ignored.
.TP 4
E 10
.B \(bu
D 5
a `\+' character specifying that there should always be
E 5
I 5
D 9
a `+' character specifying that there should always be
E 5
D 7
a sign placed before the number when using signed conversions.
E 7
I 7
a sign placed before the number when using signed conversions;
E 9
I 9
D 10
A minus sign (``-'') specifying left adjustment of the converted value
E 10
I 10
A minus sign (`-') specifying left adjustment of the converted value
E 10
in the indicated field.
E 13
I 13
.Cm X ) ,
the
.Sq Cm \&0
flag is ignored.
.It
A negative field width flag
.Sq Cm \-
indicates the converted value is to be left adjusted on the field boundary.
E 13
Except for
D 13
.B n
E 13
I 13
.Cm n
E 13
conversions, the converted value is padded on the right with blanks,
rather than on the left with blanks or zeros.
D 10
A ``-'' overrides a ``0'' if both are given.
E 9
E 7
.TP
E 10
I 10
D 13
A `-' overrides a `0' if both are given.
.TP 4
E 10
.B \(bu
E 13
I 13
A
.Sq Cm \-
overrides a
.Sq Cm \&0
if both are given.
.It
E 13
D 9
a space specifying that a blank should be left before a positive number
D 7
during a signed conversion.  A `+' overrides a space if both are used.
E 7
I 7
during a signed conversion.  A `+' overrides a space if both are used;
E 9
I 9
A space, specifying that a blank should be left before a positive number
D 10
produced by a signed conversion (
.BR d ,
E 10
I 10
produced by a signed conversion
D 13
.RB ( d ,
E 10
.BR e ,
.BR E ,
.BR f ,
.BR g ,
.BR G ,
E 13
I 13
.Pf ( Cm d ,
.Cm e ,
.Cm E ,
.Cm f ,
.Cm g ,
.Cm G ,
E 13
or
D 13
.BR i ).
E 9
D 10
.TP
E 10
I 10
.TP 4
E 10
.B \(bu
D 9
a zero `0' character indicating that zero-padding should be used
rather than blank-padding.  A `\-' overrides a `0' if both are used;
E 9
I 9
a `+' character specifying that a sign always be placed before a
E 13
I 13
.Cm i ) .
.It
D 17
a
E 17
I 17
A
E 17
.Sq Cm +
character specifying that a sign always be placed before a
E 13
number produced by a signed conversion.
D 10
A ``+'' overrides a space if both are used.
E 10
I 10
D 13
A `+' overrides a space if both are used.
E 10
E 9
E 7
.RE
D 10
.TP
E 10
I 10
.TP 4
E 10
.B \(bu
D 9
an optional digit string specifying a
.I "field width;"
if the converted value has fewer characters than the field width
it will be blank-padded on the left (or right,
D 7
if the left-adjustment indicator has been given) to make up the field width;
if the field width begins with a zero,
zero-padding will be done instead of blank-padding;
E 7
I 7
if the left-adjustment indicator has been given) to make up the field width
(note that a leading zero is a flag,
but an embedded zero is part of a field width);
E 9
I 9
An optional digit string specifying a field width.
E 13
I 13
A
.Sq Cm +
overrides a space if both are used.
.El
.It
An optional decimal digit string specifying a minimum field width.
E 13
If the converted value has fewer characters than the field width, it will
D 13
be padded on the left (or right, if the left-adjustment flag is used) to
make up the field width.
E 9
E 7
D 10
.TP
E 10
I 10
.TP 4
E 10
.B \(bu
D 7
an optional period
.RB ` . '
which serves to separate the field width from the next digit string;
.TP
.B \(bu
an optional digit string specifying a
E 7
I 7
D 9
an optional period, followed by
an optional digit string giving a
E 7
.I precision
which specifies the number of digits to appear after the
decimal point, for e- and f-conversion, or the maximum number of characters
D 7
to be printed from a string;
E 7
I 7
to be printed from a string; if the digit string is missing,
the precision is treated as zero;
E 9
I 9
D 10
An optional precision, in the form of a period (``.'') followed by an
E 10
I 10
An optional precision, in the form of a period (`.') followed by an
E 13
I 13
be padded with spaces on the left (or right, if the left-adjustment
flag has been given) to fill out
the field width.
.It
An optional precision, in the form of a period
.Sq Cm \&.
followed by an
E 13
E 10
optional digit string.  If the digit string is omitted, the precision
is taken as zero.  This gives the minimum number of digits to appear for
D 13
.BR d ,
.BR i ,
.BR o ,
.BR u ,
.BR x ,
E 13
I 13
.Cm d ,
.Cm i ,
.Cm o ,
.Cm u ,
.Cm x ,
E 13
and
D 13
.B X
conversions, the number of digits to appear after the decimal point for
.BR e ,
.BR E ,
E 13
I 13
.Cm X
conversions, the number of digits to appear after the decimal-point for
.Cm e ,
.Cm E ,
E 13
and
D 13
.B f
E 13
I 13
.Cm f
E 13
conversions, the maximum number of significant digits for
D 13
.B g
E 13
I 13
.Cm g
E 13
and
D 13
.B G
E 13
I 13
.Cm G
E 13
conversions, or the maximum number of characters to be printed from a
string for
D 13
.B s
E 13
I 13
.Cm s
E 13
conversions.
E 9
E 7
E 4
D 10
.TP
E 10
I 10
D 13
.TP 4
E 10
.B \(bu
E 2
D 9
the character
.B l
E 9
I 9
The character
.BR h ,
E 13
I 13
.It
The optional character
.Cm h ,
E 13
E 9
specifying that a following
D 13
.BR d ,
I 7
.BR i ,
E 7
.BR o ,
I 9
.BR u ,
E 9
.BR x ,
E 13
I 13
.Cm d ,
.Cm i ,
.Cm o ,
.Cm u ,
.Cm x ,
E 13
or
D 9
.B u
corresponds to a long integer
D 2
.I arg.
(A capitalized conversion code accomplishes
the same thing.)
E 2
I 2
D 7
.IR arg .
E 7
I 7
.IR arg ,
or that a following
E 9
I 9
D 13
.B X
E 13
I 13
.Cm X
E 13
conversion corresponds to a
D 13
.B "short int"
E 13
I 13
.Em short int
E 13
or
D 13
.B "unsigned short int"
E 13
I 13
.Em unsigned short int
E 13
argument, or that a following
E 9
D 13
.B n
E 13
I 13
.Cm n
E 13
D 9
corresponds to a pointer to a long integer
.IR arg ;
E 9
I 9
conversion corresponds to a pointer to a
D 13
.B "short int"
E 13
I 13
.Em short int
E 13
argument.
E 9
E 7
E 2
D 10
.TP
E 10
I 10
D 13
.TP 4
E 10
D 2
\-
E 2
I 2
.B \(bu
I 7
the character
D 9
.B h
specifying that a following
E 9
I 9
.B l
E 13
I 13
.It
The optional character
.Cm l
E 13
(ell) specifying that a following
E 9
D 13
.BR d ,
.BR i ,
.BR o ,
I 9
.BR u ,
E 9
.BR x ,
E 13
I 13
.Cm d ,
.Cm i ,
.Cm o ,
.Cm u ,
.Cm x ,
E 13
or
D 9
.B u
corresponds to a short integer
.IR arg ,
or that a following
E 9
I 9
D 13
.B X
conversion corresponds to a
.B "long int"
E 13
I 13
.Cm X
conversion applies to a pointer to a
.Em long int
E 13
or
D 13
.B "unsigned long int"
E 13
I 13
.Em unsigned long int
E 13
argument, or that a following
E 9
D 13
.B n
E 13
I 13
.Cm n
E 13
D 9
corresponds to a pointer to a short integer
.IR arg ;
E 9
I 9
conversion corresponds to a pointer to a
D 13
.B "long int"
E 13
I 13
.Em long int
I 17
argument.
.It
The optional character
.Cm q ,
specifying that a following
.Cm d ,
.Cm i ,
.Cm o ,
.Cm u ,
.Cm x ,
or
.Cm X
conversion corresponds to a
.Em quad int
or
.Em unsigned quad int
argument, or that a following
.Cm n
conversion corresponds to a pointer to a
.Em quad int
E 17
E 13
argument.
E 9
D 10
.TP
E 10
I 10
D 13
.TP 4
E 10
.B \(bu
E 13
I 13
.It
E 13
E 7
E 2
D 9
a character which indicates the type of
conversion to be applied.
E 9
I 9
The character
D 13
.B L
E 13
I 13
.Cm L
E 13
specifying that a following
D 13
.BR e ,
.BR E ,
.BR f ,
.BR g ,
E 13
I 13
.Cm e ,
.Cm E ,
.Cm f ,
.Cm g ,
E 13
or
D 13
.B G
E 13
I 13
.Cm G
E 13
conversion corresponds to a
D 13
.B "long double"
E 13
I 13
.Em long double
E 13
argument (but note that long double values are not currently supported
D 13
by the \s-2VAX\s0 and Tahoe compilers).
D 10
.TP
E 10
I 10
.TP 4
E 10
.B \(bu
A character which indicates the type of conversion to be applied.
E 9
.PP
D 9
A field width or precision may be `*' instead of a digit string.
In this case an integer
.I arg
supplies
the field width or precision.
E 9
I 9
D 10
A field width or precision may be an asterisk (``*'') instead of a
E 10
I 10
A field width or precision may be an asterisk (`*') instead of a
E 13
I 13
by the
.Tn VAX
and
.Tn Tahoe
compilers).
.It
A character that specifies the type of conversion to be applied.
.El
.Pp
A field width or precision, or both, may be indicated by
an asterisk
.Ql *
instead of a
E 13
E 10
digit string.
D 13
In this case an
.B int
argument supplies the value.
E 13
I 13
In this case, an
.Em int
argument supplies the field width or precision.
E 13
A negative field width is treated as a left adjustment flag followed by a
positive field width; a negative precision is treated as though it were
missing.
E 9
D 13
.PP
D 9
The conversion characters
and their meanings are
E 9
I 9
The conversion characters and their meanings are:
E 9
D 10
.TP
E 10
I 10
.TP 4
E 10
D 9
.B dox
The integer
.I arg
D 7
is converted to decimal, octal, or
hexadecimal notation respectively.
E 7
I 7
is converted to signed decimal, unsigned octal, or
unsigned hexadecimal notation respectively.
E 9
I 9
.B diouxX
E 13
I 13
.Pp
The conversion specifiers and their meanings are:
.Bl -tag -width "diouxX"
.It Cm diouxX
E 13
The
D 13
.B int
E 13
I 13
.Em int
E 13
(or appropriate variant) argument is converted to signed decimal
D 13
.RB ( d " and " i ),
E 13
I 13
.Pf ( Cm d
and
.Cm i ) ,
E 13
unsigned octal
D 13
.RB ( o ),
E 13
I 13
.Pq Cm o ,
E 13
unsigned decimal
D 13
.RB ( u ),
E 13
I 13
.Pq Cm u ,
E 13
or unsigned hexadecimal
D 13
.RB ( x " and " X )
notation respectively.  The letters
.B abcdef
E 13
I 13
.Pf ( Cm x
and
.Cm X )
notation.  The letters
.Cm abcdef
E 13
are used for
D 13
.B x
E 13
I 13
.Cm x
E 13
conversions; the letters
D 13
.B ABCDEF
E 13
I 13
.Cm ABCDEF
E 13
are used for
D 13
.B X
E 13
I 13
.m X
E 13
conversions.
The precision, if any, gives the minimum number of digits that must
appear; if the converted value requires fewer digits, it is padded on
the left with zeros.
E 9
E 7
D 10
.TP
E 10
I 10
D 13
.TP 4
E 10
I 7
D 9
.B i
An alias for `d'.
.TP
E 7
.B f
The float or double
.I arg
is converted to decimal notation
in the style `[\fB\-\fR]ddd.ddd'
where the number of d's after the decimal point
is equal to the precision specification
for the argument.
If the precision
is missing,
6 digits are given;
if the precision is explicitly 0, no digits and
no decimal point are printed.
.TP
E 9
I 9
.B DOU
E 13
I 13
.It Cm DOU
E 13
The
D 13
.B "long int"
E 13
I 13
.Em long int
E 13
argument is converted to signed decimal, unsigned octal, or unsigned
decimal, as if the format had been
D 13
.BR ld ,
.BR lo ,
E 13
I 13
.Cm ld ,
.Cm lo ,
E 13
or
D 13
.B lu
E 13
I 13
.Cm lu
E 13
respectively.
These conversion characters are deprecated, and will eventually disappear.
D 10
.TP 8
E 10
I 10
D 13
.TP 4
E 10
E 9
D 7
.B e
E 7
I 7
.B eE
E 13
I 13
.It Cm eE
E 13
E 7
D 9
The float or double
.I arg
is converted in the style
`[\fB\-\fR]d\fB.\fRddd\fBe\fR\(+-dd'
where there is one digit before the decimal point and
the number after is equal to the
precision specification for the argument;
when the precision is missing,
6 digits are produced.
I 7
An uppercase E is used for `E' conversion.
E 7
.TP
D 7
.B g
E 7
I 7
.B gG
E 7
The float or double
.I arg
is printed in style
E 9
I 9
The
D 13
.B double
E 13
I 13
.Em double
E 13
argument is rounded and converted in the style
D 13
`[\fB\-\fR]d\fB.\fRddd\fBe\fR\(+-dd' where there is one digit before the
decimal point and the number after is equal to the precision specification
for the argument.
If the precision is missing, 6 digits are given; if the precision is
explicitly zero, no decimal point appears.
E 13
I 13
.Sm off
.Pf [\-]d Cm \&. No ddd Cm e No \\*(Pmdd
.Sm on
where there is one digit before the
decimal-point character
and the number of digits after it is equal to the precision;
if the precision is missing,
it is taken as 6; if the precision is
zero, no decimal-point character appears.
E 13
An
D 13
.B E
E 13
I 13
.Cm E
E 13
conversion uses the letter
D 13
.B E
E 13
I 13
.Cm E
E 13
(rather than
D 13
.BR e )
E 13
I 13
.Cm e )
E 13
to introduce the exponent.
The exponent always contains at least two digits; if the value is zero,
the exponent is 00.
D 10
.TP 8
E 10
I 10
D 13
.TP 4
E 10
E 9
D 7
.BR d ,
in style
.BR f ,
or in
style
.BR e ,
E 7
I 7
.B f
E 13
I 13
.It Cm f
E 13
D 9
or in style
E 9
I 9
The
D 13
.B double
E 13
I 13
.Em double
E 13
argument is rounded and converted to decimal notation in the style
D 13
`[\fB\-\fR]ddd.ddd' where the number of digits after the decimal point
is equal to the precision.
If the precision is missing, 6 digits are given; if the precision is
explicitly 0, no digits and no decimal point are printed.
E 13
I 13
.Sm off
.Pf [-]ddd Cm \&. No ddd ,
.Sm on
where the number of digits after the decimal-point character
is equal to the precision specification.
If the precision is missing, it is taken as 6; if the precision is
explicitly zero, no decimal-point character appears.
E 13
If a decimal point appears, at least one digit appears before it.
D 10
.TP 8
E 10
I 10
D 13
.TP 4
E 10
.B g
E 13
I 13
.It Cm g
E 13
The
D 13
.B double
argument is printed in style
.B f
E 13
I 13
.Em double
argument is converted in style
.Cm f
E 13
or
E 9
D 13
.B e
E 13
I 13
.Cm e
E 13
D 9
.RB ( E )
E 7
whichever gives full precision in minimum space.
.TP
E 9
I 9
(or
D 13
.B E
E 13
I 13
.Cm E
E 13
for
D 13
.B G
E 13
I 13
.Cm G
E 13
conversions).
The precision specifies the number of significant digits.
If the precision is missing, 6 digits are given; if the precision is zero,
it is treated as 1.
Style
D 13
.B e
E 13
I 13
.Cm e
E 13
is used if the exponent from its conversion is less than -4 or greater than
or equal to the precision.
Trailing zeros are removed from the fractional part of the result; a
decimal point appears only if it is followed by at least one digit.
D 10
.TP 8
E 10
I 10
D 13
.TP 4
E 10
E 9
.B c
E 13
I 13
.It Cm c
E 13
D 9
The character
.I arg
is printed.
.TP
E 9
I 9
The
D 13
.B int
E 13
I 13
.Em int
E 13
argument is converted to an
D 13
.B "unsigned char",
and the resulting character is printed.
D 10
.TP 8
E 10
I 10
.TP 4
E 10
E 9
.B s
E 13
I 13
.Em unsigned char ,
and the resulting character is written.
.It Cm s
E 13
D 9
.I Arg
is taken to be a string (character pointer)
and characters from the string are printed until
a null character or until
the number of characters indicated by the precision
specification is reached;
however if the precision is 0 or missing
all characters up to a null are printed.
.TP
.B u
The unsigned integer
.I arg
is converted to decimal
and printed (the result will be in the
range 0 through MAXUINT, where MAXUINT equals 4294967295 on a VAX-11
and 65535 on a PDP-11).
.TP
I 7
.B n
.I Arg
is taken to be a pointer to an integer (possibly
.B short
or
.BR long )
through which is stored the number of characters written
to the output stream (or string) so far by this call to
.B printf
(or
.BR fprintf ,
etc.).
.TP
E 9
I 9
The
D 13
.B "char *"
argument is taken to be a string (character pointer).
Characters from the string are printed until a null character is reached,
or until the number of characters indicated by the precision have been
printed, whichever occurs first; if a precision is given, no null character
need be present.
D 10
.TP 8
E 10
I 10
.TP 4
E 10
E 9
.B p
E 13
I 13
.Dq Em char *
argument is expected to be a pointer to an array of character type (pointer
to a string).
Characters from the array are written up to (but not including)
a terminating
.Dv NUL
character;
if a precision is specified, no more than the number specified are
written.
If a precision is given, no null character
need be present; if the precision is not specified, or is greater than
the size of the array, the array must contain a terminating
.Dv NUL
character.
.It Cm p
E 13
D 9
.I Arg
is taken to be a pointer to
.BR void ;
it is printed in style
.BR x .
.TP
E 9
I 9
The
D 13
.B "void *"
D 10
pointer argument is printed in hexadecimal (as if by ``%x'' or ``%lx'').
.TP 8
E 10
I 10
pointer argument is printed in hexadecimal (as if by `%#x' or `%#lx').
.TP 4
E 10
.B n
E 13
I 13
.Dq Em void *
pointer argument is printed in hexadecimal (as if by
.Ql %#x
or
.Ql %#lx ) .
.It Cm n
E 13
The number of characters written so far is stored into the
integer indicated by the
D 13
.B "int *"
E 13
I 13
.Dq Em int *
E 13
(or variant) pointer argument.
No argument is converted.
D 10
.TP 8
E 10
I 10
D 13
.TP 4
E 10
E 9
E 7
.B %
D 9
Print a `%'; no argument is converted.
E 9
I 9
Prints a `%'; no argument is converted.
E 9
.PP
E 13
I 13
.It Cm %
A
.Ql %
is written. No argument is converted. The complete conversion specification
is
.Ql %% .
.El
.Pp
E 13
D 9
In no case does a non-existent or small field width
cause truncation of a field;
padding takes place only if the specified field
width exceeds the actual width.
Characters generated by
.I printf
D 7
are printed by 
E 7
I 7
are printed as by 
E 7
D 2
.IR putc (3).
E 2
I 2
D 8
.IR putc (3S).
E 8
I 8
.IR putc (3).
E 9
I 9
In no case does a non-existent or small field width cause truncation of
a field; if the result of a conversion is wider than the field width, the
D 13
field is expanded to contain it.
Similarly, padding takes place only if the specified field width exceeds
the actual width.
E 9
E 8
E 2
.PP
D 6
.B Examples
E 6
I 6
D 9
.SH "RETURN VALUE"
D 7
The functions \fIprintf\fP, \fIfprintf\fP, and \fIsprintf\fP return
the number of characters printf, or -1 if an error occurred.
E 7
I 7
The functions all return
the number of characters printed, or -1 if an error occurred.
E 9
E 7
.SH EXAMPLES
E 13
I 13
field is expanded to contain the conversion result.
.Pp
.Sh EXAMPLES
E 13
E 6
.br
To print a date and time in the form `Sunday, July 3, 10:02',
where
D 13
.I weekday
E 13
I 13
.Em weekday
E 13
and
D 13
.I month
are pointers to null-terminated strings:
.RS
.HP
.nh
D 9
printf("%s, %s %d, %02d:%02d", weekday, month, day, hour, min);
E 9
I 9
printf("%s, %s %d, %02d:%.2d", weekday, month, day, hour, min);
E 9
.RE
.hy
.PP
To print
.if n pi
.if t \(*p
to 5 decimals:
.IP
printf("pi = %.5f", 4*atan(1.0));
I 9
.PP
E 13
I 13
.Em month
are pointers to strings:
.Bd -literal -offset indent
#include <stdio.h>
D 14
fprintf(stdout,"%s, %s %d, %.2d:%.2d0",
E 14
I 14
fprintf(stdout, "%s, %s %d, %.2d:%.2d\en",
E 14
	weekday, month, day, hour, min);
.Ed
.Pp
To print \*(Pi
to five decimal places:
.Bd -literal -offset indent
#include <math.h>
#include <stdio.h>
D 14
fprintf(stdout,"pi = %.5f0", 4 * atan(1.0));
E 14
I 14
fprintf(stdout, "pi = %.5f\en", 4 * atan(1.0));
E 14
.Ed
.Pp
E 13
To allocate a 128 byte string and print into it:
D 13
.RS
.nf
.ta 1i 2i
.sp
E 13
I 13
.Bd -literal -offset indent
E 13
#include <stdio.h>
D 14
#include <varargs.h>
char *newfmt(va_alist)
D 13
	va_dcl
E 13
I 13
		va_dcl
E 14
I 14
#include <stdlib.h>
#include <stdarg.h>
char *newfmt(const char *fmt, ...)
E 14
E 13
{
D 10
	char *p, *malloc(), fmt;
E 10
I 10
D 13
	char *p, *malloc(), *fmt;
E 10
	va_list ap;
	if ((p = malloc(128)) == NULL)
		return (NULL);
	va_start(ap);
	fmt = va_arg(ap, char *);
	(void) vsprintf(p, fmt, ap);
	va_end(ap);
	return (p);
E 13
I 13
D 14
		char *p, *malloc(), *fmt;
E 14
I 14
		char *p;
E 14
		va_list ap;
		if ((p = malloc(128)) == NULL)
			return (NULL);
D 14
		va_start(ap);
		fmt = va_arg(ap, char *);
		(void) vsprintf(p, fmt, ap);
E 14
I 14
		va_start(ap, fmt);
		(void) vsnprintf(p, 128, fmt, ap);
E 14
		va_end(ap);
		return (p);
E 13
}
D 13
.RE
.fi
E 9
.SH "SEE ALSO"
D 2
putc(3),
scanf(3),
E 2
I 2
D 7
putc(3S),
scanf(3S),
E 2
ecvt(3)
E 7
I 7
D 8
putc(3S), scanf(3S)
E 8
I 8
D 10
putc(3), scanf(3)
E 10
I 10
D 11
malloc(3), putc(3), scanf(3)
E 11
I 11
printf(1), scanf(3)
E 11
E 10
E 8
E 7
.SH BUGS
D 7
Very wide fields (>128 characters) fail.
E 7
I 7
D 9
The functions still supports \fI%D\fP, \fI%O\fP, and \fI%U\fP.  Do not
use these formats, as they will be disappearing soon.
E 9
I 9
D 10
The conversion formats ``%D'', ``%O'', and ``%U'' are not standard and
E 10
I 10
The conversion formats `%D', `%O', and `%U' are not standard and
E 13
I 13
.Ed
.Sh SEE ALSO
.Xr printf 1 ,
.Xr scanf 3
.Sh STANDARDS
D 14
The functions
E 14
I 14
The
E 14
.Fn fprintf ,
.Fn printf ,
.Fn sprintf ,
D 14
.Fn snprintf ,
E 14
.Fn vprintf ,
.Fn vfprintf ,
D 14
.Fn vsprintf ,
E 14
and
D 14
.Fn vsnprintf
E 14
I 14
.Fn vsprintf
E 14
functions
conform to
.St -ansiC .
I 14
.Sh HISTORY
The functions
.Fn snprintf
and
.Fn vsnprintf
are new to this release.
E 14
.Sh BUGS
The conversion formats
D 16
.Cm %D ,
.Cm %O ,
E 16
I 16
.Cm \&%D ,
.Cm \&%O ,
E 16
and
.Cm %U
are not standard and
E 13
E 10
are provided only for backward compatibility.
D 10
The effect of padding the ``%p'' format with zeros (either by the ``0''
E 10
I 10
D 13
The effect of padding the `%p' format with zeros (either by the `0'
E 13
I 13
The effect of padding the
.Cm %p
format with zeros (either by the
.Sq Cm 0
E 13
E 10
flag or by specifying a precision), and the benign effect (i.e., none)
D 10
of the ``#'' flag on ``%n'' and ``%p'' conversions, as well as other
nonsensical combinations such as ``%Ld'', are not standard; such combinations
E 10
I 10
D 13
of the `#' flag on `%n' and `%p' conversions, as well as other
nonsensical combinations such as `%Ld', are not standard; such combinations
E 13
I 13
of the
.Sq Cm #
flag on
.Cm %n
and
.Cm %p
conversions, as well as other
nonsensical combinations such as
.Cm %Ld ,
are not standard; such combinations
E 13
E 10
should be avoided.
I 10
D 13
.PP
E 13
I 13
.Pp
E 13
Because
D 13
.I sprintf
E 13
I 13
.Fn sprintf
E 13
and
D 13
.I vsprintf
E 13
I 13
.Fn vsprintf
E 13
assume an infinitely long string,
callers must be careful not to overflow the actual space;
this is often impossible to assure.
For safety, programmers should use the
D 13
.I snprintf
E 13
I 13
.Fn snprintf
E 13
interface instead.
Unfortunately, this interface is not portable.
E 10
E 9
E 7
E 1
