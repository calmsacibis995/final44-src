h49078
s 00001/00001/00403
d D 8.2 93/12/11 22:37:58 mckusick 18 17
c copyediting for Usenix manuals
e
s 00002/00002/00402
d D 8.1 93/06/04 13:09:21 bostic 17 16
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00002/00403
d D 6.14 93/01/08 17:49:57 bostic 16 15
c typo
e
s 00001/00001/00404
d D 6.13 93/01/08 17:48:15 bostic 15 14
c typo
e
s 00011/00000/00394
d D 6.12 92/12/16 18:09:33 bostic 14 13
c note truncation, from Peter McIlroy
e
s 00003/00001/00391
d D 6.11 91/06/29 14:28:43 bostic 13 12
c add ANSI contribution notice
e
s 00016/00006/00376
d D 6.10 91/04/26 09:38:22 donn 12 11
c (1) Use stdarg.h instead of varargs.h; (2) add STANDARDS; (3) document
c the fact that vscanf(), vsscanf() and vfscanf() are new.
e
s 00006/00009/00376
d D 6.9 91/04/23 09:46:14 donn 11 10
c Some adjustments suggested by cael.
e
s 00001/00001/00384
d D 6.8 91/04/20 02:29:18 cael 10 9
c put \& between %% so sccs would stop complaining
e
s 00017/00002/00368
d D 6.7 91/04/19 15:11:28 donn 9 8
c Add vscanf() and vsscanf().
e
s 00233/00243/00137
d D 6.6 91/04/19 14:46:41 cael 8 7
c macro and text revision (-mdoc version 3)
e
s 00000/00000/00380
d D 6.5 91/04/19 14:41:34 cael 7 6
c macro and text revision (-mdoc version 3)
e
s 00030/00002/00350
d D 6.4 91/03/06 12:42:37 donn 6 5
c Document vfscanf(), which is really just __svfscanf() made public.
e
s 00289/00194/00063
d D 6.3 91/01/20 21:28:32 bostic 5 4
c new stdio
e
s 00003/00003/00254
d D 6.2 89/04/01 15:15:00 bostic 4 3
c remove subsection designations
e
s 00001/00001/00256
d D 6.1 85/05/15 15:04:11 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00009/00008/00248
d D 5.1 85/05/15 15:04:00 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00256/00000/00000
d D 4.1 85/05/15 15:03:52 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 5
D 8
.\" Copyright (c) 1990 The Regents of the University of California.
E 8
I 8
D 17
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
E 8
.\" All rights reserved.
E 17
I 17
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 17
.\"
.\" This code is derived from software contributed to Berkeley by
D 13
.\" Chris Torek.
E 13
I 13
.\" Chris Torek and the American National Standards Committee X3,
.\" on Information Processing Systems.
.\"
E 13
D 8
.\"
E 8
.\" %sccs.include.redist.man%
.\"
E 5
I 1
D 8
.\"	%W% (Berkeley) %G%
E 8
I 8
.\"     %W% (Berkeley) %G%
E 8
.\"
D 2
.TH SCANF 3S 
E 2
I 2
D 3
.TH SCANF 3S  "19 January 1983"
E 3
I 3
D 4
.TH SCANF 3S  "%Q%"
E 4
I 4
D 5
.TH SCANF 3  "%Q%"
E 4
E 3
E 2
.AT 3
E 5
I 5
D 8
.TH SCANF 3 "%Q%"
.UC 7
E 5
.SH NAME
D 6
scanf, fscanf, sscanf \- formatted input conversion
E 6
I 6
scanf, fscanf, sscanf, vfscanf \- formatted input conversion
E 6
.SH SYNOPSIS
.B #include <stdio.h>
.PP
.B scanf(format
D 5
[ , pointer ] . . .
E 5
I 5
[ , pointer ... ]
E 5
.B )
.br
.B char *format;
.PP
.B fscanf(stream, format
D 5
[ , pointer ] . . .
E 5
I 5
[ , pointer ... ]
E 5
.B )
.br
.SM
.B FILE
.B *stream;
.br
.B char *format;
.PP
D 5
.B sscanf(s, format
[ , pointer ] . . .
E 5
I 5
.B sscanf(str, format
[ , pointer ... ]
E 5
.B )
.br
D 5
.B char *s, *format;
E 5
I 5
D 6
.B char *str, *format;
E 6
I 6
.B char *str;
.br
.B char *format;
.PP
.B #include <varargs.h>
.PP
.B vfscanf(stream, format, ap)
.br
.SM
.B FILE
.B *stream;
.br
.B char *format;
.br
.B va_list ap;
.br
E 6
E 5
.SH DESCRIPTION
E 8
I 8
.Dd %Q%
.Dt SCANF 3
.Os
.Sh NAME
.Nm scanf ,
.Nm fscanf ,
.Nm sscanf ,
I 9
.Nm vscanf ,
.Nm vsscanf ,
E 9
.Nm vfscanf
.Nd input format conversion
.Sh SYNOPSIS
.Fd #include <stdio.h>
.Ft int
.Fn scanf "const char *format" ...
.Ft int
.Fn fscanf "FILE *stream" "const char *format" ...
I 9
.Ft int
.Fn sscanf "const char *str" "const char *format" ...
E 9
D 12
.Fd #include <varargs.h>
E 12
I 12
.Fd #include <stdarg.h>
E 12
.Ft int
D 9
.Fn sscanf "char *str" "const char *format" ...
E 9
I 9
.Fn vscanf "const char *format" "va_list ap"
E 9
.Ft int
D 9
.Fn vfscanf "FILE *stream" "char *format" "va_list ap"
E 9
I 9
.Fn vsscanf "const char *str" "const char *format" "va_list ap"
.Ft int
.Fn vfscanf "FILE *stream" "const char *format" "va_list ap"
E 9
.Sh DESCRIPTION
E 8
I 5
The
D 8
.I scanf
E 8
I 8
.Fn scanf
E 8
family of functions scans input according to a
D 8
.I format
E 8
I 8
.Fa format
E 8
as described below.
This format may contain
D 8
.IR "conversion specifiers" ;
E 8
I 8
.Em conversion specifiers ;
E 8
the results from such conversions, if any,
are stored through the
D 8
.I pointer
E 8
I 8
.Em pointer
E 8
arguments.
E 5
D 8
.I Scanf
D 5
reads from the standard input stream
D 2
.IR stdin .
E 2
I 2
.BR stdin .
E 2
.I Fscanf
reads from the named input
.IR stream .
.I Sscanf
E 5
I 5
reads the standard input stream
.BR stdin ,
.I fscanf
reads the named input
.IR stream ,
E 8
I 8
The
.Fn scanf
function
reads input from the standard input stream
.Em stdin ,
.Fn fscanf
reads input from the stream pointer
.Fa stream ,
E 8
and
D 8
.I sscanf
E 5
reads from the character string
D 5
.IR s .
Each function reads characters, interprets
them according to a format, and stores the results in its arguments.
Each expects as arguments
a control string
D 2
.I format,
E 2
I 2
.IR format ,
E 2
described below,
and a set of
E 5
I 5
.IR str .
I 6
.I Vfscanf
E 8
I 8
.Fn sscanf
reads its input from the character string pointed to by
.Fa str .
The
.Fn vfscanf
function
E 8
is analogous to
D 8
.I vfprintf
and reads from a named input
.I stream
E 8
I 8
.Xr vfprintf 3
and reads input from the stream pointer
.Fa stream
E 8
using a variable argument list of pointers (see
D 8
.IR varargs (3)).
E 8
I 8
D 12
.Xr varargs 3 ) .
E 12
I 12
.Xr stdarg 3 ) .
E 12
I 11
The
E 11
I 9
.Fn vscanf
D 11
scans a variable argument list from the standard input and
E 11
I 11
function scans a variable argument list from the standard input and
the
E 11
.Fn vsscanf
D 11
scans it from a string;
E 11
I 11
function scans it from a string;
E 11
these are analogous to
I 11
the
E 11
.Fn vprintf
and
.Fn vsprintf
D 11
respectively.
E 11
I 11
functions respectively.
E 11
E 9
E 8
E 6
Each successive
E 5
D 8
.I pointer
E 8
I 8
.Em pointer
E 8
D 5
arguments
indicating where the converted input should be stored.
.PP
E 5
I 5
argument must correspond properly with
each successive conversion specifier
(but see `suppression' below).
All conversions are introduced by the
D 8
.B %
E 8
I 8
.Cm %
E 8
(percent sign) character.
E 5
The
D 5
control string
usually contains
conversion specifications, which are used to direct interpretation
of input sequences.
The control string may contain:
E 5
I 5
D 8
.I format
E 8
I 8
.Fa format
E 8
string
may also contain other characters.
White space (such as blanks, tabs, or newlines) in the
D 8
.I format
E 8
I 8
.Fa format
E 8
string match any amount of white space, including none, in the input.
Everything else
matches only itself.
Scanning stops
when an input character does not match such a format character.
Scanning also stops
when an input conversion cannot be made (see below).
D 8

.SH CONVERSIONS
E 8
I 8
.Sh CONVERSIONS
E 8
Following the
D 8
.B %
E 8
I 8
.Cm %
E 8
character introducing a conversion
there may be a number of
D 8
.I flag
E 8
I 8
.Em flag
E 8
characters, as follows:
E 5
D 8
.TP 4
D 5
1.
Blanks, tabs or newlines,
which match optional white space in the input.
E 5
I 5
.B *
suppresses assignment.
E 8
I 8
.Bl -tag -width indent
.It Cm *
Suppresses assignment.
E 8
The conversion that follows occurs as usual, but no pointer is used;
the result of the conversion is simply discarded.
E 5
D 8
.TP 4
D 5
2.
An ordinary character (not %) which must match
the next character of the input stream.
E 5
I 5
.B h
indicates that the conversion will be one of
.B dioux
E 8
I 8
.It Cm h
Indicates that the conversion will be one of
.Cm dioux
E 8
or
D 8
.B n
E 8
I 8
.Cm n
E 8
and the next pointer is a pointer to a
D 8
.B short int
E 8
I 8
.Em short  int
E 8
(rather than
D 8
.BR int ).
E 5
.TP 4
D 5
3.
Conversion specifications, consisting of the
character
.BR % ,
an optional assignment suppressing character
.BR * ,
an optional numerical maximum field width, and a conversion
character.
E 5
I 5
.B l
indicates either that the conversion will be one of
.B dioux
E 8
I 8
.Em int ) .
.It Cm l
Indicates either that the conversion will be one of
.Cm dioux
E 8
or
D 8
.B n
E 8
I 8
.Cm n
E 8
and the next pointer is a pointer to a
D 8
.B long int
E 8
I 8
.Em long  int
E 8
(rather than
D 8
.BR int ),
E 8
I 8
.Em int ) ,
E 8
or that the conversion will be one of
D 8
.B efg
E 8
I 8
.Cm efg
E 8
and the next pointer is a pointer to
D 8
.B double
E 8
I 8
.Em double
E 8
(rather than
D 8
.BR float ).
.TP 4
.B L
indicates that the conversion will be
.B efg
E 8
I 8
.Em float ) .
.It Cm L
Indicates that the conversion will be
.Cm efg
E 8
and the next pointer is a pointer to
D 8
.BR "long double" .
E 8
I 8
.Em long double .
E 8
(This type is not implemented; the
D 8
.B L
E 8
I 8
.Cm L
E 8
flag is currently ignored.)
E 5
D 8
.PP
E 8
I 8
.El
.Pp
E 8
D 5
A conversion specification directs the conversion of the
next input field; the result
is placed in the variable pointed to by the corresponding argument,
unless assignment suppression was
indicated by
.BR * .
An input field is defined as a string of non-space characters;
it extends to the next inappropriate character or until the field
width, if specified, is exhausted.
E 5
I 5
In addition to these flags,
there may be an optional maximum field width,
expressed as a decimal integer,
between the
D 8
.B %
E 8
I 8
.Cm %
E 8
and the conversion.
If no width is given,
a default of `infinity' is used (with one exception, below);
otherwise at most this many characters are scanned
in processing the conversion.
Before conversion begins,
most conversions skip white space;
this white space is not counted against the field width.
E 5
D 8
.PP
E 8
I 8
.Pp
E 8
D 5
The conversion character indicates the interpretation of the
input field; the corresponding pointer argument must
usually be of a restricted type.
The following conversion characters are legal:
E 5
I 5
The following conversions are available:
E 5
D 8
.TP 4
D 5
.B  %
a single `%' is expected
in the input at this point;
no assignment is done.
E 5
I 5
.B %
matches a literal `%'.
E 8
I 8
.Bl -tag -width XXXX
.It Cm %
Matches a literal `%'.
E 8
D 10
That is, `%%' in the format string
E 10
I 10
That is, `%\&%' in the format string
E 10
matches a single input `%' character.
D 8
No conversion is done, and no assignment occurs.
E 5
.TP 4
D 5
.B  d
E 5
I 5
.B d
E 5
a decimal integer is expected;
E 8
I 8
No conversion is done, and assignment does not occur.
.It Cm d
Matches an optionally signed decimal integer;
E 8
D 5
the corresponding argument should be an integer pointer.
E 5
I 5
the next pointer must be a pointer to
D 8
.BR int .
E 5
.TP 4
D 5
.B  o
E 5
I 5
.B D
equivalent to
.BR ld ;
E 8
I 8
.Em int .
.It Cm D
Equivalent to
.Xr ld ;
E 8
this exists only for backwards compatibility.
D 8
.TP 4
.B i
an integer is expected;
E 8
I 8
.It Cm i
Matches an optionally signed integer;
E 8
the next pointer must be a pointer to
D 8
.BR int .
The integer is read in base 16 if it begins with `0x' or `0X',
in base 8 if it begins with `0', and in base 10 otherwise.
E 8
I 8
.Em int .
The integer is read in base 16 if it begins
with
.Ql 0x
or
.Ql 0X ,
in base 8 if it begins with
.Ql 0 ,
and in base 10 otherwise.
E 8
Only characters that correspond to the base are used.
D 8
.TP 4
.B o
E 5
an octal integer is expected;
E 8
I 8
.It Cm o
Matches an octal integer;
E 8
D 5
the corresponding argument should be a integer pointer.
E 5
I 5
the next pointer must be a pointer to
D 8
.BR "unsigned int" .
E 5
.TP 4
D 5
.B  x
a hexadecimal integer is expected;
the corresponding argument should be an integer pointer.
.ti -0.2i
E 5
I 5
.B O
equivalent to
.BR lo ;
E 8
I 8
.Em unsigned int .
.It Cm O
Equivalent to
.Xr lo ;
E 8
this exists for backwards compatibility.
E 5
D 8
.TP 4
D 5
.B  s
a character string is expected;
the corresponding argument should be a character pointer
pointing to an array of characters large enough to accept the
string and a terminating `\e0', which will be added.
The input field is terminated by a space character
or a newline.
E 5
I 5
.B u
a signed or unsigned decimal integer is expected;
E 8
I 8
.It Cm u
Matches an optionally signed decimal integer;
E 8
the next pointer must be a pointer to
D 8
.BR "unsigned int" .
E 5
.TP 4
D 5
.B  c
a character is expected; the
corresponding argument should be a character pointer.
The normal skip over space characters is suppressed
in this case;
to read the next non-space character, try
`%1s'.
If a field width is given, the corresponding argument
should refer to a character array, and the
indicated number of characters is read.
E 5
I 5
.B x
a signed or unsigned hexadecimal integer is expected;
E 8
I 8
.Em unsigned int .
.It Cm x
D 18
Matches an optionally a signed hexadecimal integer;
E 18
I 18
Matches an optionally signed hexadecimal integer;
E 18
E 8
the next pointer must be a pointer to
D 8
.BR "unsigned int" .
E 5
.TP 4
D 5
\z\fBe\v'1'f\v'-1'\fR
a
floating point number is expected;
the next field is converted accordingly and stored through the
corresponding argument, which should be a pointer to a
.IR float .
The input format for
floating point numbers is
an optionally signed
string of digits
possibly containing a decimal point, followed by an optional
exponent field consisting of an E or e followed by an optionally signed integer.
E 5
I 5
.B X
equivalent to
.BR lx ;
this violates the ANSI C standard X3.159-1989,
E 8
I 8
.Em unsigned int .
.It Cm X
Equivalent to
.Cm lx ;
this violates the
.St -ansiC ,
E 8
but is backwards compatible with previous
D 8
.UX
E 8
I 8
.Ux
E 8
systems.
E 5
D 8
.TP 4
D 5
.B  [
indicates a string not to be delimited by space characters.
The left bracket is followed by a set of characters and a right
bracket; the characters between the brackets define a set
of characters making up the string.
If the first character
is not circumflex (\|^\|), the input field
is all characters until the first character not in the set between
the brackets; if the first character
after the left bracket is ^, the input field is all characters
until the first character which is in the remaining set of characters
between the brackets.
The corresponding argument must point to a character array.
E 5
I 5
.B f
a floating-point number is expected;
E 8
I 8
.It Cm f
Matches an optionally signed floating-point number;
E 8
the next pointer must be a pointer to
D 8
.BR float .
.TP 4
.B e
equivalent to
.BR f .
.TP 4
.B g
equivalent to
.BR f .
.TP 4
.B E
equivalent to
.BR lf ;
this violates the ANSI C standard X3.159-1989,
E 8
I 8
.Em float .
.It Cm e
Equivalent to
.Cm f .
.It Cm g
Equivalent to
.Cm f .
.It Cm E
Equivalent to
.Cm lf ;
this violates the
.St -ansiC ,
E 8
but is backwards compatible with previous
D 8
.UX
E 8
I 8
.Ux
E 8
systems.
D 8
.TP 4
.B F
equivalent to
.BR lf ;
E 8
I 8
.It Cm F
Equivalent to
.Cm lf ;
E 8
this exists only for backwards compatibility.
D 8
.TP 4
.B s
a string is expected;
E 8
I 8
.It Cm s
Matches a sequence of non-white-space characters;
E 8
the next pointer must be a pointer to
D 8
.BR char ,
and there must be enough room for all the characters in the string,
plus a terminating `\e0'.
E 8
I 8
.Em char ,
and the array must be large enough to accept all the sequence and the
terminating
.Dv NUL
character.
E 8
The input string stops at white space
or at the maximum field width, whichever occurs first.
D 8
.TP 4
.B c
.I width
characters (default 1) are expected;
E 8
I 8
.It Cm c
Matches a sequence of
.Em width
count
characters (default 1);
E 8
the next pointer must be a pointer to
D 8
.BR char ,
E 8
I 8
.Em char ,
E 8
and there must be enough room for all the characters
D 8
(no terminating `\e0' is added).
E 8
I 8
(no terminating
.Dv NUL
is added).
E 8
The usual skip of leading white space is suppressed.
To skip white space first, use an explicit space in the format.
D 8
.TP 4
.B [
a string is expected;
E 8
I 8
.It Cm \&[
Matches a nonempty sequence of characters from the specified set
of accepted characters;
E 8
the next pointer must be a pointer to
D 8
.BR char ,
E 8
I 8
.Em char ,
E 8
and there must be enough room for all the characters in the string,
D 8
plus a terminating `\e0'.
E 8
I 8
plus a terminating
.Dv NUL
character.
E 8
The usual skip of leading white space is suppressed.
The string is to be made up of characters in
(or not in)
a particular set;
the set is defined by the characters between the open bracket
D 8
.B [
E 8
I 8
.Cm [
E 8
character
and a close bracket
D 8
.B ]
E 8
I 8
.Cm ]
E 8
character.
The set
D 8
.I excludes
E 8
I 8
.Em excludes
E 8
those characters
if the first character after the open bracket is a circumflex
D 8
.BR ^ .
E 8
I 8
.Cm ^ .
E 8
To include a close bracket in the set,
make it the first character after the open bracket
or the circumflex;
any other position will end the set.
The hyphen character
D 8
.B \-
E 8
I 8
.Cm -
E 8
is also special;
when placed between two other characters,
it adds all intervening characters to the set.
To include a hyphen,
make it the last character before the final close bracket.
D 8
For instance, `[^]0-9-]'
E 8
I 8
For instance,
.Ql [^]0-9-]
E 8
means the set `everything except close bracket, zero through nine,
and hyphen'.
D 8
The string ends at the first character not in
(or, with a circumflex, in)
the set, or when the field width runs out.
.TP 4
.B p
a pointer value (as printed by `%p' in
.IR printf (3))
is expected;
E 8
I 8
The string ends with the appearance of a character not in the
(or, with a circumflex, in) set
or when the field width runs out.
.It Cm p
Matches a pointer value (as printed by
.Ql %p
in
.Xr printf 3 ) ;
E 8
the next pointer must be a pointer to
D 8
.BR void .
.TP 4
.B n
nothing is expected;
E 8
I 8
.Em void .
.It Cm n
Nothing is expected;
E 8
instead, the number of characters consumed thus far from the input
is stored through the next pointer,
which must be a pointer to
D 8
.BR int .
E 8
I 8
.Em int .
E 8
This is
D 8
.I not
E 8
I 8
.Em not
E 8
a conversion, although it can be suppressed with the
D 8
.B *
E 8
I 8
.Cm *
E 8
flag.
E 5
D 8
.PP
E 8
I 8
.El
.Pp
E 8
D 5
The conversion characters
.BR d ,
.B o
E 5
I 5
For backwards compatibility,
D 8
other conversion characters (except '\e0')
are taken as if they were `%d' or, if uppercase, `%ld',
and a `conversion' of `%\e0' causes an immediate return of
.SM
.BR EOF .
E 8
I 8
other conversion characters (except
.Ql \e0 )
are taken as if they were
.Ql %d
or, if uppercase,
.Ql %ld ,
and a `conversion' of
.Ql %\e0
causes an immediate return of
.Dv EOF .
E 8
The
D 8
.B F
E 8
I 8
.Cm F
E 8
E 5
and
D 5
.B x
D 2
may be capitalized or preceeded by
E 2
I 2
may be capitalized or preceded by
E 2
.B l
to indicate that a pointer to
.B long
rather than to
.B int
is in the argument list.
Similarly, the conversion characters
.B e
or
E 5
I 5
D 8
.B X
E 8
I 8
.Cm X
E 8
conversions will be changed in the future
D 8
to conform to the ANSI C standard,
E 8
I 8
to conform to the
.Tn ANSI
C standard,
E 8
after which they will act like
E 5
D 8
.B f
E 8
I 8
.Cm f
E 8
D 5
may be capitalized or
preceded by
.B l
to indicate a pointer to 
.B double
rather than to 
.BR float .
The conversion characters
.BR d ,
.B o
E 5
and
D 8
.B x
E 8
I 8
.Cm x
E 8
D 2
may be preceeded by
E 2
I 2
D 5
may be preceded by
E 2
.B h
to indicate a pointer to
.B short
rather than to
.BR int .
E 5
I 5
respectively.
E 5
D 8
.PP
The
.I scanf
D 5
functions return the number of successfully matched and assigned input
items.
This can be used to decide how many input items were found.
The constant
E 5
I 5
functions return the number of successfully assigned conversions, or
E 5
.SM
.B EOF
D 5
is returned upon end of input; note that this is different
from 0, which means that no conversion was done;
if conversion was intended, it was frustrated by an
inappropriate character in the input.
.PP
For example, the call
.IP "" 10
int i; float x; char name[50];
.br
scanf("%d%f%s", &i, &x, name);
.PP
with the input line
.IP
25   54.32E\(mi1  thompson
.PP
will assign to
.I i
the value
25,
.I x
the value 5.432, and
.I name
will contain
.IR `thompson\e0' .
Or,
.IP
int i; float x; char name[50];
.br
scanf("%2d%f%*d%[1234567890]", &i, &x, name);
.PP
with input
.IP
56789 0123 56a72
.PP
will assign 56 to
D 2
.I i,
E 2
I 2
.IR i ,
E 2
789.0 to
D 2
.I x,
E 2
I 2
.IR x ,
E 2
skip `0123',
and place the string `56\e0' in
.IR name .
The next call to
.I getchar
will return `a'.
E 5
I 5
if nothing was assigned
before the end of input (or an error during input) was encountered.
A return value of 0
E 8
I 8
.Pp
.Sh RETURN VALUES
These
functions
return
the number of input items assigned, which can be fewer than provided
for, or even zero, in the event of a matching failure.
Zero
E 8
indicates that, while there was input available,
no conversions were assigned;
typically this is due to an invalid input character,
D 8
such as an alphabetic character for a `%d' conversion.
E 5
.SH "SEE ALSO"
D 5
atof(3),
E 5
I 5
strtol(3),
strtoul(3),
E 5
D 2
getc(3), printf(3)
E 2
I 2
D 4
getc(3S),
printf(3S)
E 4
I 4
getc(3),
printf(3)
E 4
E 2
D 5
.SH DIAGNOSTICS
E 5
I 5
.SH "RETURN VALUE"
E 5
The 
.I scanf
functions return
.SM
.B EOF
on end of input,
D 5
and a short count for missing or illegal data items.
E 5
I 5
or a short count for missing or illegal data items.
E 5
.SH BUGS
E 8
I 8
such as an alphabetic character for a
.Ql %d
conversion.
The value
.Dv EOF
is returned if an input failure occurs before any conversion such as an
end-of-file occurs. If an error or end-of-file occurs after conversion
has begun,
the number of conversions which were successfully completed is returned.
.Sh SEE ALSO
.Xr strtol 3 ,
.Xr strtoul 3 ,
I 14
.Xr strtod 3 ,
E 14
.Xr getc 3 ,
.Xr printf 3
I 12
.Sh STANDARDS
The functions
.Fn fscanf ,
.Fn scanf ,
and
.Fn sscanf
conform to
.St -ansiC .
E 12
.Sh HISTORY
D 12
A
.Nm
function appeared in
.At v7 .
E 12
I 12
The functions
.Fn vscanf ,
.Fn vsscanf
and
.Fn vfscanf
are new to this release.
E 12
.Sh BUGS
E 8
D 5
The success of literal matches and suppressed
assignments is not directly
determinable.
E 5
I 5
The current situation with
D 8
.B %F
E 8
I 8
.Cm %F
E 8
and
D 8
.B %X
E 8
I 8
.Cm %X
E 8
conversions is unfortunate.
D 8
.br
E 8
I 8
.Pp
E 8
All of the backwards compatibility formats will be removed in the future.
I 14
D 15
.PP
E 15
I 15
.Pp
E 15
Numerical strings are truncated to 512 characters; for example,
.Cm %f
and
D 16
.Cm
%d
E 16
I 16
.Cm %d
E 16
are implicitly
.Cm %512f
and
.Cm %512d .
E 14
I 6
D 8
.br
E 8
I 8
D 11
.Pp
E 8
There is no
D 8
.I vscanf
E 8
I 8
.Em vscanf
E 8
or
D 8
.IR vsscanf .
E 8
I 8
.Em vsscanf .
E 8
.\" Had to draw the line somewhere!
E 11
E 6
E 5
E 1
