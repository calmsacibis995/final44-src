h55753
s 00002/00002/00205
d D 8.1 93/06/04 13:07:36 bostic 14 13
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00000/00206
d D 6.11 93/04/16 08:40:36 bostic 13 12
c typo
e
s 00006/00000/00200
d D 6.10 93/01/08 17:33:53 bostic 12 11
c add Bentley paper to ref list
e
s 00065/00012/00135
d D 6.9 92/12/02 16:22:26 bostic 11 10
c add in merge sort from Peter McIlroy
e
s 00006/00001/00141
d D 6.8 91/09/23 15:16:55 bostic 10 9
c minor adjustments to explain memory use for heapsort and qsort
e
s 00004/00000/00138
d D 6.7 91/06/29 14:36:51 bostic 9 8
c add ANSI contribution notice
e
s 00057/00012/00081
d D 6.6 91/06/04 10:39:28 bostic 8 7
c add heapsort
e
s 00066/00051/00027
d D 6.5 91/04/19 14:40:37 cael 7 6
c macro and text revision (-mdoc version 3)
e
s 00032/00008/00046
d D 6.4 90/11/26 16:52:50 bostic 6 5
c reimplementation of qsort
c fix so that comparison routine can call qsort
c do insertion sort of each partition at THRESH
c detect already sorted data and skip partition sort
c select a better median in a few cases
c some coding improvements, and lots of comments
e
s 00038/00016/00016
d D 6.3 90/05/16 12:40:47 bostic 5 4
c from the ANSI standard
e
s 00002/00000/00030
d D 6.2 87/04/10 11:59:03 bostic 4 3
c bug report 4.2BSD/lib/51
e
s 00001/00001/00029
d D 6.1 85/05/15 15:44:29 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00004/00007/00026
d D 5.1 85/05/15 15:44:12 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00033/00000/00000
d D 4.1 85/05/15 15:43:54 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 5
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 5
I 5
D 7
.\" Copyright (c) 1990 The Regents of the University of California.
E 7
I 7
D 14
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
E 7
.\" All rights reserved.
E 14
I 14
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 14
E 5
.\"
I 9
.\" This code is derived from software contributed to Berkeley by
.\" the American National Standards Committee X3, on Information
.\" Processing Systems.
.\"
E 9
I 5
.\" %sccs.include.redist.man%
.\"
E 5
D 7
.\"	%W% (Berkeley) %G%
E 7
I 7
.\"     %W% (Berkeley) %G%
E 7
.\"
D 2
.TH QSORT 3 
E 2
I 2
D 3
.TH QSORT 3  "19 January 1983"
E 3
I 3
D 7
.TH QSORT 3  "%Q%"
E 3
E 2
.UC 4
.SH NAME
qsort \- quicker sort
.SH SYNOPSIS
.nf
D 5
.B qsort(base, nel, width, compar)
.B char *base;
.B int (*compar)();
E 5
I 5
.ft B
#include <stdlib.h>

void
qsort(void *base, size_t nmemb, size_t size,
I 6
.RS
.\" have to reset bold font
.ft B
E 6
int (*compar)(const void *, const void *));
I 6
.RE
E 6
.ft R
E 5
.fi
.SH DESCRIPTION
.I Qsort
E 7
I 7
.Dd %Q%
.Dt QSORT 3
.Os
.Sh NAME
D 8
.Nm qsort
.Nd quicker sort
E 8
I 8
D 11
.Nm qsort, heapsort
E 11
I 11
.Nm qsort, heapsort, mergesort
E 11
.Nd sort functions
E 8
.Sh SYNOPSIS
.Fd #include <stdlib.h>
.Ft void
.Fn qsort "void *base" "size_t nmemb" "size_t size" "int (*compar)(const void *, const void *)"
I 8
.Ft int
.Fn heapsort "void *base" "size_t nmemb" "size_t size" "int (*compar)(const void *, const void *)"
I 11
.Ft int
.Fn mergesort "void *base" "size_t nmemb" "size_t size" "int (*compar)(const void *, const void *)"
E 11
E 8
.Sh DESCRIPTION
The
.Fn qsort
D 8
function
E 7
D 2
is an implementation
of the quicker-sort algorithm.
E 2
I 2
D 5
is an implementation of the quicker-sort algorithm.
E 2
The first argument is a pointer to the base of the data;
the second is the number of elements;
D 2
the third is the width of an element
in bytes;
E 2
I 2
the third is the width of an element in bytes;
E 2
the last is the name of the comparison routine
to be called with two arguments which are pointers
to the elements being compared.
D 2
The routine must return
an integer less than, equal to, or greater than 0
E 2
I 2
The routine must return an integer less than, equal to, or greater than 0
E 2
according as the first argument is to be considered
E 5
I 5
D 6
is an implementation of C.A.R. Hoare's ``quicksort'' algorithm.
E 6
I 6
is a modified partition-exchange sort, or quicksort.
E 8
I 8
function is a modified partition-exchange sort, or quicksort.
The
.Fn heapsort
function is a modified selection sort.
I 11
The
.Fn mergesort
function is a modified merge sort with exponential search
intended for sorting data with pre-existing order.
E 11
E 8
E 6
D 7
.PP
E 7
I 7
.Pp
E 7
The
D 7
.I qsort 
E 7
I 7
.Fn qsort
E 7
D 8
function sorts an array of
E 8
I 8
and
.Fn heapsort
functions sort an array of
E 8
D 7
.I nmemb
E 7
I 7
.Fa nmemb
E 7
objects, the initial member of which is pointed to by
D 7
.IR base .
E 7
I 7
.Fa base .
E 7
The size of each object is specified by
D 7
.IR size .
.PP
E 7
I 7
.Fa size .
I 11
.Fn Mergesort
behaves similarly, but
.Em requires
that
.Fa size
be greater than
.Dq "sizeof(void *) / 2" .
E 11
.Pp
E 7
D 11
The contents of the array are sorted in ascending order according to
E 11
I 11
The contents of the array
.Fa base
are sorted in ascending order according to
E 11
a comparison function pointed to by
D 7
.IR compar ,
E 7
I 7
.Fa compar ,
E 7
D 11
which is called with two arguments that point to the objects being
E 11
I 11
which requires two arguments pointing to the objects being
E 11
compared.
D 7
.PP
E 7
I 7
.Pp
E 7
The comparison function must return an integer less than, equal to, or
greater than zero if the first argument is considered to be respectively
E 5
less than, equal to, or greater than the second.
I 5
D 7
.PP
D 6
If two members compare as equal, their order in the sorted array is
undefined.
E 6
I 6
.I Qsort
E 7
I 7
.Pp
D 8
The
E 8
I 8
The functions
E 8
.Fn qsort
D 8
function
E 7
is
E 8
I 8
and
.Fn heapsort
are
E 8
D 7
.B not
E 7
I 7
.Em not
E 7
stable, that is, if two members compare as equal, their order in
the sorted array is undefined.
I 11
The function
.Fn mergesort
is stable.
E 11
D 7
.PP
.I Qsort
E 7
I 7
.Pp
The
.Fn qsort
D 8
function
E 7
is an implementation of C.A.R. Hoare's ``quicksort'' algorithm, a variant
of partition-exchange sorting; in particular, see D.E. Knuth's Algorithm Q.
E 8
I 8
function is an implementation of C.A.R. Hoare's ``quicksort'' algorithm,
a variant of partition-exchange sorting; in particular, see D.E. Knuth's
Algorithm Q.
E 8
D 7
.I Qsort
E 7
I 7
.Fn Qsort
E 7
takes O N lg N average time.
I 8
D 11
This implementation uses median selection to avoid the traditional
E 11
I 11
This implementation uses median selection to avoid its
E 11
O N**2 worst-case behavior.
.Pp
The
.Fn heapsort
function is an implementation of J.W.J. William's ``heapsort'' algorithm,
a variant of selection sorting; in particular, see D.E. Knuth's Algorithm H.
.Fn Heapsort
takes O N lg N worst-case time.
Its
.Em only
advantage over
.Fn qsort
D 10
is that it uses no additional memory.
E 10
I 10
is that it uses almost no additional memory; while
D 11
.Nm qsort
E 11
I 11
.Fn qsort
E 11
does not allocate memory, it is implemented using recursion.
I 11
.Pp
The function
.Fn mergesort
requires additional memory of size
.Fa nmemb *
.Fa size 
bytes; it should be used only when space is not at a premium.
.Fn Mergesort
is optimized for data with pre-existing order; its worst case
time is O N lg N; its best case is O N.
.Pp
Normally,
.Fn qsort
is faster than
.Fn mergesort
is faster than
.Fn heapsort .
Memory availability and pre-existing order in the data can make this
untrue.
E 11
E 10
E 8
D 7
.SH "RETURN VALUES"
.I Qsort 
E 7
I 7
.Sh RETURN VALUES
The
.Fn qsort
function
E 7
returns no value.
I 8
.Pp
Upon successful completion,
.Fn heapsort
D 11
returns 0.
Otherwise, it returns \-1 and the global variable
E 11
I 11
and
.Fn mergesort
return 0.
Otherwise, they return \-1 and the global variable
E 11
.Va errno
is set to indicate the error.
.Sh ERRORS
The
.Fn heapsort
function succeeds unless:
.Bl -tag -width Er
.It Bq Er EINVAL
The
.Fa size
D 11
argument is zero.
E 11
I 11
argument is zero, or,
the
.Fa size
argument to
.Fn mergesort
is less than
.Dq "sizeof(void *) / 2" .
E 11
I 10
.It Bq Er ENOMEM
D 11
.Nm Heapsort
failed because it was unable to allocate memory.
E 11
I 11
.Fn Heapsort
or
.Fn mergesort
were unable to allocate memory.
.El
E 11
E 10
E 8
D 7
.SH COMPATIBILITY
E 7
I 7
.Sh COMPATIBILITY
E 7
Previous versions of
D 7
.I qsort
E 7
I 7
.Fn qsort
E 7
D 11
did not permit the comparison routine to itself call
E 11
I 11
did not permit the comparison routine itself to call
E 11
D 7
.IR qsort (3).
E 7
I 7
.Fn qsort 3 .
E 7
This is no longer true.
E 6
E 5
D 7
.SH "SEE ALSO"
D 6
sort(1)
E 6
I 6
sort(1), radixsort(3)
.sp
Hoare, C.A.R. [1962]. "Quicksort", The Computer Journal, 5:1, pp. 10-15.
.br
Knuth, D.E. [1968]. "The Art of Computer Programming Vol. 3: Sorting and
Searching", pp. 114-123.
E 6
I 5
.SH STANDARDS
D 6
.B Qsort
E 6
I 6
.I Qsort
E 6
conforms to ANSI X3.159-1989 (``ANSI C'').
E 7
I 7
.Sh SEE ALSO
.Xr sort 1 ,
.Xr radixsort 3
.Rs
.%A Hoare, C.A.R.
.%D 1962
.%T "Quicksort"
.%J "The Computer Journal"
.%V 5:1
.%P pp. 10-15
.Re
I 13
.Rs
E 13
D 11
.Rs
E 11
I 8
.%A Williams, J.W.J
.%D 1964
.%T "Heapsort"
.%J "Communications of the ACM"
.%V 7:1
.%P pp. 347-348
.Re
.Rs
E 8
.%A Knuth, D.E.
.%D 1968
.%B "The Art of Computer Programming"
.%V Vol. 3
.%T "Sorting and Searching"
D 8
.%P pp. 114-123
E 8
I 8
.%P pp. 114-123, 145-149
I 11
.Re
.Rs
.%A Mcilroy, P.M.
.%T "Optimistic Sorting and Information Theoretic Complexity"
.%J "Fourth Annual ACM-SIAM Symposium on Discrete Algorithms"
.%V January 1992
E 11
E 8
.Re
I 12
.Rs
.%A Bentley, J.L.
.%T "Engineering a Sort Function"
.%J "bentley@research.att.com"
.%V January 1992
.Re
E 12
.Sh STANDARDS
The
.Fn qsort
function
conforms to
.St -ansiC .
E 7
E 5
I 4
D 6
.SH BUGS
D 5
The comparison routine may not itself call \fIqsort\fP.
E 5
I 5
The comparison routine may not itself call
.IR qsort (3).
E 6
E 5
E 4
E 1
