h46413
s 00001/00001/00128
d D 8.2 93/12/11 22:38:05 mckusick 13 12
c copyediting for Usenix manuals
e
s 00002/00002/00127
d D 8.1 93/06/04 15:12:03 bostic 12 11
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00119/00099/00010
d D 6.9 91/04/19 14:40:47 cael 11 10
c macro and text revision (-mdoc version 3)
e
s 00003/00004/00106
d D 6.8 90/06/24 14:08:35 bostic 10 9
c fold strn{casecmp,cat,cmp,cpy}.3 into str{casecmp,cat,cmp,cpy}.3
e
s 00002/00001/00108
d D 6.7 90/06/24 12:43:28 bostic 9 8
c cleanup, strlen returns size_t, strsep arg1 is char **
e
s 00125/00069/00012
d D 6.6 90/05/15 15:33:28 bostic 8 7
c new version, reference specific man pages
e
s 00030/00051/00051
d D 6.5 87/10/22 11:59:10 bostic 7 6
c give s1/s2 meaningful names if ambiguous
e
s 00003/00003/00099
d D 6.4 87/08/03 17:18:32 bostic 6 5
c change strcasencmp to strncasecmp
e
s 00011/00002/00091
d D 6.3 87/07/02 09:28:15 bostic 5 4
c added strcasecmp() and strcasencmp()
e
s 00002/00006/00091
d D 6.2 87/04/25 14:04:33 bostic 4 3
c bug report 4.2BSD/man/31
e
s 00001/00001/00096
d D 6.1 85/05/15 15:52:52 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00010/00019/00087
d D 5.1 85/05/15 15:52:37 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00106/00000/00000
d D 4.1 85/05/15 15:52:25 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 8
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 8
I 8
D 11
.\" Copyright (c) 1990 The Regents of the University of California.
E 11
I 11
D 12
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
E 11
.\" All rights reserved.
E 12
I 12
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 12
E 8
.\"
I 8
.\" This code is derived from software contributed to Berkeley by
.\" Chris Torek.
D 11
.\"
E 11
.\" %sccs.include.redist.man%
.\"
E 8
D 11
.\"	%W% (Berkeley) %G%
E 11
I 11
.\"     %W% (Berkeley) %G%
E 11
.\"
D 2
.TH STRING 3 
E 2
I 2
D 3
.TH STRING 3  "19 January 1983"
E 3
I 3
D 8
.TH STRING 3  "%Q%"
E 8
I 8
D 11
.TH STRING 3 "%Q%"
E 8
E 3
E 2
.UC 4
.SH NAME
D 5
strcat, strncat, strcmp, strncmp, strcpy, strncpy, strlen, index, rindex \- string operations
E 5
I 5
D 6
strcat, strncat, strcmp, strncmp, strcasecmp, strcasencmp, strcpy,
E 6
I 6
D 8
strcat, strncat, strcmp, strncmp, strcasecmp, strncasecmp, strcpy,
E 6
strncpy, strlen, index, rindex \- string operations
E 8
I 8
strcat, strncat, strchr, strrchr, strcmp, strncmp, strcasecmp,
strncasecmp, strcpy, strncpy, strerror, strlen, strpbrk, strsep,
strspn, strcspn, strstr, strtok, index, rindex \- string operations
E 8
E 5
.SH SYNOPSIS
.nf
I 2
D 8
.B #include <strings.h>
.PP
E 2
D 7
.B char *strcat(s1, s2)
.B char *s1, *s2;
E 7
I 7
.B char *strcat(s, append)
.B char *s, *append;
E 7
.PP
D 7
.B char *strncat(s1, s2, n)
.B char *s1, *s2;
E 7
I 7
.B char *strncat(s, append, count)
.B char *s, *append;
.B int count;
E 7
.PP
.B strcmp(s1, s2)
.B char *s1, *s2;
.PP
D 7
.B strncmp(s1, s2, n)
E 7
I 7
.B strncmp(s1, s2, count)
E 7
.B char *s1, *s2;
I 7
.B int count;
E 7
.PP
I 5
.B strcasecmp(s1, s2)
.B char *s1, *s2;
.PP
D 6
.B strcasencmp(s1, s2, n)
E 6
I 6
D 7
.B strncasecmp(s1, s2, n)
E 7
I 7
.B strncasecmp(s1, s2, count)
E 7
E 6
.B char *s1, *s2;
I 7
.B int count;
E 7
.PP
E 5
D 7
.B char *strcpy(s1, s2)
.B char *s1, *s2;
E 7
I 7
.B char *strcpy(to, from)
.B char *to, *from;
E 7
.PP
D 7
.B char *strncpy(s1, s2, n)
.B char *s1, *s2;
E 7
I 7
.B char *strncpy(to, from, count)
.B char *to, *from;
.B int count;
E 7
.PP
.B strlen(s)
.B char *s;
.PP
.B char *index(s, c)
.B char *s, c;
.PP
.B char *rindex(s, c)
.B char *s, c;
E 8
I 8
.ft B
#include <string.h>

char *
strcat(char *s, const char * append);

char *
strncat(char *s, const char *append, size_t count);

char *
strchr(const char *s, int c);

char *
strrchr(const char *s, int c);

strcmp(const char *s1, const char *s2);

strncmp(const char *s1, const char *s2, size_t count);

strcasecmp(const char *s1, const char *s2);

strncasecmp(const char *s1, const char *s2, size_t count);

char *
strcpy(char *dst, const char *src);

char *
strncpy(char *dst, const char *src, size_t count);

char *
strerror(int errno);

I 9
size_t
E 9
strlen(const char *s);

char *
strpbrk(const char *s, const char *charset);

char *
D 9
strsep(char *stringp, const char *delim);
E 9
I 9
strsep(char **stringp, const char *delim);
E 9

size_t
strspn(const char *s, const char *charset);

size_t
strcspn(const char *s, const char *charset);

char *
strstr(const char *big, const char *little);

char *
strtok(char *s, const char *delim);

char *
index(const char *s, int c);

char *
rindex(const char *s, int c);
.ft R
E 8
.fi
.SH DESCRIPTION
These functions operate on null-terminated strings.
D 8
They do not check for overflow of any receiving string.
E 8
.PP
E 11
I 11
.Dd %Q%
.Dt STRING 3
.Os BSD 4
.Sh NAME
.Nm strcat ,
.Nm strncat ,
.Nm strchr ,
.Nm strrchr ,
.Nm strcmp ,
.Nm strncmp ,
.Nm strcasecmp,
.Nm strncasecmp ,
.Nm strcpy ,
.Nm strncpy ,
.Nm strerror ,
.Nm strlen ,
.Nm strpbrk ,
.Nm strsep,
.Nm strspn ,
.Nm strcspn ,
.Nm strstr ,
.Nm strtok ,
.Nm index ,
.Nm rindex
.Nd string specific functions
.Sh SYNOPSIS
.Fd #include <string.h>
.Ft char *
.Fn strcat "char *s" "const char * append"
.Ft char *
.Fn strncat "char *s" "const char *append" "size_t count"
.Ft char *
.Fn strchr "const char *s" "int c"
.Ft char *
.Fn strrchr "const char *s" "int c"
.Ft int
.Fn strcmp "const char *s1" "const char *s2"
.Ft int
.Fn strncmp "const char *s1" "const char *s2" "size_t count"
.Ft int
.Fn strcasecmp "const char *s1" "const char *s2"
.Ft int
.Fn strncasecmp "const char *s1" "const char *s2" "size_t count"
.Ft char *
.Fn strcpy "char *dst" "const char *src"
.Ft char *
.Fn strncpy "char *dst" "const char *src" "size_t count"
.Ft char *
.Fn strerror "int errno"
.Ft size_t
.Fn strlen "const char *s"
.Ft char *
.Fn strpbrk "const char *s" "const char *charset"
.Ft char *
.Fn strsep "char **stringp" "const char *delim"
.Ft size_t
.Fn strspn "const char *s" "const char *charset"
.Ft size_t
.Fn strcspn "const char *s" "const char *charset"
.Ft char *
.Fn strstr "const char *big" "const char *little"
.Ft char *
.Fn strtok "char *s" "const char *delim"
.Ft char *
.Fn index "const char *s" "int c"
.Ft char *
.Fn rindex "const char *s" "int c"
.Sh DESCRIPTION
D 13
The string functions
E 13
I 13
The string
E 13
functions manipulate strings terminated by a
null byte.
.Pp
E 11
D 7
.I Strcat
appends a copy of string
.I s2
to the end of string
.IR s1 .
.I Strncat
copies at most
.I n
D 2
characters.
Both return a pointer to the null-terminated result.
E 2
I 2
characters.  Both return a pointer to the null-terminated result.
E 7
I 7
D 8
\fIStrcat\fP appends a copy of string \fIappend\fP to the end of string
\fIs\fP. \fIStrncat\fP copies at most \fIcount\fP characters.  Both
return a pointer to the null-terminated result.
E 8
I 8
See the specific manual pages for more information.
E 8
E 7
E 2
D 11
.PP
E 11
I 11
For manipulating variable length generic objects as byte
strings (without the null byte check), see
.Xr bstring 3 .
.Pp
E 11
D 7
.I Strcmp
compares its arguments and returns an integer
D 2
greater than, equal to, or less than 0,
according as
E 2
I 2
greater than, equal to, or less than 0, according as
E 2
.I s1
D 2
is lexicographically greater than, equal to, or
less than
E 2
I 2
is lexicographically greater than, equal to, or less than
E 2
.IR s2 .
.I Strncmp
makes the same comparison but looks at at most
.I n
D 5
characters.
E 5
I 5
D 6
characters.  \fIStrcasecmp\fP and \fIstrcasencmp\fP are identical
E 6
I 6
characters.  \fIStrcasecmp\fP and \fIstrncasecmp\fP are identical
E 6
in function, but are case insensitive.  The returned lexicographic
difference reflects a conversion to lower-case.
E 7
I 7
D 8
\fIStrcmp\fP compares its arguments and returns an integer greater than,
equal to, or less than 0, according as \fIs1\fP is lexicographically
greater than, equal to, or less than \fIs2\fP.  \fIStrncmp\fP makes the
same comparison but looks at at most \fIcount\fP characters.
\fIStrcasecmp\fP and \fIstrncasecmp\fP are identical in function, but are
case insensitive.  The returned lexicographic difference reflects a
conversion to lower-case.
E 7
E 5
.PP
D 7
.I Strcpy
copies string
.I s2
to
.I s1,
stopping after the null character has been moved.
.I Strncpy
copies exactly
.I n
D 2
characters,
truncating or null-padding
E 2
I 2
characters, truncating or null-padding
E 2
.I s2;
D 2
the target may not be null-terminated if the length
of
E 2
I 2
the target may not be null-terminated if the length of
E 2
.I s2
is
.I n
D 2
or more.
Both return
E 2
I 2
or more.  Both return
E 2
.IR s1 .
E 7
I 7
\fIStrcpy\fP copies string \fIfrom\fP to \fIto\fP, stopping after the
null character has been moved.  \fIStrncpy\fP copies exactly \fIcount\fP
characters, appending nulls if \fIfrom\fP is less than \fIcount\fP
characters in length; the target may not be null-terminated if the
length of \fIfrom\fP is \fIcount\fP or more.  Both return \fIto\fP.
E 7
.PP
D 7
.I Strlen
returns the number of non-null characters in
.IR s .
E 7
I 7
\fIStrlen\fP returns the number of non-null characters in \fIs\fP.
E 7
.PP
.I Index
.RI ( rindex )
D 2
returns a pointer to the first (last)
occurrence of character 
E 2
I 2
returns a pointer to the first (last) occurrence of character 
E 2
D 4
.I c
in string
.I s,
or zero if
.I c
does not occur in  the string.
E 4
I 4
\fIc\fP in string \fIs\fP or zero if \fIc\fP does not occur in
the string.  Setting \fIc\fP to NULL works.
E 8
I 8
Except as noted in their specific manual pages,
D 11
they do not check for overflow of any destination
string.
.SH SEE\ ALSO
D 10
index(3), strcat(3), strncat(3), strchr(3), strrchr(3), strcmp(3),
strncmp(3), strcasecmp(3), strncasecmp(3), strcpy(3), strncpy(3),
strerror(3), strlen(3), strpbrk(3), strsep(3), strspn(3), strcspn(3),
strstr(3), strtok(3), rindex(3)
E 10
I 10
index(3), strcat(3), strchr(3), strrchr(3), strcmp(3), strcasecmp(3),
strcpy(3), strerror(3), strlen(3), strpbrk(3), strsep(3), strspn(3),
strcspn(3), strstr(3), strtok(3), rindex(3)
E 10
.SH STANDARDS
.IR Strcat ,
.IR strncat ,
.IR strchr ,
.IR strrchr ,
.IR strcmp ,
.IR strncmp ,
.IR strcpy ,
.IR strncpy ,
.IR strerror ,
.IR strlen ,
.IR strpbrk ,
.IR strsep ,
.IR strspn ,
.IR strcspn ,
.IR strstr ,
E 11
I 11
the string functions do not test the destination
for size limitations.
.Sh SEE ALSO
.Xr index 3 ,
.Xr strcat 3 ,
.Xr strchr 3 ,
.Xr strrchr 3 ,
.Xr strcmp 3 ,
.Xr strcasecmp 3 ,
.Xr strcpy 3 ,
.Xr strerror 3 ,
.Xr strlen 3 ,
.Xr strpbrk 3 ,
.Xr strsep 3 ,
.Xr strspn 3 ,
.Xr strcspn 3 ,
.Xr strstr 3 ,
.Xr strtok 3 ,
.Xr rindex 3
.Xr bstring 3
.Sh STANDARDS
The
.Fn strcat ,
.Fn strncat ,
.Fn strchr ,
.Fn strrchr ,
.Fn strcmp ,
.Fn strncmp ,
.Fn strcpy ,
.Fn strncpy ,
.Fn strerror ,
.Fn strlen ,
.Fn strpbrk ,
.Fn strsep ,
.Fn strspn ,
.Fn strcspn ,
.Fn strstr ,
E 11
and
D 11
.IR strtok
conform to ANSI X3.159-1989 (``ANSI C'').
E 11
I 11
.Fn strtok
functions
conform to
.St -ansiC .
E 11
E 8
E 4
D 2
.SH BUGS
.I Strcmp 
uses native character comparison, which is signed
on PDP11's and VAX-11's, unsigned on other machines.
E 2
E 1
