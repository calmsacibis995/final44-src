h00424
s 00002/00001/00177
d D 8.5 94/04/02 11:37:25 pendry 16 15
c 16 isn't the iov limit, it's UIO_MAXIOV
e
s 00001/00001/00177
d D 8.4 94/02/21 17:06:08 bostic 15 14
c add const to readv/writev declarations
e
s 00001/00001/00177
d D 8.3 94/02/21 16:36:57 bostic 14 13
c make readv and writev return ssize_t's
e
s 00003/00002/00175
d D 8.2 94/02/21 09:02:11 bostic 13 12
c change iov_len to be a size_t, not an int
e
s 00002/00002/00175
d D 8.1 93/06/04 13:20:56 bostic 12 11
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00001/00176
d D 6.8 92/05/04 15:35:13 bostic 11 10
c EWOULDBLOCK -> EAGAIN (POSIX)
e
s 00003/00003/00174
d D 6.7 92/04/29 09:21:42 bostic 10 8
c read and write take void *'s, iovec's contain void *'s
e
s 00001/00001/00176
d R 6.7 92/04/29 09:16:19 bostic 9 8
c read and write take void *'s, iovec's contain void *'s
e
s 00115/00109/00062
d D 6.6 91/03/10 23:41:43 cael 8 7
c man page macro and text revisions (-mdoc version 3)
e
s 00014/00001/00157
d D 6.5 86/05/14 11:11:20 karels 7 6
c nonblocking I/O, fcntl, select
e
s 00066/00010/00092
d D 6.4 86/02/24 03:33:20 lepreau 6 5
c lseek doesn't mind negative offsets, read & write do;
c bring write.2 up to read.2 stds.
e
s 00011/00000/00091
d D 6.3 85/08/26 23:31:18 mckusick 5 4
c update error messages (mostly from sun!guy)
e
s 00001/00001/00090
d D 6.2 85/06/30 17:09:12 sechrest 4 3
c improved english
e
s 00001/00001/00090
d D 6.1 85/05/09 16:08:28 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00069/00062/00022
d D 5.1 85/05/09 16:08:18 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00084/00000/00000
d D 4.1 85/05/09 16:08:12 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 8
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 8
I 8
D 12
.\" Copyright (c) 1980, 1991 Regents of the University of California.
.\" All rights reserved.
E 12
I 12
.\" Copyright (c) 1980, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 12
E 8
.\"
D 8
.\"	%W% (Berkeley) %G%
E 8
I 8
.\" %sccs.include.redist.man%
E 8
.\"
D 2
.TH WRITE 2 
E 2
I 2
D 3
.TH WRITE 2 "27 July 1983"
E 3
I 3
D 8
.TH WRITE 2 "%Q%"
E 3
E 2
.UC 4
.SH NAME
D 2
write \- write on a file
E 2
I 2
D 6
write, writev \- write on a file
E 6
I 6
write, writev \- write output
E 6
E 2
.SH SYNOPSIS
.nf
D 2
.B write(fildes, buffer, nbytes)
.B char *buffer;
E 2
I 2
.ft B
D 6
write(d, buf, nbytes)
int d;
E 6
I 6
cc = write(d, buf, nbytes)
int cc, d;
E 6
char *buf;
int nbytes;
.PP
.ft B
#include <sys/types.h>
#include <sys/uio.h>
.PP
.ft B
D 6
writev(d, iov, ioveclen)
int d;
E 6
I 6
cc = writev(d, iov, iovcnt)
int cc, d;
E 6
struct iovec *iov;
D 6
int ioveclen;
E 6
I 6
int iovcnt;
E 6
E 2
.fi
.SH DESCRIPTION
D 2
A file descriptor is a word returned from a
successful
.I open,
.I creat,
.I dup,
or
.IR pipe (2)
call.
.PP
.I Buffer
is the address of
E 2
I 2
.I Write
E 8
I 8
.\"     %W% (Berkeley) %G%
.\"
.Dd %Q%
.Dt WRITE 2
.Os BSD 4
.Sh NAME
.Nm write ,
.Nm writev
.Nd write output
.Sh SYNOPSIS
D 13
.Fd #include <unistd.h>
E 13
.Fd #include <sys/types.h>
.Fd #include <sys/uio.h>
I 13
.Fd #include <unistd.h>
E 13
.Ft ssize_t
D 10
.Fn write "int d" "const char *buf" "size_t nbytes"
E 10
I 10
.Fn write "int d" "const void *buf" "size_t nbytes"
E 10
D 14
.Ft int
E 14
I 14
.Ft ssize_t
E 14
D 15
.Fn writev "int d" "struct iovec *iov" "int iovcnt"
E 15
I 15
.Fn writev "int d" "const struct iovec *iov" "int iovcnt"
E 15
.Sh DESCRIPTION
.Fn Write
E 8
attempts to write
E 2
D 8
.I nbytes
E 8
I 8
.Fa nbytes
E 8
D 2
contiguous
bytes which are written on the output file.
The number of characters actually written is returned.
It should be regarded as an error
if this is not the same as requested.
E 2
I 2
of data to the object referenced by the descriptor
D 8
.I d
E 8
I 8
.Fa d
E 8
from the buffer pointed to by
D 8
.IR buf .
.I Writev
E 8
I 8
.Fa buf .
.Fn Writev
E 8
performs the same action, but gathers the output data
D 6
from the \fIiovlen\fP buffers specified by the members
of the \fIiovec\fP array: iov[0], iov[1], etc.
E 6
I 6
from the 
D 8
.I iovcnt
E 8
I 8
.Fa iovcnt
E 8
buffers specified by the members of the
D 8
.I iov
array: iov[0], iov[1], ..., iov[iovcnt\|\-\|1].
E 6
E 2
.PP
E 8
I 8
.Fa iov
array: iov[0], iov[1], ..., iov[iovcnt\|-\|1].
.Pp
E 8
I 6
For 
D 8
.IR writev ,
E 8
I 8
.Fn writev ,
E 8
the 
D 8
.I iovec
structure is defined as
.PP
.nf
.RS
.DT
E 8
I 8
.Fa iovec
structure is defined as:
I 13
.Pp
E 13
.Bd -literal -offset indent -compact
E 8
struct iovec {
D 10
	caddr_t	iov_base;
	int	iov_len;
E 10
I 10
	void *iov_base;
D 13
	int iov_len;
E 13
I 13
	size_t iov_len;
E 13
E 10
};
D 8
.RE
.fi
.PP
E 8
I 8
.Ed
.Pp
E 8
Each 
D 8
.I iovec
E 8
I 8
.Fa iovec
E 8
entry specifies the base address and length of an area
in memory from which data should be written.
D 8
.I Writev
E 8
I 8
.Fn Writev
E 8
will always write a complete area before proceeding
to the next.
D 8
.PP
E 6
D 2
Writes which are multiples
of 1024 characters long and begin on a 1024-byte boundary
in the file
are more efficient than any others.
E 2
I 2
On objects capable of seeking, the \fIwrite\fP starts at a position
E 8
I 8
.Pp
On objects capable of seeking, the
.Fn write
starts at a position
E 8
given by the pointer associated with
D 8
.IR d ,
E 8
I 8
.Fa d ,
E 8
see
D 8
.IR lseek (2).
E 8
I 8
.Xr lseek 2 .
E 8
Upon return from
D 8
.IR write ,
the pointer is incremented by the number of bytes actually written.
E 2
.PP
E 8
I 8
.Fn write ,
the pointer is incremented by the number of bytes which were written.
.Pp
E 8
D 2
.IR Write s
to the control terminal by a process
which is not in the process group of the termainl
and which is not ignoring or holding SIGTTOU signals
cause the writer's process group
to receive a SIGTTOU signal
(See
.IR jobs (3)
and the description of the LTOSTOP option in
.IR tty (4)
for details).
E 2
I 2
Objects that are not capable of seeking always write from the current
position.  The value of the pointer associated with such an object
is undefined.
E 2
D 8
.PP
E 8
I 8
.Pp
E 8
D 2
On some systems
E 2
I 2
If the real user is not the super-user, then
E 2
D 8
.I write
E 8
I 8
.Fn write
E 8
clears the set-user-id bit on a file.
This prevents penetration of system security
by a user who
D 2
\*(lqcaptures\*(rq a writeable set-user-id file
E 2
I 2
D 8
\*(lqcaptures\*(rq a writable set-user-id file
E 8
I 8
.Dq captures
a writable set-user-id file
E 8
E 2
owned by the super-user.
I 7
D 8
.PP
E 8
I 8
.Pp
E 8
When using non-blocking I/O on objects such as sockets that are subject
to flow control,
D 8
.I write
E 8
I 8
.Fn write
E 8
and
D 8
.I writev
E 8
I 8
.Fn writev
E 8
may write fewer bytes than requested;
the return value must be noted,
and the remainder of the operation should be retried when possible.
E 7
I 2
D 8
.SH "RETURN VALUE
D 6
Upon successful completion the number of bytes actually writen
is returned.  Otherwise a \-1 is returned and
E 6
I 6
Upon successful completion the number of bytes actually written
is returned.  Otherwise a \-1 is returned and the global variable
E 6
.I errno
E 8
I 8
.Sh RETURN VALUES
Upon successful completion the number of bytes which were written
is returned.  Otherwise a -1 is returned and the global variable
.Va errno
E 8
is set to indicate the error.
D 8
.SH ERRORS
.I Write
E 8
I 8
.Sh ERRORS
.Fn Write
E 8
I 6
and
D 8
.I writev
E 6
will fail and the file pointer will remain unchanged if one or more
of the following are true:
.TP 15
[EBADF]
\fID\fP is not a valid descriptor open for writing.
.TP 15
[EPIPE]
E 8
I 8
.Fn writev
will fail and the file pointer will remain unchanged if:
.Bl -tag -width Er
.It Bq Er EBADF
.Fa D
is not a valid descriptor open for writing.
.It Bq Er EPIPE
E 8
An attempt is made to write to a pipe that is not open
for reading by any process.
D 8
.TP 15
[EPIPE]
An attempt is made to write to a socket of type SOCK_STREAM
E 8
I 8
.It Bq Er EPIPE
An attempt is made to write to a socket of type
.DV SOCK_STREAM
E 8
D 4
which is not connected to a peer socket.
E 4
I 4
that is not connected to a peer socket.
E 4
D 8
.TP 15
[EFBIG]
E 8
I 8
.It Bq Er EFBIG
E 8
An attempt was made to write a file that exceeds the process's
file size limit or the maximum file size.
D 8
.TP 15
[EFAULT]
Part of \fIiov\fP or data to be written to the file
E 8
I 8
.It Bq Er EFAULT
Part of
.Fa iov
or data to be written to the file
E 8
points outside the process's allocated address space.
I 5
D 8
.TP 15
I 6
[EINVAL]
E 8
I 8
.It Bq Er EINVAL
E 8
The pointer associated with
D 8
.I d
E 8
I 8
.Fa d
E 8
was negative.
D 8
.TP 15
E 6
[ENOSPC]
E 8
I 8
.It Bq Er ENOSPC
E 8
There is no free space remaining on the file system
containing the file.
D 8
.TP 15
[EDQUOT]
E 8
I 8
.It Bq Er EDQUOT
E 8
The user's quota of disk blocks on the file system
containing the file has been exhausted.
D 8
.TP 15
[EIO]
E 8
I 8
.It Bq Er EIO
E 8
An I/O error occurred while reading from or writing to the file system.
I 7
D 8
.TP 15
[EWOULDBLOCK]
E 8
I 8
D 11
.It Bq Er EWOULDBLOCK
E 11
I 11
.It Bq Er EAGAIN
E 11
E 8
The file was marked for non-blocking I/O,
and no data could be written immediately.
E 7
I 6
D 8
.PP
E 8
I 8
.El
.Pp
E 8
In addition, 
D 8
.I writev
E 8
I 8
.Fn writev
E 8
may return one of the following errors:
D 8
.TP 15
[EINVAL]
.I Iovcnt
E 8
I 8
.Bl -tag -width Er
.It Bq Er EINVAL
.Fa Iovcnt
E 8
D 16
was less than or equal to 0, or greater than 16.
E 16
I 16
was less than or equal to 0, or greater than
.Dv UIO_MAXIOV .
E 16
D 8
.TP 15
[EINVAL]
E 8
I 8
.It Bq Er EINVAL
E 8
One of the
D 8
.I iov_len
E 8
I 8
.Fa iov_len
E 8
values in the
D 8
.I iov
E 8
I 8
.Fa iov
E 8
array was negative.
D 8
.TP 15
[EINVAL]
E 8
I 8
.It Bq Er EINVAL
E 8
The sum of the
D 8
.I iov_len
E 8
I 8
.Fa iov_len
E 8
values in the
D 8
.I iov
E 8
I 8
.Fa iov
E 8
array overflowed a 32-bit integer.
E 6
E 5
E 2
D 8
.SH "SEE ALSO"
D 2
creat(2), open(2), pipe(2)
.SH DIAGNOSTICS
Returns
\-1 on error: bad descriptor, buffer address, or
count; physical I/O errors.
.SH "ASSEMBLER (PDP-11)"
(write = 4.)
.br
(file descriptor in r0)
.br
.B sys  write; buffer; nbytes
.br
(byte count in r0)
.SH BUGS
It would be nice to be able to call write and have the call return
with an error indication if there was no buffer space for the written
data, rather than blocking the process.
.PP
Processes which have been orphaned by their parents
and have been inherited by
.IR init (8)
never receive SIGTTOU signals.
Output by such a process
is permitted even when they are not in the process group
of the control terminal.
E 2
I 2
D 7
lseek(2), open(2), pipe(2)
E 7
I 7
fcntl(2), lseek(2), open(2), pipe(2), select(2)
E 8
I 8
.El
.Sh SEE ALSO
.Xr fcntl 2 ,
.Xr lseek 2 ,
.Xr open 2 ,
.Xr pipe 2 ,
.Xr select 2
.Sh STANDARDS
.Fn Write
is expected to conform to IEEE Std 1003.1-1988
.Pq Dq Tn POSIX .
.Sh HISTORY
The
.Fn writev
function call
appeared in
.Bx 4.2 .
A
.Nm write
function call
appeared in
Version 6 AT&T UNIX.
E 8
E 7
E 2
E 1
