h48078
s 00000/00000/00247
d D 8.1 93/06/04 17:16:54 bostic 7 6
c 4.4BSD snapshot (revision 8.1)
e
s 00003/00003/00244
d D 6.6 91/04/19 19:12:30 bostic 6 5
c new copyright; att/bsd/shared
e
s 00231/00143/00016
d D 6.5 91/04/19 14:50:31 cael 5 4
c macro and text revision (-mdoc version 3)
e
s 00002/00002/00157
d D 6.4 86/06/04 14:37:07 mckusick 4 3
c needs a date
e
s 00001/00001/00158
d D 6.3 86/05/27 11:14:53 kjd 3 2
c add comma
e
s 00090/00034/00069
d D 6.2 86/03/13 18:24:26 donn 2 1
c Added copyright and sccs keywords.  Updated it to cover more of the
c routines in the package and to fix syntax and other fluff.
e
s 00103/00000/00000
d D 6.1 86/03/13 18:12:22 donn 1 0
c date and time created 86/03/13 18:12:22 by donn
e
u
U
t
T
I 2
D 5
.\" Copyright (c) 1986 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 5
I 5
D 6
.\" Copyright (c) 1986, 1991 Regents of the University of California.
E 6
I 6
.\" Copyright (c) 1986, 1991 The Regents of the University of California.
E 6
.\" All rights reserved.
E 5
.\"
D 5
.\"	%W% (Berkeley) %G%
E 5
I 5
D 6
.\" %sccs.include.redist.man%
E 6
I 6
.\" %sccs.include.proprietary.roff%
E 6
E 5
.\"
E 2
I 1
D 4
.TH MP 3X
.UC
E 4
I 4
D 5
.TH MP 3X "%Q%"
.UC 6
E 4
.SH NAME
D 2
itom, mcmp, m_in, m_out, madd, msub, mult, mdiv, min, mout,
pow, gcd, rpow \- multiple precision integer arithmetic
E 2
I 2
madd, msub, mult, mdiv, pow, gcd, invert, rpow, msqrt, mcmp,
move, min, omin, fmin, m_in, mout, omout, fmout, m_out, sdiv, itom
\- multiple precision integer arithmetic
E 2
.SH SYNOPSIS
.nf
.B #include <mp.h>
D 2
.sp
E 2
I 2
.B #include <stdio.h>
.PP
E 2
.B "typedef struct mint { int len; short *val; } MINT;"
.PP
D 2
.PP
E 2
.B madd(a, b, c)
.B msub(a, b, c)
.B mult(a, b, c)
.B mdiv(a, b, q, r)
D 2
.B min(a)
.B mout(a)
E 2
.B pow(a, b, m, c)
.B gcd(a, b, c)
I 2
.B invert(a, b, c)
E 2
.B rpow(a, n, c)
.B msqrt(a, b, r)
D 2
.B mcmp(a,b)
E 2
I 2
.B mcmp(a, b)
.B move(a, b)
.B min(a)
.B omin(a)
.B fmin(a, f)
.B m_in(a, n, f)
.B mout(a)
.B omout(a)
.B fmout(a, f)
.B m_out(a, n, f)
E 2
.B MINT *a, *b, *c, *m, "*q, *r;"
I 2
.B FILE *f;
E 2
.B int n;
.PP
D 2
.B
E 2
.B sdiv(a, n, q, r)
.B MINT *a, *q;
I 2
.B short n;
E 2
.B short *r;
.PP
.B MINT *itom(n)
D 2
.PP
.B cc ... \-lmp
E 2
.SH DESCRIPTION
These routines perform arithmetic on integers of
arbitrary length.
The integers are stored using the defined type
.IR MINT .
D 2
Pointers to
a
E 2
I 2
Pointers to a
E 2
.I MINT
can be initialized using the function
.I itom
which sets the initial value to
.IR n .
D 3
After that space is managed automatically by the routines.
E 3
I 3
After that, space is managed automatically by the routines.
E 3
.PP
D 2
.IR madd , " msub" , " mult" ,
assign to their third arguments the sum, difference, and
product, respectively, of their first two arguments.
E 2
I 2
.IR madd , " msub " and " mult"
assign to
.I c
the sum, difference and
product, respectively, of
.IR a " and " b .
E 2
.I mdiv
D 2
assigns the quotient and remainder, respectively,
to its third and fourth arguments.
E 2
I 2
assigns to
.IR q " and " r
the quotient and remainder obtained
from dividing
.IR a " by " b.
E 2
.I sdiv
is like
.I mdiv
D 2
except that the divisor is an ordinary integer.
E 2
I 2
except that the divisor is a short integer
.I n
and the remainder is placed in a short
whose address is given as
.IR r .
E 2
.I msqrt
D 2
produces the square root and remainder of its first argument.
E 2
I 2
produces the integer square root of
.IR a " in " b
and places the remainder in
.IR r .
E 2
.I rpow
D 2
calculates
E 2
I 2
calculates in
.I c
the value of
E 2
.I a
raised to the (``regular'' integral) power
.IR n ,
while
.I pow
D 2
calculates this (for
.IR *n " a " MINT )
reduced modulo
E 2
I 2
calculates this with a full multiple precision exponent
.I b
and the result is reduced modulo
E 2
.IR m .
I 2
.I gcd
returns the greatest common denominator of
.IR a " and " b " in " c ,
E 5
I 5
D 6
.\"     %W% (Berkeley) %G%
E 6
I 6
.\"	%W% (Berkeley) %G%
E 6
.\"
.Dd %Q%
.Dt MP 3
.Os BSD 4.3
.Sh NAME
.Nm fmin ,
.Nm fmout ,
.Nm gcd ,
.Nm invert ,
.Nm itom
.Nm m_in ,
.Nm m_out ,
.Nm madd ,
.Nm mcmp,
.Nm mdiv ,
.Nm min ,
.Nm mout ,
.Nm move ,
.Nm msqrt ,
.Nm msub ,
.Nm mult ,
.Nm omin ,
.Nm omout ,
.Nm pow ,
.Nm rpow ,
.Nm sdiv ,
.Nd multiple precision integer arithmetic
.Sh SYNOPSIS
.Fd #include <mp.h>
.Fd #include <stdio.h>
.Fd "typedef struct mint { int len; short *val; } MINT;"
.Fn madd "MINT *a" "MINT *b" "MINT *c"
.Fn msub "MINT *a" "MINT *b" "MINT *c"
.Fn mult "MINT *a" "MINT *b" "MINT *c"
.Fn mdiv "MINT *a" "MINT *b" "MINT *q" "short r"
.Fn pow "MINT *a" "MINT *b" m "MINT *c"
.Fn gcd "MINT *a" "MINT *b" "MINT *c"
.Fn invert "MINT *a" "MINT *b" "MINT *c"
.Fn rpow "MINT *a" "short n" "MINT *c"
.Fn msqrt "MINT *a" "MINT *b" "short r"
.Fn mcmp "MINT *a" "MINT *b"
.Fn move "MINT *a" "MINT *b"
.Fn min "MINT *a"
.Fn omin "MINT *a"
.Fn fmin "MINT *a" "FILE *f"
.Fn m_in "MINT *a" "int n" "FILE *f"
.Fn mout "MINT *a"
.Fn omout "MINT *a"
.Fn fmout "MINT *a" "FILE *f"
.Fn m_out "MINT *a" "int n" "FILE *f"
.Fn sdiv "MINT *a" "short n" "MINT *q" "short r"
.Fn itom "short n"
.Sh DESCRIPTION
.Bf -symbolic
The interface for this library is expected to change.
.Ef
.Pp
These functions operate on integers of variable length.
The function
.Fn itom
allocates space for an integer of length
.Fa n
which may be accessed via the returned
.Fa MINT
pointer.
The underlying storage scheme is transparent to the user.
.Pp
.Bl -tag -width "mdivXXX" -compact
.It Fn fmin
.It Fn fmout
Convert decimal input and output using file
.Fa f .
.Pp
.It Fn gcd
Finds the greatest common denominator of
.Fa a
E 5
and
D 5
.I invert
computes
.IR c " such that " a*c " mod " b " = 1,"
E 5
I 5
.Fa b ,
storing the result
in
.Fa c .
.Pp
.It Fn invert
Computes
.Fa c
such that
.Fa a Ns * Fa c No mod
.Fa b
= 1,
E 5
for
D 5
.IR a " and " b
E 5
I 5
.Fa a
and
.Fa b
E 5
relatively prime.
D 5
.I mcmp
returns a negative, zero or positive integer value when
.I a
E 5
I 5
.Pp
.It Fn m_in
.It Fn m_out
.Tn I/O
with arbitrary radix
.Fa n .
.Pp
.It Fn madd
The sum of
.Fa a
and
.Fa b
is stored in
.Fa c .
.Pp
.It Fn mcmp
Returns a negative, zero or positive integer value when
.Fa a
E 5
is less than, equal to or greater than
D 5
.IR b ,
E 5
I 5
.Fa b ,
E 5
respectively.
D 5
.I move
copies
.IR a " to " b .
E 2
.IR min " and " mout
D 2
do decimal input and output.
E 2
I 2
do decimal input and output while
.IR omin " and " omout
do octal input and output.
E 2
More generally,
.IR fmin " and " fmout
D 2
do decimal input and output from file
E 2
I 2
do decimal input and output using file
E 2
.IR f ,
E 5
I 5
.It Fn move
Copies
.Fa a
to
.Fa b .
.Pp
.It Fn min
.It Fn mout
Convert decimal input and output.
.Pp
.It Fn mdiv
Divides
.Fa a
by
.Fa b
and stores the quotient in
.Fa q
and the remainder in
.Fa r .
.Pp
.It Fn msqrt
Calculates the integer square root of
.Fa a
in
.Fa b
and places the remainder in
.Fa r .
.Pp
.It Fn msub
The difference of
.Fa a
E 5
and
D 5
.IR m_in " and " m_out
D 2
do I/O base 
E 2
I 2
do I/O with arbitrary radix
E 2
.IR n .
E 5
I 5
.Fa b
is stored in
.Fa c .
.Pp
.It Fn mult
The product of
.Fa a
and
.Fa b
is stored in
.Fa c .
.Pp
.It Fn omin
.It Fn omout
Convert octal input and output.
.Pp
.It Fn pow
Calculates
the value of
.Fa a
raised to the
full multiple precision exponent
.Fa b ,
the result is reduced modulo
.Fa m
and stored in
.Fa c .
.Pp
.It Fn rpow
Calculates
the value of
.Fa a
raised to the (``regular'' integral) power
.Fa n
and stores the result in
.Fa c .
.Pp
.It Fn sdiv
(Short divisor.)
Divides
.Fa a
by the short integer
.Fa b
and stores the quotient in
.Fa q
and the remainder in short integer
.Fa r .
E 5
I 2
On input, records should have the form of
strings of digits terminated by a newline;
output records have a similar form.
E 2
D 5
.PP
D 2
The functions are obtained with the
loader option
E 2
I 2
Programs which use the multiple-precision arithmetic library
must be loaded using the loader flag
E 2
.IR \-lmp .
.SH FILES
.ta 2i
/usr/include/mp.h	include file
.br
/usr/lib/libmp.a	object code library
.SH SEE ALSO
D 2
ape(3X)
E 2
I 2
dc(1), bc(1)
E 2
.SH DIAGNOSTICS
Illegal operations and running out of memory
produce messages and core images.
.SH BUGS
E 5
I 5
.El
.Sh FILES
.Bl -tag -width /usr/include/mp.h -compact
.It Pa /usr/lib/libmp.a
object code library
.It Pa /usr/include/mp.h
include file
.El
.Sh SEE ALSO
.Xr dc 1 ,
.Xr bc 1
.Sh HISTORY
A
.Fn gcd ,
.Fn itom ,
.Fn madd ,
.Fn mdiv ,
.Fn min ,
.Fn mout ,
.Fn msqrt ,
.Fn msub ,
.Fn mult ,
.Fn pow ,
.Fn rpow ,
and
.Fn sdiv
function appeared in
.At v7 .
.\" The rest of the functions appeared in
.\" .Bx ??
.Sh BUGS
E 5
Bases for input and output should be <= 10.
D 5
.PP
D 2
The
.I mp
package has some bugs--users are advised to use
.I ape
instead.
E 2
I 2
.IR dc (1)
E 5
I 5
.Pp
The interpreters
.Xr dc 1
E 5
and
D 5
.IR bc (1)
E 5
I 5
.Xr bc 1
E 5
don't use this library.
D 5
.PP
E 5
I 5
.Pp
E 5
The input and output routines are a crock.
D 5
.PP
.I pow
E 5
I 5
.Pp
The function name
.Fn pow
E 5
is also the name of a standard math library routine.
E 2
E 1
