.TR 103
...RP 80-11272-13 11173 39199-11
.ND December 17, 1981
.if !"\*(.T"ip" \{\
    .fp 1 tr
    .fp 2 ti
    .fp 3 tb
    .fp 4 ts
.\}
.so ~mac
.de SS
.UL "\\$1" "\\$2" "\\$3"
..
.nr PO 1i       \"left margin
.nr HM 1i       \"top margin
.nr FM 1i       \"bottom margin
.nr PS 10       \"point size
.nr VS 12      \"vertical spacing
.nr dP 1
.nr dV 1
.ds tf \s-2TROFF\s0
.ds id \s-2IDEAL\s0
.ds [. [
.ds .] ]
.de IS
.br
.nf
..
.de IE
.sp
..
.de Ip
.IP \\$1
..
.de Ts
.nr PS \\n(PS-\\n(dP
.nr VS \\n(VS-\\n(dV
.QS
..
.de Te
.nr PS \\n(PS+\\n(dP
.nr VS \\n(VS+\\n(dV
.QE
..
.EQ
delim $$
.EN
.TL
\*(id User's Manual
.AU "MH 2C-518" 5292
Christopher J. Van Wyk
.AI
.MH
.AB
\*(id is a programming language to be used for describing
pictures.
.PP
The main use of \*(id is as a preprocessor to \*(tf,
so that pictures and text may reside in the same
file and be typeset together.
This manual contains many examples of this use of \*(id.
.PP
\*(id proper produces device-independent descriptions
of pictures, so pictures may also be displayed through
the
.UX
plot filters.
.PP
This document describes how to use the existing
implementation of \*(id.
.AE
.CS 24 8 33 0 0 8
.NH 1
Introduction
.PP
\*(id is a language for describing pictures.
It is intended primarily to operate as a
preprocessor to \*(tf
.[[
ossanna joseph
.]],
much like \s-2EQN\s0
.[[
kernighan cherry
.]],
\s-2TBL\s0
.[[
lesk tables
.]],
\s-2REFER\s0
.[[
lesk inverted indexes
.]],
and \s-2PIC\s0
.[[
kernighan pic graphics
.]].
.PP
I have explained the principles that motivate
the form of \*(id elsewhere
.[[
van wyk dissertation
.]
.[
van wyk manipulation
.]].
This document describes how to use
the existing implementation of \*(id
and treats several examples in depth.
.Ts
Paragraphs like this that appear in smaller
type may be skipped on first reading:
they present sidelights that
may be ignored safely by beginners.
.Te
.NH 1
Overview of \*(id
.PP
To take advantage of \*(id's capabilities,
you must believe that
.ce 1
.IT "complex numbers are good" .
.IP \(bu
Complex numbers have a natural correspondence
to points in the Cartesian ($x-y$) coordinate
system.
.IP \(bu
Using complex numbers obviates the need for
distinguishing between ``points'' and ``dimensions.''
.IP \(bu
Complex numbers capture readily such common
operations as translation, rotation, and
reflection in the plane.
.LP
\*(id programs define pictures by means of
a system of simultaneous equations in the
significant points of the picture and
a set of drawing instructions to be
carried out with respect to those points.
\*(id solves the system of equations,
then draws the picture using the points
so determined.
.PP
All variables in \*(id programs are complex
numbers, with the usual operations:
.IP \(bu
component-wise addition and subtraction:
$(a,b) ~ +- ~ (c,d) ~ = ~ (a +- c , b +- d)$
.IP \(bu
vector multiplication:
$(a,b)*(c,d) ~ = ~ (ac - bd , ad + bc)$
.IP \(bu
vector division:
$(a,b)/(c,d) ~ = ~ (ac + bd , -ad + bc)/( c sup 2 + d sup 2 )$
.IP \(bu
component manipulation:
$roman "re" ((a,b)) ~ = ~ a$,
$roman "im" ((a,b)) ~ = ~ b$,
and
$roman "conj" ((a,b)) ~ = ~ (a,-b)$
.IP \(bu
vector magnitude calculation:
$roman "abs" ((a,b)) ~ = ~ sqrt { { a sup 2 } + { b sup 2 } }$
.IP \(bu
unit vector function:
$roman "cis" ( theta ) ~ = ~ cos theta + i sin theta$
.LP
A non-standard notation that has proved useful is
$alpha [ x , y ]$, for complex $x$ and $y$,
defined by $x + alpha ( y - x )$, and
meaning ``$alpha$ of the way from $x$ to $y$.''
.PP
Scalars are treated as vectors with null imaginary component.
For example, ``1'' is treated as ``(1,0).''
.PP
The scale of the coordinate system in which
\*(id programs are written is entirely a matter
of convenience.
The \*(id processor proper
produces output in the same coordinate
system as the input.
Postprocessors (``filters'') scale this coordinate
system to make sense for the device on which the
picture is displayed.
.PP
Some of the pictures below include captions keyed
to the associated programs.
Some of the labels are not produced by the program:
I added them to help explain the picture.
Such labels are parenthesized.
For pictures and programs that have not been
labeled, you may find that labeling them yourself
helps you understand the program.
.NH 1
Elements of the \*(id Language
.PP
This section presents statements that make up the
fundamental units of \*(id programs, so the
displayed program text represents fragments of
complete programs.
Text that appears between $/*$ and $*/$ is a comment.
.NH 2
Boxes
.PP
The building blocks of \*(id programs are called
.IT boxes ,
which readers familiar with programming may think
of as procedures or subroutines.
In fact,
the picture drawn by an \*(id program must itself
be a box,
called
.IT main ;
we suppress this extra level
of box-nesting for all of Section 3.
.NH 3
Defining Boxes
.PP
Here is a simple box
and one instance of it:
.IS
...width 0.5
...colwid 8.0
...maxx 1.000000
...maxy 0.500000
...minx 0.000000
...miny 0.000000
...left 1.000000 0.500000 ' (ne)
...left 1.000000 0.000000 ' (se)
...right 0.000000 0.500000 '(nw) 
...right 0.000000 0.000000 '(sw) 
...line 0.000000 0.500000 1.000000 0.500000
...line 0.000000 0.000000 0.000000 0.500000
...line 1.000000 0.000000 0.000000 0.000000
...line 1.000000 0.500000 1.000000 0.000000
.IF
.P1
rect {
	var ne, nw, se, sw,
		wd, ht;
	nw = sw + (0,1)*ht;
	ne = nw + wd;
	se = sw + wd;
	conn ne to nw to sw to se to ne;
}
.P2
.LP
It is called
.IT rect ,
has six local complex variables:
.IT ne ,
.IT nw ,
.IT se ,
.IT sw ,
.IT wd ,
and
.IT ht ,
three equations among these variables,
and an instruction to draw four lines.
.NH 3
Placing Boxes
.PP
To ask for an instance of
.IT rect ,
we use a
.IT put
statement with a
.IT "parameter section"
containing enough additional
equations that the local variables of
this instance of
.IT rect
are determined uniquely.
For example, we might give the dimensions
.IT ht "" (
and
.IT wd )
and one of the corners
(say
.IT sw ):
.IS
...width 0.25
...maxx 0.500000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...line 0.000000 1.000000 0.500000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 0.500000 0.000000 0.000000 0.000000
...line 0.500000 1.000000 0.500000 0.000000
.IF
.P1
put rect {
	ht = 2;
	wd = 1;
	sw = 0;
};
.P2
Any of the following put
statements would draw the same rectangle:
(C programmers will recognize the $/*$ and $*/$ comment brackets.)
.P1
/* giving one corner, one dimension
   and a relation on the dimensions */
put rect {
	ht = 2;
	wd = 0.5*ht;
	nw = (0,2);
};
.P2
.P1
/* giving two adjacent corners
   and the perpendicular dimension */
put rect {
	nw = (0,2);
	sw = 0;
	wd = 1;
};
.P2
.P1
/* giving two diagonal corners
   and a relation on the dimensions */
put rect {
	ne = (1,2);
	sw = 0;
	wd = 0.5*ht;
};
.P2
.P1
/* giving three corners */
put rect {
	ne = (1,2);
	nw = (0,2);
	se = 1;
};
.P2
.P1
/* giving the center of a side,
   a corner, and another dimension */
put rect {
	(nw+sw)/2 = (0,1);
	nw = (0,2);
	wd = 1;
};
.P2
.LP
The put statement is to \*(id what a procedure
call is to a conventional programming language.
The difference is that none of the variables
of a box must be specified to be a parameter
whose value is expected in any call:
any of the box's variables may be set by the
put statement, and \*(id will determine the
rest by means of the equations
in the definition of the box.
This means we can give whatever
information we know about this instance of the box,
as long as it is enough to determine everything uniquely.
This mechanism is useful because we often want to
set down a rectangle by giving one of its corners,
but not necessarily the same corner each time;
in a conventional programming language, we would
need to provide a different procedure for each
corner, and the code to solve for the other
corners from it.
(Almost certainly, not all of the put statements
above are equally useful; but it is good to be
able to use any of them when the need arises.)
.Ts
Here is how \*(id solves the system of equations
implicit in a program:
First, all equations are placed on a queue.
Every time a box is called, the solutions
to these equations may\(emand probably will\(embe
different, so all the equations of a box
are enqueued separately for each time that
box is put.
(Of course, different copies of the equation
refer to different copies of the variable,
but \*(id keeps that straight.)
During processing, \*(id maintains two classes
of variables: dependent and independent.
Each dependent variable is represented as a
linear combination of independent variables
plus a constant term.
(Variables whose values are known are a trivial
case of dependent variables.)
All variables start out independent.
As long as there are equations on the queue, \*(id
examines the head equation:
if, after substituting for all dependent variables,
the equation is linear, \*(id determines new
information from it if possible\(emthat is,
\*(id tries to make one variable dependent
on the others, thus reducing the number of
independent variables\(emor decides
whether it is redundant or inconsistent;
if the equation remains non-linear after substitution,
\*(id adds it to the end of the queue and proceeds.
If \*(id ever goes through the whole queue without
discovering any new information, the system cannot
be solved
(by \*(id, anyway)
and \*(id complains bitterly.
If there are any independent variables left after
this processing, \*(id will complain too, because
there is no way they can become known.
.Te
.PP
The variables
.IT wd
and
.IT ht
above are complex numbers just like the corners,
so we can rotate the rectangle
by giving them complex non-real values:
.IS
...width 0.5
...maxx 0.707107
...maxy 2.121320
...minx -1.414214
...miny 0.000000
...line -1.414214 1.414214 -0.707107 2.121320
...line 0.000000 0.000000 -1.414214 1.414214
...line 0.707107 0.707107 0.000000 0.000000
...line -0.707107 2.121320 0.707107 0.707107
.IF
.P1
put rect {
	sw = 0;
	wd = (1,1)/abs((1,1));
	ht = 2*wd;
};
.P2
.LP
(The double parentheses are needed in ``$abs((1,1))''$ because
``$abs(1,1)$'' is parsed as a function with two arguments.)
One point about this example often confuses new users:
the vectors
.IT wd
and
.IT ht
point in the
.IT same
direction.
It is in the definition of
.IT rect
that the $ht$ vector is rotated ninety degrees
and added to the southern points to arrive
at the northern points.
Thus, if we give a
.IT ht
that is perpendicular to
.IT wd ,
we get a very flat rectangle.
.PP
On the other hand, the definition of
.IT rect
does not assure that
.IT ht
and
.IT wd
will point in the same direction.
This put statement
draws a parallelogram:
.IS
...width 0.25
...maxx 0.707107
...maxy 1.707107
...minx 0.000000
...miny 0.000000
...line 0.000000 1.000000 0.707107 1.707107
...line 0.000000 0.000000 0.000000 1.000000
...line 0.707107 0.707107 0.000000 0.000000
...line 0.707107 1.707107 0.707107 0.707107
.IF
.P1
put rect {
	ht = 1;
	wd = (1,1)/abs((1,1));
	sw = 0;
};
.P2
.LP
Some people who feel that
a box called
.IT rect
should draw only rectangles
are disturbed by this example.
One remedy is to add another equation
to the definition of
.IT rect ,
asserting that two adjacent sides
are perpendicular;
\*(id will complain if this equation
is not satisfied
(although it won't stop drawing).
One such equation is
.P1
wd/abs(wd) = ht/abs(ht);
.P2
.PP
Here is a definition for box
.IT arrow
that keeps the head of the arrow symmetrical
about its shaft:
.IS
...maxx 1.000000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...line 0.000000 0.000000 0.068404 0.187939
...line 0.187939 0.068404 0.000000 0.000000
...line 1.000000 1.000000 0.000000 0.000000
.IF
.P1
arrow {
	var hd, tl, head, wing;
	head = 0.1;
	wing = head*(tl-hd)/abs(tl-hd);
	conn hd to tl;
	conn hd + cis(25)*wing to hd to hd + cis(-25)*wing;
}
.P2
.LP
Note the definition of
.IT wing
in the example above:
the second part of the expression is a unit vector
that points from
.IT tl
to
.IT hd ;
this is multiplied by
.IT head ,
the length of the ``wings'' on the arrowhead.
.Ts
When a put
statement is interpreted, the equations in
its parameter section are processed before
the equations in its definition.
Thus, if there are inconsistent equations
between the put
statement
and the box definition, the equations in
the put
statement take precedence.
This can be useful to provide
default values for variables of a box.
For instance, if the definition of
.IT rect
gave such default values to
.IT ht
and
.IT wd ,
they would take effect unless overridden
by equations in the parameter section
of the put statement.
.Te
.Ts
\*(id ignores inconsistent equations, but it
does generate error messages about them.
To avoid this error message
about a particular equation, use a
tilde (``\f8~\fP'') instead of an equals
sign in the equation.
The tilde does
.IT not
give the equation any lower ``priority''
than an equation with an equals sign:
all it does is shut off the error message.
So, the two ordered systems ``$x ~ = ~ 1$, $x ~ font 8 "~" ~ 2$''
and ``$x ~ font 8 "~" ~ 2$, $x ~ = ~ 1$'' are
.IT different:
in the former, $x$ receives the value 1, and no error
message appears when the second equation is processed;
in the latter, $x$ receives the value 2, and an error
is generated when the second equation is encountered.
.Te
.NH 2
Special Boxes\(emCircles and Arcs
.PP
Boxes to draw circles and circular arcs are defined
in special library files.
.NH 3
Circles
.PP
The box named
.IT circle
has five local variables:
.IT center ,
.IT radius ,
.IT z1 ,
.IT z2 ,
and
.IT z3 .
The last three may be any points on the circle.
As above, we must give enough information to
determine a circle;
giving two points on it is insufficient, and
giving three collinear points is inconsistent.
Here are three ways to draw
a circle of radius one centered at the origin.
.IS
...width 0.5
...maxx 1.100000
...maxy 1.000000
...minx -1.000000
...miny -1.006308
...circle -0.422618 -0.906308 0.100000
...circle -0.707107 0.707107 0.100000
...circle 1.000000 0.000000 0.100000
...right -0.422618 -0.906308 '(z3)  
...right -0.707107 0.707107 '(z2) 
...left 1.000000 0.000000 ' (z1)
...circle 0.000000 0.000000 1.000000
.IF
.P1
/* giving center and radius */
put circle {
	center = 0;
	radius = 1;
};
.P2
.P1
/* giving center and a point on the circle */
put circle {
	center = 0;
	z1 = 1; /* could also have given z2 or z3 */
};
.P2
.P1
/* giving three points on the circle */
put circle {
	z1 = (1,0);
	z2 = cis(135);
	z3 = cis(235);
};
.P2
.LP
Once the circle has been determined, all five of its
internal variables are known.
So, if we ask for a circle giving three points, the
radius and center will be known afterward.
On the other hand, if we ask for a circle by giving
the center and the radius, the three points $z1$, $z2$,
and $z3$, will be known, and will be on the circle,
but there is no guarantee where they will be.
.NH 3
Arcs
.PP
Box
.IT arc
has eight local variables:
.IT center ,
.IT radius ,
.IT start ,
.IT midway ,
.IT end ,
.IT startang ,
.IT midang ,
and
.IT endang .
It is an arc centered at point
.IT center
with radius
.IT radius ,
starting at point
.IT start
at an angle
.IT startang ,
passing through point
.IT midway
at an angle
.IT midang ,
and ending at point
.IT end
at an angle
.IT endang .
(All angles are measured with respect to $center$,
in degrees, with the positive $x$-axis taken to be
zero degrees, and the counterclockwise direction to
be positive.)
Note that $midway$ is
.IT not
necessarily the midpoint of the arc!
If neither
.IT midway
nor
.IT midang
is given, the arc is drawn
counterclockwise from
.IT start
to
.IT end .
Once again, a variety of put statements draw the same arc:
.IS
...maxx 1.100000
...maxy 1.000000
...minx -1.100000
...miny -1.000000
...circle -0.573576 -0.819152 0.100000
...circle -1.000000 0.000000 0.100000
...circle 1.000000 0.000000 0.100000
...left -0.573576 -0.819152 ' (end)
...right -1.000000 -0.000000 '(midway) 
...left 1.000000 0.000000 ' (start)
...arc 0.000000 0.000000 1.000000 0.000000 -0.573576 -0.819152 0.000000 4.101524 1.000000
.IF
.P1
/* giving center, radius, and
   starting and ending angles */
put arc {
	center = 0;
	radius = 1;
	startang = 0;
	endang = 235;
};
.P2
.P1
/* giving center, starting point,
   and ending angle */
put arc {
	center = 0;
	start = 1;
	endang = 235;
};
.P2
.IS
...maxx 1.100000
...maxy 1.000000
...minx -1.100000
...miny -1.000000
...circle -0.573576 -0.819152 0.100000
...circle -1.000000 0.000000 0.100000
...circle 1.000000 0.000000 0.100000
...left -0.573576 -0.819152 ' (start)
...right -1.000000 -0.000000 '(midway) 
...left 1.000000 0.000000 ' (end)
...arc 0.000000 0.000000 1.000000 0.000000 -0.573576 -0.819152 0.000000 4.101524 1.000000
.IF
.P1
/* giving three points on the arc */
put arc {
	start = cis(235);
	midway = -1;
	end = 0;
};
.P2
.NH 2
Other Elements of \*(id Pictures
.PP
\*(id pictures also may contain text and splines.
.NH 3
Text Captions
.PP
There are three commands to place text with respect to a point.
The
.IT left
command left-justifies the text with respect to the specified location:
the text will start there.
The
.IT right
command right-justifies the text so that it ends at the specified
location.
The default is to center the text at the point.
(The arrows in this picture point to the locations of the named points.)
.P1
left "some text" at x;
.P2
.P1
\&"some centered text" at y;
.P2
.P1
right "some other text" at z;
.P2
.IS
...colwid 6.0
...width 4.0
...maxx 7.000000
...maxy 0.000000
...minx 0.000000
...miny -1.000000
...line 6.000000 0.000000 6.093969 -0.034202
...line 6.034202 -0.093969 6.000000 0.000000
...line 6.000000 0.000000 7.000000 -1.000000
...left 7.000000 -1.000000 ' (z)
...right 6.000000 0.000000 'some other text
...line 3.000000 0.000000 3.093969 -0.034202
...line 3.034202 -0.093969 3.000000 0.000000
...line 3.000000 0.000000 4.000000 -1.000000
...left 4.000000 -1.000000 ' (y)
...center 3.000000 0.000000 'some centered text
...line 0.000000 0.000000 0.093969 -0.034202
...line 0.034202 -0.093969 0.000000 0.000000
...line 0.000000 0.000000 1.000000 -1.000000
...left 1.000000 -1.000000 ' (x)
...left 0.000000 0.000000 'some text
.IE
.LP
To include a double quote mark in a string, escape it with a back-slash.
If you have a line running through a point at which you place some text,
you may want to add a space to one end of the text so that the line
doesn't chop through the text.
The string may include \*(tf special characters (like \e(bu)
and commands to other preprocessors (notably \s-2EQN\s0),
but \*(id should be run before any other preprocessors.
.NH 3
Splines
.PP
\*(id provides quadratic splines that are drawn with a
B-spline basis:
the user supplies a sequence of guiding points, and \*(id
draws a smooth curve that is tangent to the polygonal
path they define at the midpoint of each segment;
the spline also starts at the first point and ends at the last.
.IS
...colwid 8.0
...width 1.0
...maxx 2.0
...minx -1.0
...maxy 2.0
...miny 0.0
...maxx 2.100000
...maxy 2.100000
...minx -1.100000
...miny -0.100000
...circle 2.000000 2.000000 0.100000
...circle -1.000000 1.000000 0.100000
...circle 1.000000 0.000000 0.100000
...circle 0.000000 0.000000 0.100000
...left 2.000000 2.000000 ' (w)
...right -1.000000 1.000000 '(z) 
...left 1.000000 0.000000 ' (y)
...right 0.000000 0.000000 '(x) 
...spline 2.000000 2.000000
...knot -1.000000 1.000000
...knot 1.000000 0.000000
...knot 0.000000 0.000000
...endspline
.IF
.P1
spline x to y to z to w;


.P2
.NH 1
Putting Boxes Together
.PP
In this section we present several complete
\*(id programs to show how to build up
pictures from boxes.
.NH 2
Naming Instances of Boxes
.PP
Most pictures involve more than placements of simple boxes.
And when pictures involve several boxes, certain geometrical
relationships should exist among them.
We can refer to the local variables of a box that has been put\(emall
we need to do is name the put statement.
Here is a simple example showing a diagram that could be used to illustrate
Pythagoras's Theorem for isoceles triangles:
.IS
...width 1.0
...maxx 3.000000
...maxy 2.000000
...minx 0.000000
...miny -1.000000
...line 2.000000 2.000000 3.000000 1.000000
...line 1.000000 1.000000 2.000000 2.000000
...line 2.000000 0.000000 1.000000 1.000000
...line 3.000000 1.000000 2.000000 0.000000
...line 1.000000 0.000000 2.000000 0.000000
...line 1.000000 -1.000000 1.000000 0.000000
...line 2.000000 -1.000000 1.000000 -1.000000
...line 2.000000 0.000000 2.000000 -1.000000
...line 0.000000 1.000000 1.000000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 1.000000 0.000000 0.000000 0.000000
...line 1.000000 1.000000 1.000000 0.000000
.IF
.P1
main {
	put first: rect {
		sw = 0;
		ht = wd = 1;
	};
	put next: rect {
		nw = first.se;
		ht = wd = first.ht;
	};
	put last: rect {
		sw = first.ne;
		se = next.ne;
		ht = wd;
	};
}
.P2
.LP
First we place an instance of
.IT rect
called
.IT first .
Then we place another
.IT rect
with its upper left corner ($ne$)
at the lower right of
.IT first .
Finally, we draw a third square,
two of whose adjacent points are
identified with points on the first
two squares placed.
We could have used any two adjacent points on
.IT last :
if we had placed
$last.ne$ at $first.ne$
and $last.nw$ at $next.ne$,
\*(id would have figured all the relationships
out right, although the program might be quite
inscrutable to humans.
.PP
How can we circumscribe a triangle?
If we name the put statement that produces
the instance, we can just give its three
vertices as values for $z1$, $z2$, and $z3$
in an instance of
.IT circle .
.IS
...maxx 2.081139
...maxy 3.081139
...minx -1.081139
...miny -0.081139
...circle 0.500000 1.500000 1.581139
...line 1.000000 0.000000 0.000000 0.000000
...line 2.000000 2.000000 1.000000 0.000000
...line 0.000000 0.000000 2.000000 2.000000
.IF
.P1
triangle {
	var z1, z2, z3;
	conn z1 to z2 to z3 to z1;
}

main {
	put T: triangle {
		z1 = 0;
		z2 = 1;
		z3 = (2,2);
	};
	put circle {
		z1 = T.z1;
		z2 = T.z2;
		z3 = T.z3;
	};
}
.P2
.NH 2
Parameter Section Commands
.PP
Any \*(id statement may appear in the parameter
section of a put statement.
This section illustrates some uses of this feature.
.PP
Suppose we will need to draw
pictures of a linked list before and after
insertion of a new node.
We might start with this definition
of a
.IT listnode :
.IS
...width 1.0
...colwid 8.0
...maxx 2.000000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...line 1.000000 1.000000 2.000000 1.000000
...line 1.000000 0.000000 1.000000 1.000000
...line 2.000000 0.000000 1.000000 0.000000
...line 2.000000 1.000000 2.000000 0.000000
...line 0.000000 1.000000 1.000000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 1.000000 0.000000 0.000000 0.000000
...line 1.000000 1.000000 1.000000 0.000000
.IF
.P1
listnode {
	put info: rect {
		var hook;
		hook = (nw + sw)/2;
		ht = lht;
		wd = lwd/2;
	};
	put next: rect {
		var c;
		c = (nw + se)/2;
		sw = info.se;
		ht = lht;
		wd = lwd/2;
	};
}
.P2
.LP
This version of
.IT listnode
depends on
.IT rect .
Notice that it references two variables
($lwd$ and $lht$) that are not local to
itself:
these variables must be defined in any
environment in which $listnode$ is put.
(They are global to it.)
We have added statements that define new
variables ($hook$ in $first$ and $c$ in $next$)
that are local to the particular instance of
.IT rect .
.PP
Now we draw the list as it is before insertion:
.IS
...width 2.0
...maxx 6.000000
...maxy 1.000000
...minx -1.000000
...miny -2.000000
...line 0.000000 0.500000 -0.181262 0.415476
...line -0.181262 0.584524 0.000000 0.500000
...line -1.000000 0.500000 0.000000 0.500000
...right -1.000000 0.500000 'list 
...line 2.000000 -1.500000 1.818738 -1.584524
...line 1.818738 -1.415476 2.000000 -1.500000
...line 1.000000 -1.500000 2.000000 -1.500000
...right 1.000000 -1.500000 'new 
...line 4.000000 0.500000 3.818738 0.415476
...line 3.818738 0.584524 4.000000 0.500000
...line 1.500000 0.500000 4.000000 0.500000
...line 3.000000 -1.000000 4.000000 -1.000000
...line 3.000000 -2.000000 3.000000 -1.000000
...line 4.000000 -2.000000 3.000000 -2.000000
...line 4.000000 -1.000000 4.000000 -2.000000
...line 2.000000 -1.000000 3.000000 -1.000000
...line 2.000000 -2.000000 2.000000 -1.000000
...line 3.000000 -2.000000 2.000000 -2.000000
...line 3.000000 -1.000000 3.000000 -2.000000
...line 5.000000 1.000000 6.000000 1.000000
...line 5.000000 0.000000 5.000000 1.000000
...line 6.000000 0.000000 5.000000 0.000000
...line 6.000000 1.000000 6.000000 0.000000
...line 4.000000 1.000000 5.000000 1.000000
...line 4.000000 0.000000 4.000000 1.000000
...line 5.000000 0.000000 4.000000 0.000000
...line 5.000000 1.000000 5.000000 0.000000
...line 6.000000 1.000000 5.000000 0.000000
...line 1.000000 1.000000 2.000000 1.000000
...line 1.000000 0.000000 1.000000 1.000000
...line 2.000000 0.000000 1.000000 0.000000
...line 2.000000 1.000000 2.000000 0.000000
...line 0.000000 1.000000 1.000000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 1.000000 0.000000 0.000000 0.000000
...line 1.000000 1.000000 1.000000 0.000000
.IF
.P1
main {
	var lht, lwd;
	lht = 1;
	lwd = 2*lht;
	put first: listnode {
		info.sw = 0;
	};
	put last: listnode {
		info.sw = 2[first.info.sw,first.next.se];
		conn next.sw to next.ne;
	};
	put new: listnode {
		info.nw = 2[first.next.ne,first.next.se];
	};
	put arrow {
		hd = last.info.hook;
		tl = first.next.c;
	};
	put arrow {
		hd = new.info.hook;
		tl = hd - 1;
		right "new " at tl;
	};
	put arrow {
		hd = first.info.hook;
		tl = hd - 1;
		right "list " at tl;
	};
}
.P2
.LP
Here we have added statements directly to the
parameter section of two of the calls to
.IT arrow
to avoid either naming each instance of
.IT arrow
or naming the tails of these arrows so that
text could be placed there.
We have also added a statement to draw the
null pointer in box
.IT last .
.PP
The program to draw the list after insertion of the
new node remains largely unchanged:
the nodes haven't moved; only the arrows hooking them
together have moved.
.ne 4i
.IS
...maxx 6.000000
...maxy 1.000000
...minx -1.000000
...miny -2.000000
...line 0.000000 0.500000 -0.181262 0.415476
...line -0.181262 0.584524 0.000000 0.500000
...line -1.000000 0.500000 0.000000 0.500000
...right -1.000000 0.500000 'list 
...line 2.000000 -1.500000 1.818738 -1.584524
...line 1.818738 -1.415476 2.000000 -1.500000
...line 1.000000 -1.500000 2.000000 -1.500000
...right 1.000000 -1.500000 'new 
...line 4.000000 0.000000 4.022866 -0.198689
...line 3.862494 -0.145231 4.000000 0.000000
...line 3.500000 -1.500000 4.000000 0.000000
...line 2.000000 -1.000000 1.862494 -0.854769
...line 2.022866 -0.801311 2.000000 -1.000000
...line 1.500000 0.500000 2.000000 -1.000000
...line 3.000000 -1.000000 4.000000 -1.000000
...line 3.000000 -2.000000 3.000000 -1.000000
...line 4.000000 -2.000000 3.000000 -2.000000
...line 4.000000 -1.000000 4.000000 -2.000000
...line 2.000000 -1.000000 3.000000 -1.000000
...line 2.000000 -2.000000 2.000000 -1.000000
...line 3.000000 -2.000000 2.000000 -2.000000
...line 3.000000 -1.000000 3.000000 -2.000000
...line 5.000000 1.000000 6.000000 1.000000
...line 5.000000 0.000000 5.000000 1.000000
...line 6.000000 0.000000 5.000000 0.000000
...line 6.000000 1.000000 6.000000 0.000000
...line 4.000000 1.000000 5.000000 1.000000
...line 4.000000 0.000000 4.000000 1.000000
...line 5.000000 0.000000 4.000000 0.000000
...line 5.000000 1.000000 5.000000 0.000000
...line 6.000000 1.000000 5.000000 0.000000
...line 1.000000 1.000000 2.000000 1.000000
...line 1.000000 0.000000 1.000000 1.000000
...line 2.000000 0.000000 1.000000 0.000000
...line 2.000000 1.000000 2.000000 0.000000
...line 0.000000 1.000000 1.000000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 1.000000 0.000000 0.000000 0.000000
...line 1.000000 1.000000 1.000000 0.000000
.IF
.P1
main {
	var lht, lwd;
	lht = 1;
	lwd = 2*lht;
	put first: listnode {
		info.sw = 0;
	};
	put last: listnode {
		info.sw = 2[first.info.sw,first.next.se];
		conn next.sw to next.ne;
	};
	put new: listnode {
		info.nw = 2[first.next.ne,first.next.se];
	};
	/* These two arrows are different: */
	put arrow {
		hd = new.info.nw;
		tl = first.next.c;
	};
	put arrow {
		hd = last.info.sw;
		tl = new.next.c;
	}
	/* These are the same as before: */
	put arrow {
		hd = new.info.hook;
		tl = hd - 1;
		right "new " at tl;
	};
	put arrow {
		hd = first.info.hook;
		tl = hd - 1;
		right "list " at tl;
	};
}
.P2
.NH 2
A Shorter Version
.PP
The previous example is somewhat long-winded
because it demonstrates many features of \*(id
that really aren't needed.
For instance, it would probably have made better
sense to define
.IT listnode
as a basic element rather than building it out
of
.IT rect s.
This would reduce the need for delving deep
into the internals of boxes from outside
(e.g.
.IT first.info.hook ).
Here is the same example reworked:
.IS
...width 2
...maxx 6.000000
...maxy 1.000000
...minx -1.000000
...miny -2.000000
...line 0.000000 0.500000 -0.181262 0.415476
...line -0.181262 0.584524 0.000000 0.500000
...line -1.000000 0.500000 0.000000 0.500000
...right -1.000000 0.500000 'list 
...line 2.000000 -1.500000 1.818738 -1.584524
...line 1.818738 -1.415476 2.000000 -1.500000
...line 1.000000 -1.500000 2.000000 -1.500000
...right 1.000000 -1.500000 'new 
...line 4.000000 0.000000 4.022866 -0.198689
...line 3.862494 -0.145231 4.000000 0.000000
...line 3.500000 -1.500000 4.000000 0.000000
...line 2.000000 -1.000000 1.862494 -0.854769
...line 2.022866 -0.801311 2.000000 -1.000000
...line 1.500000 0.500000 2.000000 -1.000000
...line 3.000000 -2.000000 3.000000 -1.000000
...line 4.000000 -1.000000 2.000000 -1.000000
...line 4.000000 -2.000000 4.000000 -1.000000
...line 2.000000 -2.000000 4.000000 -2.000000
...line 2.000000 -1.000000 2.000000 -2.000000
...line 5.000000 0.000000 5.000000 1.000000
...line 6.000000 1.000000 4.000000 1.000000
...line 6.000000 0.000000 6.000000 1.000000
...line 4.000000 0.000000 6.000000 0.000000
...line 4.000000 1.000000 4.000000 0.000000
...line 6.000000 1.000000 5.000000 0.000000
...line 1.000000 0.000000 1.000000 1.000000
...line 2.000000 1.000000 0.000000 1.000000
...line 2.000000 0.000000 2.000000 1.000000
...line 0.000000 0.000000 2.000000 0.000000
...line 0.000000 1.000000 0.000000 0.000000
.IE
.P1
listnode {
	var n, s, e, w, ne, nw, se, sw, next;
	n = s + (0,1)*lht;
	ne = n + 0.5*lwd = nw + lwd;
	se = s + 0.5*lwd = sw + lwd;
	e = (ne + se)/2;
	w = (nw + sw)/2;
	next = (ne + s)/2;
	conn nw to ne to se to sw to nw;
	conn n to s;
}

main {
	var lht, lwd;
	lht = 1;
	lwd = 2;
	put first: listnode {
		sw = 0;
	};
	put last: listnode {
		sw = 2[first.sw,first.se];
		conn s to ne;
	};
	put new: listnode {
		nw = 2[first.ne,first.se];
	};
	put arrow {
		hd = new.nw;
		tl = first.next;
	};
	put arrow {
		hd = last.sw;
		tl = new.next;
	};
	put arrow {
		hd = new.w;
		tl = hd - 1;
		right "new " at tl;
	};
	put arrow {
		hd = first.w;
		tl = hd - 1;
		right "list " at tl;
	};
}
.P2
Notice that equations need not be just a left side and a right side:
they may include several expressions that should be equal.
.NH 1
Iteration of \*(id Constructs
.NH 2
Pens
.PP
In Donald Knuth's \s-2METAFONT\s0
.[[
knuth tex metafont
.]]
system, pens are different
shapes\(emcircles, ellipses, and polygons\(emthat draw along
curves.
\*(id includes pens as a generalization of this idea:
.IT any
box may be used to draw along a line.
For instance, users may define ``dashed'' or ``dotted'' pens.
A pen statement looks like this:
.P1
conn $x$ to $y$
	using $n$ $pen$ {
		...
	} <$a$,$b$>;
.P2
(The only keywords in this statement are $conn$, $"to"$, and $using$.)
.IT Pen
may be any box.
\*(id will place $n$ copies of
.IT pen
in the space from $x$ to $y$.
$a$ and $b$ are expressions known to
.IT pen .
The first instance of
.IT pen
will have $a$ at $x$, and
the last instance of
.IT pen
will have $b$ at $y$;
every instance in between will have
its $a$ at the preceding one's $b$,
and its $b$ at the succeeding one's $a$,
as shown in this picture:
.IS
...colwid 6.0
...width 4.0
...maxx 8.000000
...maxy 0.500000
...minx 0.000000
...miny -0.500000
...right 8.000000 0.000000 '\f2b\fP 
...left 7.000000 0.000000 ' \f2a\fP
...line 7.000000 0.500000 8.000000 0.500000
...line 7.000000 -0.500000 7.000000 0.500000
...line 8.000000 -0.500000 7.000000 -0.500000
...line 8.000000 0.500000 8.000000 -0.500000
...left 8.000000 0.000000 ' \f2y\fP
...center 7.500000 -0.400000 '\f2n\fP
...center 6.500000 0.000000 '...
...right 6.000000 0.000000 '\f2b\fP 
...left 5.000000 0.000000 ' \f2a\fP
...line 5.000000 0.500000 6.000000 0.500000
...line 5.000000 -0.500000 5.000000 0.500000
...line 6.000000 -0.500000 5.000000 -0.500000
...line 6.000000 0.500000 6.000000 -0.500000
...center 5.500000 -0.400000 '\f2i\fP+1
...right 5.000000 0.000000 '\f2b\fP 
...left 4.000000 0.000000 ' \f2a\fP
...line 4.000000 0.500000 5.000000 0.500000
...line 4.000000 -0.500000 4.000000 0.500000
...line 5.000000 -0.500000 4.000000 -0.500000
...line 5.000000 0.500000 5.000000 -0.500000
...center 4.500000 -0.400000 '\f2i\fP
...right 4.000000 0.000000 '\f2b\fP 
...left 3.000000 0.000000 ' \f2a\fP
...line 3.000000 0.500000 4.000000 0.500000
...line 3.000000 -0.500000 3.000000 0.500000
...line 4.000000 -0.500000 3.000000 -0.500000
...line 4.000000 0.500000 4.000000 -0.500000
...center 3.500000 -0.400000 '\f2i\fP\-1
...center 2.500000 0.000000 '...
...right 2.000000 0.000000 '\f2b\fP 
...left 1.000000 0.000000 ' \f2a\fP
...line 1.000000 0.500000 2.000000 0.500000
...line 1.000000 -0.500000 1.000000 0.500000
...line 2.000000 -0.500000 1.000000 -0.500000
...line 2.000000 0.500000 2.000000 -0.500000
...center 1.500000 -0.400000 '2
...right 1.000000 0.000000 '\f2b\fP 
...left 0.000000 0.000000 ' \f2a\fP
...line 0.000000 0.500000 1.000000 0.500000
...line 0.000000 -0.500000 0.000000 0.500000
...line 1.000000 -0.500000 0.000000 -0.500000
...line 1.000000 0.500000 1.000000 -0.500000
...center 0.500000 -0.400000 '1
...right 0.000000 0.000000 '\f2x\fP 
.IE
.PP
Here is an example box that contains an angular wavy path:
.ne 2i
.IS
...colwid 9.0
...width 1.0
...maxx 1.000000
...maxy 0.200000
...minx 0.000000
...miny -0.200000
...line 0.250000 -0.200000 0.000000 0.000000
...line 0.750000 0.200000 0.250000 -0.200000
...line 1.000000 0.000000 0.750000 0.200000
...left 1.000000 0.000000 ' (end)
...right 0.000000 0.000000 '(start) 
.IE
.P1
wavy {
	var start, end, perp, pt1, pt2, ht;
	perp = (0,1)*(start - end)/abs(start - end);
	pt1 = 0.25[start,end] + perp*ht;
	pt2 = 0.75[start,end] - perp*ht;
	conn start to pt1 to pt2 to end;
}
.P2
.LP
Here we use
.IT wavy
as a pen to indicate that part of a rectangle is missing.
.IS
...maxx 2.000000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...line 1.352848 0.112861 1.280000 0.200000
...line 1.127152 0.087139 1.352848 0.112861
...line 1.200000 0.000000 1.127152 0.087139
...line 1.432848 0.312861 1.360000 0.400000
...line 1.207152 0.287139 1.432848 0.312861
...line 1.280000 0.200000 1.207152 0.287139
...line 1.512848 0.512861 1.440000 0.600000
...line 1.287152 0.487139 1.512848 0.512861
...line 1.360000 0.400000 1.287152 0.487139
...line 1.592848 0.712861 1.520000 0.800000
...line 1.367152 0.687139 1.592848 0.712861
...line 1.440000 0.600000 1.367152 0.687139
...line 1.672848 0.912861 1.600000 1.000000
...line 1.447152 0.887139 1.672848 0.912861
...line 1.520000 0.800000 1.447152 0.887139
...line 2.000000 1.000000 1.600000 1.000000
...line 2.000000 0.000000 2.000000 1.000000
...line 1.200000 0.000000 2.000000 0.000000
...line 0.952848 0.112861 0.880000 0.200000
...line 0.727152 0.087139 0.952848 0.112861
...line 0.800000 0.000000 0.727152 0.087139
...line 1.032848 0.312861 0.960000 0.400000
...line 0.807152 0.287139 1.032848 0.312861
...line 0.880000 0.200000 0.807152 0.287139
...line 1.112848 0.512861 1.040000 0.600000
...line 0.887152 0.487139 1.112848 0.512861
...line 0.960000 0.400000 0.887152 0.487139
...line 1.192848 0.712861 1.120000 0.800000
...line 0.967152 0.687139 1.192848 0.712861
...line 1.040000 0.600000 0.967152 0.687139
...line 1.272848 0.912861 1.200000 1.000000
...line 1.047152 0.887139 1.272848 0.912861
...line 1.120000 0.800000 1.047152 0.887139
...line 0.000000 1.000000 1.200000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 0.800000 0.000000 0.000000 0.000000
.IF
.P1
main {
	var ne, nw, se, sw;
	var n1, s1, n2, s2;
	ne = nw + 2;
	se = sw + 2;
	ne = se + (0,1);
	n2 - 0.4 = n1 = 0.6[nw,ne];
	s2 - 0.4 = s1 = 0.4[sw,se];
	conn n1 to nw to sw to s1;
	conn n1 to s1
		using int(5*abs(n1-s1)) wavy {
			ht = -0.1;
		} <start,end>;
	conn n2 to ne to se to s2;
	conn n2 to s2
		using int(5*abs(n2-s2)) wavy {
			ht = -0.1;
		} <start,end>;
}
.P2
.LP
We can change
.IT wavy
to contain a smooth wave
by changing the word
.IT conn
in the fifth line of its definition to
.IT spline ,
and use the same instructions above to draw
the picture with the new pen.
.IS
...maxx 2.000000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...spline 1.200000 0.000000
...knot 1.127152 0.087139
...knot 1.352848 0.112861
...knot 1.280000 0.200000
...endspline
...spline 1.280000 0.200000
...knot 1.207152 0.287139
...knot 1.432848 0.312861
...knot 1.360000 0.400000
...endspline
...spline 1.360000 0.400000
...knot 1.287152 0.487139
...knot 1.512848 0.512861
...knot 1.440000 0.600000
...endspline
...spline 1.440000 0.600000
...knot 1.367152 0.687139
...knot 1.592848 0.712861
...knot 1.520000 0.800000
...endspline
...spline 1.520000 0.800000
...knot 1.447152 0.887139
...knot 1.672848 0.912861
...knot 1.600000 1.000000
...endspline
...line 2.000000 1.000000 1.600000 1.000000
...line 2.000000 0.000000 2.000000 1.000000
...line 1.200000 0.000000 2.000000 0.000000
...spline 0.800000 0.000000
...knot 0.727152 0.087139
...knot 0.952848 0.112861
...knot 0.880000 0.200000
...endspline
...spline 0.880000 0.200000
...knot 0.807152 0.287139
...knot 1.032848 0.312861
...knot 0.960000 0.400000
...endspline
...spline 0.960000 0.400000
...knot 0.887152 0.487139
...knot 1.112848 0.512861
...knot 1.040000 0.600000
...endspline
...spline 1.040000 0.600000
...knot 0.967152 0.687139
...knot 1.192848 0.712861
...knot 1.120000 0.800000
...endspline
...spline 1.120000 0.800000
...knot 1.047152 0.887139
...knot 1.272848 0.912861
...knot 1.200000 1.000000
...endspline
...line 0.000000 1.000000 1.200000 1.000000
...line 0.000000 0.000000 0.000000 1.000000
...line 0.800000 0.000000 0.000000 0.000000
.IE
.NH 2
Pens as For-Statements
.PP
The pen statement
.P1
conn $x$ to $y$
	using $n$ $pen$ {
		...
	} <$a$,$b$>;
.P2
.LP
has the same effect as
.P1
for $i$ = 1 to $n$ {
	put $pen$ {
		$a$ = (($i$-1)/$n$)[$x$,$y$];
		$b$ = ($i$/$n$)[$x$,$y$];
		...
	};
}
.P2
.LP
imagining for a moment that \*(id had for-statements.
.Ts
This means a pen statement can be used to synthesize
a for-statement in an \*(id program.
Here is a pen statement to draw a dashed arc:
.IS
...maxx 1.000000
...maxy 1.000000
...minx -1.000000
...miny -1.000000
...arc 0.000000 0.000000 -0.951056 0.309017 -0.987688 0.156434 2.827433 2.984513 1.000000
...arc 0.000000 0.000000 -0.809017 0.587785 -0.891006 0.453991 2.513274 2.670354 1.000000
...arc 0.000000 0.000000 -0.587785 0.809017 -0.707107 0.707107 2.199115 2.356194 1.000000
...arc 0.000000 0.000000 -0.309017 0.951056 -0.453991 0.891006 1.884956 2.042035 1.000000
...arc 0.000000 0.000000 -0.000000 1.000000 -0.156435 0.987688 1.570796 1.727876 1.000000
...arc 0.000000 0.000000 0.309017 0.951057 0.156434 0.987688 1.256637 1.413717 1.000000
...arc 0.000000 0.000000 0.587785 0.809017 0.453991 0.891007 0.942478 1.099557 1.000000
...arc 0.000000 0.000000 0.809017 0.587785 0.707107 0.707107 0.628319 0.785398 1.000000
...arc 0.000000 0.000000 0.951057 0.309017 0.891007 0.453991 0.314159 0.471239 1.000000
...arc 0.000000 0.000000 1.000000 0.000000 0.987688 0.156434 0.000000 0.157080 1.000000
.IF
.P1
conn 0 to 180
	using 10 arc {
		center = 0;
		radius = 1;
	}<startang, 9+endang>;
.P2
.Te
.Ts
To draw a set of concentric circles
we can say:
.IS
...maxx 5.000000
...maxy 5.000000
...minx -5.000000
...miny -5.000000
...circle 0.000000 0.000000 5.000000
...circle 0.000000 0.000000 4.000000
...circle 0.000000 0.000000 3.000000
...circle 0.000000 0.000000 2.000000
...circle 0.000000 0.000000 1.000000
.IF
.P1
main {
	conn 1 to 6
		using 5 circle {
			center = 0;
			} <radius,radius+1>;
}
.P2
.sp 1
.Te
.Ts
In the first example, the second expression in angle
brackets is important: it means that each ``dash''
covers nine degrees.
In the second example, this expression is redundant:
its only purpose is to prevent \*(id from generating
a stream of error messages about inconsistent equations.
This contorted way of simulating for-statements
is necessary only because pens are meant to do
the right thing at each end of and all along a path that is
being drawn with some box, and not as general
iteration constructs.
.Te
.Ts
Why doesn't \*(id have
for-statements?
Notice that every variable in an \*(id program
is assigned a value exactly once.
Obviously the index of a for-statement must be
an exception to that rule.
Generating the index internally prevents the
need to have two kinds of variables\(emchanging
and fixed.
The local variables of boxes placed by pen statements
cannot be referenced outside the pen statement,
because the boxes are not named when they are placed.
A general for-statement could lead to the need to
generate automatically names for different instances of boxes,
a hard problem that I don't understand well enough yet.
.Te
.NH 2
Filling Regions
.PP
Because any box can be used as a pen, we can shade regions.
(We can have not only dashed and dotted ink, but checkered paint!)
Take box
.IT wavy ,
for instance.
First we construct a box
.IT brush ,
which consists of seven copies of
.IT wavy
going horizontally:
.IS
...maxx 7.000000
...maxy 0.300000
...minx 0.000000
...miny -0.300000
...line 6.250000 -0.300000 6.000000 0.000000
...line 6.750000 0.300000 6.250000 -0.300000
...line 7.000000 0.000000 6.750000 0.300000
...line 5.250000 -0.300000 5.000000 0.000000
...line 5.750000 0.300000 5.250000 -0.300000
...line 6.000000 0.000000 5.750000 0.300000
...line 4.250000 -0.300000 4.000000 0.000000
...line 4.750000 0.300000 4.250000 -0.300000
...line 5.000000 0.000000 4.750000 0.300000
...line 3.250000 -0.300000 3.000000 0.000000
...line 3.750000 0.300000 3.250000 -0.300000
...line 4.000000 0.000000 3.750000 0.300000
...line 2.250000 -0.300000 2.000000 0.000000
...line 2.750000 0.300000 2.250000 -0.300000
...line 3.000000 0.000000 2.750000 0.300000
...line 1.250000 -0.300000 1.000000 0.000000
...line 1.750000 0.300000 1.250000 -0.300000
...line 2.000000 0.000000 1.750000 0.300000
...line 0.250000 -0.300000 0.000000 0.000000
...line 0.750000 0.300000 0.250000 -0.300000
...line 1.000000 0.000000 0.750000 0.300000
.IF
.P1
brush {
	var top, bot;
	var bwd, bht;
	var leftpt, rightpt;
	leftpt = 0.5*(top+bot) - bwd/2;
	rightpt = 0.5*(top+bot) + bwd/2;
	conn leftpt to rightpt
		using 7 wavy {
			ht = bht;
		}<start,end>;
}
.P2
Then we use ``brush'' to draw vertically
over the region of interest.
.IS
...maxx 1.000000
...maxy 0.933333
...minx -1.000000
...miny -0.933333
...line 0.785714 -0.933333 0.714286 -0.833333
...line 0.928571 -0.733333 0.785714 -0.933333
...line 1.000000 -0.833333 0.928571 -0.733333
...line 0.500000 -0.933333 0.428571 -0.833333
...line 0.642857 -0.733333 0.500000 -0.933333
...line 0.714286 -0.833333 0.642857 -0.733333
...line 0.214286 -0.933333 0.142857 -0.833333
...line 0.357143 -0.733333 0.214286 -0.933333
...line 0.428571 -0.833333 0.357143 -0.733333
...line -0.071429 -0.933333 -0.142857 -0.833333
...line 0.071429 -0.733333 -0.071429 -0.933333
...line 0.142857 -0.833333 0.071429 -0.733333
...line -0.357143 -0.933333 -0.428571 -0.833333
...line -0.214286 -0.733333 -0.357143 -0.933333
...line -0.142857 -0.833333 -0.214286 -0.733333
...line -0.642857 -0.933333 -0.714286 -0.833333
...line -0.500000 -0.733333 -0.642857 -0.933333
...line -0.428571 -0.833333 -0.500000 -0.733333
...line -0.928571 -0.933333 -1.000000 -0.833333
...line -0.785714 -0.733333 -0.928571 -0.933333
...line -0.714286 -0.833333 -0.785714 -0.733333
...line 0.785714 -0.600000 0.714286 -0.500000
...line 0.928571 -0.400000 0.785714 -0.600000
...line 1.000000 -0.500000 0.928571 -0.400000
...line 0.500000 -0.600000 0.428571 -0.500000
...line 0.642857 -0.400000 0.500000 -0.600000
...line 0.714286 -0.500000 0.642857 -0.400000
...line 0.214286 -0.600000 0.142857 -0.500000
...line 0.357143 -0.400000 0.214286 -0.600000
...line 0.428571 -0.500000 0.357143 -0.400000
...line -0.071429 -0.600000 -0.142857 -0.500000
...line 0.071429 -0.400000 -0.071429 -0.600000
...line 0.142857 -0.500000 0.071429 -0.400000
...line -0.357143 -0.600000 -0.428571 -0.500000
...line -0.214286 -0.400000 -0.357143 -0.600000
...line -0.142857 -0.500000 -0.214286 -0.400000
...line -0.642857 -0.600000 -0.714286 -0.500000
...line -0.500000 -0.400000 -0.642857 -0.600000
...line -0.428571 -0.500000 -0.500000 -0.400000
...line -0.928571 -0.600000 -1.000000 -0.500000
...line -0.785714 -0.400000 -0.928571 -0.600000
...line -0.714286 -0.500000 -0.785714 -0.400000
...line 0.785714 -0.266667 0.714286 -0.166667
...line 0.928571 -0.066667 0.785714 -0.266667
...line 1.000000 -0.166667 0.928571 -0.066667
...line 0.500000 -0.266667 0.428571 -0.166667
...line 0.642857 -0.066667 0.500000 -0.266667
...line 0.714286 -0.166667 0.642857 -0.066667
...line 0.214286 -0.266667 0.142857 -0.166667
...line 0.357143 -0.066667 0.214286 -0.266667
...line 0.428571 -0.166667 0.357143 -0.066667
...line -0.071429 -0.266667 -0.142857 -0.166667
...line 0.071429 -0.066667 -0.071429 -0.266667
...line 0.142857 -0.166667 0.071429 -0.066667
...line -0.357143 -0.266667 -0.428571 -0.166667
...line -0.214286 -0.066667 -0.357143 -0.266667
...line -0.142857 -0.166667 -0.214286 -0.066667
...line -0.642857 -0.266667 -0.714286 -0.166667
...line -0.500000 -0.066667 -0.642857 -0.266667
...line -0.428571 -0.166667 -0.500000 -0.066667
...line -0.928571 -0.266667 -1.000000 -0.166667
...line -0.785714 -0.066667 -0.928571 -0.266667
...line -0.714286 -0.166667 -0.785714 -0.066667
...line 0.785714 0.066667 0.714286 0.166667
...line 0.928571 0.266667 0.785714 0.066667
...line 1.000000 0.166667 0.928571 0.266667
...line 0.500000 0.066667 0.428571 0.166667
...line 0.642857 0.266667 0.500000 0.066667
...line 0.714286 0.166667 0.642857 0.266667
...line 0.214286 0.066667 0.142857 0.166667
...line 0.357143 0.266667 0.214286 0.066667
...line 0.428571 0.166667 0.357143 0.266667
...line -0.071429 0.066667 -0.142857 0.166667
...line 0.071429 0.266667 -0.071429 0.066667
...line 0.142857 0.166667 0.071429 0.266667
...line -0.357143 0.066667 -0.428571 0.166667
...line -0.214286 0.266667 -0.357143 0.066667
...line -0.142857 0.166667 -0.214286 0.266667
...line -0.642857 0.066667 -0.714286 0.166667
...line -0.500000 0.266667 -0.642857 0.066667
...line -0.428571 0.166667 -0.500000 0.266667
...line -0.928571 0.066667 -1.000000 0.166667
...line -0.785714 0.266667 -0.928571 0.066667
...line -0.714286 0.166667 -0.785714 0.266667
...line 0.785714 0.400000 0.714286 0.500000
...line 0.928571 0.600000 0.785714 0.400000
...line 1.000000 0.500000 0.928571 0.600000
...line 0.500000 0.400000 0.428571 0.500000
...line 0.642857 0.600000 0.500000 0.400000
...line 0.714286 0.500000 0.642857 0.600000
...line 0.214286 0.400000 0.142857 0.500000
...line 0.357143 0.600000 0.214286 0.400000
...line 0.428571 0.500000 0.357143 0.600000
...line -0.071429 0.400000 -0.142857 0.500000
...line 0.071429 0.600000 -0.071429 0.400000
...line 0.142857 0.500000 0.071429 0.600000
...line -0.357143 0.400000 -0.428571 0.500000
...line -0.214286 0.600000 -0.357143 0.400000
...line -0.142857 0.500000 -0.214286 0.600000
...line -0.642857 0.400000 -0.714286 0.500000
...line -0.500000 0.600000 -0.642857 0.400000
...line -0.428571 0.500000 -0.500000 0.600000
...line -0.928571 0.400000 -1.000000 0.500000
...line -0.785714 0.600000 -0.928571 0.400000
...line -0.714286 0.500000 -0.785714 0.600000
...line 0.785714 0.733333 0.714286 0.833333
...line 0.928571 0.933333 0.785714 0.733333
...line 1.000000 0.833333 0.928571 0.933333
...line 0.500000 0.733333 0.428571 0.833333
...line 0.642857 0.933333 0.500000 0.733333
...line 0.714286 0.833333 0.642857 0.933333
...line 0.214286 0.733333 0.142857 0.833333
...line 0.357143 0.933333 0.214286 0.733333
...line 0.428571 0.833333 0.357143 0.933333
...line -0.071429 0.733333 -0.142857 0.833333
...line 0.071429 0.933333 -0.071429 0.733333
...line 0.142857 0.833333 0.071429 0.933333
...line -0.357143 0.733333 -0.428571 0.833333
...line -0.214286 0.933333 -0.357143 0.733333
...line -0.142857 0.833333 -0.214286 0.933333
...line -0.642857 0.733333 -0.714286 0.833333
...line -0.500000 0.933333 -0.642857 0.733333
...line -0.428571 0.833333 -0.500000 0.933333
...line -0.928571 0.733333 -1.000000 0.833333
...line -0.785714 0.933333 -0.928571 0.733333
...line -0.714286 0.833333 -0.785714 0.933333
.IF
.P1
conn (0,1) to (0,-1)
	using 6 brush {
		bwd = 2;
		bht = 0.1;
		}<top,bot>;




.P2
.NH 1
Opaque Boxes
.PP
\*(id includes statements to blot out pieces
of a picture.
In this section we will sometimes place opaque boxes
without explicitly drawing any background.
In such cases, assume
that we have painted over
the area with pens as above.
.NH 2
Opaque Polygons
.PP
\*(id needs to know the vertices of a polygon in order
to opaque the area it covers.
The vertices are specified as a list in a
.IT bdlist
statement.
For instance, to opaque a rectangular region using the
.IT rect
box defined in Section 3, we could use the following statement:
.IS
...maxx 1.000000
...maxy 0.957143
...minx -1.000000
...miny -0.957143
...line -0.400000 0.600000 0.600000 0.600000
...line -0.400000 -0.400000 -0.400000 0.600000
...line 0.600000 -0.400000 -0.400000 -0.400000
...line 0.600000 0.600000 0.600000 -0.400000
...line 0.785714 -0.957143 0.714286 -0.857143
...line 0.928571 -0.757143 0.785714 -0.957143
...line 1.000000 -0.857143 0.928571 -0.757143
...line 0.500000 -0.957143 0.428571 -0.857143
...line 0.642857 -0.757143 0.500000 -0.957143
...line 0.714286 -0.857143 0.642857 -0.757143
...line 0.214286 -0.957143 0.142857 -0.857143
...line 0.357143 -0.757143 0.214286 -0.957143
...line 0.428571 -0.857143 0.357143 -0.757143
...line -0.071429 -0.957143 -0.142857 -0.857143
...line 0.071429 -0.757143 -0.071429 -0.957143
...line 0.142857 -0.857143 0.071429 -0.757143
...line -0.357143 -0.957143 -0.428571 -0.857143
...line -0.214286 -0.757143 -0.357143 -0.957143
...line -0.142857 -0.857143 -0.214286 -0.757143
...line -0.642857 -0.957143 -0.714286 -0.857143
...line -0.500000 -0.757143 -0.642857 -0.957143
...line -0.428571 -0.857143 -0.500000 -0.757143
...line -0.928571 -0.957143 -1.000000 -0.857143
...line -0.785714 -0.757143 -0.928571 -0.957143
...line -0.714286 -0.857143 -0.785714 -0.757143
...line 0.785714 -0.671429 0.714286 -0.571429
...line 0.928571 -0.471429 0.785714 -0.671429
...line 1.000000 -0.571429 0.928571 -0.471429
...line 0.500000 -0.671429 0.428571 -0.571429
...line 0.642857 -0.471429 0.500000 -0.671429
...line 0.714286 -0.571429 0.642857 -0.471429
...line 0.214286 -0.671429 0.142857 -0.571429
...line 0.357143 -0.471429 0.214286 -0.671429
...line 0.428571 -0.571429 0.357143 -0.471429
...line -0.071429 -0.671429 -0.142857 -0.571429
...line 0.071429 -0.471429 -0.071429 -0.671429
...line 0.142857 -0.571429 0.071429 -0.471429
...line -0.357143 -0.671429 -0.428571 -0.571429
...line -0.214286 -0.471429 -0.357143 -0.671429
...line -0.142857 -0.571429 -0.214286 -0.471429
...line -0.642857 -0.671429 -0.714286 -0.571429
...line -0.500000 -0.471429 -0.642857 -0.671429
...line -0.428571 -0.571429 -0.500000 -0.471429
...line -0.928571 -0.671429 -1.000000 -0.571429
...line -0.785714 -0.471429 -0.928571 -0.671429
...line -0.714286 -0.571429 -0.785714 -0.471429
...line 0.785714 -0.385714 0.714286 -0.285714
...line 0.928571 -0.185714 0.785714 -0.385714
...line 1.000000 -0.285714 0.928571 -0.185714
...line 0.642857 -0.185714 0.600000 -0.245714
...line 0.714286 -0.285714 0.642857 -0.185714
...line -0.400000 -0.325714 -0.428571 -0.285714
...line -0.642857 -0.385714 -0.714286 -0.285714
...line -0.500000 -0.185714 -0.642857 -0.385714
...line -0.428571 -0.285714 -0.500000 -0.185714
...line -0.928571 -0.385714 -1.000000 -0.285714
...line -0.785714 -0.185714 -0.928571 -0.385714
...line -0.714286 -0.285714 -0.785714 -0.185714
...line 0.785714 -0.100000 0.714286 0.000000
...line 0.928571 0.100000 0.785714 -0.100000
...line 1.000000 0.000000 0.928571 0.100000
...line 0.642857 0.100000 0.600000 0.040000
...line 0.714286 0.000000 0.642857 0.100000
...line -0.400000 -0.040000 -0.428571 0.000000
...line -0.642857 -0.100000 -0.714286 0.000000
...line -0.500000 0.100000 -0.642857 -0.100000
...line -0.428571 0.000000 -0.500000 0.100000
...line -0.928571 -0.100000 -1.000000 0.000000
...line -0.785714 0.100000 -0.928571 -0.100000
...line -0.714286 0.000000 -0.785714 0.100000
...line 0.785714 0.185714 0.714286 0.285714
...line 0.928571 0.385714 0.785714 0.185714
...line 1.000000 0.285714 0.928571 0.385714
...line 0.642857 0.385714 0.600000 0.325714
...line 0.714286 0.285714 0.642857 0.385714
...line -0.400000 0.245714 -0.428571 0.285714
...line -0.642857 0.185714 -0.714286 0.285714
...line -0.500000 0.385714 -0.642857 0.185714
...line -0.428571 0.285714 -0.500000 0.385714
...line -0.928571 0.185714 -1.000000 0.285714
...line -0.785714 0.385714 -0.928571 0.185714
...line -0.714286 0.285714 -0.785714 0.385714
...line 0.785714 0.471429 0.714286 0.571429
...line 0.928571 0.671429 0.785714 0.471429
...line 1.000000 0.571429 0.928571 0.671429
...line 0.642857 0.671429 0.591837 0.600000
...line 0.714286 0.571429 0.642857 0.671429
...line 0.357143 0.671429 0.306122 0.600000
...line 0.408163 0.600000 0.357143 0.671429
...line 0.071429 0.671429 0.020408 0.600000
...line 0.122449 0.600000 0.071429 0.671429
...line -0.400000 0.531429 -0.428571 0.571429
...line -0.214286 0.671429 -0.265306 0.600000
...line -0.163265 0.600000 -0.214286 0.671429
...line -0.642857 0.471429 -0.714286 0.571429
...line -0.500000 0.671429 -0.642857 0.471429
...line -0.428571 0.571429 -0.500000 0.671429
...line -0.928571 0.471429 -1.000000 0.571429
...line -0.785714 0.671429 -0.928571 0.471429
...line -0.714286 0.571429 -0.785714 0.671429
...line 0.785714 0.757143 0.714286 0.857143
...line 0.928571 0.957143 0.785714 0.757143
...line 1.000000 0.857143 0.928571 0.957143
...line 0.500000 0.757143 0.428571 0.857143
...line 0.642857 0.957143 0.500000 0.757143
...line 0.714286 0.857143 0.642857 0.957143
...line 0.214286 0.757143 0.142857 0.857143
...line 0.357143 0.957143 0.214286 0.757143
...line 0.428571 0.857143 0.357143 0.957143
...line -0.071429 0.757143 -0.142857 0.857143
...line 0.071429 0.957143 -0.071429 0.757143
...line 0.142857 0.857143 0.071429 0.957143
...line -0.357143 0.757143 -0.428571 0.857143
...line -0.214286 0.957143 -0.357143 0.757143
...line -0.142857 0.857143 -0.214286 0.957143
...line -0.642857 0.757143 -0.714286 0.857143
...line -0.500000 0.957143 -0.642857 0.757143
...line -0.428571 0.857143 -0.500000 0.957143
...line -0.928571 0.757143 -1.000000 0.857143
...line -0.785714 0.957143 -0.928571 0.757143
...line -0.714286 0.857143 -0.785714 0.957143
.IF
.P1
put rect {
	opaque;
	bdlist = sw, se, ne, nw;
	sw = (-0.4,-0.4);
	wd = ht = 1;
};




.P2
.LP
The sides of the rectangle are drawn by
.IT rect :
they are not supplied automatically by the opaqueing routine.
If we wanted to save only the interior of the rectangle,
we could use almost the same statement:
.IS
...minx -1.0
...maxx 1.0
...miny -1.0
...maxy 1.0
...maxx 0.600000
...maxy 0.600000
...minx -0.400000
...miny -0.400000
...line -0.400000 0.600000 0.600000 0.600000
...line -0.400000 -0.400000 -0.400000 0.600000
...line 0.600000 -0.400000 -0.400000 -0.400000
...line 0.600000 0.600000 0.600000 -0.400000
...line 0.500000 -0.385714 0.428571 -0.285714
...line 0.600000 -0.245714 0.500000 -0.385714
...line 0.214286 -0.385714 0.142857 -0.285714
...line 0.357143 -0.185714 0.214286 -0.385714
...line 0.428571 -0.285714 0.357143 -0.185714
...line -0.071429 -0.385714 -0.142857 -0.285714
...line 0.071429 -0.185714 -0.071429 -0.385714
...line 0.142857 -0.285714 0.071429 -0.185714
...line -0.357143 -0.385714 -0.400000 -0.325714
...line -0.214286 -0.185714 -0.357143 -0.385714
...line -0.142857 -0.285714 -0.214286 -0.185714
...line 0.500000 -0.100000 0.428571 0.000000
...line 0.600000 0.040000 0.500000 -0.100000
...line 0.214286 -0.100000 0.142857 0.000000
...line 0.357143 0.100000 0.214286 -0.100000
...line 0.428571 0.000000 0.357143 0.100000
...line -0.071429 -0.100000 -0.142857 0.000000
...line 0.071429 0.100000 -0.071429 -0.100000
...line 0.142857 0.000000 0.071429 0.100000
...line -0.357143 -0.100000 -0.400000 -0.040000
...line -0.214286 0.100000 -0.357143 -0.100000
...line -0.142857 0.000000 -0.214286 0.100000
...line 0.500000 0.185714 0.428571 0.285714
...line 0.600000 0.325714 0.500000 0.185714
...line 0.214286 0.185714 0.142857 0.285714
...line 0.357143 0.385714 0.214286 0.185714
...line 0.428571 0.285714 0.357143 0.385714
...line -0.071429 0.185714 -0.142857 0.285714
...line 0.071429 0.385714 -0.071429 0.185714
...line 0.142857 0.285714 0.071429 0.385714
...line -0.357143 0.185714 -0.400000 0.245714
...line -0.214286 0.385714 -0.357143 0.185714
...line -0.142857 0.285714 -0.214286 0.385714
...line 0.500000 0.471429 0.428571 0.571429
...line 0.591837 0.600000 0.500000 0.471429
...line 0.214286 0.471429 0.142857 0.571429
...line 0.306122 0.600000 0.214286 0.471429
...line 0.428571 0.571429 0.408163 0.600000
...line -0.071429 0.471429 -0.142857 0.571429
...line 0.020408 0.600000 -0.071429 0.471429
...line 0.142857 0.571429 0.122449 0.600000
...line -0.357143 0.471429 -0.400000 0.531429
...line -0.265306 0.600000 -0.357143 0.471429
...line -0.142857 0.571429 -0.163265 0.600000
.IF
.P1
put rect {
	opaque exterior;
	bdlist = sw, se, ne, nw;
	sw = (-0.4,-0.4);
	wd = ht = 1;
};
.P2
.PP
If we plan to opaque a lot of rectangles,
we should include a
.IT bdlist
in the definition of
.IT rect .
Such a default
.IT bdlist
would be referenced only if the parameter section
of the put statement included an opaque statement
.IT and
did not include its own
.IT bdlist .
.NH 2
Opaque Circular Arc Polygons
.PP
The edges of opaque regions can also be circular arcs.
.Ts
This generalization of the simple boundary statement
is the most recent addition to \*(id.
It avoids treating circles and their sectors and segments
as special cases, and makes opaqueing circular
arc polygons much easier.
.Te
.LP
To specify a circular arc edge, one gives its endpoints
and a point through which it passes;
this ``pass-through'' point is marked in the boundary
list by the symbol ``\f8^\fP''.
For example, the boundary list for the sector shown below is
.\".IS
.\"...libfile sector
.\"main {
.\"	put background {
.\"	};
.\"put sector {
.\"	center = (-1,-1);
.\"	radius = 2;
.\"	startang = 30;
.\"	endang = 60;
.\"	opaque;
.\"};
.\"}
.\".IF
.P1
boundary = center, cis(30), ^ cis(45), cis(60);





.P2
.PP
Another common opaque arc is the segment:
.\".IS
.\"...libfile segment
.\"main {
.\"	put background {
.\"	};
.\"put segment {
.\"	center = (-1,-1);
.\"	radius = 2;
.\"	startang = 0;
.\"	endang = 90;
.\"	opaque;
.\"};
.\"}
.\".IF
.P1
boundary = cis(0), ^ cis(45), cis(90);










.P2
.PP
One can construct an opaque circle out of two semicircular edges:
.IS
...maxx 1.000000
...maxy 1.000000
...minx -1.000000
...miny -1.000000
...circle 0.000000 0.000000 1.000000
...arc 0.000000 0.000000 0.500000 0.000000 0.500000 0.000000 0.000000 6.283185 0.500000
...line 0.453088 -0.891466 0.428571 -0.857143
...line 0.642857 -0.757143 0.627545 -0.778581
...line 0.646799 -0.762661 0.642857 -0.757143
...line 0.214286 -0.957143 0.142857 -0.857143
...line 0.357143 -0.757143 0.214286 -0.957143
...line 0.428571 -0.857143 0.357143 -0.757143
...line -0.071429 -0.957143 -0.142857 -0.857143
...line 0.071429 -0.757143 -0.071429 -0.957143
...line 0.142857 -0.857143 0.071429 -0.757143
...line -0.380158 -0.924922 -0.428571 -0.857143
...line -0.214286 -0.757143 -0.344128 -0.938923
...line -0.142857 -0.857143 -0.214286 -0.757143
...line -0.500000 -0.757143 -0.553890 -0.832590
...line -0.428571 -0.857143 -0.500000 -0.757143
...line 0.765619 -0.643295 0.714286 -0.571429
...line 0.500000 -0.671429 0.428571 -0.571429
...line 0.642857 -0.471429 0.500000 -0.671429
...line 0.714286 -0.571429 0.642857 -0.471429
...line 0.214286 -0.671429 0.142857 -0.571429
...line 0.357143 -0.471429 0.214286 -0.671429
...line 0.428571 -0.571429 0.357143 -0.471429
...line -0.071429 -0.671429 -0.142857 -0.571429
...line 0.053035 -0.497179 -0.071429 -0.671429
...line 0.142857 -0.571429 0.086457 -0.492468
...line -0.357143 -0.671429 -0.428571 -0.571429
...line -0.214286 -0.471429 -0.357143 -0.671429
...line -0.142857 -0.571429 -0.214286 -0.471429
...line -0.642857 -0.671429 -0.714286 -0.571429
...line -0.500000 -0.471429 -0.642857 -0.671429
...line -0.428571 -0.571429 -0.500000 -0.471429
...line -0.785714 -0.471429 -0.838355 -0.545125
...line -0.714286 -0.571429 -0.785714 -0.471429
...line 0.785714 -0.385714 0.714286 -0.285714
...line 0.928571 -0.185714 0.785714 -0.385714
...line 0.969887 -0.243556 0.928571 -0.185714
...line 0.500000 -0.385714 0.428571 -0.285714
...line 0.642857 -0.185714 0.500000 -0.385714
...line 0.714286 -0.285714 0.642857 -0.185714
...line 0.428571 -0.285714 0.419177 -0.272563
...line -0.357143 -0.385714 -0.428571 -0.285714
...line -0.342097 -0.364650 -0.357143 -0.385714
...line -0.642857 -0.385714 -0.714286 -0.285714
...line -0.500000 -0.185714 -0.642857 -0.385714
...line -0.428571 -0.285714 -0.500000 -0.185714
...line -0.785714 -0.185714 -0.924805 -0.380441
...line -0.714286 -0.285714 -0.785714 -0.185714
...line 0.785714 -0.100000 0.714286 0.000000
...line 0.928571 0.100000 0.785714 -0.100000
...line 1.000000 0.000000 0.928571 0.100000
...line 0.500000 -0.100000 0.492041 -0.088857
...line 0.642857 0.100000 0.500000 -0.100000
...line 0.714286 0.000000 0.642857 0.100000
...line -0.642857 -0.100000 -0.714286 0.000000
...line -0.500000 0.100000 -0.642857 -0.100000
...line -0.492041 0.088857 -0.500000 0.100000
...line -0.928571 -0.100000 -1.000000 0.000000
...line -0.785714 0.100000 -0.928571 -0.100000
...line -0.714286 0.000000 -0.785714 0.100000
...line 0.785714 0.185714 0.714286 0.285714
...line 0.924805 0.380441 0.785714 0.185714
...line 0.500000 0.185714 0.428571 0.285714
...line 0.642857 0.385714 0.500000 0.185714
...line 0.714286 0.285714 0.642857 0.385714
...line 0.357143 0.385714 0.342097 0.364650
...line 0.428571 0.285714 0.357143 0.385714
...line -0.419177 0.272563 -0.428571 0.285714
...line -0.642857 0.185714 -0.714286 0.285714
...line -0.500000 0.385714 -0.642857 0.185714
...line -0.428571 0.285714 -0.500000 0.385714
...line -0.928571 0.185714 -0.969887 0.243556
...line -0.785714 0.385714 -0.928571 0.185714
...line -0.714286 0.285714 -0.785714 0.385714
...line 0.785714 0.471429 0.714286 0.571429
...line 0.838355 0.545125 0.785714 0.471429
...line 0.500000 0.471429 0.428571 0.571429
...line 0.642857 0.671429 0.500000 0.471429
...line 0.714286 0.571429 0.642857 0.671429
...line 0.214286 0.471429 0.142857 0.571429
...line 0.357143 0.671429 0.214286 0.471429
...line 0.428571 0.571429 0.357143 0.671429
...line -0.086457 0.492468 -0.142857 0.571429
...line 0.071429 0.671429 -0.053035 0.497179
...line 0.142857 0.571429 0.071429 0.671429
...line -0.357143 0.471429 -0.428571 0.571429
...line -0.214286 0.671429 -0.357143 0.471429
...line -0.142857 0.571429 -0.214286 0.671429
...line -0.642857 0.471429 -0.714286 0.571429
...line -0.500000 0.671429 -0.642857 0.471429
...line -0.428571 0.571429 -0.500000 0.671429
...line -0.714286 0.571429 -0.765619 0.643295
...line 0.500000 0.757143 0.428571 0.857143
...line 0.553891 0.832590 0.500000 0.757143
...line 0.214286 0.757143 0.142857 0.857143
...line 0.344128 0.938923 0.214286 0.757143
...line 0.428571 0.857143 0.380158 0.924922
...line -0.071429 0.757143 -0.142857 0.857143
...line 0.071429 0.957143 -0.071429 0.757143
...line 0.142857 0.857143 0.071429 0.957143
...line -0.357143 0.757143 -0.428571 0.857143
...line -0.214286 0.957143 -0.357143 0.757143
...line -0.142857 0.857143 -0.214286 0.957143
...line -0.642857 0.757143 -0.646799 0.762661
...line -0.627544 0.778581 -0.642857 0.757143
...line -0.428571 0.857143 -0.453088 0.891466
.IF
.P1
boundary = cis(0), ^ cis(90), cis(180), ^ cis(270);






.P2
.LP
Here, the outer circle has an opaque exterior,
while the inner circle has an opaque interior.
.NH 2
Order is Important
.PP
Without the ability to opaque,
the order in which boxes are put does not matter.
But when some boxes are opaque, order obviously
.IT does
matter.
Put statements are executed
in the order in which they appear in the box definition.
When an opaque box is drawn, the opaquing is done
.IT first ,
then the lines of the box are drawn;
so, for instance, an opaque
.IT listnode
does include the line down its middle separating its
.IT info
field from its
.IT next
field.
.NH 2
Some Hard Facts
.PP
Neither text nor splines can be used to opaque objects,
nor will they be clipped properly if they are in a
picture and an opaque box is placed over them.
.Ts
The problem with text is that \*(id operates as a \*(tf preprocessor,
so it cannot determine anything about the size of the
text, and it needs to know that if it is to do anything
involving opaquing and text.
.Te
.Ts
The problem with splines is more subtle.
When a line or circular arc is chopped,
it is easy to specify the lines or circular arcs that remain.
But when a spline is chopped, the guiding points of the resulting curve pieces
are hard to determine.
.Te
.NH 1
Paper Commands
.PP
\*(id includes two commands that are analogous
to the way people draw on paper.
.NH 2
Construct
.PP
The
.IT construct
statement looks just like a put statement,
with the keyword
.IT put
replaced by
.IT construct .
It is best to think of it as laying a sheet of
tracing paper over the current drawing.
Anything constructed will be drawn on this sheet.
When you return to the layer underneath,
you may refer to any of the local variables
as with a put statement, but the lines and curves
in the constructed picture don't show.
.IS
...maxy 2.0
...minx -1.0
...maxx 1.0
...maxx 0.542262
...maxy 0.500000
...minx 0.457738
...miny -1.500000
...line 0.500000 -1.000000 0.457738 -0.909369
...line 0.542262 -0.909369 0.500000 -1.000000
...line 0.500000 -1.000000 0.500000 0.000000
...center 0.500000 -1.500000 'bottom
...center 0.500000 0.500000 'top
.IF
.P1
main {
	construct A: rect {
		sw = 0;
		wd = ht = 1;
	};
	construct B: rect {
		n = A.s - (0,1);
		wd = ht = 1;
	};
	'top' at A.c;
	'bottom' at B.c;
	put arrow {
		hd = B.n;
		tl = A.s;
	};
}
.P2
.LP
Here we have used ``invisible boxes'' to place the
arrow around the text without drawing the boxes.
.NH 2
Draw
.PP
The
construct command may also be used to localize the
effects of opaque boxes.
We saw above how to draw a filled polygon:
paint over the area, then opaque the exterior
of the polygon.
But how can we draw
.IT two
filled polygons in the same picture?
.PP
One solution is to construct them both, then use the
.IT draw
command to add them to the main picture.
The draw command transfers the contents of the
named sheet of tracing paper to the sheet below.
.IS
...width 2.0
...colwid 8.0
...maxx 1.500000
...maxy 1.000000
...minx -0.475528
...miny -0.000000
...circle 1.000000 0.500000 0.500000
...line 1.443966 0.729988 1.400000 0.714286
...line 1.300000 0.821429 1.413687 0.780826
...line 1.362942 0.843908 1.300000 0.821429
...line 1.489215 0.603291 1.400000 0.571429
...line 1.300000 0.678571 1.487374 0.611652
...line 1.400000 0.714286 1.300000 0.678571
...line 1.498689 0.463818 1.400000 0.428571
...line 1.300000 0.535714 1.498755 0.464731
...line 1.400000 0.571429 1.300000 0.535714
...line 1.461538 0.307692 1.400000 0.285714
...line 1.300000 0.392857 1.470871 0.331832
...line 1.400000 0.428571 1.300000 0.392857
...line 1.300000 0.250000 1.408257 0.211337
...line 1.400000 0.285714 1.300000 0.250000
...line 1.300000 0.107143 1.306379 0.104865
...line 1.316742 0.113122 1.300000 0.107143
...line 1.300000 0.892857 1.200000 0.857143
...line 1.100000 0.964286 1.300000 0.892857
...line 1.142193 0.979355 1.100000 0.964286
...line 1.300000 0.750000 1.200000 0.714286
...line 1.100000 0.821429 1.300000 0.750000
...line 1.200000 0.857143 1.100000 0.821429
...line 1.300000 0.607143 1.200000 0.571429
...line 1.100000 0.678571 1.300000 0.607143
...line 1.200000 0.714286 1.100000 0.678571
...line 1.300000 0.464286 1.200000 0.428571
...line 1.100000 0.535714 1.300000 0.464286
...line 1.200000 0.571429 1.100000 0.535714
...line 1.300000 0.321429 1.200000 0.285714
...line 1.100000 0.392857 1.300000 0.321429
...line 1.200000 0.428571 1.100000 0.392857
...line 1.300000 0.178571 1.200000 0.142857
...line 1.100000 0.250000 1.300000 0.178571
...line 1.200000 0.285714 1.100000 0.250000
...line 1.100000 0.107143 1.235294 0.058824
...line 1.200000 0.142857 1.100000 0.107143
...line 1.100000 0.892857 1.000000 0.857143
...line 0.900000 0.964286 1.100000 0.892857
...line 1.000000 1.000000 0.900000 0.964286
...line 1.100000 0.750000 1.000000 0.714286
...line 0.900000 0.821429 1.100000 0.750000
...line 1.000000 0.857143 0.900000 0.821429
...line 1.100000 0.607143 1.000000 0.571429
...line 0.900000 0.678571 1.100000 0.607143
...line 1.000000 0.714286 0.900000 0.678571
...line 1.100000 0.464286 1.000000 0.428571
...line 0.900000 0.535714 1.100000 0.464286
...line 1.000000 0.571429 0.900000 0.535714
...line 1.100000 0.321429 1.000000 0.285714
...line 0.900000 0.392857 1.100000 0.321429
...line 1.000000 0.428571 0.900000 0.392857
...line 1.100000 0.178571 1.000000 0.142857
...line 0.900000 0.250000 1.100000 0.178571
...line 1.000000 0.285714 0.900000 0.250000
...line 1.100000 0.035714 1.000000 -0.000000
...line 0.900000 0.107143 1.100000 0.035714
...line 1.000000 0.142857 0.900000 0.107143
...line 0.900000 0.892857 0.800000 0.857143
...line 0.764706 0.941176 0.900000 0.892857
...line 0.900000 0.750000 0.800000 0.714286
...line 0.700000 0.821429 0.900000 0.750000
...line 0.800000 0.857143 0.700000 0.821429
...line 0.900000 0.607143 0.800000 0.571429
...line 0.700000 0.678571 0.900000 0.607143
...line 0.800000 0.714286 0.700000 0.678571
...line 0.900000 0.464286 0.800000 0.428571
...line 0.700000 0.535714 0.900000 0.464286
...line 0.800000 0.571429 0.700000 0.535714
...line 0.900000 0.321429 0.800000 0.285714
...line 0.700000 0.392857 0.900000 0.321429
...line 0.800000 0.428571 0.700000 0.392857
...line 0.900000 0.178571 0.800000 0.142857
...line 0.700000 0.250000 0.900000 0.178571
...line 0.800000 0.285714 0.700000 0.250000
...line 0.900000 0.035714 0.857807 0.020645
...line 0.700000 0.107143 0.900000 0.035714
...line 0.800000 0.142857 0.700000 0.107143
...line 0.700000 0.892857 0.683258 0.886878
...line 0.693621 0.895135 0.700000 0.892857
...line 0.700000 0.750000 0.600000 0.714286
...line 0.591743 0.788663 0.700000 0.750000
...line 0.700000 0.607143 0.600000 0.571429
...line 0.529129 0.668168 0.700000 0.607143
...line 0.600000 0.714286 0.538462 0.692308
...line 0.700000 0.464286 0.600000 0.428571
...line 0.501245 0.535269 0.700000 0.464286
...line 0.600000 0.571429 0.501311 0.536183
...line 0.700000 0.321429 0.600000 0.285714
...line 0.512626 0.388348 0.700000 0.321429
...line 0.600000 0.428571 0.510785 0.396709
...line 0.700000 0.178571 0.637057 0.156092
...line 0.586313 0.219174 0.700000 0.178571
...line 0.600000 0.285714 0.556034 0.270012
...line -0.475528 0.654508 0.000000 1.000000
...line -0.293893 0.095491 -0.475528 0.654508
...line 0.293893 0.095491 -0.293893 0.095491
...line 0.475528 0.654508 0.293893 0.095491
...line 0.000000 1.000000 0.475528 0.654508
...line 0.178571 0.171429 0.151451 0.095491
...line 0.205692 0.095491 0.178571 0.171429
...line 0.035714 0.171429 0.008594 0.095491
...line 0.062835 0.095491 0.035714 0.171429
...line -0.107143 0.171429 -0.134263 0.095492
...line -0.080022 0.095491 -0.107143 0.171429
...line -0.250000 0.171429 -0.277120 0.095491
...line -0.222880 0.095491 -0.250000 0.171429
...line 0.250000 0.114286 0.214286 0.214286
...line 0.321429 0.314286 0.250000 0.114286
...line 0.344235 0.250429 0.321429 0.314286
...line 0.107143 0.114286 0.071429 0.214286
...line 0.178571 0.314286 0.107143 0.114286
...line 0.214286 0.214286 0.178571 0.314286
...line -0.035714 0.114286 -0.071429 0.214286
...line 0.035714 0.314286 -0.035714 0.114286
...line 0.071429 0.214286 0.035714 0.314286
...line -0.178571 0.114286 -0.214286 0.214286
...line -0.107143 0.314286 -0.178571 0.114286
...line -0.071429 0.214286 -0.107143 0.314286
...line -0.250000 0.314286 -0.310208 0.145704
...line -0.214286 0.214286 -0.250000 0.314286
...line 0.368540 0.325232 0.357143 0.357143
...line 0.250000 0.257143 0.214286 0.357143
...line 0.321429 0.457143 0.250000 0.257143
...line 0.357143 0.357143 0.321429 0.457143
...line 0.107143 0.257143 0.071429 0.357143
...line 0.178571 0.457143 0.107143 0.257143
...line 0.214286 0.357143 0.178571 0.457143
...line -0.035714 0.257143 -0.071429 0.357143
...line 0.035714 0.457143 -0.035714 0.257143
...line 0.071429 0.357143 0.035714 0.457143
...line -0.178571 0.257143 -0.214286 0.357143
...line -0.107143 0.457143 -0.178571 0.257143
...line -0.071429 0.357143 -0.107143 0.457143
...line -0.321429 0.257143 -0.357143 0.357143
...line -0.250000 0.457143 -0.321429 0.257143
...line -0.214286 0.357143 -0.250000 0.457143
...line -0.392857 0.457143 -0.402567 0.429956
...line -0.357143 0.357143 -0.392857 0.457143
...line 0.392845 0.400035 0.357143 0.500000
...line 0.250000 0.400000 0.214286 0.500000
...line 0.321429 0.600000 0.250000 0.400000
...line 0.357143 0.500000 0.321429 0.600000
...line 0.107143 0.400000 0.071429 0.500000
...line 0.178571 0.600000 0.107143 0.400000
...line 0.214286 0.500000 0.178571 0.600000
...line -0.035714 0.400000 -0.071429 0.500000
...line 0.035714 0.600000 -0.035714 0.400000
...line 0.071429 0.500000 0.035714 0.600000
...line -0.178571 0.400000 -0.214286 0.500000
...line -0.107143 0.600000 -0.178571 0.400000
...line -0.071429 0.500000 -0.107143 0.600000
...line -0.321429 0.400000 -0.357143 0.500000
...line -0.250000 0.600000 -0.321429 0.400000
...line -0.214286 0.500000 -0.250000 0.600000
...line -0.392857 0.600000 -0.426872 0.504759
...line -0.357143 0.500000 -0.392857 0.600000
...line 0.392857 0.542857 0.357143 0.642857
...line 0.441549 0.679196 0.392857 0.542857
...line 0.250000 0.542857 0.214286 0.642857
...line 0.321429 0.742857 0.250000 0.542857
...line 0.357143 0.642857 0.321429 0.742857
...line 0.107143 0.542857 0.071429 0.642857
...line 0.178571 0.742857 0.107143 0.542857
...line 0.214286 0.642857 0.178571 0.742857
...line -0.035714 0.542857 -0.071429 0.642857
...line 0.035714 0.742857 -0.035714 0.542857
...line 0.071429 0.642857 0.035714 0.742857
...line -0.178571 0.542857 -0.214286 0.642857
...line -0.107143 0.742857 -0.178571 0.542857
...line -0.071429 0.642857 -0.107143 0.742857
...line -0.321429 0.542857 -0.357143 0.642857
...line -0.250000 0.742857 -0.321429 0.542857
...line -0.214286 0.642857 -0.250000 0.742857
...line -0.406498 0.704662 -0.451177 0.579562
...line -0.357143 0.642857 -0.384837 0.720400
...line 0.392857 0.685714 0.378939 0.724684
...line 0.401040 0.708627 0.392857 0.685714
...line 0.250000 0.685714 0.214286 0.785714
...line 0.287615 0.791036 0.250000 0.685714
...line 0.107143 0.685714 0.071429 0.785714
...line 0.174189 0.873444 0.107143 0.685714
...line 0.214286 0.785714 0.186025 0.864845
...line -0.035714 0.685714 -0.071429 0.785714
...line 0.035714 0.885714 -0.035714 0.685714
...line 0.071429 0.785714 0.035714 0.885714
...line -0.178571 0.685714 -0.214286 0.785714
...line -0.107143 0.885714 -0.178571 0.685714
...line -0.071429 0.785714 -0.107143 0.885714
...line -0.321429 0.685714 -0.344328 0.749831
...line -0.282482 0.794765 -0.321429 0.685714
...line -0.214286 0.785714 -0.230902 0.832240
...line 0.107143 0.828571 0.071429 0.928571
...line 0.133680 0.902876 0.107143 0.828571
...line -0.035714 0.828571 -0.071429 0.928571
...line 0.020255 0.985284 -0.035714 0.828571
...line 0.071429 0.928571 0.062008 0.954948
...line -0.178571 0.828571 -0.190393 0.861671
...line -0.158465 0.884868 -0.178571 0.828571
...line -0.071429 0.928571 -0.076967 0.944080
.IF
.P1
null {
}

pentagon {
	var center, radius,
		pt1, pt2, pt3, pt4, pt5;
	pt1 = center + radius;
	pt2 = center + cis(72)*radius;
	pt3 = center + cis(144)*radius;
	pt4 = center + cis(-144)*radius;
	pt5 = center + cis(-72)*radius;
	conn pt1 to pt2 to pt3 to pt4 to pt5 to pt1;
	bdlist = pt1, pt2, pt3, pt4, pt5;
}

main {
	construct A: null {
		conn (0,1) to 0
			using 7 brush {
				bwd = 1;
				bht = 0.1;
				}<top,bot>;
		put pentagon {
			center = (0,0.5);
			radius = (0,0.5);
			opaque exterior;
		};
	};
	construct B: null {
		conn (0.5,0.5) to (1.5,0.5)
			using 5 brush {
				bwd = (0,1);
				bht = 0.1;
				}<top,bot>;
		put circle {
			center = (1,0.5);
			radius = 0.5;
			opaque exterior;
		};
	};
	draw A;
	draw B;
}
.P2
.LP
Even put statements can be added to the parameter sections
of construct (and put) statements!
Believe it or not, box
.IT null
defined above is one of the most useful:
it gives us a way to name a set of commands and variables
so that we may reference them later, yet it doesn't
require us to define a box that will be used only once.
.PP
Given construct and draw, why do we need a special box
.IT hole
to opaque a circular area without drawing anything?
Why not just construct an opaque circle, then draw it
on the main picture?
The problem is that the effect of opaquing is localized
just as much as the drawing, so an opaque constructed
circle won't opaque anything that lies underneath.
.NH 1
Library Files
.PP
Library files are available to draw common figures and for special
figures like circles and arcs.
To include a library file as part of an \*(id program,
include the line
.P1
\&...libfile $name$
.P2
in your \*(id program (between the .IS and .IE lines that mark its
start and end.)
This section describes available library files that have been alluded
to up to now.
.NH 2
Rectangle
.PP
File
.IT rect
contains the definition of box
.IT rect ,
which looks like the definition in Section 3, with
five more variables:  $n$, $s$, $e$, $w$, and $c$,
which are the four compass points and the center,
respectively.
.P1
rect {
	var ne, nw, sw, se,
	n, e, w, s, c,
	ht, wd;
	ne = se + (0,1)*ht;
	nw = sw + (0,1)*ht;
	ne = nw + wd;
	n = (ne+nw)/2;
	s = (se+sw)/2;
	e = (ne+se)/2;
	w = (nw+sw)/2;
	c = (ne+sw)/2;
	ht ~ 1;
	wd ~ 1.5;
	bdlist = ne, nw, sw, se;
	conn ne to nw to sw to se to ne;
}
.P2
.NH 2
Arrow
.PP
File
.IT arrow
contains the definition of box
.IT arrow
as given in Section 3.
.P1
arrow {
	var tl, hd, head, perp, headang;
	conn tl to hd;
	perp = head*(tl-hd)/abs(tl-hd);
	conn hd + cis(headang)*perp to hd to hd + cis(-headang)*perp;
	head ~ 0.1;
	headang ~ 25;
}
.P2
.NH 2
Wavy
.PP
Library file
.IT wavy
contains the definition for the familiar
.IT wavy .
.P1
wavy {
	var start, end, perp, pt1, pt2, ht;
	perp = (0,1)*(start - end)/abs(start - end);
	pt1 = 0.25[start,end] + perp*ht;
	pt2 = 0.75[start,end] - perp*ht;
	conn start to pt1 to pt2 to end;
}
.P2
.NH 2
Dash
.PP
Library file
.IT dash
contains the definition of box
.IT dash ,
which may be useful for drawing dashed lines:
.P1
dash {
	var start, end;
	conn start to 0.25[start,end];
	conn 0.75[start,end] to end;
}
.P2
.NH 2
Circles
.PP
Box
.IT circle
resides in a library file of the same name, and
has the local variables described in Section 3:
$center$, $radius$, $z1$, $z2$, and $z3$.
.Ts
Box
.IT circle
actually consists of variable declarations
and a put of box
.IT CIRCLE .
So, if you will have many circles of a particular radius,
it might be easier for you to define your own, say, $circle3$:
.P1
...libfile CIRCLE
circle {
	var center, radius, z1, z2, z3;
	put CIRCLE {
		radius = 3;
	}
}
.P2
.Te
.NH 2
Arcs
.PP
Box
.IT arc
is contained in a library file of the same name,
with local variables as described in Section 3:
$center$, $radius$, $start$, $midway$, $end$,
$startang$, $midang$, and $endang$.
.Ts
As above,
.IT arc
calls on
a box called
.IT ARC .
.Te
.NH 1
Examples
.NH 2
B-Trees
.PP
This example depicts a B-tree whose nodes have many children.*
.FS
*P. J. Weinberger, Unix B-trees, Bell Laboratories, 1981.
.FE
.IS
...colwid 6.0
...width 3.0
...maxx 4.200000
...maxy 3.000000
...minx -0.653991
...miny -2.487688
...center 0.600000 1.500000 '.
...center 1.000000 1.500000 '.
...center 1.400000 1.500000 '.
...center 1.800000 1.500000 '.
...center 3.200000 -1.400000 '\(bu
...center 3.600000 -1.200000 '\(bu
...center 4.000000 -1.000000 '\(bu
...center 1.200000 -0.400000 '\(bu
...center 1.600000 -0.200000 '\(bu
...center 2.000000 0.000000 '\(bu
...line 0.000000 2.000000 0.084524 2.181262
...line 0.181262 2.084524 0.000000 2.000000
...line 0.000000 2.000000 1.000000 3.000000
...line 2.200000 0.200000 2.103814 0.375352
...line 2.239032 0.396155 2.200000 0.200000
...line 2.200000 0.200000 2.000000 1.500000
...line 1.000000 -0.400000 0.878177 -0.241384
...line 1.008635 -0.200186 1.000000 -0.400000
...line 1.000000 -0.400000 0.400000 1.500000
...line 0.400000 -0.700000 0.314862 -0.519026
...line 0.451108 -0.506640 0.400000 -0.700000
...line 0.400000 -0.700000 0.200000 1.500000
...line -0.200000 -1.000000 -0.253199 -0.807205
...line -0.116827 -0.818115 -0.200000 -1.000000
...line -0.200000 -1.000000 0.000000 1.500000
...line -0.200000 -1.000000 1.800000 -1.000000
...line -0.200000 -2.000000 -0.200000 -1.000000
...line 1.800000 -2.000000 -0.200000 -2.000000
...line 1.800000 -1.000000 1.800000 -2.000000
...line 2.253990 -2.391006 2.107719 -2.254607
...line 2.229616 -2.192497 2.253990 -2.391006
...line 2.253990 -2.391006 1.800000 -1.500000
...line 1.296434 -2.487688 1.199472 -2.312764
...line 1.334596 -2.291363 1.296434 -2.487688
...line 1.296434 -2.487688 1.140000 -1.500000
...line 0.303565 -2.487688 0.265404 -2.291363
...line 0.400527 -2.312764 0.303565 -2.487688
...line 0.303565 -2.487688 0.460000 -1.500000
...line -0.653991 -2.391006 -0.629617 -2.192497
...line -0.507720 -2.254607 -0.653991 -2.391006
...line -0.653991 -2.391006 -0.200000 -1.500000
...line 0.400000 -0.700000 2.400000 -0.700000
...line 0.400000 -1.000000 0.400000 -0.700000
...line 2.400000 -1.700000 1.800000 -1.700000
...line 2.400000 -0.700000 2.400000 -1.700000
...line 1.000000 -0.400000 3.000000 -0.400000
...line 1.000000 -0.700000 1.000000 -0.400000
...line 3.000000 -1.400000 2.400000 -1.400000
...line 3.000000 -0.400000 3.000000 -1.400000
...line 2.200000 0.200000 4.200000 0.200000
...line 2.200000 -0.400000 2.200000 0.200000
...line 4.200000 -0.800000 3.000000 -0.800000
...line 4.200000 0.200000 4.200000 -0.800000
...line 0.000000 2.000000 2.000000 2.000000
...line 0.000000 1.000000 0.000000 2.000000
...line 2.000000 1.000000 0.000000 1.000000
...line 2.000000 2.000000 2.000000 1.000000
.IF
.P1
\&...libfile rect
arrow {
	var tl, hd, headvec, head;
	headvec = hd + head*(tl - hd)/abs(tl - hd);
	conn tl to hd;
	conn hd + cis(20)*(headvec - hd)
		to hd
		to hd + cis(-20)*(headvec - hd);
}

dot {
	var s, e;
	'\e(bu' at 0.5[s, e] - (0,0.1);
}

per {
	var s, e;
	'.' at 0.5[s, e];
}

main {
	var rw, rh;
	rw = 2;
	rh = 1;
	var hmv, vmv;
	hmv = 0.6;
	vmv = 0.3;
	var ah;
	ah = 0.2;
	put root: rect {
		sw = (0,1);
		wd = rw;
		ht = 1;
	};
	put next: rect {
		sw = youngest.sw + 2*(hmv, vmv);
		wd = rw;
		ht = rh;
	};
	put youngest: rect {
		sw = bro.sw + (hmv, vmv);
		wd = rw;
		ht = rh;
		opaque;
	};
	put bro: rect {
		sw = eldest.sw + (hmv, vmv);
		wd = rw;
		ht = rh;
		opaque;
	};
	put eldest: rect {
		im(nw) = im(3[root.nw,root.sw]);
		re(0.5[nw, next.nw]) = re(0.5[root.nw, root.ne]);
		wd = rw;
		ht = rh;
		opaque;
		put arrow {
			head = ah;
			tl = 0.0[sw, se] + 0.5 * (nw - sw);
			hd = tl - (0, 1) * cis(-27);
		};
		put arrow {
			head = ah;
			tl = 0.33[sw, se] + 0.5 * (nw -sw);
			hd = tl - (0,1) * cis(-9);
		};
		put arrow {
			head = ah;
			tl = 0.67[sw, se] + 0.5 * (nw - sw);
			hd = tl - (0,1) * cis(9);
		};
		put arrow {
			head = ah;
			tl = 1.0[sw, se] + 0.5 * (nw -sw);
			hd = tl - (0,1) * cis(27);
		};
	};
	put arrow {
		head = ah;
		tl=root.sw + 0.5 * (root.nw - root.sw);
		hd=eldest.nw;
	};
	put arrow {
		head = ah;
		tl=0.1[root.sw,root.se] + 0.5 * (root.nw - root.sw);
		hd=bro.nw;
	};
	put a: arrow {
		head = ah;
		tl=0.2[root.sw,root.se] + 0.5 * (root.nw - root.sw);
		hd=youngest.nw;
	};
	put b: arrow {
		head = ah;
		tl = 0.5[root.ne, root.se];
		hd = next.nw;
	};
	put arrow {
		head = ah;
		hd = root.nw;
		tl = 0.5[root.nw, root.ne] + (0, 1.0);
	};
	conn next.nw to youngest.nw using 3 dot{}<s, e>;
	conn next.se to youngest.se using 3 dot{}<s, e>;
	conn b.tl to a.tl using 4 per{}<s, e>;
}
.P2
.NH 2
A Sector Grid
.PP
Norm Schryer used this figure to show how numerical integration
is used to find the area of planar regions.
.IS
...colwid 8.0
...width 2.0
...maxx 1.000000
...maxy 1.000000
...minx 0.000000
...miny 0.000000
...line 0.950000 0.312250 0.950000 0.000000
...line 0.900000 0.435890 0.900000 0.000000
...line 0.850000 0.526783 0.850000 0.000000
...line 0.800000 0.600000 0.800000 0.000000
...line 0.750000 0.661438 0.750000 0.000000
...line 0.700000 0.714143 0.700000 0.000000
...line 0.650000 0.759934 0.650000 0.000000
...line 0.600000 0.800000 0.600000 0.000000
...line 0.550000 0.835165 0.550000 0.000000
...line 0.500000 0.866025 0.500000 0.000000
...line 0.450000 0.893029 0.450000 0.000000
...line 0.400000 0.916515 0.400000 0.000000
...line 0.350000 0.936750 0.350000 0.000000
...line 0.300000 0.953939 0.300000 0.000000
...line 0.250000 0.968246 0.250000 0.000000
...line 0.200000 0.979796 0.200000 0.000000
...line 0.150000 0.988686 0.150000 0.000000
...line 0.100000 0.994987 0.100000 0.000000
...line 0.050000 0.998749 0.050000 0.000000
...line 0.000000 1.000000 0.000000 0.000000
...line 0.312250 0.950000 0.000000 0.950000
...line 0.435890 0.900000 0.000000 0.900000
...line 0.526783 0.850000 0.000000 0.850000
...line 0.600000 0.800000 0.000000 0.800000
...line 0.661438 0.750000 0.000000 0.750000
...line 0.714143 0.700000 0.000000 0.700000
...line 0.759934 0.650000 0.000000 0.650000
...line 0.800000 0.600000 0.000000 0.600000
...line 0.835165 0.550000 0.000000 0.550000
...line 0.866025 0.500000 0.000000 0.500000
...line 0.893029 0.450000 0.000000 0.450000
...line 0.916515 0.400000 0.000000 0.400000
...line 0.936750 0.350000 0.000000 0.350000
...line 0.953939 0.300000 0.000000 0.300000
...line 0.968246 0.250000 0.000000 0.250000
...line 0.979796 0.200000 0.000000 0.200000
...line 0.988686 0.150000 0.000000 0.150000
...line 0.994987 0.100000 0.000000 0.100000
...line 0.998749 0.050000 0.000000 0.050000
...line 1.000000 0.000000 0.000000 0.000000
.IF
.P1





\&...libfile hole
gridline {
	var a,b;
	var neg, pos;
	conn a - neg to a + pos;
}

main {
	var n;
	n = 21;
	conn (0,0) to (0,1+1/(n-1))
		using n gridline {
			neg = 0;
			pos = 1;
		} <a,b>;
	conn (0,0) to (1+1/(n-1),0)
		using n gridline {
			neg = 0;
			pos = (0,1);
		} <a,b>;
	put hole {
		radius = 1;
		center = (0,0);
		opaque exterior;
	};
}
.P2
.NH 2
Polygon Clipping
.PP
This example illustrates all possible positions of a line
segment with respect to a polygon.
It will appear in a book on graphics and image processing.*
.FS
*T. Pavlidis, Graphics and Image Processing, to be published.
.FE
.ps 8
.EQ
delim $$
gsize 8
define P12 " P sub 1 ( P sub 2 ) "
define P21 " P sub 2 ( P sub 1 )"
.EN
.IS
...width 4.5
...colwid 6.0
...minx -1
...maxx 6
...miny -1
...maxy 12
...maxx 4.700000
...maxy 10.600000
...minx -0.077382
...miny -0.600000
...left 3.600000 0.800000 '$P21$
...left 3.600000 1.200000 '$P12$
...circle 3.500000 0.800000 0.020000
...arc 3.500000 1.200000 3.520000 1.200000 3.520000 1.200000 0.000000 6.283185 0.020000
...line 3.500000 -0.600000 3.500000 0.780003
...line 3.500000 0.819994 3.500000 1.180000
...line 3.500000 1.220001 3.500000 2.600000
...line 4.500000 1.000000 4.000000 0.133975
...line 4.000000 0.133975 2.515192 0.826352
...line 2.515192 0.826352 2.515192 1.173648
...line 2.515192 1.173648 3.922618 1.906308
...line 3.922618 1.906308 4.500000 1.000000
...arc 1.000000 -0.400000 1.020000 -0.400000 1.020000 -0.400000 0.000000 6.283185 0.020000
...arc 1.000000 0.000000 1.020000 0.000000 1.020000 0.000000 0.000000 6.283185 0.020000
...line 1.000000 -0.600000 1.000000 -0.420000
...line 1.000000 -0.380000 1.000000 -0.020000
...line 1.000000 0.020000 1.000000 2.600000
...line 2.000000 1.000000 1.500000 0.133975
...line 1.500000 0.133975 0.015192 0.826352
...line 0.015192 0.826352 0.015192 1.173648
...line 0.015192 1.173648 1.422618 1.906308
...line 1.422618 1.906308 2.000000 1.000000
...arc 3.500000 4.000000 3.520000 4.000000 3.520000 4.000000 0.000000 6.283185 0.020000
...arc 3.500000 5.200000 3.520000 5.200000 3.520000 5.200000 0.000000 6.283185 0.020000
...line 3.500000 3.400000 3.500000 3.980000
...line 3.500000 4.020000 3.500000 5.180005
...line 3.500000 5.219995 3.500000 6.600000
...line 4.500000 5.000000 4.000000 4.133975
...line 4.000000 4.133975 2.515192 4.826352
...line 2.515192 4.826352 2.515192 5.173648
...line 2.515192 5.173648 3.922618 5.906308
...line 3.922618 5.906308 4.500000 5.000000
...arc 1.000000 4.000000 1.020000 4.000000 1.020000 4.000000 0.000000 6.283185 0.020000
...arc 1.000000 6.100000 1.020000 6.100000 1.020000 6.100000 0.000000 6.283185 0.020000
...line 1.000000 3.400000 1.000000 3.980000
...line 1.000000 4.020000 1.000000 6.080015
...line 1.000000 6.119984 1.000000 6.600000
...line 2.000000 5.000000 1.500000 4.133975
...line 1.500000 4.133975 0.015192 4.826352
...line 0.015192 4.826352 0.015192 5.173648
...line 0.015192 5.173648 1.422618 5.906308
...line 1.422618 5.906308 2.000000 5.000000
...arc 3.500000 9.200000 3.520000 9.200000 3.520000 9.200000 0.000000 6.283185 0.020000
...arc 3.500000 10.100000 3.520000 10.100000 3.520000 10.100000 0.000000 6.283185 0.020000
...line 3.500000 7.400000 3.500000 9.179997
...line 3.500000 9.220005 3.500000 10.080006
...line 3.500000 10.119987 3.500000 10.600000
...line 4.500000 9.000000 4.000000 8.133975
...line 4.000000 8.133975 2.515192 8.826352
...line 2.515192 8.826352 2.515192 9.173648
...line 2.515192 9.173648 3.922618 9.906308
...line 3.922618 9.906308 4.500000 9.000000
...arc 1.000000 10.400000 1.020000 10.400000 1.020000 10.400000 0.000000 6.283185 0.020000
...arc 1.000000 10.100000 1.020000 10.100000 1.020000 10.100000 0.000000 6.283185 0.020000
...line 1.000000 7.400000 1.000000 10.080006
...line 1.000000 10.119987 1.000000 10.379999
...line 2.000000 9.000000 1.500000 8.133975
...line 1.500000 8.133975 0.015192 8.826352
...line 0.015192 8.826352 0.015192 9.173648
...line 0.015192 9.173648 1.422618 9.906308
...line 1.422618 9.906308 2.000000 9.000000
...right 2.800000 -0.200000 '(f)
...left 4.700000 1.000000 '$----$
...left 1.100000 -0.400000 '$P21$
...left 1.100000 0.000000 '$P12$
...right 0.300000 -0.200000 '(e)
...left 0.015192 0.326352 '$--++$
...left 3.600000 4.000000 '$P21$
...left 3.600000 5.200000 '$P12$
...right 2.800000 3.800000 '(d)(d1)
...left 4.422618 5.456308 '$(--+-)$
...left 4.422618 5.606308 '$---+$
...left 1.100000 4.000000 '$P21$
...left 1.100000 6.100000 '$P12$
...right 0.300000 3.800000 '(c)(c1)
...left -0.077382 5.756308 '$(-++-)$
...left -0.077382 5.906308 '$+--+$
...left 3.600000 9.200000 '$P21$
...left 3.600000 10.100000 '$P12$
...right 2.800000 7.800000 '(b)(b1)
...left 4.422618 9.756309 '$(-+--)$
...left 4.422618 9.906308 '$+---$
...left 1.100000 10.400000 '$P21$
...left 1.100000 10.100000 '$P12$
...right 0.300000 7.800000 '(a)
...left -0.077382 9.906308 '$++--$
.IE
.ps
.P1
\&.ps 8
.EQ
delim off
.EN
\&.EQ
gsize 8
define P12 " P sub 1 ( P sub 2 ) "
define P21 " P sub 2 ( P sub 1 )"
\&.EN
\&...libfile circle
\&...minx -1
\&...maxx 6
\&...miny -1
\&...maxy 12
box spot{
	var loc;
	put circle{
		var center, radius;
		center = loc;
		radius = 0.02;
		opaque;
		};
	}
box vert{
	var midd, llength;
	conn midd+llength to midd-llength;
	}
box poly{
	var c1,p1,p2,p3,p4,p5,r1,tp,bp,ta,tb;
	p1 = c1+r1;
	p2 = cis(65)[c1,p1];
	p3 = cis(170)[c1,p1];
	p4 = cis(190)[c1,p1];
	p5 = cis(300)[c1,p1];
	tp = c1+(0,ta)*r1;
	bp = c1+(0,tb)*r1;
	conn p1 to p2;
	conn p2 to p3;
	conn p3 to p4;
	conn p4 to p5;
	conn p5 to p1;
	put vert{ midd=c1; llength=(0,1.6)*r1; };
	put spot{ loc=tp; };
	put spot{ loc=bp; };
	left '$P12$' at tp+0.1;
	left '$P21$' at bp+0.1;
	}
box main {
	put poly{
		c1 =(1,9); r1 = (1,0); ta=1.1; tb=1.4;
		left '$++--$' at p2-1.5;
		right '(a)' at c1-(0.7,1.2);
		};
	put poly{
		c1 =(3.5,9); r1 = (1,0); ta=1.1; tb=0.2;
		left '$+---$' at p2+0.5;
		left '$(-+--)$' at p2+(0.5,-0.15);
		right '(b)(b1)' at c1-(0.7,1.2);
		};
	put poly{
		c1 =(1,5); r1 = (1,0); ta=1.1; tb=-1;
		left '$+--+$' at p2-1.5;
		left '$(-++-)$' at p2-(1.5,0.15);
		right '(c)(c1)' at c1-(0.7,1.2);
		};
	put poly{
		c1 =(3.5,5); r1 = (1,0); ta=0.2; tb=-1;
		left '$---+$' at p2+(0.5,-0.3);
		left '$(--+-)$' at p2+(0.5,-0.45);
		right '(d)(d1)' at c1-(0.7,1.2);
		};
	put poly{
		c1 =(1,1); r1 = (1,0); ta=-1; tb=-1.4;
		left '$--++$' at p4-(0,0.5);
		right '(e)' at c1-(0.7,1.2);
		};
	put poly{
		c1 =(3.5,1); r1 = (1,0); ta=0.2; tb=-0.2;
		left '$----$' at p1+0.2;
		right '(f)' at c1-(0.7,1.2);
		};
}
.P2
.NH 1
Acknowledgements
.PP
My thanks to all who read drafts of this manual and
criticized constructively:
Al Aho,
Lorinda Cherry,
Eric Grosse,
Steve Johnson,
Brian Kernighan,
John Mashey,
Doug McIlroy,
and
Theo Pavlidis;
and to early users of \*(id, especially
Eric Grosse,
Theo Pavlidis,
Norm Schryer,
and
Peter Weinberger.
.SG MH-11272-CVW/unix
.[
$LIST$
.]
