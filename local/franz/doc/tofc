ch1.n:.Lc \s+2F\s-2RANZ\s0\ L\s-2ISP\s0\s-2 1
ch1.n:.sh 2
ch1.n:.sh 2 Data\ Types
ch1.n:.sh 3 lispval - - 0
ch1.n:.sh 3 symbol
ch1.n:.sh 3 list
ch1.n:.sh 3 binary
ch1.n:.sh 3 fixnum
ch1.n:.sh 3 flonum
ch1.n:.sh 3 bignum
ch1.n:.sh 3 string
ch1.n:.sh 3  port
ch1.n:.sh 3 array
ch1.n:.sh 3 value
ch1.n:.sh 3 hunk
ch1.n:.sh 2 Documentation Conventions.
ch2.n:.Lc Data\ Structure\ Access 2
ch2.n:.sh 2 Lists \n(ch 1
ch2.n:.sh 3 list\ creation
ch2.n:.Lf cons "'g_arg1 'g_arg2"
ch2.n:.Lf xcons "'g_arg1 'g_arg2"
ch2.n:.Lf ncons "'g_arg"
ch2.n:.Lf list "['g_arg1 ... ]"
ch2.n:.Lf append "'l_arg1 'l_arg2"
ch2.n:.Lf append1 "'l_arg1 'g_arg2"
ch2.n:.Lf quote! "g_form1 ..." 
ch2.n:.Lf bignum-to-list "'b_arg"
ch2.n:.Lf list-to-bignum "'l_ints"
ch2.n:.sh 3 list\ predicates 
ch2.n:.Lf dtpr "'g_arg"
ch2.n:.Lf listp "'g_arg"
ch2.n:.Lf tailp "'l_x 'l_y"
ch2.n:.Lf length "'l_arg"
ch2.n:.sh 3 list\ accessing
ch2.n:.Lf c\.\.r "'lh_arg"
ch2.n:.Lf nthcdr "'x_index 'l_list"
ch2.n:.Lf nthelem "'x_arg1 'l_arg2"
ch2.n:.Lf last "'l_arg"
ch2.n:.Lf ldiff "'l_x 'l_y"
ch2.n:.sh 3 list\ manipulation
ch2.n:.Lf rplaca "'lh_arg1 'g_arg2"
ch2.n:.Lf rplacd "'lh_arg1 'g_arg2"
ch2.n:.Lf attach "'g_x 'l_l"
ch2.n:.Lf delete "'g_val 'l_list ['x_count]"
ch2.n:.Lf delq "'g_val 'l_list ['x_count]"
ch2.n:.Lx dremove "'g_val 'l_list ['x_count]"
ch2.n:.Lf remove "'g_x 'l_l"
ch2.n:.Lf insert "'g_object 'l_list 'u_comparefn 'g_nodups"
ch2.n:.Lf merge "'l_data1 'l_data2 'u_comparefn"
ch2.n:.Lf subst "'g_x 'g_y 'l_s"
ch2.n:.Lx dsubst "'g_x 'g_y 'l_s"
ch2.n:.Lf lsubst "'l_x 'g_y 'l_s"
ch2.n:.Lf subpair "'l_old 'l_new 'l_expr"
ch2.n:.Lf nconc "'l_arg1 'l_arg2 ['l_arg3 ...]"
ch2.n:.Lf reverse "'l_arg"
ch2.n:.Lx nreverse "'l_arg"
ch2.n:.Lx dreverse "'l_arg"
ch2.n:.Lf nreconc "'l_arg 'g_arg"
ch2.n:.sh 2 Predicates
ch2.n:.Lf arrayp "'g_arg"
ch2.n:.Lf atom "'g_arg"
ch2.n:.Lf bcdp "'g_arg"
ch2.n:.Lf bigp "'g_arg"
ch2.n:.Lf dtpr "'g_arg"
ch2.n:.Lf hunkp "'g_arg"
ch2.n:.Lf listp "'g_arg"
ch2.n:.Lf stringp "'g_arg"
ch2.n:.Lf symbolp "'g_arg"
ch2.n:.Lf valuep "'g_arg"
ch2.n:.Lf type "'g_arg"
ch2.n:.Lx typep "'g_arg"
ch2.n:.Lf signp "'s_test 'g_val"
ch2.n:.Lf eq "'g_arg1 'g_arg2"
ch2.n:.Lf neq "'g_x 'g_y"
ch2.n:.Lf equal "'g_arg1 'g_arg2"
ch2.n:.Lx eqstr "'g_arg1 'g_arg2"
ch2.n:.Lf not "'g_arg"
ch2.n:.Lx null "'g_arg"
ch2.n:.Lf member "'g_arg1 'l_arg2"
ch2.n:.Lx memq "'g_arg1 'l_arg2"
ch2.n:.sh 2 Symbols\ and\ Strings
ch2.n:.sh 3 symbol\ and\ string\ creation
ch2.n:.Lf concat "['stn_arg1 ... ]"
ch2.n:.Lx uconcat "['stn_arg1 ... ]"
ch2.n:.Lf concatl "'l_arg"
ch2.n:.Lf implode "'l_arg"
ch2.n:.Lx maknam "'l_arg"
ch2.n:.Lf gensym "'s_leader"
ch2.n:.Lf copysymbol "'s_arg 'g_pred"
ch2.n:.Lf ascii "'x_charnum"
ch2.n:.Lf intern "'s_arg"
ch2.n:.Lf remob "'s_symbol"
ch2.n:.Lf rematom "'s_arg"
ch2.n:.sh 3 string\ and\ symbol\ predicates
ch2.n:.Lf symbolp "'g_arg"
ch2.n:.Lf stringp "'g_arg"
ch2.n:.Lf boundp "'s_name"
ch2.n:.Lf alphalessp "'st_arg1 'st_arg2"
ch2.n:.sh 3 symbol\ and\ string\ accessing
ch2.n:.Lf symeval "'s_arg"
ch2.n:.Lf get_pname "'s_arg"
ch2.n:.Lf plist "'s_arg"
ch2.n:.Lf getd "'s_arg"
ch2.n:.Lf getchar "'s_arg 'x_index"
ch2.n:.Lx nthchar "'s_arg 'x_index"
ch2.n:.Lx getcharn "'s_arg 'x_index"
ch2.n:.Lf substring "'st_string 'x_index ['x_length]"
ch2.n:.Lx substringn "'st_string 'x_index ['x_length]"
ch2.n:.sh 3 symbol\ and\ string\ manipulation
ch2.n:.Lf set "'s_arg1 'g_arg2"
ch2.n:.Lf setq "s_atm1 'g_val1 [ s_atm2 'g_val2 ... ... ]"
ch2.n:.Lf desetq "sl_pattern1 'g_exp1 [... ...]"
ch2.n:.Lf setplist "'s_atm 'l_plist"
ch2.n:.Lf makunbound "'s_arg"
ch2.n:.Lf aexplode "'s_arg"
ch2.n:.Lx explode  "'g_arg"
ch2.n:.Lx aexplodec "'s_arg"
ch2.n:.Lx explodec "'g_arg"
ch2.n:.Lx aexploden "'s_arg"
ch2.n:.Lx exploden "'g_arg"
ch2.n:.sh 2 Arrays
ch2.n:.sh 3 array\ creation
ch2.n:.Lf marray  "'g_data 's_access 'g_aux 'x_length 'x_delta"
ch2.n:.Lf *array "'s_name 's_type 'x_dim1 ... 'x_dim\fIn\fP"
ch2.n:.Lx array "s_name s_type x_dim1 ... x_dim\fIn\fP"
ch2.n:.sh 3 array\ predicate
ch2.n:.Lf arrayp "'g_arg"
ch2.n:.sh 3 array\ accessors
ch2.n:.Lf getaccess "'a_array"
ch2.n:.Lx getaux "'a_array"
ch2.n:.Lx getdelta "'a_array"
ch2.n:.Lx getdata "'a_array"
ch2.n:.Lx getentry "'a_array"
ch2.n:.Lf arrayref "'a_name 'x_ind"
ch2.n:.Lf arraycall "s_type 'as_array 'x_ind1 ... "
ch2.n:.Lf arraydims "'s_name"
ch2.n:.Lf listarray "'sa_array ['x_elements]"
ch2.n:.sh 3 array\ manipulation
ch2.n:.Lf putaccess "'a_array 'su_func"
ch2.n:.Lx putaux "'a_array 'g_aux"
ch2.n:.Lx putdata "'a_array 'g_arg"
ch2.n:.Lx putdelta "'a_array 'x_delta"
ch2.n:.Lx putdisc "'y_func 's_discipline"
ch2.n:.Lf store "'l_arexp 'g_val"
ch2.n:.Lf fillarray "'s_array 'l_itms"
ch2.n:.sh 2 Hunks
ch2.n:.sh 3 hunk\ creation
ch2.n:.Lf hunk "'g_val1 ['g_val2 ... 'g_val\fIn\fP]"
ch2.n:.Lf makhunk "'xl_arg"
ch2.n:.Lf *makhunk "'x_arg"
ch2.n:.sh 3 hunk\ predicates
ch2.n:.Lf hunkp "'g_arg"
ch2.n:.Lf hunksize "'h_arg"
ch2.n:.sh 3 hunk\ accessor
ch2.n:.Lf cxr "'x_ind 'h_hunk"
ch2.n:.sh 3 hunk\ manipulators
ch2.n:.Lf rplacx "'x_ind 'h_hunk 'g_val"
ch2.n:.Lx *rplacx "'x_ind 'h_hunk 'g_val"
ch2.n:.sh 2 Structures
ch2.n:.sh 3 assoc\ list
ch2.n:.Lf assoc "'g_arg1 'l_arg2"
ch2.n:.Lx assq "'g_arg1 'l_arg2"
ch2.n:.Lf sassoc "'g_arg1 'l_arg2 'sl_func"
ch2.n:.Lf sassq "'g_arg1 'l_arg2 'sl_func"
ch2.n:.Lf sublis "'l_alst 'l_exp"
ch2.n:.sh 3 property\ list
ch2.n:.Lf plist "'s_name"
ch2.n:.Lf setplist "'s_atm 'l_plist"
ch2.n:.Lf get "'ls_name 'g_ind"
ch2.n:.Lf getl "'ls_name 'l_indicators"
ch2.n:.Lf putprop "'ls_name 'g_val 'g_ind"
ch2.n:.Lx defprop "ls_name g_val g_ind"
ch2.n:.Lf remprop "'ls_name 'g_ind"
ch2.n:.sh 3 tconc\ structure
ch2.n:.Lf tconc "'l_ptr 'g_x"
ch2.n:.Lf lconc "'l_ptr 'l_x"
ch2.n:.sh 2 Random\ functions
ch2.n:.Lf bcdad "'s_funcname"
ch2.n:.Lf copy "'g_arg"
ch2.n:.Lf copyint* "'x_arg"
ch2.n:.Lf cpy1 "'xvt_arg"
ch2.n:.Lf getaddress "'s_entry1 's_binder1 'st_discipline1 [... ...]"
ch2.n:.Lf macroexpand "'g_form"
ch2.n:.Lf ptr "'g_arg"
ch2.n:.Lf quote "g_arg"
ch2.n:.Lf kwote "'g_arg"
ch2.n:.Lf replace "'g_arg1 'g_arg2"
ch2.n:.Lf scons "'x_arg 'bs_rest"
ch2.n:.Lf sload "'s_file"
ch2.n:.Lf sort "'l_data 'u_comparefn"
ch2.n:.Lf sortcar "'l_list 'u_comparefn"
ch3.n:.Lc Arithmetic\ Functions 3
ch3.n:.sh 2 "" \n(ch 0
ch3.n:.sh 2 Generic\ Functions
ch3.n:.Lf abs 'n_arg
ch3.n:.Lf absval "'n_arg"
ch3.n:.Lf add "['n_arg1 ...]"
ch3.n:.Lf add1 'n-arg
ch3.n:.Lf acos "'fx_arg"
ch3.n:.Lf asin "'fx_arg"
ch3.n:.Lf atan "'fx_arg1 'fx_arg2"
ch3.n:.Lf bignum-leftshift "bx_arg x_amount"
ch3.n:.Lf boole "'x_key 'x_v1 'x_v2 ..."
ch3.n:.Lf cos "'fx_angle"
ch3.n:.Lf diff "['n_arg1 ... ]"
ch3.n:.Lf difference "['n_arg1 ...]"
ch3.n:.Lf Divide "'i_dividend 'i_divisor"
ch3.n:.Lf Emuldiv "'x_fact1 'x_fact2 'x_addn 'x_divisor"
ch3.n:.Lf evenp "'x_arg"
ch3.n:.Lf exp "'fx_arg"
ch3.n:.Lf expt "'n_base 'n_power"
ch3.n:.Lf fact "'x_arg"
ch3.n:.Lf fix "'n_arg"
ch3.n:.Lf fixp "'g_arg"
ch3.n:.Lf float "'n_arg"
ch3.n:.Lf floatp "'g_arg"
ch3.n:.Lf greaterp "['n_arg1 ...]"
ch3.n:.Lf haipart "bx_number x_bits"
ch3.n:.Lf haulong "bx_number"
ch3.n:.Lf lessp "['n_arg1 ...]"
ch3.n:.Lf log "'fx_arg"
ch3.n:.Lf lsh "'x_val 'x_amt"
ch3.n:.Lf max "'n_arg1 ... "
ch3.n:.Lf min "'n_arg1 ... "
ch3.n:.Lf minus "'n_arg"
ch3.n:.Lf minusp "'g_arg"
ch3.n:.Lf mod "'i_dividend 'i_divisor"
ch3.n:.Lf *mod "'x_dividend 'x_divisor"
ch3.n:.Lf numberp "'g_arg"
ch3.n:.Lf numbp "'g_arg"
ch3.n:.Lf oddp "'x_arg"
ch3.n:.Lf onep "'g_arg"
ch3.n:.Lf plus "['n_arg ...]"
ch3.n:.Lf plusp "'n_arg"
ch3.n:.Lf product "['n_arg1 ... ]"
ch3.n:.Lf *quo "'i_x 'i_y"
ch3.n:.Lf quotient "['n_arg1 ...]"
ch3.n:.Lf random "['x_limit]"
ch3.n:.Lf remainder "'i_dividend 'i_divisor"
ch3.n:.Lf rot "'x_val 'x_amt"
ch3.n:.Lf sin "'fx_angle"
ch3.n:.Lf sqrt "'fx_arg"
ch3.n:.Lf sticky-bignum-leftshift "'bx_arg 'x_amount"
ch3.n:.Lf sub1 "'n_arg"
ch3.n:.Lf sum "['n_arg1 ...]"
ch3.n:.Lf times "['n_arg1 ... ]"
ch3.n:.Lf zerop "'g_arg"
ch3.n:.sh 2
ch3.n:.Lf 1+ "'x_arg"
ch3.n:.Lf 1\(mi "'x_arg"
ch3.n:.Lf \(pl "['x_arg ...]"
ch3.n:.Lf \(** "['x_arg ...]"
ch3.n:.Lf \(mi "['x_arg ...]"
ch3.n:.Lf  / "['x_arg1 ...]"
ch3.n:.Lf < "'x_arg1 'x_arg2"
ch3.n:.Lf \(eq "'g_arg1 'g_arg2"
ch3.n:.Lf > "'x_arg1 'x_arg2"
ch4.n:.Lc	Special\ Functions 4
ch4.n:.Lf and "[g_arg1 ...]"
ch4.n:.Lf apply "'u_func 'l_args"
ch4.n:.Lf arg "['x_numb]"
ch4.n:.Lf break "[g_message ['g_pred]]"
ch4.n:.Lf *break "'g_pred 'g_message"
ch4.n:.Lf catch "g_exp [ls_tag]"
ch4.n:.Lf *catch "'ls_tag g_exp"
ch4.n:.Lf comment "[g_arg ...]"
ch4.n:.Lf cond "[l_clause1 ...]"
ch4.n:.Lf cvttointlisp
ch4.n:.Lf cvttomaclisp
ch4.n:.Lf cvttoucilisp
ch4.n:.Lf debug "s_msg"
ch4.n:.Lf debugging "'g_arg"
ch4.n:.Lf declare "[g_arg ...]"
ch4.n:.Lf def "s_name (s_type l_argl g_exp1 ...)"
ch4.n:.Lf defmacro "s_name l_arg g_exp1 ..."
ch4.n:.Lf defun "s_name [s_mtype] ls_argl g_exp1 ... "
ch4.n:.Lf do "l_vrbs l_test g_exp1 ..."
ch4.n:.Lf do "s_name g_init g_repeat g_test g_exp1 ..."
ch4.n:.Lf err "['s_value [nil]]"
ch4.n:.Lf error "['s_message1 ['s_message2]]"
ch4.n:.Lf errset "g_expr [s_flag]"
ch4.n:.Lf eval "'g_val ['x_bind-pointer]"
ch4.n:.Lf evalframe "'x_pdlpointer"
ch4.n:.Lf evalhook "'g_form 'su_evalfunc ['su_funcallfunc]"
ch4.n:.Lf eval-when "l_times g_exp1 ... g_expn"
ch4.n:.Lf exec "s_arg1 ..."
ch4.n:.Lf exece "'s_fname ['l_args ['l_envir]]"
ch4.n:.Lf freturn "'x_pdl-pointer 'g_retval"
ch4.n:.Lf frexp "'f_arg"
ch4.n:.Lf funcall "'u_func ['g_arg1 ...]"
ch4.n:.Lf funcallhook "'l_form 'su_funcallfunc ['su_evalfunc]"
ch4.n:.Lf function "u_func"
ch4.n:.Lf getdisc "'y_func"
ch4.n:.Lf go "g_labexp"
ch4.n:.Lf I-throw-err "'l_token"
ch4.n:.Lf let "l_args g_exp1 ... g_exprn"
ch4.n:.Lf let* "l_args g_exp1 ... g_expn"
ch4.n:.Lf listify "'x_count"
ch4.n:.Lf map "'u_func 'l_arg1 ..."
ch4.n:.Lf mapc "'u_func 'l_arg1 ..."
ch4.n:.Lf mapcan "'u_func 'l_arg1 ..."
ch4.n:.Lf mapcar "'u_func 'l_arg1 ..."
ch4.n:.Lf mapcon "'u_func 'l_arg1 ..."
ch4.n:.Lf maplist "'u_func 'l_arg1 ..."
ch4.n:.Lf mfunction "t_entry 's_disc"
ch4.n:.Lf oblist
ch4.n:.Lf or "[g_arg1 ... ]"
ch4.n:.Lf prog "l_vrbls g_exp1 ..."
ch4.n:.Lf prog1 "'g_exp1 ['g_exp2 ...]"
ch4.n:.Lf prog2 "'g_exp1 'g_exp2 ['g_exp3 ...]"
ch4.n:.Lf progn "'g_exp1 ['g_exp2 ...]"
ch4.n:.Lf progv "'l_locv 'l_initv g_exp1 ..."
ch4.n:.Lf purcopy "'g_exp"
ch4.n:.Lf purep "'g_exp"
ch4.n:.Lf putd "'s_name 'u_func"
ch4.n:.Lf return "['g_val]"
ch4.n:.Lf setarg "'x_argnum 'g_val"
ch4.n:.Lf throw "'g_val [s_tag]"
ch4.n:.Lf *throw "'s_tag 'g_val"
ch4.n:.Lf unwind-protect "g_protected [g_cleanup1 ...]"
ch5.n:.Lc Input/Output 5
ch5.n:.Lf cfasl "'st_file 'st_entry 'st_funcname ['st_disc ['st_library]]"
ch5.n:.Lf close "'p_port" 
ch5.n:.Lf cprintf "'st_format 'xfst_val ['p_port]"
ch5.n:.Lf drain "['p_port]"
ch5.n:.Lf fasl "'st_name ['st_mapf ['g_warn]]"
ch5.n:.Lf ffasl "'st_file 'st_entry 'st_funcname ['st_discipline]"
ch5.n:.Lf filepos "'p_port ['x_pos]"
ch5.n:.Lf flatc "'g_form ['x_max]"
ch5.n:.Lf flatsize "'g_form ['x_max]"
ch5.n:.Lf fileopen "'st_name 'st_mode"
ch5.n:.Lf fseek "'p_port 'x_offset 'x_flag"
ch5.n:.Lf infile "'s_filename"
ch5.n:.Lf load "'s_filename ['st_map ['g_warn]]"
ch5.n:.Lf makereadtable "['s_flag]"
ch5.n:.Lf nwritn "['p_port]"
ch5.n:.Lf outfile "'s_filename ['st_type]"
ch5.n:.Lf patom "'g_exp ['p_port]"
ch5.n:.Lf pntlen "'xfs_arg"
ch5.n:.Lf portp "'g_arg"
ch5.n:.Lf pp "[l_option] s_name1 ..."
ch5.n:.Lf princ "'g_arg ['p_port]"
ch5.n:.Lf print "'g_arg ['p_port]"
ch5.n:.Lf probef "'st_file"
ch5.n:.Lf $prpr "'g_form"
ch5.n:.Lf ratom  "['p_port ['g_eof]]"
ch5.n:.Lf read "['p_port ['g_eof]]"
ch5.n:.Lf readc "['p_port ['g_eof]]"
ch5.n:.Lf readlist "'l_arg"
ch5.n:.Lf removeaddress "'s_name1 ['s_name2 ...]"
ch5.n:.Lf resetio
ch5.n:.Lf setsyntax "'s_symbol 's_synclass ['ls_func]"
ch5.n:.Lf tab "'x_col ['p_port]"
ch5.n:.Lf terpr "['p_port]"
ch5.n:.Lf terpri "['p_port]"
ch5.n:.Lf tyi "['p_port]"
ch5.n:.Lf tyipeek "['p_port]"
ch5.n:.Lf tyo "'x_char ['p_port]"
ch5.n:.Lf untyi "'x_char ['p_port]"
ch5.n:.Lf zapline 
ch6.n:.Lc System\ Functions 6
ch6.n:.Lf allocate "'s_type 'x_pages"
ch6.n:.Lf argv "'x_argnumb"
ch6.n:.Lf baktrace 
ch6.n:.Lf boundp "'s_name"
ch6.n:.Lf chdir "'s_path"
ch6.n:.Lf dumplisp "s_name"
ch6.n:.Lf eval-when "l_time g_exp1 ..."
ch6.n:.Lf exit "['x_code]"
ch6.n:.Lf fake "'x_addr"
ch6.n:.Lf fork 
ch6.n:.Lf gc
ch6.n:.Lf gcafter "s_type"
ch6.n:.Lf getenv "'s_name"
ch6.n:.Lf hashtabstat
ch6.n:.Lf help "[sx_arg]"
ch6.n:.Lf include "s_filename"
ch6.n:.Lf includef "'s_filename"
ch6.n:.Lf maknum "'g_arg"
ch6.n:.Lf monitor "['xs_maxaddr]"
ch6.n:.Lf opval "'s_arg ['g_newval]"
ch6.n:.Lf process "s_pgrm [s_frompipe s_topipe]"
ch6.n:.Lf ptime 
ch6.n:.Lf reset
ch6.n:.Lf restorelisp "'s_name"
ch6.n:.Lf retbrk "['x_level]
ch6.n:.Lf *rset "'g_flag"
ch6.n:.Lf savelisp "'s_name"
ch6.n:.Lf segment "'s_type 'x_size"
ch6.n:.Lf shell
ch6.n:.Lf showstack
ch6.n:.Lf signal "'x_signum 's_name"
ch6.n:.Lf sizeof "'g_arg"
ch6.n:.Lf small-segment "'s_type 'x_cells"
ch6.n:.Lf sstatus "g_type g_val"
ch6.n:.Lf sstatus\ appendmap "g_val"
ch6.n:.Lf sstatus\ automatic-reset "g_val"
ch6.n:.Lf sstatus\ chainatom "g_val"
ch6.n:.Lf sstatus\ dumpcore "g_val"
ch6.n:.Lf sstatus\ dumpmode "x_val"
ch6.n:.Lf sstatus\ evalhook "g_val"
ch6.n:.Lf sstatus\ feature "g_val"
ch6.n:.Lf sstatus\ gcstrings "g_val"
ch6.n:.Lf sstatus\ ignoreeof "g_val"
ch6.n:.Lf sstatus\ nofeature "g_val"
ch6.n:.Lf sstatus\ translink "g_val"
ch6.n:.Lf sstatus\ uctolc "g_val"
ch6.n:.Lf status "g_code"
ch6.n:.Lf status\ ctime 
ch6.n:.Lf status\ feature "g_val"
ch6.n:.Lf status\ features 
ch6.n:.Lf status\ isatty 
ch6.n:.Lf status\ localtime
ch6.n:.Lf status\ syntax "s_char"
ch6.n:.Lf status\ undeffunc
ch6.n:.Lf status\ version
ch6.n:.Lf syscall "'x_index ['xst_arg1 ...]"
ch6.n:.Lf top-level
ch6.n:.Lf wait
ch61.n:.Lc "Local functions" 61
ch7.n:.Lc The\ Lisp\ Reader 7
ch7.n:.sh 2 Introduction \n(ch 1
ch7.n:.sh +0 Syntax\ Classes
ch7.n:.sh +0 Reader\ operations
ch7.n:.sh +0 Character\ classes
ch7.n:.sh +0 Syntax\ classes
ch7.n:.sh +0 Character\ Macros
ch7.n:.sh +1 Types
ch7.n:.sh +1 Normal
ch7.n:.sh +0 Splicing
ch7.n:.sh +0 Infix
ch7.n:.sh -1 Invocations
ch7.n:.sh -1 Functions
ch7.n:.Lf setsyntax 's_symbol\ 's_synclass\ ['ls_func]
ch7.n:.Lf getsyntax 's_symbol
ch7.n:.Lf add-syntax-class 's_synclass\ 'l_properties
ch8.n:.Lc Functions\ and\ Macros 8
ch8.n:.sh 2 valid\ function\ objects 8
ch8.n:.sh 2 functions
ch8.n:.sh 2 macros
ch8.n:.sh 3  macro\ forms
ch8.n:.sh +0 defmacro
ch8.n:.sh +0 the\ backquote\ character\ macro
ch8.n:.sh +0 sharp\ sign\ character\ macro
ch8.n:.sh +1 conditional\ inclusion
ch8.n:.sh +0 fixnum\ character\ equivalents
ch8.n:.sh +0 read\ time\ evaluation
ch8.n:.sh 2 foreign\ subroutines\ and\ functions
ch9.n:.Lc Arrays 9
ch9.n:.sh 2 "general arrays" \n(ch 1
ch9.n:.sh 2 "subparts of an array object"
ch9.n:.sh 3 "access function"
ch9.n:.sh 3 auxiliary
ch9.n:.sh 3 data
ch9.n:.sh 3 length
ch9.n:.sh 3 delta
ch9.n:.sh 2 "The Maclisp compatible array package"
ch10.n:.Lc Exception\ Handling 10
ch10.n:.sh 2 Errset\ and\ Error\ Handler\ Functions 10
ch10.n:.sh 2 "The Anatomy of an error"
ch10.n:.sh 2 "Error handling algorithm"
ch10.n:.sh 2 "Default aids"
ch10.n:.sh +0 Autoloading
ch10.n:.sh +0 Interrupt\ processing
ch11.n:.Lc The\ Joseph\ Lister\ Trace\ Package 11
ch11.n:.Lf trace "[ls_arg1 ...]"
ch11.n:.Lf traceargs "s_func [x_level]"
ch11.n:.Lf tracedump ""
ch11.n:.Lf untrace "[s_arg1 ...]"
ch12.n:.Lc Liszt\ -\ the\ lisp\ compiler 12
ch12.n:.sh 2 "General strategy of the compiler" \n(ch 1
ch12.n:.sh 2 "Running the compiler"
ch12.n:.sh 2 "Special forms"
ch12.n:.sh 3  macro\ expansion
ch12.n:.sh +0 classification
ch12.n:.sh +1 "eval-when"
ch12.n:.sh +0 "declare"
ch12.n:.sh +0 "(progn 'compile \fRform1 form2 ... formn\fB)\fP"
ch12.n:.sh +0 "include/includef"
ch12.n:.sh +0 "def"
ch12.n:.sh +0 "other forms"
ch12.n:.sh 2 "Using the compiler"
ch12.n:.sh 2 "Compiler options"
ch12.n:.sh 2 autorun
ch12.n:.sh 2 "pure literals"
ch12.n:.sh 2 "transfer tables"
ch12.n:.sh +0 "Fixnum functions"
ch13.n:.Lc The\ CMU\ User\ Toplevel\ and\ the\ File\ Package 13
ch13.n:.sh 2 User\ Command\ Input\ Top\ Level 13
ch13.n:.Lf top-level
ch13.n:.Lf valueof "'g_eventspec"
ch13.n:.sh 2 The\ File\ Package
ch13.n:.Lf changes "s_flag"
ch13.n:.Lf dc "s_word s_id [ g_descriptor1  ... ] <text> <esc>"
ch13.n:.Lf dskin "l_filenames"
ch13.n:.Lf dskout "s_file1 ..."
ch13.n:.Lf dskouts "s_file1 ..."
ch13.n:.Lf dv  "s_atom g_value"
ch13.n:.Lf file "'s_file"
ch13.n:.Lf file-fns "'s_file"
ch13.n:.Lf getdef "'s_file ['s_i1 ...]"
ch13.n:.Lf mark!changed "'s_f"
ch14.n:.Lc The\ LISP\ Stepper 14
ch14.n:.sh 2 Simple\ Use\ Of\ Stepping 14
ch14.n:.Lf step "s_arg1..."
ch14.n:.sh 2 Advanced\ Features
ch14.n:.sh 3 Selectively\ Turning\ On\ Stepping.
ch14.n:.sh 3 Stepping\ With\ Breakpoints.
ch14.n:.sh 2 Overhead\ of\ Stepping.
ch14.n:.sh 2 Evalhook\ and\ Funcallhook
ch15.n:.Lc The\ FIXIT\ Debugger 15
ch15.n:.sh 2 Introduction 15
ch15.n:.Lf debug "[ s_msg ]"
ch15.n:.sh 2 Interaction\ with\ \fItrace\fP
ch15.n:.sh 2 Interaction\ with\ \fIstep\fP 
ch15.n:.sh 2 Multiple\ error\ levels
ch16.n:.Lc The\ LISP\ Editor 16
ch16.n:.sh 2 The\ Editors 16
ch16.n:.sh 2 Scope\ of\ Attention
ch16.n:.sh 2 Pattern\ Matching\ Commands
ch16.n:.sh 3 Commands\ That\ Search
ch16.n:.sh 4 Location\ Specifications
ch16.n:.sh 3 The\ Edit\ Chain
ch16.n:.sh 2 Printing\ Commands
ch16.n:.sh 2 Structure\ Modification\ Commands
ch16.n:.sh 2 Extraction\ and\ Embedding\ Commands
ch16.n:.sh 2 Move\ and\ Copy\ Commands
ch16.n:.sh 2 Parentheses\ Moving\ Commands
ch16.n:.sh 3 Using\ to\ and\ thru
ch16.n:.sh 2 Undoing\ Commands
ch16.n:.sh 2 \Commands\ that\ Evaluate
ch16.n:.sh 2 Commands\ that\ Test
ch16.n:.sh 2 Editor\ Macros
ch16.n:.sh 2 Miscellaneous\ Editor\ Commands
ch16.n:.sh 2 Editor\ Functions
ch16.n:.Lf editf "s_x1 ..."
ch16.n:.Lf edite "l_expr l_coms s_atm)"
ch16.n:.Lf editracefn "s_com"
ch16.n:.Lf editv "s_var [ g_com1 ... ]"
ch16.n:.Lf editp "s_x"
ch16.n:.Lf editl "coms atm marklst mess"
ch16.n:.Lf editfns "s_x [ g_coms1 ... ]" 
ch16.n:.Lf edit4e "pat y"
ch16.n:.Lf editfpat "pat flg"
ch16.n:.Lf editfindp "x pat flg"
ch16.n:.Lf ## "g_com1 ..."
