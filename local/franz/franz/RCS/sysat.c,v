head     1.20;
access   jkf sklower layer;
symbols  hash:1.19.1;
locks    ; strict;
comment  @ * @;


1.20
date     85.03.13.17.19.21;  author sklower;  state Exp;
branches ;
next     1.19;

1.19
date     84.02.29.16.52.50;  author sklower;  state Exp;
branches 1.19.1.1;
next     1.18;

1.18
date     83.12.09.16.13.50;  author sklower;  state Exp;
branches ;
next     1.17;

1.17
date     83.11.26.12.04.34;  author sklower;  state Exp;
branches ;
next     1.16;

1.16
date     83.09.29.22.46.53;  author jkf;  state Exp;
branches ;
next     1.15;

1.15
date     83.09.04.10.17.54;  author jkf;  state Exp;
branches ;
next     1.14;

1.14
date     83.08.29.14.52.14;  author sklower;  state Exp;
branches ;
next     1.13;

1.13
date     83.08.06.08.38.06;  author jkf;  state Exp;
branches ;
next     1.12;

1.12
date     83.07.24.21.26.42;  author sklower;  state Exp;
branches ;
next     1.11;

1.11
date     83.06.19.22.39.03;  author jkf;  state Exp;
branches ;
next     1.10;

1.10
date     83.06.19.15.15.50;  author jkf;  state Exp;
branches ;
next     1.9;

1.9
date     83.06.09.00.56.02;  author sklower;  state Exp;
branches ;
next     1.8;

1.8
date     83.06.04.02.11.47;  author sklower;  state Exp;
branches ;
next     1.7;

1.7
date     83.05.07.23.45.57;  author jkf;  state Exp;
branches ;
next     1.6;

1.6
date     83.03.21.16.40.42;  author jkf;  state Exp;
branches ;
next     1.5;

1.5
date     83.02.19.15.33.09;  author layer;  state Exp;
branches ;
next     1.4;

1.4
date     83.02.11.04.11.45;  author layer;  state Exp;
branches ;
next     1.3;

1.3
date     83.01.31.20.10.36;  author layer;  state Exp;
branches ;
next     1.2;

1.2
date     83.01.31.15.05.07;  author jkf;  state Exp;
branches ;
next     1.1;

1.1
date     83.01.29.13.38.11;  author jkf;  state Exp;
branches ;
next     ;

1.19.1.1
date     84.03.31.19.17.56;  author layer;  state Exp;
branches ;
next     ;


desc
@system initial data structure creation
@


1.20
log
@note existence of os_4_3
@
text
@#ifndef lint
static char *rcsid =
   "$Header: sysat.c,v 1.19 84/02/29 16:52:50 sklower Exp $";
#endif

/*					-[Thu Sep 29 14:05:32 1983 by jkf]-
 * 	sysat.c				$Locker: sklower $
 * startup data structure creation
 *
 * (c) copyright 1982, Regents of the University of California
 */

#include "global.h"
#include "lfuncs.h"
#define FIDDLE(z,b,c,y) z->a.clb=newdot(); (z->a.clb->d.car=newint())->i=b->i; \
	z->a.clb->d.cdr=newdot(); (z->a.clb->d.cdr->d.car=newint())->i=c->i; \
	z->a.clb->d.cdr->d.cdr=newdot(); (z->a.clb->d.cdr->d.cdr->d.car=newint())->i=y; \
	b = z->a.clb->d.car; c = z->a.clb->d.cdr->d.car; \
	copval(z,z->a.clb); z->a.clb = nil;

#define cforget(x) protect(x); Lforget(); unprot();

/*  The following array serves as the temporary counters of the items	*/
/*  and pages used in each space.					*/

long int tint[2*NUMSPACES];

extern int tgcthresh; 
extern int initflag; 	/*  starts off TRUE to indicate unsafe to gc  */

extern int *beginsweep;	/* place for garbage collector to begin sweeping */
extern int page_limit;  /* begin warning messages about running out of space */
extern char purepage[]; /* which pages should not be swept by gc */
extern int ttsize;	/* need to know how much of pagetable to set to other */

extern lispval Iaddstat(), Isstatus();
lispval inewatom();

makevals()
	{
	int i;
	lispval temp;

	/*  system list structure and atoms are initialized.  */

	/*  Before any lisp data can be created, the space usage */
	/*  counters must be set up, temporarily in array tint.  */

	atom_items = (lispval) &tint[0];
	atom_pages = (lispval) &tint[1];
	str_items = (lispval) &tint[2];
	str_pages = (lispval) &tint[3];
	int_items = (lispval) &tint[4];
	int_pages = (lispval) &tint[5];
	dtpr_items = (lispval) &tint[6];
	dtpr_pages = (lispval) &tint[7];
	doub_items = (lispval) &tint[8];
	doub_pages = (lispval) &tint[9];
	sdot_items = (lispval) &tint[10];
	sdot_pages = (lispval) &tint[11];
	array_items = (lispval) &tint[12];
	array_pages = (lispval) &tint[13];
	val_items = (lispval) &tint[14];
	val_pages = (lispval) &tint[15];
	funct_items = (lispval) &tint[16];
	funct_pages = (lispval) &tint[17];

	for (i=0; i < 7; i++)
	{
		hunk_pages[i] = (lispval) &tint[18+i*2];
		hunk_items[i] = (lispval) &tint[19+i*2];
	}

	vect_items = (lispval) &tint[34];
	vecti_items = (lispval) &tint[35];
	vect_pages = (lispval) &tint[36];
	vecti_pages = (lispval) &tint[37];
	other_items = (lispval) &tint[38];
	other_pages = (lispval) &tint[39];
	
	/*  This also applies to the garbage collection threshhold  */

	gcthresh = (lispval) &tgcthresh;

	/*  Now we commence constructing system lisp structures.  */

	/*  nil is a special case, constructed especially at location zero  */

	hasht[hashfcn("nil")] = (struct atom *)nil;


	/* allocate space for namestack and bindstack first
	 * then set up beginsweep variable so that the sweeper will
	 * ignore these `always in use' pages
	 */

	lbot = orgnp = np = ((struct argent *)csegment(VALUE,NAMESIZE,FALSE));
	orgbnp = bnp = ((struct nament *)csegment(DTPR,NAMESIZE,FALSE));
	/* since these dtpr pages will not be swept, we don't want them
	 * to show up in count of dtpr pages allocated or it will confuse
	 * gcafter when it tries to determine how much space is free
	 */
	dtpr_pages->i = 0;
	beginsweep = (int *) xsbrk(0);

	/*
	 *  patching up info in type and pure tables
	 */
#if unisys3botch
	/*
	 * This code is in here because Schriebman made Romberger tend
	 * more important things for too long for Apple and Fateman to
	 * wait
	 */
	{extern int dmpmode; int jj = ATOX(beginsweep);
	dmpmode = 407; for(i=19;i < jj; i++) typetable[i] = 0; }
#endif
	for(i=ATOX(beginsweep); i < ttsize; i++) (typetable+1)[i] = OTHER;
	purepage[ATOX(np)] = 1;  /* Mark these as non-gc'd arrays */
	purepage[ATOX(bnp)] = 1;

	/*
	 * Names of various spaces and things
	 */

	atom_name = inewatom("symbol");
	str_name = inewatom("string");
	int_name = inewatom("fixnum");
	dtpr_name = inewatom("list");
	doub_name = inewatom("flonum");
	sdot_name = inewatom("bignum");
	array_name = inewatom("array");
	val_name = inewatom("value");
	funct_name = inewatom("binary");
	port_name = inewatom("port");		/* not really a space */
	vect_name = inewatom("vector");
	vecti_name = inewatom("vectori");
	other_name = inewatom("other");

	{
	    char name[6], *strcpy();

	    strcpy(name, "hunk0");
	    for (i=0; i< 7; i++) {
		hunk_name[i] = matom(name);
		name[4]++;
	    }
	}
	
	/*  set up the name stack as an array of pointers */
	nplim = orgnp+NAMESIZE-6*NAMINC;
	temp = inewatom("namestack");
	nstack = temp->a.fnbnd = newarray();
	nstack->ar.data = (char *) (np);
	(nstack->ar.length = newint())->i = NAMESIZE;
	(nstack->ar.delta = newint())->i = sizeof(struct argent);
	Vnogbar = inewatom("unmarked_array");
	/* marking of the namestack will be done explicitly in gc1 */
	(nstack->ar.aux = newdot())->d.car = Vnogbar; 
						

	/* set up the binding stack as an array of dotted pairs */

	bnplim = orgbnp+NAMESIZE-5;
	temp = inewatom("bindstack");
	bstack = temp->a.fnbnd = newarray();
	bstack->ar.data = (char *) (bnp);
	(bstack->ar.length = newint())->i = NAMESIZE;
	(bstack->ar.delta = newint())->i = sizeof(struct nament);
	/* marking of the bindstack will be done explicitly in gc1 */
	(bstack->ar.aux = newdot())->d.car = Vnogbar; 

	/* more atoms */

	tatom = inewatom("t");
	tatom->a.clb = tatom;
	lambda = inewatom("lambda");
	nlambda = inewatom("nlambda");
	cara = inewatom("car");
	cdra = inewatom("cdr");
	Veval = inewatom("eval");
	quota = inewatom("quote");
	reseta = inewatom("reset");
	gcafter = inewatom("gcafter");	/* garbage collection wind-up */
	macro = inewatom("macro");
	ibase = inewatom("ibase");		/* base for input conversion */
	ibase->a.clb = inewint(10);
	(inewatom("base"))->a.clb = ibase->a.clb;
	fclosure = inewatom("fclosure");
	clos_marker = inewatom("int:closure-marker");
	Vpbv = inewatom("value-structure-argument");
	rsetatom = inewatom("*rset");
	rsetatom->a.clb = nil;
	Vsubrou = inewatom("subroutine");
	Vpiport = inewatom("piport");
	Vpiport->a.clb = P(piport = stdin);	/* standard input */
	Vpoport = inewatom("poport");
	Vpoport->a.clb = P(poport = stdout);	/* stand. output */
	inewatom("errport")->a.clb = (P(errport = stderr));/* stand. err. */
	ioname[PN(stdin)]  = (lispval) pinewstr("$stdin");
	ioname[PN(stdout)] = (lispval) pinewstr("$stdout");
	ioname[PN(stderr)] = (lispval) pinewstr("$stderr");
	inewatom("Standard-Input")->a.clb = Vpiport->a.clb;
	inewatom("Standard-Output")->a.clb = Vpoport->a.clb;
	inewatom("Standard-Error")->a.clb = P(errport);
	(Vreadtable = inewatom("readtable"))->a.clb  = Imkrtab(0);
	strtab = Imkrtab(0);
	Vptport = inewatom("ptport");
	Vptport->a.clb = nil;				/* protocal port */

	Vcntlw = inewatom("^w");	/* when non nil, inhibits output to term */
	Vcntlw->a.clb = nil;

	Vldprt = inewatom("$ldprint");	
			/* when nil, inhibits printing of fasl/autoload   */
						/* cfasl messages to term */
	Vldprt->a.clb = tatom;

	Vprinlevel = inewatom("prinlevel");	/* printer recursion count */
	Vprinlevel->a.clb = nil;		/* infinite recursion */

	Vprinlength = inewatom("prinlength");	/* printer element count */
	Vprinlength->a.clb = nil;		/* infinite elements */

	Vfloatformat = inewatom("float-format");
	Vfloatformat->a.clb = (lispval) pinewstr("%.16g");

	Verdepth = inewatom("Error-Depth");
	Verdepth->a.clb = inewint(0);		/* depth of error */

	Vpurcopylits = inewatom("$purcopylits");
	Vpurcopylits->a.clb = tatom;		/* tells fasl to purcopy
						 *  literals it reads
						 */
	Vdisplacemacros = inewatom("displace-macros");
        Vdisplacemacros->a.clb = nil;		/* replace macros calls
						 * with their expanded forms
						 */

	Vprintsym = inewatom("print");
	
	atom_buffer = (lispval) strbuf;
	Vlibdir = inewatom("lisp-library-directory");
	Vlibdir->a.clb = inewatom("/usr/lib/lisp");
	/*  The following atoms are used as tokens by the reader  */

	perda = inewatom(".");
	lpara = inewatom("(");
	rpara = inewatom(")");
	lbkta = inewatom("[");
	rbkta = inewatom("]");
	snqta = inewatom("'");
	exclpa = inewatom("!");


	(Eofa = inewatom("eof"))->a.clb = eofa;

	/*  The following few atoms have values the reader tokens.  */
	/*  Perhaps this is a kludge which should be abandoned.  */
	/*  On the other hand, perhaps it is an inspiration.	*/

	inewatom("perd")->a.clb = perda;
	inewatom("lpar")->a.clb = lpara;
	inewatom("rpar")->a.clb = rpara;
	inewatom("lbkt")->a.clb = lbkta;
	inewatom("rbkt")->a.clb = rbkta;

	noptop = inewatom("noptop");

	/*  atoms used in connection with comments.  */

	commta = inewatom("comment");
	rcomms = inewatom("readcomments");

	/*  the following atoms are used for lexprs */

	lexpr_atom = inewatom("last lexpr binding\7");
	lexpr = inewatom("lexpr");

	/* the following atom is used to reference the bind stack for eval */
	bptr_atom = inewatom("eval1 binding pointer\7");
	bptr_atom->a.clb = nil;

	/* the following atoms are used for evalhook hackery */
	evalhatom = inewatom("evalhook");
	evalhatom->a.clb = nil;
	evalhcallsw = FALSE;

	funhatom = inewatom("funcallhook");
	funhatom->a.clb = nil;
	funhcallsw = FALSE;

	Vevalframe = inewatom("evalframe");

	sysa = inewatom("sys");
	plima = inewatom("pagelimit");	/*  max number of pages  */


	startup = inewatom("startup");	/*  used by save and restore  */
	sysa = inewatom("sys");	/*  sys indicator for system variables  */
	splice = inewatom("splicing");


	
	/* vector stuff */

	odform = inewatom("odformat");	/* format for printf's used in od */
	rdrsdot = newsdot();		/* used in io conversions of bignums */
	rdrsdot2 = newsdot();		/* used in io conversions of bignums */
	rdrint = newint();		/* used as a temporary integer */
	(nilplist = newdot())->d.cdr = newdot();
					/* used as property list for nil,
					   since nil will eventually be put at
					   0 (consequently in text and not
					   writable) */

	/* error variables */
	(Vererr = inewatom("ER%err"))->a.clb = nil;
	(Vertpl = inewatom("ER%tpl"))->a.clb = nil;
	(Verall = inewatom("ER%all"))->a.clb = nil;
	(Vermisc = inewatom("ER%misc"))->a.clb = nil;
	(Verbrk = inewatom("ER%brk"))->a.clb = nil;
	(Verundef = inewatom("ER%undef"))->a.clb = nil;
	(Vlerall = newdot())->d.car = Verall;	/* list (ER%all) */
	(Veruwpt = inewatom("ER%unwind-protect"))->a.clb = nil;
	(Verrset = inewatom("errset"))->a.clb = nil;


	/* set up the initial status list */

	stlist = nil;			/* initially nil */
	{
	    lispval feature, dom;
	    Iaddstat(inewatom("features"),ST_READ,ST_NO,nil);
	    Iaddstat(feature = inewatom("feature"),ST_FEATR,ST_FEATW,nil);
	    Isstatus(feature,inewatom("franz"));
	    Isstatus(feature,inewatom("Franz"));
	    Isstatus(feature,inewatom(OS));
	    Isstatus(feature,inewatom("string"));
	    Isstatus(feature,dom = inewatom(DOMAIN));
	    Iaddstat(inewatom("domain"),ST_READ,ST_NO,dom);
	    Isstatus(feature,inewatom(MACHINE));
#ifdef PORTABLE
	    Isstatus(feature,inewatom("portable"));
#endif
#ifdef unisoft
	    Isstatus(feature,inewatom("unisoft"));
#endif
#ifdef sun
	    Isstatus(feature,inewatom("sun"));
#endif
#ifdef os_masscomp
	    Isstatus(feature,inewatom("mc500"));
#endif
#if os_4_1c | os_4_2 | os_4_3
	    Isstatus(feature,inewatom("long-filenames"));
#endif
	}
	Iaddstat(inewatom("nofeature"),ST_NFETR,ST_NFETW,nil);
	Iaddstat(inewatom("syntax"),ST_SYNT,ST_NO,nil);
	Iaddstat(inewatom("uctolc"),ST_READ,ST_TOLC,nil);
	Iaddstat(inewatom("dumpcore"),ST_READ,ST_CORE,nil);
	Isstatus(inewatom("dumpcore"),nil);	/*set up signals*/

	Iaddstat(inewatom("chainatom"),ST_RINTB,ST_INTB,inewint(0));
	Iaddstat(inewatom("dumpmode"),ST_DMPR,ST_DMPW,nil);
	Iaddstat(inewatom("appendmap"),ST_READ,ST_SET,nil);  /* used by fasl */
	Iaddstat(inewatom("debugging"),ST_READ,ST_SET,nil);  
	Iaddstat(inewatom("evalhook"),ST_RINTB,ST_INTB,inewint(3));
	Isstatus(inewatom("evalhook"),nil); /*evalhook switch off */
	Iaddstat(inewatom("bcdtrace"),ST_READ,ST_BCDTR,nil);
	Iaddstat(inewatom("ctime"),ST_CTIM,ST_NO,nil);
	Iaddstat(inewatom("localtime"),ST_LOCT,ST_NO,nil);
	Iaddstat(inewatom("isatty"),ST_ISTTY,ST_NO,nil);
	Iaddstat(inewatom("ignoreeof"),ST_READ,ST_SET,nil);
	Iaddstat(inewatom("version"),ST_READ,ST_NO,mstr("Franz Lisp, Opus 38"));
	Iaddstat(inewatom("automatic-reset"),ST_READ,ST_AUTR,nil);
	Iaddstat(inewatom("translink"),ST_READ,ST_TRAN,nil);
	Isstatus(inewatom("translink"),nil);		/* turn off tran links */
	Iaddstat(inewatom("undeffunc"),ST_UNDEF,ST_NO,nil); /* list undef funcs */
	Iaddstat(inewatom("gcstrings"),ST_READ,ST_GCSTR,nil); /* gc strings */

	/* garbage collector things */

	gcport = inewatom("gcport");	/* port for gc dumping */
	gccheck = inewatom("gccheck");	/* flag for checking during gc */
	gcdis = inewatom("gcdisable");	/* variable for disabling the gc */
	gcdis->a.clb = nil;
	gcload = inewatom("gcload");	/* option for gc while loading */
	loading = inewatom("loading");	/* flag--in loader if = t  */
	noautot = inewatom("noautotrace");	/* option to inhibit auto-trace */
	Vgcprint = inewatom("$gcprint");	/* if t then pring gc messages */
	Vgcprint->a.clb = nil;
	
	(gcthresh = newint())->i = tgcthresh;
	gccall1 = newdot();  gccall2 = newdot();  /* used to call gcafter */
	gccall1->d.car = gcafter;  /* start constructing a form for eval */

	arrayst = mstr("ARRAY");	/* array marker in name stack */
	bcdst = mstr("BINARY");		/* binary function marker */
	listst = mstr("INTERPRETED");	/* interpreted function marker */
	macrost = mstr("MACRO");	/* macro marker */
	protst = mstr("PROTECTED");	/* protection marker */
	badst = mstr("BADPTR");		/* bad pointer marker */
	argst = mstr("ARGST");		/* argument marker */
	hunkfree = mstr("EMPTY");	/* empty hunk cell value */

	/* type names */

	FIDDLE(atom_name,atom_items,atom_pages,ATOMSPP);
	FIDDLE(str_name,str_items,str_pages,STRSPP);
	FIDDLE(other_name,other_items,other_pages,STRSPP);
	FIDDLE(int_name,int_items,int_pages,INTSPP);
	FIDDLE(dtpr_name,dtpr_items,dtpr_pages,DTPRSPP);
	FIDDLE(doub_name,doub_items,doub_pages,DOUBSPP);
	FIDDLE(sdot_name,sdot_items,sdot_pages,SDOTSPP);
	FIDDLE(array_name,array_items,array_pages,ARRAYSPP);
	FIDDLE(val_name,val_items,val_pages,VALSPP);
	FIDDLE(funct_name,funct_items,funct_pages,BCDSPP);

	FIDDLE(hunk_name[0], hunk_items[0], hunk_pages[0], HUNK2SPP);
	FIDDLE(hunk_name[1], hunk_items[1], hunk_pages[1], HUNK4SPP);
	FIDDLE(hunk_name[2], hunk_items[2], hunk_pages[2], HUNK8SPP);
	FIDDLE(hunk_name[3], hunk_items[3], hunk_pages[3], HUNK16SPP);
	FIDDLE(hunk_name[4], hunk_items[4], hunk_pages[4], HUNK32SPP);
	FIDDLE(hunk_name[5], hunk_items[5], hunk_pages[5], HUNK64SPP);
	FIDDLE(hunk_name[6], hunk_items[6], hunk_pages[6], HUNK128SPP);
	
	FIDDLE(vect_name, vect_items, vect_pages, VECTORSPP)
	FIDDLE(vecti_name, vecti_items, vecti_pages, VECTORSPP)

	(plimit = newint())->i = page_limit;
	copval(plima,plimit);  /*  default value  */

	/* the following atom is used when reading caar, cdar, etc. */

	xatom = inewatom("??");
	dofuns();
#if sun_4_1c ||sun_4_2 || sun_4_2beta
	hookupcore();
#endif
	/*  now it is OK to collect garbage  */

	initflag = FALSE;
	}

/*  matom("name")  ******************************************************/
/*									*/
/*  simulates an atom being read in from the reader and returns a	*/
/*  pointer to it.							*/
/*									*/
/*  BEWARE:  if an atom becomes "truly worthless" and is collected,	*/
/*  the pointer becomes obsolete.					*/
/*									*/
lispval
matom(string)
char *string;
	{
	strbuf[0] = 0;
	strncat(strbuf,string,STRBLEN-1); /* strcpyn always pads to n */
	strbuf[STRBLEN-1] = 0;
	return(getatom(TRUE));
	}

/*  mstr  ***************************************************************/
/*									*/
/*  Makes a string.  Uses matom.					*/
/*  Not the most efficient but will do until the string from the code	*/
/*  itself can be used as a lispval.					*/

lispval mstr(string) char *string;
	{
	return((lispval)(pinewstr(string)));
	}

/*  mfun("name",start)  *************************************************/
/*									*/
/*  Same as matom, but entry point to c code is associated with		*/
/*  "name" as function binding.						*/
/*  A pointer to the atom is returned.					*/
/*									*/
lispval mfun(string,start,discip) char *string; lispval (*start)(), discip;
	{
	lispval v;
	v = inewatom(string);
	v->a.fnbnd = newfunct();
	v->a.fnbnd->bcd.start = start;
	v->a.fnbnd->bcd.discipline = discip;
	return(v);
	}

struct ftab {
	char *string;
	lispval (*start)();
	lispval *discip;
};

lispval
mftab(table)
register struct ftab *table;
{
	register lispval v;
	for(;table->string;table++) {
		v = inewatom(table->string);
		v = v->a.fnbnd = newfunct();
		v->bcd.start = table->start;
		v->bcd.discipline = *table->discip;
	}
}

static struct ftab cfuns[] = {
  {"car", Lcar, &(lambda)},
  {"cdr", Lcdr, &(lambda)},
  {"eval", Leval1, &(lambda)},
  {"asin", Lasin, &(lambda)},
  {"acos", Lacos, &(lambda)},
  {"atan", Latan, &(lambda)},
  {"cos", Lcos, &(lambda)},
  {"sin", Lsin, &(lambda)},
  {"sqrt", Lsqrt, &(lambda)},
  {"exp", Lexp, &(lambda)},
  {"log", Llog, &(lambda)},
  {"lsh", Llsh, &(lambda)},
  {"bignum-leftshift", Lbiglsh, &(lambda)},
  {"sticky-bignum-leftshift", Lsbiglsh, &(lambda)},
  {"frexp", Lfrexp, &(lambda)},
  {"rot", Lrot, &(lambda)},
  {"random", Lrandom, &(lambda)},
  {"atom", Latom, &(lambda)},
  {"apply", Lapply, &(lambda)},
  {"funcall", Lfuncal, &(lambda)},
  {"lexpr-funcall", Llexfun, &(lambda)},
  {"return", Lreturn, &(lambda)},
/* 	MK("cont",Lreturn,lambda),  */
  {"cons", Lcons, &(lambda)},
  {"scons", Lscons, &(lambda)},
  {"bignum-to-list", Lbigtol, &(lambda)},
  {"cadr", Lcadr, &(lambda)},
  {"caar", Lcaar, &(lambda)},
  {"cddr", Lc02r, &(lambda)},
  {"caddr", Lc12r, &(lambda)},
  {"cdddr", Lc03r, &(lambda)},
  {"cadddr", Lc13r, &(lambda)},
  {"cddddr", Lc04r, &(lambda)},
  {"caddddr", Lc14r, &(lambda)},
  {"nthelem", Lnthelem, &(lambda)},
  {"eq", Leq, &(lambda)},
  {"equal", Lequal, &(lambda)},
/**	MK("zqual",Zequal,lambda), 	*/
  {"numberp", Lnumberp, &(lambda)},
  {"dtpr", Ldtpr, &(lambda)},
  {"bcdp", Lbcdp, &(lambda)},
  {"portp", Lportp, &(lambda)},
  {"arrayp", Larrayp, &(lambda)},
  {"valuep", Lvaluep, &(lambda)},
  {"get_pname", Lpname, &(lambda)},
  {"ptr", Lptr, &(lambda)},
  {"arrayref", Larayref, &(lambda)},
  {"marray", Lmarray, &(lambda)},
  {"getlength", Lgetl, &(lambda)},
  {"putlength", Lputl, &(lambda)},
  {"getaccess", Lgeta, &(lambda)},
  {"putaccess", Lputa, &(lambda)},
  {"getdelta", Lgetdel, &(lambda)},
  {"putdelta", Lputdel, &(lambda)},
  {"getaux", Lgetaux, &(lambda)},
  {"putaux", Lputaux, &(lambda)},
  {"getdata", Lgetdata, &(lambda)},
  {"putdata", Lputdata, &(lambda)},
  {"mfunction", Lmfunction, &(lambda)},
  {"getentry", Lgtentry, &(lambda)},
  {"getdisc", Lgetdisc, &(lambda)},
  {"putdisc", Lputdisc, &(lambda)},
  {"segment", Lsegment, &(lambda)},
  {"rplaca", Lrplca, &(lambda)},
  {"rplacd", Lrplcd, &(lambda)},
  {"set", Lset, &(lambda)},
  {"replace", Lreplace, &(lambda)},
  {"infile", Linfile, &(lambda)},
  {"outfile", Loutfile, &(lambda)},
  {"terpr", Lterpr, &(lambda)},
  {"print", Lprint, &(lambda)},
  {"close", Lclose, &(lambda)},
  {"patom", Lpatom, &(lambda)},
  {"pntlen", Lpntlen, &(lambda)},
  {"read", Lread, &(lambda)},
  {"ratom", Lratom, &(lambda)},
  {"readc", Lreadc, &(lambda)},
  {"truename", Ltruename, &(lambda)},
  {"implode", Limplode, &(lambda)},
  {"maknam", Lmaknam, &(lambda)},
  {"deref", Lderef, &(lambda)},
  {"concat", Lconcat, &(lambda)},
  {"uconcat", Luconcat, &(lambda)},
  {"putprop", Lputprop, &(lambda)},
  {"monitor", Lmonitor, &(lambda)},
  {"get", Lget, &(lambda)},
  {"getd", Lgetd, &(lambda)},
  {"putd", Lputd, &(lambda)},
  {"prog", Nprog, &(nlambda)},
  {"quote", Nquote, &(nlambda)},
  {"function", Nfunction, &(nlambda)},
  {"go", Ngo, &(nlambda)},
  {"*catch", Ncatch, &(nlambda)},
  {"errset", Nerrset, &(nlambda)},
  {"status", Nstatus, &(nlambda)},
  {"sstatus", Nsstatus, &(nlambda)},
  {"err-with-message", Lerr, &(lambda)},
  {"*throw", Nthrow, &(lambda)},	/* this is a lambda now !! */
  {"reset", Nreset, &(nlambda)},
  {"break", Nbreak, &(nlambda)},
  {"exit", Lexit, &(lambda)},
  {"def", Ndef, &(nlambda)},
  {"null", Lnull, &(lambda)},
	  	/*{"framedump", Lframedump, &(lambda)},*/
  {"and", Nand, &(nlambda)},
  {"or", Nor, &(nlambda)},
  {"setq", Nsetq, &(nlambda)},
  {"cond", Ncond, &(nlambda)},
  {"list", Llist, &(lambda)},
  {"load", Lload, &(lambda)},
  {"nwritn", Lnwritn, &(lambda)},
  {"*process", Lprocess, &(lambda)},	/*  execute a shell command  */
  {"allocate", Lalloc, &(lambda)},	/*  allocate a page  */
  {"sizeof", Lsizeof, &(lambda)},	/*  size of one item of a data type  */
  {"dumplisp", Ndumplisp, &(nlambda)},	/*  NEW save the world  */
  {"top-level", Ntpl, &(nlambda)},	/*  top level eval-print read loop  */
  {"mapcar", Lmpcar, &(lambda)},
  {"maplist", Lmaplist, &(lambda)},
  {"mapcan", Lmapcan, &(lambda)},
  {"mapcon", Lmapcon, &(lambda)},
  {"assq", Lassq, &(lambda)},
  {"mapc", Lmapc, &(lambda)},
  {"map", Lmap, &(lambda)},
  {"flatc", Lflatsi, &(lambda)},
  {"alphalessp", Lalfalp, &(lambda)},
  {"drain", Ldrain, &(lambda)},
  {"killcopy", Lkilcopy, &(lambda)}, /*  forks aand aborts for adb */
  {"opval", Lopval, &(lambda)},	/*  sets and retrieves system variables  */
  {"ncons", Lncons, &(lambda)},
  {"remob", Lforget, &(lambda)},	/*  function to take atom out of hash table  */
  {"not", Lnull, &(lambda)},
  {"plus", Ladd, &(lambda)},
  {"add", Ladd, &(lambda)},
  {"times", Ltimes, &(lambda)},
  {"difference", Lsub, &(lambda)},
  {"quotient", Lquo, &(lambda)},
  {"+", Lfp, &(lambda)},
  {"-", Lfm, &(lambda)},
  {"*", Lft, &(lambda)},
  {"/", Lfd, &(lambda)},
  {"1+", Lfadd1, &(lambda)},
  {"1-", Lfsub1, &(lambda)},
  {"^", Lfexpt, &(lambda)},
  {"double-to-float", Ldbtofl, &(lambda)},
  {"float-to-double", Lfltodb, &(lambda)},
  {"<", Lflessp, &(lambda)},
  {"mod", Lmod, &(lambda)},
  {"minus", Lminus, &(lambda)},
  {"absval", Labsval, &(lambda)},
  {"add1", Ladd1, &(lambda)},
  {"sub1", Lsub1, &(lambda)},
  {"greaterp", Lgreaterp, &(lambda)},
  {"lessp", Llessp, &(lambda)},
  {"any-zerop", Lzerop, &(lambda)},   /* used when bignum arg possible */
  {"zerop", Lzerop, &(lambda)},
  {"minusp", Lnegp, &(lambda)},
  {"onep", Lonep, &(lambda)},
  {"sum", Ladd, &(lambda)},
  {"product", Ltimes, &(lambda)},
  {"do", Ndo, &(nlambda)},
  {"progv", Nprogv, &(nlambda)},
  {"progn", Nprogn, &(nlambda)},
  {"prog2", Nprog2, &(nlambda)},
  {"oblist", Loblist, &(lambda)},
  {"baktrace", Lbaktrace, &(lambda)},
  {"tyi", Ltyi, &(lambda)},
  {"tyipeek", Ltyipeek, &(lambda)},
  {"untyi", Luntyi, &(lambda)},
  {"tyo", Ltyo, &(lambda)},
  {"termcapinit", Ltci, &(lambda)},
  {"termcapexe", Ltcx, &(lambda)},
  {"int:setsyntax", Lsetsyn, &(lambda)},	/* an internal function */
  {"int:getsyntax", Lgetsyntax, &(lambda)},
  {"int:showstack", LIshowstack, &(lambda)},
  {"int:franz-call", LIfranzcall, &(lambda)},
  {"makereadtable", Lmakertbl, &(lambda)},
  {"zapline", Lzapline, &(lambda)},
  {"aexplode", Lxplda, &(lambda)},
  {"aexplodec", Lxpldc, &(lambda)},
  {"aexploden", Lxpldn, &(lambda)},
  {"hashtabstat", Lhashst, &(lambda)},
#ifdef METER
  {"gcstat", Lgcstat, &(lambda)},
#endif
  {"argv", Largv, &(lambda)},
  {"arg", Larg, &(lambda)},
  {"setarg", Lsetarg, &(lambda)},
  {"showstack", Lshostk, &(lambda)},
  {"freturn", Lfretn, &(lambda)},
  {"*rset", Lrset, &(lambda)},
  {"eval1", Leval1, &(lambda)},
  {"evalframe", Levalf, &(lambda)},
  {"evalhook", Levalhook, &(lambda)},
  {"funcallhook", Lfunhook, &(lambda)},
  {"int:fclosure-stack-stuff", LIfss, &(lambda)},
  {"resetio", Nioreset, &(nlambda)},
  {"chdir", Lchdir, &(lambda)},
  {"ascii", Lascii, &(lambda)},
  {"boole", Lboole, &(lambda)},
  {"type", Ltype, &(lambda)},	/* returns type-name of argument */
  {"fix", Lfix, &(lambda)},
  {"float", Lfloat, &(lambda)},
  {"fact", Lfact, &(lambda)},
  {"cpy1", Lcpy1, &(lambda)},
  {"Divide", LDivide, &(lambda)},
  {"Emuldiv", LEmuldiv, &(lambda)},
  {"readlist", Lreadli, &(lambda)},
  {"plist", Lplist, &(lambda)},	/* gives the plist of an atom */
  {"setplist", Lsetpli, &(lambda)},	/* get plist of an atom  */
  {"eval-when", Nevwhen, &(nlambda)},
  {"syscall", Lsyscall, &(lambda)},
  {"intern", Lntern, &(lambda)},
  {"ptime", Lptime, &(lambda)},	/* return process user time */
  {"fork", Lfork, &(lambda)},	/* turn on fork and wait */
  {"wait", Lwait, &(lambda)},
/*	MK("pipe",Lpipe,lambda),	*/
/*	MK("fdopen",Lfdopen,lambda), */
  {"exece", Lexece, &(lambda)},
  {"gensym", Lgensym, &(lambda)},
  {"remprop", Lremprop, &(lambda)},
  {"bcdad", Lbcdad, &(lambda)},
  {"symbolp", Lsymbolp, &(lambda)},
  {"stringp", Lstringp, &(lambda)},
  {"rematom", Lrematom, &(lambda)},
/**	MK("prname",Lprname,lambda),	*/
  {"getenv", Lgetenv, &(lambda)},
  {"I-throw-err", Lctcherr, &(lambda)}, /* directly force a throw or error */
  {"makunbound", Lmakunb, &(lambda)},
  {"haipart", Lhaipar, &(lambda)},
  {"haulong", Lhau, &(lambda)},
  {"signal", Lsignal, &(lambda)},
  {"fasl", Lfasl, &(lambda)},	/* NEW - new fasl loader */
  {"cfasl", Lcfasl, &(lambda)},	/* read in compiled C file */
  {"getaddress", Lgetaddress, &(lambda)},
  {"removeaddress", Lrmadd, &(lambda)}, 	/* unbind symbols    */
  {"make-c-thunk", Lmkcth, &(lambda)}, 	/* make wrappers    */
  {"boundp", Lboundp, &(lambda)},	/* tells if an atom is bound */
  {"fake", Lfake, &(lambda)},	/* makes a fake lisp pointer */
/***	MK("od",Lod,lambda),		/* dumps info */
  {"maknum", Lmaknum, &(lambda)},	/* converts a pointer to an integer */
  {"*mod", LstarMod, &(lambda)},		/* return fixnum modulus */
  {"*invmod", Lstarinvmod, &(lambda)},	/* return fixnum modulus ^-1 */
  {"fseek", Lfseek, &(lambda)},	/* seek to a specific byte in a file */
  {"fileopen",  Lfileopen, &( lambda)},
  {"pv%", Lpolyev, &(lambda)},	/* polynomial evaluation instruction*/
  {"cprintf", Lcprintf, &(lambda)},  /* formatted print 		    */
  {"sprintf", Lsprintf, &(lambda)},  /* formatted print to string	    */
  {"copyint*", Lcopyint, &(lambda)},	/* copyint*  */
  {"purcopy", Lpurcopy, &(lambda)},	/* pure copy */
  {"purep", Lpurep, &(lambda)},	/* check if pure */
  {"int:memreport", LImemory, &(lambda)}, /* dump memory stats */
/*
 * Hunk stuff
 */
  {"*makhunk", LMakhunk, &(lambda)},		/* special hunk creater */
  {"hunkp", Lhunkp, &(lambda)},		/* test a hunk */
  {"cxr", Lcxr, &(lambda)},			/* cxr of a hunk */
  {"rplacx", Lrplcx, &(lambda)},		/* replace element of a hunk */
  {"*rplacx", Lstarrpx, &(lambda)},		/* rplacx used by hunk */
  {"hunksize", Lhunksize, &(lambda)},	/* size of a hunk */
  {"hunk-to-list", Lhtol, &(lambda)},	/* hunk to list */
  {"new-vector", Lnvec, &(lambda)},
  {"new-vectori-byte", Lnvecb, &(lambda)},
  {"new-vectori-word", Lnvecw, &(lambda)},
  {"new-vectori-long", Lnvecl, &(lambda)},
  {"vectorp", Lvectorp, &(lambda)},
  {"vectorip", Lpvp, &(lambda)},
  {"int:vref", LIvref, &(lambda)},
  {"int:vset", LIvset, &(lambda)},
  {"int:vsize", LIvsize, &(lambda)},
  {"vsetprop", Lvsp, &(lambda)},
  {"vprop", Lvprop, &(lambda)},
  {"probef", Lprobef, &(lambda)},	/* test file existance */
  {"substring", Lsubstring, &(lambda)},
  {"substringn", Lsstrn, &(lambda)},
  {"character-index", Lcharindex, &(lambda)}, /* index of char in string */
  {"time-string", Ltymestr, &(lambda)},
  {"gc", Ngc, &(nlambda)},
  {"gcafter", Ngcafter, &(nlambda)},	/* garbage collection wind-up */
  {0}
};
static dofuns(){mftab(cfuns);}
@


1.19
log
@1.) add (status feature mc500 for masscomp)
2.) add new function (make-c-thunk)
@
text
@d3 1
a3 1
   "$Header: sysat.c,v 1.18 83/12/09 16:13:50 sklower Exp $";
d355 1
a355 1
#if os_4_1c | os_4_2
@


1.19.1.1
log
@hash table hacks
@
text
@d6 1
a6 1
/*					-[Wed Mar 14 19:14:28 1984 by layer]-
d40 1
a40 1
{
a42 1
	extern struct atom nilatom;
d87 1
a87 2
	/*  nil is added first */
	addkey ( &nilatom, oblist);
d89 3
a351 1

d442 1
a443 4
	packages = makehashtable ("packagetable", 20);
	addpackage (oblist);

	/*  now it is OK to collect garbage  */
d445 1
a445 1
}
d447 8
a454 8
/*  matom("name")
**
**  simulates an atom being read in from the reader and returns a
**  pointer to it.
**
**  BEWARE:  if an atom becomes "truly worthless" and is collected,
**  the pointer becomes obsolete.
*/
d458 1
a458 1
{
d460 1
a460 2
	/* strcpyn always pads to n */
	strncat(strbuf,string,STRBLEN-1);
d463 1
a463 1
}
d472 1
a472 1
{
d474 1
a474 1
}
d638 2
a639 2
  {"killcopy", Lkilcopy, &(lambda)}, /* forks and aborts for adb */
  {"opval", Lopval, &(lambda)},	/* sets and retrieves system variables */
d641 1
a641 1
  {"remob", Lforget, &(lambda)}, /* function to take atom out of hash table */
d675 1
d692 1
d747 1
d749 2
a750 2
  {"fake", Lfake, &(lambda)},		/* makes a fake lisp pointer */
  {"od", Lod, &(lambda)},		/* dumps info */
a783 12

/*
** hash table stuff
*/
  {"hashtabstat", Lhashst, &(lambda)},
  {"oblist", Loblist, &(lambda)},
  {"list-all-packages", Lallpackages, &(lambda)},
  {"gethash", Lgethash, &(lambda)},
  {"addhash", Laddhash, &(lambda)},
  {"make-hash-table", Lmakeht, &(lambda)},
  {"hash-table-p", Lhtablep, &(lambda)},

@


1.18
log
@Reorganize the way all the C coded lisp internal functions are
hooked up, by means of a table, so that people can easily hook
up libaries whosale, by generating appropriate tables.

Also, accomodate two bugs in uniplus system III, (a)
partially initiallized arrays being set to the character 
&, and (b) shared text being unnacceptable for the write system call.
@
text
@d3 1
a3 1
   "$Header: sysat.c,v 1.17 83/11/26 12:04:34 sklower Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker:  $
d352 3
d747 1
@


1.17
log
@bug in initializing segments of type table and pure page flags --
need to subtract offsets.
@
text
@d3 1
a3 1
   "$Header: sysat.c,v 1.16 83/09/29 22:46:53 jkf Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker: sklower $
a14 1
#define MK(x,y,z) mfun(x,y,z)
d37 1
d109 9
d126 13
a138 13
	atom_name = matom("symbol");
	str_name = matom("string");
	int_name = matom("fixnum");
	dtpr_name = matom("list");
	doub_name = matom("flonum");
	sdot_name = matom("bignum");
	array_name = matom("array");
	val_name = matom("value");
	funct_name = matom("binary");
	port_name = matom("port");		/* not really a space */
	vect_name = matom("vector");
	vecti_name = matom("vectori");
	other_name = matom("other");
d152 1
a152 1
	temp = matom("namestack");
d157 1
a157 1
	Vnogbar = matom("unmarked_array");
d165 1
a165 1
	temp = matom("bindstack");
d175 1
a175 1
	tatom = matom("t");
d177 10
a186 4
	lambda = matom("lambda");
	nlambda = matom("nlambda");
	macro = matom("macro");
	ibase = matom("ibase");		/* base for input conversion */
d188 5
a192 5
	(matom("base"))->a.clb = ibase->a.clb;
	fclosure = matom("fclosure");
	clos_marker = matom("int:closure-marker");
	Vpbv = matom("value-structure-argument");
	rsetatom = matom("*rset");
d194 2
a195 2
	Vsubrou = matom("subroutine");
	Vpiport = matom("piport");
d197 1
a197 1
	Vpoport = matom("poport");
d199 1
a199 1
	matom("errport")->a.clb = (P(errport = stderr));/* stand. err. */
d203 4
a206 4
	matom("Standard-Input")->a.clb = Vpiport->a.clb;
	matom("Standard-Output")->a.clb = Vpoport->a.clb;
	matom("Standard-Error")->a.clb = P(errport);
	(Vreadtable = matom("readtable"))->a.clb  = Imkrtab(0);
d208 1
a208 1
	Vptport = matom("ptport");
d211 1
a211 1
	Vcntlw = matom("^w");	/* when non nil, inhibits output to term */
d214 1
a214 1
	Vldprt = matom("$ldprint");	
d219 1
a219 1
	Vprinlevel = matom("prinlevel");	/* printer recursion count */
d222 1
a222 1
	Vprinlength = matom("prinlength");	/* printer element count */
d225 1
a225 1
	Vfloatformat = matom("float-format");
d228 1
a228 1
	Verdepth = matom("Error-Depth");
d231 1
a231 1
	Vpurcopylits = matom("$purcopylits");
d235 1
a235 1
	Vdisplacemacros = matom("displace-macros");
d240 1
a240 1
	Vprintsym = matom("print");
d243 2
a244 2
	Vlibdir = matom("lisp-library-directory");
	Vlibdir->a.clb = matom("/usr/lib/lisp");
d247 7
a253 7
	perda = matom(".");
	lpara = matom("(");
	rpara = matom(")");
	lbkta = matom("[");
	rbkta = matom("]");
	snqta = matom("'");
	exclpa = matom("!");
d256 1
a256 3
	(Eofa = matom("eof"))->a.clb = eofa;
	cara = MK("car",Lcar,lambda);
	cdra = MK("cdr",Lcdr,lambda);
d262 5
a266 5
	matom("perd")->a.clb = perda;
	matom("lpar")->a.clb = lpara;
	matom("rpar")->a.clb = rpara;
	matom("lbkt")->a.clb = lbkta;
	matom("rbkt")->a.clb = rbkta;
d268 1
a268 1
	noptop = matom("noptop");
d272 2
a273 2
	commta = matom("comment");
	rcomms = matom("readcomments");
d277 2
a278 2
	lexpr_atom = matom("last lexpr binding\7");
	lexpr = matom("lexpr");
d281 1
a281 1
	bptr_atom = matom("eval1 binding pointer\7");
d285 1
a285 1
	evalhatom = matom("evalhook");
d289 1
a289 1
	funhatom = matom("funcallhook");
d293 1
a293 1
	Vevalframe = matom("evalframe");
d295 2
a296 3
	sysa = matom("sys");
	plima = matom("pagelimit");	/*  max number of pages  */
	Veval = MK("eval",Leval1,lambda);
d299 3
a301 245
	MK("asin",Lasin,lambda);
	MK("acos",Lacos,lambda);
	MK("atan",Latan,lambda);
	MK("cos",Lcos,lambda);
	MK("sin",Lsin,lambda);
	MK("sqrt",Lsqrt,lambda);
	MK("exp",Lexp,lambda);
	MK("log",Llog,lambda);
	MK("lsh",Llsh,lambda);
	MK("bignum-leftshift",Lbiglsh,lambda);
	MK("sticky-bignum-leftshift",Lsbiglsh,lambda);
	MK("frexp",Lfrexp,lambda);
	MK("rot",Lrot,lambda);
	MK("random",Lrandom,lambda);
	MK("atom",Latom,lambda);
	MK("apply",Lapply,lambda);
	MK("funcall",Lfuncal,lambda);
	MK("lexpr-funcall",Llexfun,lambda);
	MK("return",Lreturn,lambda);
/* 	MK("cont",Lreturn,lambda);  */
	MK("cons",Lcons,lambda);
	MK("scons",Lscons,lambda);
	MK("bignum-to-list",Lbigtol,lambda);
	MK("cadr",Lcadr,lambda);
	MK("caar",Lcaar,lambda);
	MK("cddr",Lc02r,lambda);
	MK("caddr",Lc12r,lambda);
	MK("cdddr",Lc03r,lambda);
	MK("cadddr",Lc13r,lambda);
	MK("cddddr",Lc04r,lambda);
	MK("caddddr",Lc14r,lambda);
	MK("nthelem",Lnthelem,lambda);
	MK("eq",Leq,lambda);
	MK("equal",Lequal,lambda);
/**	MK("zqual",Zequal,lambda); 	*/
	MK("numberp",Lnumberp,lambda);
	MK("dtpr",Ldtpr,lambda);
	MK("bcdp",Lbcdp,lambda);
	MK("portp",Lportp,lambda);
	MK("arrayp",Larrayp,lambda);
	MK("valuep",Lvaluep,lambda);
	MK("get_pname",Lpname,lambda);
	MK("ptr",Lptr,lambda);
	MK("arrayref",Larrayref,lambda);
	MK("marray",Lmarray,lambda);
	MK("getlength",Lgetl,lambda);
	MK("putlength",Lputl,lambda);
	MK("getaccess",Lgeta,lambda);
	MK("putaccess",Lputa,lambda);
	MK("getdelta",Lgetdel,lambda);
	MK("putdelta",Lputdel,lambda);
	MK("getaux",Lgetaux,lambda);
	MK("putaux",Lputaux,lambda);
	MK("getdata",Lgetdata,lambda);
	MK("putdata",Lputdata,lambda);
	MK("mfunction",Lmfunction,lambda);
	MK("getentry",Lgetentry,lambda);
	MK("getdisc",Lgetdisc,lambda);
	MK("putdisc",Lputdisc,lambda);
	MK("segment",Lsegment,lambda);
	MK("rplaca",Lrplaca,lambda);
	MK("rplacd",Lrplacd,lambda);
	MK("set",Lset,lambda);
	MK("replace",Lreplace,lambda);
	MK("infile",Linfile,lambda);
	MK("outfile",Loutfile,lambda);
	MK("terpr",Lterpr,lambda);
	MK("print",Lprint,lambda);
	MK("close",Lclose,lambda);
	MK("patom",Lpatom,lambda);
	MK("pntlen",Lpntlen,lambda);
	MK("read",Lread,lambda);
	MK("ratom",Lratom,lambda);
	MK("readc",Lreadc,lambda);
	MK("truename",Ltruename,lambda);
	MK("implode",Limplode,lambda);
	MK("maknam",Lmaknam,lambda);
	MK("deref",Lderef,lambda);
	MK("concat",Lconcat,lambda);
	MK("uconcat",Luconcat,lambda);
	MK("putprop",Lputprop,lambda);
	MK("monitor",Lmonitor,lambda);
	MK("get",Lget,lambda);
	MK("getd",Lgetd,lambda);
	MK("putd",Lputd,lambda);
	MK("prog",Nprog,nlambda);
	quota = MK("quote",Nquote,nlambda);
	MK("function",Nfunction,nlambda);
	MK("go",Ngo,nlambda);
	MK("*catch",Ncatch,nlambda);
	MK("errset",Nerrset,nlambda);
	MK("status",Nstatus,nlambda);
	MK("sstatus",Nsstatus,nlambda);
	MK("err-with-message",Lerr,lambda);
	MK("*throw",Nthrow,lambda);	/* this is a lambda now !! */
	reseta = MK("reset",Nreset,nlambda);
	MK("break",Nbreak,nlambda);
	MK("exit",Lexit,lambda);
	MK("def",Ndef,nlambda);
	MK("null",Lnull,lambda);
	/* debugging, remove when done */
	{ lispval Lframedump(); 
	  MK("framedump",Lframedump,lambda);
	}
	MK("and",Nand,nlambda);
	MK("or",Nor,nlambda);
	MK("setq",Nsetq,nlambda);
	MK("cond",Ncond,nlambda);
	MK("list",Llist,lambda);
	MK("load",Lload,lambda);
	MK("nwritn",Lnwritn,lambda);
	MK("*process",Lprocess,lambda);	/*  execute a shell command  */
	MK("allocate",Lalloc,lambda);	/*  allocate a page  */
	MK("sizeof",Lsizeof,lambda);	/*  size of one item of a data type  */
	MK("dumplisp",Ndumplisp,nlambda);	/*  NEW save the world  */
	MK("top-level",Ntpl,nlambda);	/*  top level eval-print read loop  */
	startup = matom("startup");	/*  used by save and restore  */
	MK("mapcar",Lmapcar,lambda);
	MK("maplist",Lmaplist,lambda);
	MK("mapcan",Lmapcan,lambda);
	MK("mapcon",Lmapcon,lambda);
	MK("assq",Lassq,lambda);
	MK("mapc",Lmapc,lambda);
	MK("map",Lmap,lambda);
	MK("flatc",Lflatsi,lambda);
	MK("alphalessp",Lalfalp,lambda);
	MK("drain",Ldrain,lambda);
	MK("killcopy",Lkilcopy,lambda); /*  forks aand aborts for adb */
	MK("opval",Lopval,lambda);	/*  sets and retrieves system variables  */
	MK("ncons",Lncons,lambda);
	sysa = matom("sys");	/*  sys indicator for system variables  */
	MK("remob",Lforget,lambda);	/*  function to take atom out of hash table  */
	splice = matom("splicing");
	MK("not",Lnull,lambda);
	MK("plus",Ladd,lambda);
	MK("add",Ladd,lambda);
	MK("times",Ltimes,lambda);
	MK("difference",Lsub,lambda);
	MK("quotient",Lquo,lambda);
	MK("+",Lfp,lambda);
	MK("-",Lfm,lambda);
	MK("*",Lft,lambda);
	MK("/",Lfd,lambda);
	MK("1+",Lfadd1,lambda);
	MK("1-",Lfsub1,lambda);
	MK("^",Lfexpt,lambda);
	MK("double-to-float",Ldbtofl,lambda);
	MK("float-to-double",Lfltodb,lambda);
	MK("<",Lflessp,lambda);
	MK("mod",Lmod,lambda);
	MK("minus",Lminus,lambda);
	MK("absval",Labsval,lambda);
	MK("add1",Ladd1,lambda);
	MK("sub1",Lsub1,lambda);
	MK("greaterp",Lgreaterp,lambda);
	MK("lessp",Llessp,lambda);
	MK("any-zerop",Lzerop,lambda);   /* used when bignum arg possible */
	MK("zerop",Lzerop,lambda);
	MK("minusp",Lnegp,lambda);
	MK("onep",Lonep,lambda);
	MK("sum",Ladd,lambda);
	MK("product",Ltimes,lambda);
	MK("do",Ndo,nlambda);
	MK("progv",Nprogv,nlambda);
	MK("progn",Nprogn,nlambda);
	MK("prog2",Nprog2,nlambda);
	MK("oblist",Loblist,lambda);
	MK("baktrace",Lbaktrace,lambda);
	MK("tyi",Ltyi,lambda);
	MK("tyipeek",Ltyipeek,lambda);
	MK("untyi",Luntyi,lambda);
	MK("tyo",Ltyo,lambda);
	MK("termcapinit",Ltci,lambda);
	MK("termcapexe",Ltcx,lambda);
	MK("int:setsyntax",Lsetsyn,lambda);	/* an internal function */
	MK("int:getsyntax",Lgetsyntax,lambda);
	MK("int:showstack",LIshowstack,lambda);
	MK("int:franz-call",LIfranzcall,lambda);
	MK("makereadtable",Lmakertbl,lambda);
	MK("zapline",Lzapline,lambda);
	MK("aexplode",Lexplda,lambda);
	MK("aexplodec",Lexpldc,lambda);
	MK("aexploden",Lexpldn,lambda);
	MK("hashtabstat",Lhashst,lambda);
#ifdef METER
	MK("gcstat",Lgcstat,lambda);
#endif
	MK("argv",Largv,lambda);
	MK("arg",Larg,lambda);
	MK("setarg",Lsetarg,lambda);
	MK("showstack",Lshostk,lambda);
	MK("freturn",Lfretn,lambda);
	MK("*rset",Lrset,lambda);
	MK("eval1",Leval1,lambda);
	MK("evalframe",Levalf,lambda);
	MK("evalhook",Levalhook,lambda);
	MK("funcallhook",Lfunhook,lambda);
	MK("int:fclosure-stack-stuff",LIfss,lambda);
	MK("resetio",Nresetio,nlambda);
	MK("chdir",Lchdir,lambda);
	MK("ascii",Lascii,lambda);
	MK("boole",Lboole,lambda);
	MK("type",Ltype,lambda);	/* returns type-name of argument */
	MK("fix",Lfix,lambda);
	MK("float",Lfloat,lambda);
	MK("fact",Lfact,lambda);
	MK("cpy1",Lcpy1,lambda);
	MK("Divide",LDivide,lambda);
	MK("Emuldiv",LEmuldiv,lambda);
	MK("readlist",Lreadli,lambda);
	MK("plist",Lplist,lambda);	/* gives the plist of an atom */
	MK("setplist",Lsetpli,lambda);	/* get plist of an atom  */
	MK("eval-when",Nevwhen,nlambda);
	MK("syscall",Lsyscall,lambda);
	MK("intern",Lintern,lambda);
	MK("ptime",Lptime,lambda);	/* return process user time */
	MK("fork",Lfork,lambda);	/* turn on fork and wait */
	MK("wait",Lwait,lambda);
/*	MK("pipe",Lpipe,lambda);	*/
/*	MK("fdopen",Lfdopen,lambda); */
	MK("exece",Lexece,lambda);
	MK("gensym",Lgensym,lambda);
	MK("remprop",Lremprop,lambda);
	MK("bcdad",Lbcdad,lambda);
	MK("symbolp",Lsymbolp,lambda);
	MK("stringp",Lstringp,lambda);
	MK("rematom",Lrematom,lambda);
/**	MK("prname",Lprname,lambda);	*/
	MK("getenv",Lgetenv,lambda);
	MK("I-throw-err",Lctcherr,lambda); /* directly force a throw or error */
	MK("makunbound",Lmakunb,lambda);
	MK("haipart",Lhaipar,lambda);
	MK("haulong",Lhau,lambda);
	MK("signal",Lsignal,lambda);
	MK("fasl",Lfasl,lambda);	/* NEW - new fasl loader */
	MK("cfasl",Lcfasl,lambda);	/* read in compiled C file */
	MK("getaddress",Lgetaddress,lambda);
					/* bind symbols without doing cfasl */
	MK("removeaddress",Lrmadd,lambda); 	/* unbind symbols    */
	MK("boundp",Lboundp,lambda);	/* tells if an atom is bound */
	MK("fake",Lfake,lambda);	/* makes a fake lisp pointer */
/***	MK("od",Lod,lambda);		/* dumps info */
	MK("maknum",Lmaknum,lambda);	/* converts a pointer to an integer */
	MK("*mod",LstarMod,lambda);		/* return fixnum modulus */
	MK("*invmod",Lstarinvmod,lambda);	/* return fixnum modulus ^-1 */
a302 3
	MK("fseek",Lfseek,lambda);	/* seek to a specific byte in a file */
	MK("fileopen", Lfileopen, lambda);
					/* open a file for read/write/append*/
a303 19
	MK("pv%",Lpolyev,lambda);	/* polynomial evaluation instruction*/
	MK("cprintf",Lcprintf,lambda);  /* formatted print 		    */
	MK("sprintf",Lsprintf,lambda);  /* formatted print to string	    */
	MK("copyint*",Lcopyint,lambda);	/* copyint*  */
	MK("purcopy",Lpurcopy,lambda);	/* pure copy */
	MK("purep",Lpurep,lambda);	/* check if pure */
	MK("int:memreport",LImemory,lambda); /* dump memory stats */

/*
 * Hunk stuff
 */

	MK("*makhunk",LMakhunk,lambda);		/* special hunk creater */
	MK("hunkp",Lhunkp,lambda);		/* test a hunk */
	MK("cxr",Lcxr,lambda);			/* cxr of a hunk */
	MK("rplacx",Lrplacx,lambda);		/* replace element of a hunk */
	MK("*rplacx",Lstarrpx,lambda);		/* rplacx used by hunk */
	MK("hunksize",Lhunksize,lambda);	/* size of a hunk */
	MK("hunk-to-list",Lhtol,lambda);	/* hunk to list */
a305 11
	MK("new-vector",Lnvec,lambda);
	MK("new-vectori-byte",Lnvecb,lambda);
	MK("new-vectori-word",Lnvecw,lambda);
	MK("new-vectori-long",Lnvecl,lambda);
	MK("vectorp",Lvectorp,lambda);
	MK("vectorip",Lpvp,lambda);
	MK("int:vref",LIvref,lambda);
	MK("int:vset",LIvset,lambda);
	MK("int:vsize",LIvsize,lambda);
	MK("vsetprop",Lvsp,lambda);
	MK("vprop",Lvprop,lambda);
d307 1
a307 6
	MK("probef",Lprobef,lambda);	/* test file existance */
	MK("substring",Lsubstring,lambda);
	MK("substringn",Lsstrn,lambda);
	MK("character-index",Lcharindex,lambda); /* index of char in string */
	MK("time-string",Ltimestr,lambda);
	odform = matom("odformat");	/* format for printf's used in od */
d318 6
a323 6
	(Vererr = matom("ER%err"))->a.clb = nil;
	(Vertpl = matom("ER%tpl"))->a.clb = nil;
	(Verall = matom("ER%all"))->a.clb = nil;
	(Vermisc = matom("ER%misc"))->a.clb = nil;
	(Verbrk = matom("ER%brk"))->a.clb = nil;
	(Verundef = matom("ER%undef"))->a.clb = nil;
d325 2
a326 2
	(Veruwpt = matom("ER%unwind-protect"))->a.clb = nil;
	(Verrset = matom("errset"))->a.clb = nil;
d334 9
a342 9
	    Iaddstat(matom("features"),ST_READ,ST_NO,nil);
	    Iaddstat(feature = matom("feature"),ST_FEATR,ST_FEATW,nil);
	    Isstatus(feature,matom("franz"));
	    Isstatus(feature,matom("Franz"));
	    Isstatus(feature,matom(OS));
	    Isstatus(feature,matom("string"));
	    Isstatus(feature,dom = matom(DOMAIN));
	    Iaddstat(matom("domain"),ST_READ,ST_NO,dom);
	    Isstatus(feature,matom(MACHINE));
d344 1
a344 1
	    Isstatus(feature,matom("portable"));
d347 1
a347 1
	    Isstatus(feature,matom("unisoft"));
d350 1
a350 1
	    Isstatus(feature,matom("sun"));
d353 1
a353 1
	    Isstatus(feature,matom("long-filenames"));
d356 5
a360 5
	Iaddstat(matom("nofeature"),ST_NFETR,ST_NFETW,nil);
	Iaddstat(matom("syntax"),ST_SYNT,ST_NO,nil);
	Iaddstat(matom("uctolc"),ST_READ,ST_TOLC,nil);
	Iaddstat(matom("dumpcore"),ST_READ,ST_CORE,nil);
	Isstatus(matom("dumpcore"),nil);	/*set up signals*/
d362 17
a378 17
	Iaddstat(matom("chainatom"),ST_RINTB,ST_INTB,inewint(0));
	Iaddstat(matom("dumpmode"),ST_DMPR,ST_DMPW,nil);
	Iaddstat(matom("appendmap"),ST_READ,ST_SET,nil);  /* used by fasl */
	Iaddstat(matom("debugging"),ST_READ,ST_SET,nil);  
	Iaddstat(matom("evalhook"),ST_RINTB,ST_INTB,inewint(3));
	Isstatus(matom("evalhook"),nil); /*evalhook switch off */
	Iaddstat(matom("bcdtrace"),ST_READ,ST_BCDTR,nil);
	Iaddstat(matom("ctime"),ST_CTIM,ST_NO,nil);
	Iaddstat(matom("localtime"),ST_LOCT,ST_NO,nil);
	Iaddstat(matom("isatty"),ST_ISTTY,ST_NO,nil);
	Iaddstat(matom("ignoreeof"),ST_READ,ST_SET,nil);
	Iaddstat(matom("version"),ST_READ,ST_NO,mstr("Franz Lisp, Opus 38"));
	Iaddstat(matom("automatic-reset"),ST_READ,ST_AUTR,nil);
	Iaddstat(matom("translink"),ST_READ,ST_TRAN,nil);
	Isstatus(matom("translink"),nil);		/* turn off tran links */
	Iaddstat(matom("undeffunc"),ST_UNDEF,ST_NO,nil); /* list undef funcs */
	Iaddstat(matom("gcstrings"),ST_READ,ST_GCSTR,nil); /* gc strings */
d382 3
a384 5
	MK("gc",Ngc,nlambda);
	gcafter = MK("gcafter",Ngcafter,nlambda);	/* garbage collection wind-up */
	gcport = matom("gcport");	/* port for gc dumping */
	gccheck = matom("gccheck");	/* flag for checking during gc */
	gcdis = matom("gcdisable");	/* variable for disabling the gc */
d386 4
a389 4
	gcload = matom("gcload");	/* option for gc while loading */
	loading = matom("loading");	/* flag--in loader if = t  */
	noautot = matom("noautotrace");	/* option to inhibit auto-trace */
	Vgcprint = matom("$gcprint");	/* if t then pring gc messages */
d434 5
a438 2
	xatom = matom("??");

d457 1
a457 1
	strcatn(strbuf,string,STRBLEN-1); /* strcpyn always pads to n */
d482 1
a482 1
	v = matom(string);
d488 302
@


1.16
log
@add character-index function
@
text
@d3 1
a3 1
   "$Header: sysat.c,v 1.15 83/09/04 10:17:54 jkf Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker:  $
d109 3
a111 3
	for(i=((int)beginsweep)>>9; i < ttsize; i++) (typetable+1)[i] = OTHER;
	purepage[((int)np)>>9] = 1;  /* Mark these as non-gc'd arrays */
	purepage[((int)bnp)>>9] = 1;
@


1.15
log
@change err to err-with-message
@
text
@d3 1
a3 1
   "$Header: sysat.c,v 1.14 83/08/29 14:52:14 sklower Exp $";
d6 2
a7 2
/*					-[Sun Sep  4 08:56:49 1983 by jkf]-
 * 	sysat.c				$Locker: jkf $
d573 1
@


1.14
log
@make reference to ttsize variable so that you can use the same sysat for
rawlisp and rawhlisp
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.13 83/08/06 08:38:06 jkf Exp $";
d6 2
a7 2
/*					-[Fri Aug  5 12:51:44 1983 by jkf]-
 * 	sysat.c				$Locker: sklower $
d380 1
a380 1
	MK("err",Lerr,lambda);
@


1.13
log
@getatom change
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.12 83/07/24 21:26:42 sklower Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker: jkf $
d35 1
d109 1
a109 1
	for(i=((int)beginsweep)>>9; i < TTSIZE; i++) (typetable+1)[i] = OTHER;
@


1.12
log
@under 4.2 unix, file names can be greather than 14 characters
so we should put this fact in the status features list.
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.11 83/06/19 22:39:03 jkf Exp $";
d6 2
a7 2
/*					-[Sun Jun 19 22:26:47 1983 by jkf]-
 * 	sysat.c				$Locker: sklower $
d724 1
a724 1
	return(getatom());
@


1.11
log
@add fixnum expt ^
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.10 83/06/19 15:15:50 jkf Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker: jkf $
d618 3
a620 1
	    
@


1.10
log
@add Vprintsym
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.9 83/06/09 00:56:02 sklower Exp $";
d6 1
a6 1
/*					-[Sun Jun 19 14:41:54 1983 by jkf]-
d431 1
@


1.9
log
@allow the atom lisp-library-directory to work for primitive load and
cfasl as well.
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.8 83/06/04 02:11:47 sklower Exp $";
d6 2
a7 2
/*					-[Sat May  7 20:48:42 1983 by jkf]-
 * 	sysat.c				$Locker: sklower $
d223 3
@


1.8
log
@add new function dealing with fclosures, deref for assistance in talking
to arbitrary c-functions.
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.7 83/05/07 23:45:57 jkf Exp $";
a175 1
	atom_buffer = (lispval) strbuf;
d223 3
@


1.7
log
@make closures recursive
@
text
@d3 1
a3 1
   "$Header: sysat.c 1.6 83/03/21 16:40:42 jkf Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker: jkf $
d175 2
d358 1
d426 2
d477 1
d560 1
@


1.6
log
@print gc: before gc
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.5 83/02/19 15:33:09 layer Exp $";
d6 1
a6 1
/*					-[Tue Mar  8 09:00:34 1983 by jkf]-
d139 1
d174 1
@


1.5
log
@fixed status features list.
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.4 83/02/11 04:11:45 layer Exp $";
d6 2
a7 2
/*					-[Fri Feb 11 04:09:31 1983 by layer]-
 * 	sysat.c				$Locker:  $
d640 3
@


1.4
log
@ble) = t, if PORTABLE defined
if M68K defined then specify what type of 68k we are on
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.3 83/01/31 20:10:36 layer Exp $";
d7 1
a7 1
 * 	sysat.c				$Locker: layer $
d597 5
a601 2
#ifdef M68K
	    Isstatus(feature,matom(MACHTYPE));
@


1.3
log
@changed name of fasl to Lfasl (from Lnfasl)
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.2 83/01/31 15:05:07 jkf Exp $";
d6 1
a6 1
/*					-[Mon Jan 31 20:06:51 1983 by layer]-
d594 6
@


1.2
log
@float-format changed to "%.16g" (from "%.16G") for compatibility
with the 68k C compiler.
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/sysat.c,v 1.1 83/01/29 13:38:11 jkf Exp $";
d6 2
a7 2
/*					-[Sat Jan 29 13:36:38 1983 by jkf]-
 * 	sysat.c				$Locker: jkf $
d506 1
a506 1
	MK("fasl",Lnfasl,lambda);	/* NEW - new fasl loader */
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   "$Header: /na/franz/franz/RCS/eval.c,v 1.1 83/01/29 12:14:54 jkf Exp $";
d207 1
a207 1
	Vfloatformat->a.clb = (lispval) pinewstr("%.16G");
@
