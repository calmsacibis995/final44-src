(File |dhl/rule2.l|)
(trace-rules lambda fput-datum fput quote fremove-slot fremove null cond)
(print-rule-exit-trace lambda terpr quote patom indent)
(print-rule-trace lexpr terpr quote patom indent cons |1-| + cdr < do minusp eq cond - let listify arg)
(indent lambda - quote patom eq cond < do)
(userfailgoal lambda terpr patom quote list eval cond caddr cadr car let)
(basicfail lambda terpr quote patom)
(proved lambda exitcontinue terpri patom list append apply nreverse cdr atom cond cons setq null quote rdata liszt-internal-do mapcar findicators1 rdata-only rvalues-only inspect-datum rvalue-only let succeed caddr cadr car)
(assert-fact lambda fremove-datum fremove fput-datum-comment flistget delete do fdata1 fput-datum nreverse cdr atom cons setq *fdata liszt-internal-do mapcar findicators1 *fdata-only *fvalues-only get-restricted-values rdata rput quote *rdata *rvalues assoc null cond caddr cadr car let)
(removewantedmark lambda caddr quote cadr car fremove-datum fremove)
(wanttoprove lambda fput-datum-comment flistget delete do fdata1 fput-datum nreverse cdr atom cons setq *fdata liszt-internal-do mapcar findicators1 *fdata-only *fvalues-only get-restricted-values let quote cadr car rdata caddr assoc null cond rput)
(notprovedyet lambda quote cadr car rlistget cdr caddr assoc)
(flatten-tree lambda rplacd cdr flatten-tree car setq null liszt-internal-do mapcan list atom cond)
(get-one-match lambda quote list car eq dtpr and is-var cond append)
(get-possible-solutions lambda rplacd get-one-match rvalues assoc nreverse atom cons rdata findicators1 rdata-only rvalues-only mapcar fslots setq null list quote cdr ftree flatten-tree eq dtpr and is-var cond liszt-internal-do mapcan caddr cadr car let)
(sentin-applyrule lambda return eval fdata fdata-only fvalues-only do caddr cadr action nreverse cdr atom cond car cons setq null quote *rdata liszt-internal-do mapcar findicators1 *rdata-only *rvalues-only inspect-datum *rvalue-only condition let)
(production-applyrule lambda caddr cadr fput-datum fput eval eq action bind-to mapc enqueue nreverse cdr atom cond car cons setq null quote *rdata liszt-internal-do mapcar findicators1 *rdata-only *rvalues-only inspect-datum *rvalue-only condition get-possible-solutions let)
(basicapplyrule lambda action list append apply rdata rdata-only rvalues-only rvalue-only let succeed assertions nreverse cdr atom car cons setq null quote *rdata liszt-internal-do mapcar findicators1 *rdata-only *rvalues-only inspect-datum *rvalue-only condition eval cond)
(action macro quote cons cadr)
(assertions macro cons quote list cadr)
(condition macro quote cons cadr)
(tryrule lambda proved rhs bind-to basicprove nreverse cdr atom cond car cons setq null quote *rdata liszt-internal-do mapcar findicators1 *rdata-only *rvalues-only inspect-datum *rvalue-only lhs match let)
(lhs macro quote cons cadr)
(rhs macro quote cons cadr)
(dequeue lambda)
(enqueue lambda list append null cond)
(possiblerules lambda nreverse cdr atom cond car cons setq null quote *rdata liszt-internal-do mapcar findicators1 *rdata-only *rvalues-only)
(pushrule lambda list append null cond)
(poprule lambda)
