(File |frl/fask.l|)
(substitute-you lambda delq quote cons memq cond user-frame for)
(generate-possessive-genitive lambda get-familiar-name or quote stringify user-frame eq null cond)
(descend-tree lambda memq |1st| eq return fchildren select1 nreverse foreach quote noun-plural-form capitalize request2 rplacd car funcall cond or collect-family cdr nselect frame? and if setq null cons ncons do)
(fsay-something lambda fname fsay or)
(ask-says-options lambda cdr quote samepnamep or fsay for frame? cond cons car setq nreverse null do foreach)
(describe-values lambda cdr quote samepnamep not funcall frame? and if append cons car setq nreverse null do foreach newconjunctivizer shout1 fsay-procedure for)
(say-value lambda list say-values)
(say-values lambda cdr funcall cons car setq nreverse null do foreach conjunctivize and if fsay-procedure for)
(fsay-procedure lexpr nreverse cdr atom cons setq null fdata liszt-internal-do mapcar findicators1 fdata-only car |1st| quote > cond arg for)
(fsay1 lexpr list and cons |1-| + cdr < arg do minusp eq cond let listify quote apply for)
(fsay lexpr say-values return nreverse cdr atom car cons null fdata liszt-internal-do mapcar findicators1 fdata-only fvalues-only fname list quote eq = cond arg setq prog)
(expand-key-name lambda car return caar eq cond null do assq cdr or declare)
(describe-structures lambda cdr terpri $prpr car #print null setq liszt-internal-do mapc)
(describe-value-structures lambda nreverse cdr atom cond car cons setq null liszt-internal-do mapcar findicators1 fextract-data describe-values)
(discuss-key1 lambda shout1 noun-plural-form indefinite-article or append shout0 expand-key-name fname for eq memq caseq list rplacd assoc quote function funcall liszt-internal-do mapc classify return if cdr cons atom cond findicator fextract-datum and car nreverse null do filter setq prog)
(discuss-key-local lambda *fdata discuss-key1)
(discuss-key lambda fdata-heritage fdata eq cond caseq discuss-key1)
(select-super-properties lambda conjunctivize1 shout1 fdata-only fsiblings atom findicators1 fextract-data setifyq setminus fname expand-key-name noun-plural-form shout0 and cond nreverse cdr fdata discuss-key1 car cons setq null fdescendants liszt-internal-do mapcar quote apply mapappend for)
(discuss-requirements-for-options lambda return conjunctivize1 append shout1 describe-constraints cdr noun-plural-form quote cons shout0 and cond prog)
(discuss-preferences-for-options lambda return null conjunctivize1 append verb-plural-form shout1 describe-constraints noun-plural-form quote cons shout0 cdr setq and cond prog)
(filter-options-with-preferences lambda list return fclassify-value true? and mapc prog select discuss-preferences-for-options nreverse cdr atom cond car cons setq null findicators1 fextract-data liszt-internal-do mapcar quote apply mapappend setify)
(filter-options-with-requirements lambda list return fclassify-value false? and mapc prog select discuss-requirements-for-options nreverse cdr atom cond car cons setq null findicators1 fextract-data liszt-internal-do mapcar quote apply mapappend setify)
(present-and-filter-options lambda filter-options-with-preferences select-relevant-data for filter-options-with-requirements setminusq setq quote discuss-key declare)
(relevant-sources lambda ffamily frame? and if list rplacd feval nreverse cdr atom cond car cons setq null fdata findicators1 fdata-only mapcan or liszt-internal-do mapcar quote apply mapappend setifyq)
(filter-data-by-source lambda cons cdr atom cond quote faccess fbucket intersectq? and car setq nreverse null do filter)
(select-relevant-data lambda discuss-key1 and if relevant-sources fdata-heritage memq fdata eq cond caseq filter-data-by-source for)
(ask-use-suggestions lambda conjunctivize1 append firstn > verb-plural-form lowercase number-phrase < length cdr atom cond flistget fbucket fextract-message or list car |1st| cons shout0 progn quote fdata inspect-datum fdatum setq return null and if declare prog)
(ask-discuss-values lambda select-relevant-data quote discuss-key or)
(ask-suggest-values lambda feval nreverse cdr atom cond car cons setq null select-relevant-data findicators1 fextract-data for liszt-internal-do mapcar quote apply mapappend)
(confirm lambda request affirmative? quote for cond)
(lask* lexpr arg plusp cond lask quote for)
(lask lexpr cons |1-| + cdr < arg do minusp eq cond let listify apply quote for)
(ask* lexpr arg quote funcall)
(ask lexpr freplace-datum freplace-value user-frame fput-datum fput-value confirm go |try again.| list fremove-facet fremove ok? finherit fdatum? fvalue? eq requests ask-says-options ask-use-suggestions *catch catch if nreverse atom car liszt-internal-do mapcar findicators1 fextract-data setifyq ask-discuss-values funcall boundp shout0 ifnot fname quote cons plusp return minusp bigp not cdr and zerop or minus arg null > cond setq declare prog)
