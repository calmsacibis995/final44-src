(File |frl/futil.l|)
(fapropos-sorted lambda quote function fapropos sort)
(fapropos lambda reclaim cons return or cdr equal = cond do car null frames liszt-internal-do mapc exploden setq prog)
(requirements lambda quote rdata-heritage)
(preferences lambda quote rdata-heritage)
(get-if-removed-methods lambda nreverse cdr atom cond car cons setq null quote rdata liszt-internal-do mapcar findicators1 rdata-only)
(get-if-added-methods lambda nreverse cdr atom cond car cons setq null quote rdata liszt-internal-do mapcar findicators1 rdata-only)
(run-if-removed-methods1 lambda cdr car cond funcall null setq liszt-internal-do mapc quote for)
(run-if-removed-methods lambda get-if-removed-methods run-if-removed-methods1 quote *catch catch)
(run-if-added-methods1 lambda cdr car cond funcall null setq liszt-internal-do mapc quote for)
(run-if-added-methods lambda get-if-added-methods run-if-added-methods1 quote *catch catch)
(warning lambda *break break quote list shout0 and if)
(number lambda length)
(fgename lambda fgensym frame? not do)
(fgensym lambda quote list explode nconc implode |1+| setq for)
(ako? lambda cdr return quote flink? or forall prog2 car null do exists cons ncons setq atom and if)
(fconnect? lambda fdescendants fname memq eq cond)
(flink? lambda fdescendants memq fname eq or)
(remove-inverse-slot lambda fname quote fremove-datum fremove-value frame? and if)
(add-inverse-slot lambda fname quote frame+ fput-datum fput-value)
(select-most-specific lambda cdr atom cond quote flistget fbucket fextract-message cons car setq nreverse null do foreach sortcar cdar list)
(collect-sources lambda nreverse cdr atom cond flistget fbucket fextract-messages car cons setq null liszt-internal-do mapcar quote apply mapappend setifyq)
(collect-individuals lambda rplacd cdr car collect-individuals setq quote fchildren liszt-internal-do mapcan fname cons ncons individual? null cond)
(collect-specializations lambda rplacd cdr car collect-specializations setq quote fchildren liszt-internal-do mapcan fname cons ncons generic? null cond)
(fsiblings lambda nreverse cdr car cons setq null fchildren liszt-internal-do mapcar quote apply mapappend setifyq fname delq)
(collect-family lambda rplacd |1-| collect-family car setq fchildren liszt-internal-do mapcan fname cons ncons bigp not cdr and zerop null cond)
(ffamily lambda fdescendants fname cons)
(fdescendants lambda rplacd cdr fdescendants car setq cond null liszt-internal-do mapcan append setifyq fchildren)
(fchildren lambda nreverse cdr atom cond car cons setq null quote *fdata liszt-internal-do mapcar findicators1 *fdata-only *fvalues-only)
(fringe1 lambda rplacd fringe1 setq liszt-internal-do mapcan car list cdr null cond)
(fringe lambda ftree fringe1)
(ftree lambda ftree nreverse cdr atom cond car setq null quote *fdata findicators1 *fdata-only *fvalues-only liszt-internal-do mapcar fname cons)
(feval-safely lexpr *break break car cons |1-| + cdr < arg do minusp eq cond let listify quote apply errset for)
(frun-safely lexpr *break break car cons |1-| + cdr < arg do minusp eq cond let listify quote apply errset for)
(frun lexpr frame eval apply atom for eq = arg null cond)
(feval lexpr eval for eq = arg null cond)
(fequal lambda fname? eq)
(fcopy lambda subst)
(freset1 lambda load cdr car fdestroy null frames setq liszt-internal-do mapc progn quote ok? and if)
(freset lambda cdr car fdestroy null frames setq liszt-internal-do mapc quote ok? and if)
(fslots lambda nreverse car cons setq null cdr atom cond frame fbucket liszt-internal-do mapcar findicators)
(frame+ lambda fcreate frame frame? or)
(frame? lambda car eq quote get atom cond)
(frame lambda error quote get or atom null cond)
(print-one-frame lambda + $prdf print tab atom null liszt-internal-do mapc car quote princ setq return last cdr cond prog)
(show lexpr terpri frame $prpr car null cons |1-| + cdr < arg do minusp eq cond let listify setq liszt-internal-do mapc)
(fname? lambda eq car quote get and atom cond)
(fname lambda car |1st| atom cond)
(frames lambda funcall null cond)
