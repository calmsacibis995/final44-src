(File |frl/ttyio.l|)
(print-frame lambda cdr terpri $prpr null quote apply car frame? setq liszt-internal-do mapc #print atom and if read tyipeek boole eq = cond for tyi nointerrupt)
(pagepause lambda error prog progn and if cursorpos tyi eq = tyipeek nointerrupt quote princ clear-input cond)
(fbug lambda exec terpri quote patom)
(uppercasify lambda cdr car quote function funcall rplaca null do exploden nmapcar maknam intern)
(princ-list lambda terpri $prpr liszt-internal-do mapc #print do-foreach conjunctivize1 shout-indented cdr return or car null do forall cond cons ncons setq atom and if)
(fhelp lexpr arg and plusp cond setq prog2)
(fverbose lexpr arg and plusp cond setq prog2)
(fdebug lexpr arg and plusp cond setq prog2)
(shout lexpr terpri shout0 arg > bigp not cdr null and zerop cond)
(shout-centered lexpr shout-indented flatc minus cdr / min indent-to arg > and cond linel setq prog declare)
(shout1 lambda linel shout-indented)
(shout0 lambda shout-indented newline)
(printblock lambda quote prinl1)
(sprint lambda #prin1 indent-to)
(ntyo lambda |1-| tyo bigp not cdr null and zerop do declare)
(indent-to lambda / tyo ntyo tabsize - |\\| cdr + < setq terpri > cond linel chrct for declare)
(tabsize macro quote status progn)
(shoutchrct lambda charpos linel cdr -)
(shoutblank lambda |1+| tyo > do declare)
(shoutflatc lambda flatc eq cond)
(shoutroom lambda bigp not null and zerop cond shoutflatc shoutgap cdr +)
(shoutgap lambda caddr cdr car return caar eq null do assq cadr cond)
(shout-indented lexpr ascii #princ shoutgap shoutblank indent-to terpri shoutroom eq cddr cadr cdr null car quote do shoutchrct > list arg atom cond for declare)
(readl1 lambda setf prog1 pop prog2 bigp not |1st| list eval boole logand zerop or - quote cursorpos reverse cons return eq = cond declare flatc tyi do cdr tyo car null liszt-internal-do mapc nreverse setq and if princ newline)
(read1 lambda tyi bigp cdr null tyipeek ascii quote list eval boole zerop not atom and read)
(readl lambda go car return reverse cons readlist errset and if quote #answer readl1 setq prog)
(readline lexpr quote readl1 nreverse maknam arg shout0 plusp and if)
(no-word? lambda memq)
(yes-word? lambda memq)
(affirmative? lambda no-word? cond)
(ok? lexpr cons |1-| + cdr < arg do minusp eq cond let listify quote apply affirmative?)
(re-request lambda terpri quote shout0 *throw throw errset tyi)
(#answer-reset lambda quote putprop)
(#answer lambda get |1+| quote putprop stringify for null cond)
(bracket-string lambda list nconc quote cons)
(feed-string-to-pidgin lambda *throw throw car cond readlist errset for)
(readl2 lambda quote cdr nconc car eq = and readl1 do)
(request-pidgin lexpr cons |1-| + cdr < arg do minusp eq cond let listify apply function quote #answer for)
(request4 lexpr cons |1-| + cdr < arg do minusp eq cond let listify apply function quote #answer for)
(request2 lexpr cons |1-| + cdr < arg do minusp eq cond let listify apply makereadtable quote function for)
(requests1 lexpr go requests shout0 car null return atom cons |1-| + cdr < arg do minusp eq cond let listify quote apply setq prog)
(request lexpr list and arg > cond request2)
(request1 lexpr quote progv cons |1-| + cdr < arg do minusp eq cond let listify)
(requests lexpr quote progv cons |1-| + cdr < arg do minusp eq cond let listify)
(#prin1 lambda print)
(prin1 lambda print)
(request6 lambda read space shout)
(request5 lexpr return print read go > not cond add1 cdr quote car list setq space arg shout terpri prog)
