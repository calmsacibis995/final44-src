(File |talk/pidgin.l|)
(finish-pidgin-read lambda eq = tyi do)
(pidgin-to-lisp1 nlambda sprinter cursorpos shout0 equal read setq |1-| finish-pidgin-read bigp not null zerop car eval cond do for quote apply cdr and if)
(pidgin-to-lisp nlambda print car list read setq eq cons ncons do uwrite quote apply)
(printlbp lambda return tyo print progn equal = or ifnot shout-indented indent-to printc linel - sort sortcar setf push cond cdr quote get cons car setq nreverse null denlist foreach do do-foreach prog)
(printden lambda quote denlist sort prinl)
(flushdenotations lambda cdr car denflush null denlist quote delq setq liszt-internal-do mapc)
(denflush lambda cdr remprop car null quote concatenate cons list* setq liszt-internal-do mapc)
(denlist lambda return quote mapatoms prog)
(den nlambda cdr concatenate for get and if cons apply quote list shout0 terpri car setq null do do-foreach)
(variants lexpr |1+| cdr putprop and if > quote arg get do)
(:parselist-unless lambda :parselist-unless read-next-token progn and if istoken :parse cons eq cond)
(:parselist lambda :parselist read-next-token eq cond :parse cons)
(buildfun nlambda check quote read-next-token istoken or ifnot atom eval cons push cdr setf prog2 prog1 pop progn and if eq cond car setq nreverse null do)
(check lambda quote list warning read-next-token memq eq atom and or cond)
(nottoken macro quote list cadr)
(istoken macro list quote cons cadr)
(eattoken macro quote)
(rightlist lambda quote :parselist)
(right lambda :parse)
(denfunc lambda quote subst sublis)
(denfun nlambda denfunc quote cons)
(ism lambda :parselist cons)
(isi lambda :parse list)
(isp lambda :parse list)
(iss lambda list)
(isn lambda list)
(isf lambda eq cond nconc quote list setq atom and if)
(delim macro quote cons cadr)
(infixm macro quote list cadddr caddr cadr)
(infixd macro quote list caddddr cadddr caddr cadr)
(infixr macro |1-| quote list cadddr caddr cadr)
(infix macro quote list cadddr caddr cadr)
(suffix macro quote list cadddr caddr cadr)
(prefix macro quote list cadddr caddr cadr)
(nilfix macro quote list caddr cadr)
(deffix macro and if eval list return cdddr cadr caddr quote car concatenate cdr setq prog progn)
(pidgin-read lambda error *break break eq cdr car list cond return :parse read-next-token progn quote *catch catch and if setq prog)
(pidgin-!-macro lambda read)
(pidgin-%-macro lambda readc tyi eq tyipeek ascii do)
(define-pidgin-character lambda cons setq setf push memq or)
(talk lambda cdr car null liszt-internal-do mapc makereadtable setq quote setsyntax)
(eoferr lambda *throw throw quote print)
(lederr lambda *throw throw clear-input |1-| tyi tyo declare terpri eq = bigp not cdr zerop null or tyipeek listen plusp and if do quote cons print)
(fastcall lambda funcall putprop remprop quote getl for cadr subrcall plist car eq cond)
(verify lambda read-next-token cond)
(read-next-token lambda read-next-token memq eoferr read setq eq cond)
(associate lambda lederr verify fastcall associate quote get or cdr < cond declare)
(:parse lambda read-next-token setq prog2 prog1 fastcall quote get atom and cond associate declare)
