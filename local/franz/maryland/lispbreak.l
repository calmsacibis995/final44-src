;
; This file contains functions to aid in error handling and debugging.
;
; This lispbreak package causes a break to occur whenever an error
; occurs or whenever lisp is interrupted by hitting the del key.  A
; break may also be generated by explicitly calling the function
; lispbreak using the form:  (lispbreak [prompt [flag]])  where
; 'prompt' will be used as the prompt in the lispbreak.  If 'flag' is t,
; the break level will be printed along with the prompt.  'flag'
; defaults to nil.  For example,  (lispbreak " ** ")  will generate
; the prompt:
;	n **
; where 'n' is the event number.  (lispbreak " ** " t)  will generate:
;	n<m> **
; where 'n' is the event number, and 'm' is the break level.  If 'prompt'
; is not given, the default prompt:
;	n<m>
; is used where 'n' and 'm' are as given above.
;
; Within the break, the user may use any of the functions that he can
; use at the top level.  In addition, he may also use the following commands:
;
;	ok val	to continue execution from the point where the last
;		break was called.  if given,  val  is eval'd and
;		returned as the value of the break.
;
;	go n	go to nth level lispbreak, n > 0.  if n is not given,
;		the current level - 1 is assumed.
;
;	^D	alias for 'go'
;
;	stk	does a (showstack)
;
;	top	does a (reset)
;
;	no val	return to last call to attempt (described below), like (fail)
;
;	?	get list of commands
;
; attempt and fail are functions that allow execution to restart at
; a specified place.  (attempt <expr>) returns the value of <expr> or
; $$FAIL if the function (fail) is called while attempting to eval <expr>.
; attempt is best used at a top level loop in a program.  If (fail 'val)
; is used, 'val will be returned instead of $$FAIL.
;
; This package may be simply loaded into lisp or be made autoloadable
; by including the following in a .lisprc:
;
;	(putprop 'lispbreak '/usr/liz/lisp/lispbreak 'autoload)
;	(putprop 'predcheck '/usr/liz/lisp/lispbreak 'autoload)
;	(putprop 'attempt '/usr/liz/lisp/lispbreak 'autoload)
;	(putprop 'LBerr-handler '/usr/liz/lisp/lispbreak 'autoload)
;	(signal 2 'lispbreak)
;	(setq ER%tpl 'LBerr-handler)
;
(eval-when (compile) (load 'uommacs.o))

(declare
  (special
	LBlevel		 ; depth of current lispbreak
	LBattempt-level	 ; depth of last attempt
	LBerrflag	 ; t iff the current lispbreak was caused by an error
	before-lispbreak ; may be bound to function that will be called before
			 ;	a lispbreak occurs
	after-lispbreak	 ; bound to function called after a lispbreak
	lispxmacros
	ER%tpl poport ^w
	)
  (localf LBbreak LBget-where LBcheck-return LBdo-return LBerr)
  (macros t))

(signal 2 'lispbreak)
(setq ER%tpl 'LBerr-handler)
(or (boundp 'LBlevel) (setq LBlevel 0))
(or (boundp 'LBattempt-level) (setq LBattempt-level nil))
(or (boundp 'LBerrflag) (setq LBerrflag nil))
  
(defun lispbreak (&optional prompt &optional levelp)
 (let (^w poport) (LBbreak prompt levelp nil)))

(defun LBbreak (prompt levelp LBerrflag)
 (let ((lispxmacros lispxmacros)
       (LBlevel (add1 LBlevel))
       (before (and (boundp 'before-lispbreak) before-lispbreak))
       (after (and (boundp 'after-lispbreak) after-lispbreak))
	before-lispbreak after-lispbreak retinfo)
  (and (or (eq LBlevel 1) (not (assq 'ok lispxmacros)))
       (setq lispxmacros
	    (append '((ok LBok-return lispxline)
		      (go LBgo-return (car lispxline))
		      (| EOF| LBgo-return nil)
		      (stk showstack)
		      (top reset)
		      (? lispbreakhelp)
		      (no LBfail lispxline)
		      )
		    lispxmacros)))
  (cond ((stringp prompt)
	   (and levelp (setq prompt (uconcat "<" LBlevel ">" prompt))))
	(t (setq prompt (uconcat "<" LBlevel "> "))))
  (and (getd before) (catch (eval `(,before)) LBbreaktag))
  (for do (terpr)
          (setq retinfo (catch (userexec prompt) LBbreaktag))
          (if (LBcheck-return retinfo)
	      (and (getd after) (catch (eval `(,after)) LBbreaktag))
	      (return (LBdo-return retinfo))))))

(defun LBok-return (lispxline)
  (let ((where (cond ((cdr lispxline)
		        (LBget-where (cadr lispxline)))
		     (t LBlevel))))
    (and where
	 (cond (lispxline
	          (throw (list 'ok where (eval (car lispxline))) LBbreaktag))
	       (t (throw (list 'ok where) LBbreaktag))))))

(defun LBgo-return (where)
  (cond ((null where)
	   (and (eq LBlevel 1) (reset))
           (setq where (sub1 LBlevel)))
	(t (setq where (LBget-where where))))
  (and where (throw (list 'go where) LBbreaktag)))

(defun LBget-where (where)
  (let (where2)
    (cond ((not (numberp where))
	     (msg "Illegal level, must be a number: " where)
	      nil)
    	  (t (setq where2 (cond ((minusp where)
				   (plus where LBlevel))
		      		(t where)))
	     (cond ((zerop where2)
		      (reset))
		   ((minusp where2)
	     	      (msg "Illegal level given: " where)
	      	       nil)
	           (t where2))))))

; LBcheck-return returns t if this is really the end of the current
; lisbreak and we are returning at this level.  It will throw past this
; level if we are not to end here.  If we are to continue the lispbreak
; at this level, it returns nil.  It also checks for various error
; conditions.
;
; retinfo looks like (how where &optional what)
; how is one of:  go, no, ok

(defun LBcheck-return (retinfo)
  (cond ((lessp (cadr retinfo) LBlevel)
           (throw retinfo LBbreaktag))
	((eq (car retinfo) 'go)
	    nil)
	((eq (car retinfo) 'no)
	    t)
	((eq LBerrflag 'nc)
	   (msg "Non continuable error")
	    nil)
	((and LBerrflag (null (cddr retinfo)))
	   (msg "Must use 'ok val' to return from error")
	    nil)
	(t)))

; LBdo-return will either do the appropriate throw or will return the
; value that should be returned as the value of the lispbreak.

(defun LBdo-return (retinfo)
  (cond ((eq (car retinfo) 'no)		; then do fail -- throw to attempt
	   (if (cddr retinfo)
	       then (fail (caddr retinfo))
	       else (fail)))
	(LBerrflag
	   (throw (caddr retinfo) LBerr-return))
	(t (caddr retinfo))))

(defmacro attempt (x)
  `(let ((LBattempt-level (1+ LBlevel)))
        (catch ,x LBattempt)))

(defun LBfail (lispxline)
  (cond ((null LBattempt-level)
	   (msg "Not within an attempt"))
	(lispxline
	   (throw `(no ,LBattempt-level ,(eval (car lispxline))) LBbreaktag))
	(t (throw `(no ,LBattempt-level) LBbreaktag))))

(defun fail (&optional (val '$$FAIL))
  (throw val LBattempt))

(defun LBerr-handler (x)
;  x looks like  (type id contflag msg &rest data)
  (ncons (LBerr (for xx in (cddddr x)
		     join (list '| | xx)
		     finally (cons (cadddr x) $$val))
		(caddr x))))

(defun LBerr (msg contflag)
 (let (^w poport)
  (for x in msg do (patom x))
  (terpr)
  (setq ER%tpl 'LBerr-handler)
  (cond ((status exit-on-error)
	   (msg '|Exiting immediately on error|)
	   (exit 1))
	(contflag
	   (catch (LBbreak nil nil t) LBerr-return))
	(t (msg "Non continuable error")
	   (LBbreak nil nil 'nc)))))

(defun lispbreakhelp nil (msg
"ok val	to continue execution from the point where the last lispbreak was
	called.  if given, 'val' is eval'd and returned.
go n	go to nth level lispbreak, n > 0.  if n is not given, the current
	level - 1 is assumed.
^D	same as 'go'
stk	does a (showstack)
top	does a (reset)
no val	return to last call to attempt")
(lispxhelp))
