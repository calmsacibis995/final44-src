head     4.6;
branch   ;
access   ;
symbols  PATCH8:4.4 PATCH7:4.1 KPATCH6:4.1 ASRSNAP1001:4.1 PATCH5:4.1 KPATCH4:4.1 KPATCH3:4.1 KPATCH2:4.1 KREL1:4.1;
locks    ; strict;
comment  @ * @;


4.6
date     91.02.25.15.11.48;  author bostic;  state Exp;
branches ;
next     4.5;

4.5
date     90.06.25.20.58.42;  author kfall;  state Exp;
branches ;
next     4.4;

4.4
date     89.12.19.13.30.53;  author jtkohl;  state Exp;
branches ;
next     4.3;

4.3
date     89.12.13.11.22.22;  author jtkohl;  state Exp;
branches ;
next     4.2;

4.2
date     89.12.13.11.21.04;  author jtkohl;  state Exp;
branches ;
next     4.1;

4.1
date     89.01.24.14.12.04;  author root;  state Exp;
branches ;
next     4.0;

4.0
date     89.01.23.10.01.26;  author jtkohl;  state Exp;
branches ;
next     1.4;

1.4
date     89.01.23.09.21.53;  author jtkohl;  state Exp;
branches ;
next     1.3;

1.3
date     87.11.16.10.39.51;  author jtkohl;  state Exp;
branches ;
next     1.2;

1.2
date     87.11.16.10.30.05;  author jtkohl;  state Exp;
branches ;
next     1.1;

1.1
date     87.11.16.10.29.10;  author jtkohl;  state Exp;
branches ;
next     ;


desc
@acl_files.c for the Athena acl library
@


4.6
log
@`acl_abort' was declared implicitly `extern' and later `static'
@
text
@/*
 *	$Source: /usr/src/kerberosIV/acl/RCS/acl_files.c,v $
 *	$Author: kfall $
 *
 * Copyright 1987,1989 by the Massachusetts Institute of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 *
 */

#ifndef lint
static char rcsid_acl_files_c[] = "$Id: acl_files.c,v 4.5 90/06/25 20:58:42 kfall Exp Locker: bostic $";
#endif lint


/*** Routines for manipulating access control list files ***/

#include <stdio.h>
#include <strings.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/errno.h>
#include <ctype.h>
#include "des.h"
#include "krb.h"

#ifndef KRB_REALM
#define KRB_REALM	"CS.BERKELEY.EDU"
#endif

/* "aname.inst@@realm" */
#define MAX_PRINCIPAL_SIZE  (ANAME_SZ + INST_SZ + REALM_SZ + 3)
#define INST_SEP '.'
#define REALM_SEP '@@'

#define LINESIZE 2048		/* Maximum line length in an acl file */

#define NEW_FILE "%s.~NEWACL~"	/* Format for name of altered acl file */
#define WAIT_TIME 300		/* Maximum time allowed write acl file */

#define CACHED_ACLS 8		/* How many acls to cache */
				/* Each acl costs 1 open file descriptor */
#define ACL_LEN 16		/* Twice a reasonable acl length */

#define MAX(a,b) (((a)>(b))?(a):(b))
#define MIN(a,b) (((a)<(b))?(a):(b))

#define COR(a,b) ((a!=NULL)?(a):(b))

extern int errno;

extern char *malloc(), *calloc();
extern time_t time();

/* Canonicalize a principal name */
/* If instance is missing, it becomes "" */
/* If realm is missing, it becomes the local realm */
/* Canonicalized form is put in canon, which must be big enough to hold
   MAX_PRINCIPAL_SIZE characters */
acl_canonicalize_principal(principal, canon)
char *principal;
char *canon;
{
    char *dot, *atsign, *end;
    int len;

    dot = index(principal, INST_SEP);
    atsign = index(principal, REALM_SEP);

    /* Maybe we're done already */
    if(dot != NULL && atsign != NULL) {
	if(dot < atsign) {
	    /* It's for real */
	    /* Copy into canon */
	    strncpy(canon, principal, MAX_PRINCIPAL_SIZE);
	    canon[MAX_PRINCIPAL_SIZE-1] = '\0';
	    return;
	} else {
	    /* Nope, it's part of the realm */
	    dot = NULL;
	}
    }
    
    /* No such luck */
    end = principal + strlen(principal);

    /* Get the principal name */
    len = MIN(ANAME_SZ, COR(dot, COR(atsign, end)) - principal);
    strncpy(canon, principal, len);
    canon += len;

    /* Add INST_SEP */
    *canon++ = INST_SEP;

    /* Get the instance, if it exists */
    if(dot != NULL) {
	++dot;
	len = MIN(INST_SZ, COR(atsign, end) - dot);
	strncpy(canon, dot, len);
	canon += len;
    }

    /* Add REALM_SEP */
    *canon++ = REALM_SEP;

    /* Get the realm, if it exists */
    /* Otherwise, default to local realm */
    if(atsign != NULL) {
	++atsign;
	len = MIN(REALM_SZ, end - atsign);
	strncpy(canon, atsign, len);
	canon += len;
	*canon++ = '\0';
    } else if(krb_get_lrealm(canon, 1) != KSUCCESS) {
	strcpy(canon, KRB_REALM);
    }
}
	    
/* Get a lock to modify acl_file */
/* Return new FILE pointer */
/* or NULL if file cannot be modified */
/* REQUIRES WRITE PERMISSION TO CONTAINING DIRECTORY */
static FILE *acl_lock_file(acl_file)
char *acl_file;
{
    struct stat s;
    char new[LINESIZE];
    int nfd;
    FILE *nf;
    int mode;

    if(stat(acl_file, &s) < 0) return(NULL);
    mode = s.st_mode;
    sprintf(new, NEW_FILE, acl_file);
    for(;;) {
	/* Open the new file */
	if((nfd = open(new, O_WRONLY|O_CREAT|O_EXCL, mode)) < 0) {
	    if(errno == EEXIST) {
		/* Maybe somebody got here already, maybe it's just old */
		if(stat(new, &s) < 0) return(NULL);
		if(time(0) - s.st_ctime > WAIT_TIME) {
		    /* File is stale, kill it */
		    unlink(new);
		    continue;
		} else {
		    /* Wait and try again */
		    sleep(1);
		    continue;
		}
	    } else {
		/* Some other error, we lose */
		return(NULL);
	    }
	}

	/* If we got to here, the lock file is ours and ok */
	/* Reopen it under stdio */
	if((nf = fdopen(nfd, "w")) == NULL) {
	    /* Oops, clean up */
	    unlink(new);
	}
	return(nf);
    }
}

static int acl_abort();

/* Commit changes to acl_file written onto FILE *f */
/* Returns zero if successful */
/* Returns > 0 if lock was broken */
/* Returns < 0 if some other error occurs */
/* Closes f */
static int acl_commit(acl_file, f)
char *acl_file;
FILE *f;     
{
    char new[LINESIZE];
    int ret;
    struct stat s;

    sprintf(new, NEW_FILE, acl_file);
    if(fflush(f) < 0
       || fstat(fileno(f), &s) < 0
       || s.st_nlink == 0) {
	acl_abort(acl_file, f);
	return(-1);
    }

    ret = rename(new, acl_file);
    fclose(f);
    return(ret);
}

/* Abort changes to acl_file written onto FILE *f */
/* Returns 0 if successful, < 0 otherwise */
/* Closes f */
static int acl_abort(acl_file, f)
char *acl_file;
FILE *f;     
{
    char new[LINESIZE];
    int ret;
    struct stat s;

    /* make sure we aren't nuking someone else's file */
    if(fstat(fileno(f), &s) < 0
       || s.st_nlink == 0) {
	   fclose(f);
	   return(-1);
       } else {
	   sprintf(new, NEW_FILE, acl_file);
	   ret = unlink(new);
	   fclose(f);
	   return(ret);
       }
}

/* Initialize an acl_file */
/* Creates the file with permissions perm if it does not exist */
/* Erases it if it does */
/* Returns return value of acl_commit */
int acl_initialize(acl_file, perm)
char *acl_file;
int perm;
{
    FILE *new;
    int fd;

    /* Check if the file exists already */
    if((new = acl_lock_file(acl_file)) != NULL) {
	return(acl_commit(acl_file, new));
    } else {
	/* File must be readable and writable by owner */
	if((fd = open(acl_file, O_CREAT|O_EXCL, perm|0600)) < 0) {
	    return(-1);
	} else {
	    close(fd);
	    return(0);
	}
    }
}

/* Eliminate all whitespace character in buf */
/* Modifies its argument */
static nuke_whitespace(buf)
char *buf;
{
    register char *pin, *pout;

    for(pin = pout = buf; *pin != '\0'; pin++)
	if(!isspace(*pin)) *pout++ = *pin;
    *pout = '\0';		/* Terminate the string */
}

/* Hash table stuff */

struct hashtbl {
    int size;			/* Max number of entries */
    int entries;		/* Actual number of entries */
    char **tbl;			/* Pointer to start of table */
};

/* Make an empty hash table of size s */
static struct hashtbl *make_hash(size)
int size;
{
    struct hashtbl *h;

    if(size < 1) size = 1;
    h = (struct hashtbl *) malloc(sizeof(struct hashtbl));
    h->size = size;
    h->entries = 0;
    h->tbl = (char **) calloc(size, sizeof(char *));
    return(h);
}

/* Destroy a hash table */
static destroy_hash(h)
struct hashtbl *h;
{
    int i;

    for(i = 0; i < h->size; i++) {
	if(h->tbl[i] != NULL) free(h->tbl[i]);
    }
    free(h->tbl);
    free(h);
}

/* Compute hash value for a string */
static unsigned hashval(s)
register char *s;
{
    register unsigned hv;

    for(hv = 0; *s != '\0'; s++) {
	hv ^= ((hv << 3) ^ *s);
    }
    return(hv);
}

/* Add an element to a hash table */
static add_hash(h, el)
struct hashtbl *h;
char *el;
{
    unsigned hv;
    char *s;
    char **old;
    int i;

    /* Make space if it isn't there already */
    if(h->entries + 1 > (h->size >> 1)) {
	old = h->tbl;
	h->tbl = (char **) calloc(h->size << 1, sizeof(char *));
	for(i = 0; i < h->size; i++) {
	    if(old[i] != NULL) {
		hv = hashval(old[i]) % (h->size << 1);
		while(h->tbl[hv] != NULL) hv = (hv+1) % (h->size << 1);
		h->tbl[hv] = old[i];
	    }
	}
	h->size = h->size << 1;
	free(old);
    }

    hv = hashval(el) % h->size;
    while(h->tbl[hv] != NULL && strcmp(h->tbl[hv], el)) hv = (hv+1) % h->size;
    s = malloc(strlen(el)+1);
    strcpy(s, el);
    h->tbl[hv] = s;
    h->entries++;
}

/* Returns nonzero if el is in h */
static check_hash(h, el)
struct hashtbl *h;
char *el;
{
    unsigned hv;

    for(hv = hashval(el) % h->size;
	h->tbl[hv] != NULL;
	hv = (hv + 1) % h->size) {
	    if(!strcmp(h->tbl[hv], el)) return(1);
	}
    return(0);
}

struct acl {
    char filename[LINESIZE];	/* Name of acl file */
    int fd;			/* File descriptor for acl file */
    struct stat status;		/* File status at last read */
    struct hashtbl *acl;	/* Acl entries */
};

static struct acl acl_cache[CACHED_ACLS];

static int acl_cache_count = 0;
static int acl_cache_next = 0;

/* Returns < 0 if unsuccessful in loading acl */
/* Returns index into acl_cache otherwise */
/* Note that if acl is already loaded, this is just a lookup */
static int acl_load(name)
char *name;
{
    int i;
    FILE *f;
    struct stat s;
    char buf[MAX_PRINCIPAL_SIZE];
    char canon[MAX_PRINCIPAL_SIZE];

    /* See if it's there already */
    for(i = 0; i < acl_cache_count; i++) {
	if(!strcmp(acl_cache[i].filename, name)
	   && acl_cache[i].fd >= 0) goto got_it;
    }

    /* It isn't, load it in */
    /* maybe there's still room */
    if(acl_cache_count < CACHED_ACLS) {
	i = acl_cache_count++;
    } else {
	/* No room, clean one out */
	i = acl_cache_next;
	acl_cache_next = (acl_cache_next + 1) % CACHED_ACLS;
	close(acl_cache[i].fd);
	if(acl_cache[i].acl) {
	    destroy_hash(acl_cache[i].acl);
	    acl_cache[i].acl = (struct hashtbl *) 0;
	}
    }

    /* Set up the acl */
    strcpy(acl_cache[i].filename, name);
    if((acl_cache[i].fd = open(name, O_RDONLY, 0)) < 0) return(-1);
    /* Force reload */
    acl_cache[i].acl = (struct hashtbl *) 0;

 got_it:
    /*
     * See if the stat matches
     *
     * Use stat(), not fstat(), as the file may have been re-created by
     * acl_add or acl_delete.  If this happens, the old inode will have
     * no changes in the mod-time and the following test will fail.
     */
    if(stat(acl_cache[i].filename, &s) < 0) return(-1);
    if(acl_cache[i].acl == (struct hashtbl *) 0
       || s.st_nlink != acl_cache[i].status.st_nlink
       || s.st_mtime != acl_cache[i].status.st_mtime
       || s.st_ctime != acl_cache[i].status.st_ctime) {
	   /* Gotta reload */
	   if(acl_cache[i].fd >= 0) close(acl_cache[i].fd);
	   if((acl_cache[i].fd = open(name, O_RDONLY, 0)) < 0) return(-1);
	   if((f = fdopen(acl_cache[i].fd, "r")) == NULL) return(-1);
	   if(acl_cache[i].acl) destroy_hash(acl_cache[i].acl);
	   acl_cache[i].acl = make_hash(ACL_LEN);
	   while(fgets(buf, sizeof(buf), f) != NULL) {
	       nuke_whitespace(buf);
	       acl_canonicalize_principal(buf, canon);
	       add_hash(acl_cache[i].acl, canon);
	   }
	   fclose(f);
	   acl_cache[i].status = s;
       }
    return(i);
}

/* Returns nonzero if it can be determined that acl contains principal */
/* Principal is not canonicalized, and no wildcarding is done */
acl_exact_match(acl, principal)
char *acl;
char *principal;
{
    int idx;

    return((idx = acl_load(acl)) >= 0
	   && check_hash(acl_cache[idx].acl, principal));
}

/* Returns nonzero if it can be determined that acl contains principal */
/* Recognizes wildcards in acl of the form
   name.*@@realm, *.*@@realm, and *.*@@* */
acl_check(acl, principal)
char *acl;
char *principal;
{
    char buf[MAX_PRINCIPAL_SIZE];
    char canon[MAX_PRINCIPAL_SIZE];
    char *realm;

    acl_canonicalize_principal(principal, canon);

    /* Is it there? */
    if(acl_exact_match(acl, canon)) return(1);

    /* Try the wildcards */
    realm = index(canon, REALM_SEP);
    *index(canon, INST_SEP) = '\0';	/* Chuck the instance */

    sprintf(buf, "%s.*%s", canon, realm);
    if(acl_exact_match(acl, buf)) return(1);

    sprintf(buf, "*.*%s", realm);
    if(acl_exact_match(acl, buf) || acl_exact_match(acl, "*.*@@*")) return(1);
       
    return(0);
}

/* Adds principal to acl */
/* Wildcards are interpreted literally */
acl_add(acl, principal)
char *acl;
char *principal;
{
    int idx;
    int i;
    FILE *new;
    char canon[MAX_PRINCIPAL_SIZE];

    acl_canonicalize_principal(principal, canon);

    if((new = acl_lock_file(acl)) == NULL) return(-1);
    if((acl_exact_match(acl, canon))
       || (idx = acl_load(acl)) < 0) {
	   acl_abort(acl, new);
	   return(-1);
       }
    /* It isn't there yet, copy the file and put it in */
    for(i = 0; i < acl_cache[idx].acl->size; i++) {
	if(acl_cache[idx].acl->tbl[i] != NULL) {
	    if(fputs(acl_cache[idx].acl->tbl[i], new) == NULL
	       || putc('\n', new) != '\n') {
		   acl_abort(acl, new);
		   return(-1);
	       }
	}
    }
    fputs(canon, new);
    putc('\n', new);
    return(acl_commit(acl, new));
}

/* Removes principal from acl */
/* Wildcards are interpreted literally */
acl_delete(acl, principal)
char *acl;
char *principal;
{
    int idx;
    int i;
    FILE *new;
    char canon[MAX_PRINCIPAL_SIZE];

    acl_canonicalize_principal(principal, canon);

    if((new = acl_lock_file(acl)) == NULL) return(-1);
    if((!acl_exact_match(acl, canon))
       || (idx = acl_load(acl)) < 0) {
	   acl_abort(acl, new);
	   return(-1);
       }
    /* It isn't there yet, copy the file and put it in */
    for(i = 0; i < acl_cache[idx].acl->size; i++) {
	if(acl_cache[idx].acl->tbl[i] != NULL
	   && strcmp(acl_cache[idx].acl->tbl[i], canon)) {
	       fputs(acl_cache[idx].acl->tbl[i], new);
	       putc('\n', new);
	}
    }
    return(acl_commit(acl, new));
}

@


4.5
log
@default realm to CS.BERKELEY.EDU
@
text
@d2 2
a3 2
 *	$Source: /usr/src/kerberosIV/src/lib/acl/RCS/acl_files.c,v $
 *	$Author: jtkohl $
d13 1
a13 1
static char rcsid_acl_files_c[] = "$Id: acl_files.c,v 4.4 89/12/19 13:30:53 jtkohl Exp Locker: kfall $";
d167 2
@


4.4
log
@use quotes, not brokets for krb.h
[from Steve Lunt at Bellcore]
@
text
@d2 1
a2 1
 *	$Source: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/acl/RCS/acl_files.c,v $
d13 1
a13 1
static char rcsid_acl_files_c[] = "$Id: acl_files.c,v 4.3 89/12/13 11:22:22 jtkohl Exp Locker: jtkohl $";
d26 1
d30 1
a30 1
#define KRB_REALM	"ATHENA.MIT.EDU"
@


4.3
log
@change Header to Id
@
text
@d13 1
a13 1
static char rcsid_acl_files_c[] = "$Id: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/acl/RCS/acl_files.c,v 4.2 89/12/13 11:21:04 jtkohl Exp Locker: jtkohl $";
d26 1
a26 1
#include <krb.h>
@


4.2
log
@fixes from athena sources:
Use stat() not fstat() as the acl file may have been re-created by an
acl_add or acl_delete call.  If this happens, we are now referencing
the wrong inode.        [rfrench]
Fixes from tjcoppet:

When an acl file does not exist, and the cache is full, the
load_acl() proc does not zero the hash table pointer. This
causes certain olc servers to die unexpectedly.

File descriptor leak fixed in acl_load().
@
text
@d2 2
a3 2
 *	$Source: /mit/kerberos/src/lib/acl/RCS/acl_files.c,v $
 *	$Author: root $
d13 1
a13 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 4.1 89/01/24 14:12:04 root Exp $";
@


4.1
log
@add notice.
@
text
@d3 1
a3 1
 *	$Author: jtkohl $
d13 1
a13 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 4.0 89/01/23 10:01:26 root Locked $";
d388 4
a391 1
	if(acl_cache[i].acl) destroy_hash(acl_cache[i].acl);
d401 8
a408 2
    /* See if the stat matches */
    if(fstat(acl_cache[i].fd, &s) < 0) return(-1);
d424 1
@


4.0
log
@No change, incrementing vno to 4.x
@
text
@d4 6
d13 1
a13 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 1.4 89/01/23 09:21:53 jtkohl Exp $";
a15 7
/*

Copyright 1987 by the Massachusetts Institute of Technology

All Rights Reserved.

*/
@


1.4
log
@Programmer/Auditor: John Kohl
changes: name changes to krb_xxx
@
text
@d7 1
a7 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 1.3 87/11/16 10:39:51 jtkohl Locked $";
@


1.3
log
@lint cleanup (replace index with idx)
@
text
@d2 1
a2 1
 *	$Source: /paris/source/4.3/athena.lib/acl/RCS/acl_files.c,v $
d7 1
a7 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 1.2 87/11/16 10:30:05 jtkohl Locked $";
d116 1
a116 1
    } else if(get_krbrlm(canon, 1) != KSUCCESS) {
@


1.2
log
@add RCS info, plus dfn. of time()
@
text
@d2 1
a2 1
 *	$Source: /u1/zephyr/src/acl/RCS/acl_files.c,v $
d7 1
a7 1
static char rcsid_acl_files_c[] = "$Header: acl_files.c,v 1.4 87/07/02 09:48:20 jtkohl Exp $";
d427 1
a427 1
    int index;
d429 2
a430 2
    return((index = acl_load(acl)) >= 0
	   && check_hash(acl_cache[index].acl, principal));
d468 1
a468 1
    int index;
d477 1
a477 1
       || (index = acl_load(acl)) < 0) {
d482 3
a484 3
    for(i = 0; i < acl_cache[index].acl->size; i++) {
	if(acl_cache[index].acl->tbl[i] != NULL) {
	    if(fputs(acl_cache[index].acl->tbl[i], new) == NULL
d502 1
a502 1
    int index;
d511 1
a511 1
       || (index = acl_load(acl)) < 0) {
d516 4
a519 4
    for(i = 0; i < acl_cache[index].acl->size; i++) {
	if(acl_cache[index].acl->tbl[i] != NULL
	   && strcmp(acl_cache[index].acl->tbl[i], canon)) {
	       fputs(acl_cache[index].acl->tbl[i], new);
@


1.1
log
@Initial revision
@
text
@d1 17
d55 1
@
