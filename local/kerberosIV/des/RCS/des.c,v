head     4.13;
branch   ;
access   ;
symbols  PATCH8:4.13 PATCH7:4.13 KPATCH6:4.13 ASRSNAP1001:4.13 PATCH5:4.13 ADAMS_NSA:4.13 KPATCH4:4.13 KPATCH3:4.13 KPATCH2:4.13 KREL1:4.13 BETA5/24/88:4.10 v1:1.4;
locks    ; strict;
comment  @ * @;


4.13
date     89.01.21.16.49.55;  author jtkohl;  state Exp;
branches ;
next     4.12;

4.12
date     89.01.17.16.19.51;  author rfrench;  state Exp;
branches ;
next     4.11;

4.11
date     88.11.15.11.28.38;  author jtkohl;  state Exp;
branches ;
next     4.10;

4.10
date     88.02.24.14.20.44;  author steiner;  state Exp;
branches ;
next     4.9;

4.9
date     88.02.05.19.08.07;  author steiner;  state Exp;
branches ;
next     4.8;

4.8
date     88.01.14.18.42.32;  author steiner;  state Exp;
branches ;
next     4.7;

4.7
date     88.01.13.17.48.04;  author raeburn;  state Exp;
branches ;
next     4.6;

4.6
date     87.11.28.02.53.09;  author raeburn;  state Exp;
branches ;
next     4.5;

4.5
date     87.11.24.06.29.28;  author raeburn;  state Exp;
branches ;
next     4.4;

4.4
date     87.11.24.06.17.10;  author raeburn;  state Exp;
branches ;
next     4.3;

4.3
date     87.10.23.10.45.13;  author steiner;  state Exp;
branches ;
next     4.2;

4.2
date     87.09.10.16.13.48;  author steiner;  state Exp;
branches ;
next     4.1;

4.1
date     87.09.01.15.40.19;  author steiner;  state Exp;
branches ;
next     1.13;

1.13
date     87.01.13.16.33.38;  author wesommer;  state Exp;
branches ;
next     1.12;

1.12
date     87.01.09.15.44.20;  author wesommer;  state Exp;
branches ;
next     1.11;

1.11
date     86.08.14.23.10.23;  author spm;  state Exp;
branches ;
next     1.10;

1.10
date     86.08.08.14.09.38;  author spm;  state Exp;
branches ;
next     1.9;

1.9
date     86.08.08.14.09.11;  author spm;  state Exp;
branches ;
next     1.8;

1.8
date     85.12.16.13.44.54;  author spm;  state Exp;
branches ;
next     1.7;

1.7
date     85.08.19.16.52.50;  author spm;  state Exp;
branches ;
next     1.6;

1.6
date     85.08.19.15.25.05;  author spm;  state Exp;
branches ;
next     1.5;

1.5
date     85.08.16.17.41.53;  author spm;  state Exp;
branches ;
next     1.4;

1.4
date     85.08.16.12.48.16;  author spm;  state Exp;
branches ;
next     1.3;

1.3
date     85.08.14.10.22.10;  author spm;  state Exp;
branches ;
next     1.2;

1.2
date     85.08.12.13.36.49;  author spm;  state Exp;
branches ;
next     1.1;

1.1
date     85.08.11.14.15.13;  author spm;  state Exp;
branches ;
next     ;


desc
@works
@


4.13
log
@lint cleanups
(Programmer: John Kohl)
@
text
@/*
 * $Source: /mit/kerberos/src/lib/des/RCS/des.c,v $
 * $Author: rfrench $
 *
 * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute
 * of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 *
 * These routines perform encryption and decryption using the DES
 * private key algorithm, or else a subset of it-- fewer inner loops.
 * (AUTH_DES_ITER defaults to 16, may be less.)
 *
 * Under U.S. law, this software may not be exported outside the US
 * without license from the U.S. Commerce department.
 *
 * The key schedule is passed as an arg, as well as the cleartext or
 * ciphertext.
 *
 * All registers labeled imply Vax using the Ultrix or 4.2bsd
 * compiler.
 *
 *
 *	NOTE:  bit and byte numbering:
 *			DES algorithm is defined in terms of bits of L
 *			followed by bits of R.
 *		bit 0  ==> lsb of L
 *		bit 63 ==> msb of R
 *
 * Always work in register pairs, FROM L1,R1 TO L2,R2 to make
 * bookkeeping easier.
 *
 * originally written by Steve Miller, MIT Project Athena
 */

#ifndef	lint
static char rcsid_des_c[] =
"$Header: des.c,v 4.12 89/01/17 16:19:51 jtkohl Locked $";
#endif	lint

#include <mit-copyright.h>

#include <stdio.h>
#include <des.h>
#include "des_internal.h"
#include "s_table.h"
#ifdef BIG
#include "p_table.h"
#endif

#ifdef DEBUG
#define DBG_PRINT(s) if (des_debug & 2) \
    des_debug_print(s,i,L1&0xffff,(L1>>16)&0xffff, \
		R1&0xffff,(R1>>16)&0xffff)
#else
#define DBG_PRINT(s)
#endif

extern int des_debug;
extern des_cblock_print_file ();
extern des_debug_print ();

int
des_ecb_encrypt(clear, cipher, schedule, encrypt)
    unsigned long *clear;
    unsigned long *cipher;
    int encrypt;		/* 0 ==> decrypt, else encrypt */
    register des_key_schedule schedule; /* r11 */
{

    /* better pass 8 bytes, length not checked here */

    register unsigned long R1, L1; /* R1 = r10, L1 = r9 */
    register unsigned long R2, L2; /* R2 = r8, L2 = r7 */
    long i;
    /* one more registers left on VAX, see below P_temp_p */
#ifdef BITS16
    sbox_in_16_a S_in_16_a;
    sbox_in_16_b S_in_16_b;
    sbox_in_16_c S_in_16_c;
    unsigned int *S_in_a_16_p = (unsigned int *) &S_in_16_a;
    unsigned int *S_in_b_16_p = (unsigned int *) &S_in_16_b;
    unsigned int *S_in_c_16_p = (unsigned int *) &S_in_16_c;
#endif
#ifndef BITS32
#ifndef BITS16
    dunno how to do this machine type, you lose;
#endif
#endif
    unsigned long P_temp;
    register unsigned char *P_temp_p = (unsigned char *) & P_temp;
#ifdef BITS16
    sbox_out S_out;
    unsigned long *S_out_p = (unsigned long *) &S_out;
#endif
    unsigned long R_save, L_save;
#ifdef DEBUG
    unsigned long dbg_tmp[2];
#endif

    /*
     * Use L1,R1 and L2,R2 as two sets of "64-bit" registers always
     * work from L1,R1 input to L2,R2 output; initialize the cleartext
     * into registers.
     */
#ifdef MUSTALIGN
#ifdef DEBUG
    /*
     * If the alignment is wrong, the programmer really screwed up --
     * we aren't even getting the right data type.  His problem.  Keep
     * this code for debugging.
     */
    /* Make sure schedule is ok */
    if ((long) schedule & 3) {
	fprintf(stderr,"des.c schedule arg pointer not aligned\n");
	abort();
    }
#endif
    if ((long) clear & 3) {
	bcopy((char *)clear++,(char *)&L_save,sizeof(L_save));
	bcopy((char *)clear,(char *)&R_save,sizeof(R_save));
	L1 = L_save;
	R1 = R_save;
    }
    else
#endif
    {
	if (clear) L1 = *clear++;
	else L1 = NULL;
	if (clear) R1 = *clear;
	else R1 = NULL;
    }

#ifdef DEBUG
    if (des_debug & 2) {
	printf("All values printed from low byte (bit 0)");
	printf(" --> high byte (bit 63)\n");
	i = 0;
	dbg_tmp[0] = L1;
	dbg_tmp[1] = R1;
	printf("iter = %2d  before IP\n\t\tL1 R1 = ",i);
	des_cblock_print_file (dbg_tmp, stdout);
    }

    DBG_PRINT("before IP");
#endif

/*   IP_start:*/

    /* all the Initial Permutation code is in the include file */
#include "ip.c"
    /* reset input to L1,R1 */
    L1 = L2;
    R1 = R2;

    /* iterate through the inner loop */
    for (i = 0; i <= (AUTH_DES_ITER-1); i++) {

#ifdef DEBUG
	if (des_debug & 2) {
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    printf("iter = %2d	start loop\n\t\tL1 R1 = ",i);
	    des_cblock_print_file (dbg_tmp, stdout);
	    DBG_PRINT("start loop");
	}

#endif

	R_save = R1;
	L_save = L1;

/*   E_start:*/
	/* apply the E permutation from R1 to L2, R2 */
#ifndef VAXASM
#ifdef SLOW_E
#include "e.c"
#else /* Bill's fast E */
	L2 = (R1 << 1);
	if (R1 & (1<<31))
	    L2 |= 1<<0;
	L2 &= 077;
	L2 |= (R1 <<3) & 07700;
	L2 |= (R1 <<5) & 0770000;
	L2 |= (R1 <<7) & 077000000;
	L2 |= (R1 <<9) & 07700000000;
	L2 |= (R1 <<11) & 030000000000;

	/* now from right to right */

	R2 = ((R1 >> 17) & 0176000);
	if (R1 & (1<<0)) R2 |= 1<<15;

	R2 |= ((R1 >> 21) & 017);
	R2 |= ((R1 >> 19) & 01760);
#endif /* SLOW_E */
#else /* VAXASM */
	/* E operations */
	/* right to left */
	asm("	rotl	$1,r10,r7");
	L2 &= 077;
	L2 |= (R1 <<3) & 07700;
	L2 |= (R1 <<5) & 0770000;
	L2 |= (R1 <<7) & 077000000;
	L2 |= (R1 <<9) & 07700000000;
	L2 |= (R1 <<11) & 030000000000;

	asm("	rotl	$-17,r10,r8");
	R2 &= 0176000;
	asm("	rotl	$-21,r10,r0");
	asm("	bicl2	$-16,r0");
	asm("  bisl2	r0,r8");
	asm("	rotl	$-19,r10,r0");
	asm("	bicl2	$-1009,r0");
	asm("  bisl2	r0,r8");

#endif

	/* reset input to L1,R1 */
	L1 = L2;
	R1 = R2;

#ifdef DEBUG
	if (des_debug & 2) {
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    DBG_PRINT("after e");
	    printf("iter = %2d	after e\n\t\tL1 R1 = ",i);
	    des_cblock_print_file (dbg_tmp, stdout);
	}
#endif

/*   XOR_start:*/
	/*
	 * XOR with the key schedule, "schedule"
	 *
	 * If this is an encryption operation, use schedule[i],
	 * otherwise use schedule [AUTH_DES_ITER-i-1]
	 *
	 * First XOR left half.
	 */
	if (encrypt) {
	    L1 ^= *(((unsigned long *) &schedule[i] )+0);
	    /* now right half */
	    R1 ^= *(((unsigned long *) &schedule[i] )+1);
	}
	else {
	    L1 ^= *(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] )+0);
	    /* now right half */
	    R1 ^= *(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] )+1);
	}

	/* dont have to reset input to L1, R1 */

#ifdef DEBUG
	if (des_debug & 2) {
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    DBG_PRINT("after xor");
	    printf("iter = %2d	after xor\n\t\tL1 R1 =",i);
	    des_cblock_print_file (dbg_tmp, stdout);
	}
#endif

/*   S_start:*/
	/* apply the S selection from L1, R1 to R2 */

#ifdef notdef
#include "s.c"
#endif

	/* S operations , cant use registers for bit field stuff */
	/* from S_in to S_out */

#ifdef BITS16
	*S_in_a_16_p = L1&0xffff;
	*S_in_b_16_p = (L1>>16)&0xffff;
	*S_in_c_16_p = R1&0xffff;
	(*(unsigned long *) &S_out) =
	    (unsigned) S_adj[0][S_in_16_a.b0];
	S_out.b1 = (unsigned) S_adj[1][S_in_16_a.b1];
	/* b2 spans two words */
	S_out.b2 = (unsigned)
	    S_adj[2][(unsigned) S_in_16_a.b2
		     + (((unsigned) S_in_16_b.b2) << 4)];
	S_out.b3 = (unsigned) S_adj[3][S_in_16_b.b3];
	S_out.b4 = (unsigned) S_adj[4][S_in_16_b.b4];
	/* b5 spans both parts */
	S_out.b5 = (unsigned)
	    S_adj[5][(unsigned) S_in_16_b.b5
		     + (((unsigned) S_in_16_c.b5) << 2)];
	S_out.b6 = (unsigned) S_adj[6][S_in_16_c.b6];
	S_out.b7 = (unsigned) S_adj[7][S_in_16_c.b7];
	R1 = *S_out_p;
#else
	/* is a 32 bit sys */
#ifndef VAXASM
	R2 =  (unsigned) S_adj[0][L1 & 077];
	L2 = (unsigned) S_adj[1][(L1 >> 6) & 077];
	R2 |= (L2 <<4 );
	L2 = (unsigned) S_adj[2][(L1 >> 12) & 077];
	R2 |= (L2 <<8);
	L2 = (unsigned) S_adj[3][(L1 >> 18) & 077];
	R2 |= (L2 <<12);
	L2 = (unsigned) S_adj[4][(L1 >> 24) & 077];
	R2 |= (L2 <<16);
	/* b5 spans both parts */
	L2 = (unsigned)
	    S_adj[5][(unsigned) ((L1 >>30) & 03) + ((R1 & 017) << 2)];
	R2 |= (L2 << 20);
	L2 = (unsigned) S_adj[6][(R1 >> 4) & 077];
	R2 |= (L2 <<24);
	L2 = (unsigned) S_adj[7][(R1 >> 10) & 077];
	R1 = R2 | (L2 <<28);
	/* reset input to L1, R1 */
#else /* vaxasm */
	/*
	 * this is the c code produced above, with
	 * extzv replaced by rotl
	 */
	asm("bicl3	$-64,r9,r0");
	asm("movzbl	_S_adj[r0],r8");
	asm("rotl	$-6,r9,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+64[r0],r7");
	asm("ashl	$4,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-12,r9,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+128[r0],r7");
	asm("ashl	$8,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-18,r9,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+192[r0],r7");
	asm("ashl	$12,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-24,r9,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+256[r0],r7");
	asm("ashl	$16,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-30,r9,r0");
	asm("bicl2	$-4,r0");
	asm("bicl3	$-16,r10,r1");
	asm("ashl	$2,r1,r1");
	asm("addl2	r1,r0");
	asm("movzbl	_S_adj+320[r0],r7");
	asm("ashl	$20,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-4,r10,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+384[r0],r7");
	asm("ashl	$24,r7,r0");
	asm("bisl2	r0,r8");
	asm("rotl	$-10,r10,r0");
	asm("bicl2	$-64,r0");
	asm("movzbl	_S_adj+448[r0],r7");
	asm("ashl	$28,r7,r0");
	asm("bisl2	r8,r0");
	asm("movl	r0,r10");

#endif /* vaxasm */
#endif

#ifdef DEBUG
	if (des_debug & 2) {
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    DBG_PRINT("after s");
	    printf("iter = %2d	after s\n\t\tL1 R1 = ",i);
	    des_cblock_print_file (dbg_tmp, stdout);
	}
#endif

/*   P_start:*/
	/* and then the p permutation from R1 into R2 */
#include "p.c"
	/* reset the input to L1, R1 */
	R1 = R2;

#ifdef DEBUG
	if (des_debug & 2) {
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    DBG_PRINT("after p");
	    printf("iter = %2d	after p\n\t\tL1 R1 = ",i);
	    des_cblock_print_file (dbg_tmp, stdout);
	}
#endif

	/* R1 is the output value from the f() */
	/* move R[iter] to L[iter+1] */
/*   XOR_2_start:*/
	L1 = R_save;
	/* xor with left */
	R1 = L_save ^ R1;
	/* reset the input */
    }

    /* flip left and right before final permutation */
    L2 = R1;			/* flip */
    R2 = L1;
    /* reset the input */
    L1 = L2;
    R1 = R2;

#ifdef DEBUG
    if (des_debug & 2) {
	dbg_tmp[0] = L1;
	dbg_tmp[1] = R1;
	DBG_PRINT("before FP");
	printf("iter = %2d  before FP\n\t\tL1 R1 = ",i);
	des_cblock_print_file (dbg_tmp, stdout);
    }

#endif

/*FP_start:*/
    /* do the final permutation from L1R1 to L2R2 */
    /* all the fp code is in the include file */
#include "fp.c"

    /* copy the output to the ciphertext string;
     * can be same as cleartext
     */

#ifdef MUSTALIGN
    if ((long) cipher & 3) {
	L_save = L2;	/* cant bcopy a reg */
	R_save = R2;
	bcopy((char *)&L_save,(char *)cipher++,sizeof(L_save));
	bcopy((char *)&R_save,(char *)cipher,sizeof(R_save));
    }
    else
#endif
    {
	*cipher++ = L2;
	*cipher = R2;
    }

#ifdef DEBUG
    if (des_debug & 2) {
	L1 = L2;
	R1 = R2;
	dbg_tmp[0] = L1;
	dbg_tmp[1] = R1;
	DBG_PRINT("done");
	printf("iter = %2d  done\n\t\tL1 R1 = ",i);
	des_cblock_print_file (dbg_tmp, stdout);
    }
#endif

    /* that's it, no errors can be returned */
    return 0;
}

@


4.12
log
@Programmer: jtkohl
Auditor: rfrench
Changed instances of des_cblock_print to des_cblock_print_file
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d39 1
a39 1
"$Header: des.c,v 4.11 88/11/15 11:28:38 jtkohl Locked $";
a77 6
#ifdef BITS32
    sbox_in_a S_in_a;
    sbox_in_b S_in_b;
    unsigned long *S_in_a_p = (unsigned long *) &S_in_a;
    unsigned long *S_in_b_p = (unsigned long *) &S_in_b;
#endif
d91 3
d96 1
a97 3
    unsigned long P_temp;
    register unsigned char *P_temp_p = (unsigned char *) & P_temp;
    unsigned char *xor_temp;
d121 2
a122 2
	bcopy(clear++,&L_save,sizeof(L_save));
	bcopy(clear,&R_save,sizeof(R_save));
d149 1
a149 1
IP_start:
d174 1
a174 1
    E_start:
d234 1
a234 1
    XOR_start:
d266 1
a266 1
    S_start:
d377 1
a377 1
    P_start:
d395 1
a395 1
    XOR_2_start:
d420 1
a420 1
FP_start:
d433 2
a434 2
	bcopy(&L_save,cipher++,sizeof(L_save));
	bcopy(&R_save,cipher,sizeof(R_save));
@


4.11
log
@Programmer: Bill Sommerfeld
Auditor: John Kohl
changes:
rename routines to des_xxx     
rename structures likewise
use local variables and static routines where appropriate
convert to des_internal.h       
make debug routines consistent
@
text
@d2 2
a3 2
 * $Source: //ra/mit/wesommer/des/RCS/des.c,v $
 * $Author: steiner $
d39 1
a39 1
"$Header: des.c,v 4.10 88/02/24 14:20:44 steiner Exp $";
d61 1
a61 1
extern des_cblock_print ();
d148 1
a148 1
	des_cblock_print (dbg_tmp);
d170 1
a170 1
	    des_cblock_print (dbg_tmp);
d235 1
a235 1
	    des_cblock_print (dbg_tmp);
d267 1
a267 1
	    des_cblock_print (dbg_tmp);
d378 1
a378 1
	    des_cblock_print (dbg_tmp);
d394 1
a394 1
	    des_cblock_print (dbg_tmp);
d420 1
a420 1
	des_cblock_print (dbg_tmp);
d456 1
a456 1
	des_cblock_print (dbg_tmp);
@


4.10
log
@Copyright notice, etc.
@
text
@d2 1
a2 1
 * $Source: /mit/kerberos/tools/RCS/prototype.c,v $
d39 1
a39 1
"$Header: prototype.c,v 1.2 88/02/22 18:54:06 steiner Locked $";
d46 1
a52 1
static debug_print();
d54 1
a54 1
    debug_print(s,i,L1&0xffff,(L1>>16)&0xffff, \
d61 2
a62 1
extern C_Block_print();
a63 38
#ifdef PC8086
/* The cc86 I/O library is busted.... */
static char *hex[256] = {
    "00", "01", "02", "03", "04", "05", "06", "07",
    "08", "09", "0a", "0b", "0c", "0d", "0e", "0f",
    "10", "11", "12", "13", "14", "15", "16", "17",
    "18", "19", "1a", "1b", "1c", "1d", "1e", "1f",
    "20", "21", "22", "23", "24", "25", "26", "27",
    "28", "29", "2a", "2b", "2c", "2d", "2e", "2f",
    "30", "31", "32", "33", "34", "35", "36", "37",
    "38", "39", "3a", "3b", "3c", "3d", "3e", "3f",
    "40", "41", "42", "43", "44", "45", "46", "47",
    "48", "49", "4a", "4b", "4c", "4d", "4e", "4f",
    "50", "51", "52", "53", "54", "55", "56", "57",
    "58", "59", "5a", "5b", "5c", "5d", "5e", "5f",
    "60", "61", "62", "63", "64", "65", "66", "67",
    "68", "69", "6a", "6b", "6c", "6d", "6e", "6f",
    "70", "71", "72", "73", "74", "75", "76", "77",
    "78", "79", "7a", "7b", "7c", "7d", "7e", "7f",
    "80", "81", "82", "83", "84", "85", "86", "87",
    "88", "89", "8a", "8b", "8c", "8d", "8e", "8f",
    "90", "91", "92", "93", "94", "95", "96", "97",
    "98", "99", "9a", "9b", "9c", "9d", "9e", "9f",
    "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7",
    "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af",
    "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7",
    "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf",
    "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7",
    "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf",
    "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7",
    "d8", "d9", "da", "db", "dc", "dd", "de", "df",
    "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7",
    "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef",
    "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7",
    "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"
    };
#endif /* PC8086 */

d65 1
a65 1
ecb_encrypt(clear, cipher, schedule, encrypt)
d69 1
a69 1
    register Key_schedule schedule; /* r11 */
d148 1
a148 1
	C_Block_print(dbg_tmp);
d170 1
a170 1
	    C_Block_print(dbg_tmp);
d235 1
a235 1
	    C_Block_print(dbg_tmp);
d267 1
a267 1
	    C_Block_print(dbg_tmp);
d378 1
a378 1
	    C_Block_print(dbg_tmp);
d394 1
a394 1
	    C_Block_print(dbg_tmp);
d420 1
a420 1
	C_Block_print(dbg_tmp);
d456 1
a456 1
	C_Block_print(dbg_tmp);
a463 23
#ifdef DEBUG
static debug_print(string,i,ll,lh,rl,rh)
    char *string;
    unsigned i;
    unsigned ll,lh,rl,rh;
{
    printf("iter = %2d	",i);
    printf(string);
#ifdef PC8086
    printf("\t\tL1 = %s %s %s %s  R1 = %s %s %s %s\n",
	   hex[ll & 0xff], hex[(ll >> 8) & 0xff],
	   hex[lh & 0xff], hex[(lh >> 8) & 0xff],
	   hex[rl & 0xff], hex[(rl >> 8) & 0xff],
	   hex[rh & 0xff], hex[(rh >> 8) & 0xff]);
#else /* ! PC8086 */
    printf("\t\tL1 = %02x %02x %02x %02x  R1 = %02x %02x %02x %02x\n",
	   ll & 0xff, (ll >> 8) & 0xff,
	   lh & 0xff, (lh >> 8) & 0xff,
	   rl & 0xff, (rl >> 8) & 0xff,
	   rh & 0xff, (rh >> 8) & 0xff);
#endif
}
#endif /* DEBUG */
@


4.9
log
@Fixed deferencing null pointer.
Programmer: Charley Marker.
Auditors: jon, jtkohl.
@
text
@d2 2
a3 1
 * des.c
d5 2
a6 2
 *	MIT Project Athena
 *	Copyright MIT	1985
d8 2
a9 1
 *	originally written by Steve Miller, MIT Project Athena
a10 4
 *	$Source: /mit/kerberos/src/lib/des/RCS/des.c,v $
 *	$Author: steiner $
 *	$Locker:  $
 *
d33 2
d37 6
a42 4
#ifndef lint
static char rcsid[] =
    "$Header: des.c,v 4.8 88/01/14 18:42:32 steiner Exp $";
#endif
@


4.8
log
@Formatted.
Programmer: raeburn.
@
text
@d9 3
a11 3
 *	$Source: /mit/kerberos/lib/des/RCS/des.c,v $
 *	$Author: raeburn $
 *	$Locker: raeburn $
d39 1
a39 1
    "$Header: des.c,v 4.6 87/11/28 02:53:09 raeburn Locked $";
d169 4
a172 2
	L1 = *clear++;
	R1 = *clear;
@


4.7
log
@Put #ifdef DEBUG around check for alignment.
@
text
@d13 3
a15 3
 *	These routines perform encryption and decryption using the DES
 *  private key algorithm, or else a subset of it-- fewer inner loops.
 *  ( AUTH_DES_ITER defaults to 16, may be less)
d17 2
a18 2
 *	Under U.S. law, this software may not be exported outside the US
 *  without license from the U.S. Commerce department.
d20 2
a21 2
 *	The key schedule is passed as an arg, as well as the cleartext or
 *  ciphertext.
d23 2
a24 1
 *  All registers labeled imply Vax using the Ultrix or 4.2bsd compiler.
d26 1
d33 2
a34 2
 *	Always work in register pairs,
 *  FROM L1,R1 TO L2,R2 to make bookkeeping easier.
d42 5
a46 5
# include	<stdio.h>
# include	<des.h>
# include	"s_table.h"
#ifdef	BIG
# include	"p_table.h"
d49 5
a53 4
#ifdef	DEBUG
static	debug_print();
#define	DBG_PRINT(s)	if (des_debug & 2) \
debug_print(s,i,L1&0xffff,(L1>>16)&0xffff,R1&0xffff,(R1>>16)&0xffff)
d55 1
a55 1
#define	DBG_PRINT(s)
d58 2
a59 2
extern	int	des_debug;
extern		C_Block_print();
d63 1
a63 1
static	char	*hex[256] = {
d96 2
a97 2
};
#endif	/* PC8086 */
d101 4
a104 4
    unsigned long	*clear;
    unsigned long	*cipher;
    int			encrypt;	/* 0 ==> decrypt, else encrypt */
    register Key_schedule schedule;	/* r11 */
d109 2
a110 2
    register unsigned long R1, L1; /*  R1 = r10, L1 = r9 */
    register unsigned long R2, L2; /*  R2 = r8, L2 = r7 */
d113 5
a117 5
#ifdef	BITS32
    sbox_in_a		 S_in_a;
    sbox_in_b		 S_in_b;
    unsigned	long	*S_in_a_p = (unsigned long *) &S_in_a;
    unsigned	long	*S_in_b_p = (unsigned long *) &S_in_b;
d119 7
a125 7
#ifdef	BITS16
    sbox_in_16_a	S_in_16_a;
    sbox_in_16_b	S_in_16_b;
    sbox_in_16_c	S_in_16_c;
    unsigned int	*S_in_a_16_p = (unsigned int *) &S_in_16_a;
    unsigned int	*S_in_b_16_p = (unsigned int *) &S_in_16_b;
    unsigned int	*S_in_c_16_p = (unsigned int *) &S_in_16_c;
d127 2
a128 2
#ifndef	BITS32
#ifndef	BITS16
d132 4
a135 4
    sbox_out		S_out;
    unsigned long	*S_out_p = (unsigned long *) &S_out;
    unsigned long	R_save, L_save;
    unsigned long	P_temp;
d137 1
a137 1
    unsigned char	*xor_temp;
d139 1
a139 1
    unsigned long	dbg_tmp[2];
d143 3
a145 3
     * use L1,R1 and L2,R2 as two sets of "64-bit" registers
     * always work from L1,R1 input to L2,R2 output;
     * init the cleartext into registers
d147 1
a147 1
#ifdef	MUSTALIGN		/* ibm rt */
d150 3
a152 3
     * if the alignment is wrong, the programmer really screwed up --
     * we aren't even getting the right data type.  his problem.  keep
     * this code for debugging....
d173 1
a173 1
#ifdef	DEBUG
d196 1
a196 1
    for ( i = 0; i <= (AUTH_DES_ITER-1); i++) {
d198 1
a198 1
#ifdef	DEBUG
d202 1
a202 1
	    printf("iter = %2d  start loop\n\t\tL1 R1 = ",i);
d214 1
a214 1
#ifndef	VAXASM
d216 1
a216 1
#include	"e.c"
d228 1
a228 1
/* now from right to right */
d231 1
a231 1
        if (R1 & (1<<0)) R2 |= 1<<15;
d233 2
a234 2
        R2 |= ((R1 >> 21) & 017);
        R2 |= ((R1 >> 19) & 01760);
d262 1
a262 1
#ifdef	DEBUG
d267 1
a267 1
	    printf("iter = %2d  after e\n\t\tL1 R1 = ",i);
a269 1

d276 2
a277 2
	 * if this is an encryption operation, use schedule[i],
	 * else use schedule [AUTH_DES_ITER-i-1]
d279 1
a279 1
	 * first XOR left half
d283 1
a283 1
	    /* now right half*/
d288 1
a288 1
	    /* now right half*/
d294 1
a294 2

#ifdef	DEBUG
d299 1
a299 1
	    printf("iter = %2d  after xor\n\t\tL1 R1 =",i);
a301 1

d308 1
a308 1
#include	"s.c"
d314 1
a314 1
#ifdef	BITS16
d318 2
a319 1
	(*(unsigned long *) &S_out) = (unsigned) S_adj[0][S_in_16_a.b0];
d323 2
a324 1
	    S_adj[2][(unsigned) S_in_16_a.b2 + (((unsigned) S_in_16_b.b2) << 4)];
d329 2
a330 1
	    S_adj[5][(unsigned) S_in_16_b.b5 + (((unsigned) S_in_16_c.b5) << 2)];
d336 1
a336 1
#ifndef	VAXASM
d355 1
a355 1
#else				/* vaxasm */
d402 1
a402 1
#endif				/* vaxasm */
d405 1
a405 2

#ifdef	DEBUG
d410 1
a410 1
	    printf("iter = %2d  after s\n\t\tL1 R1 = ",i);
a412 1

d421 1
a421 2

#ifdef	DEBUG
d426 1
a426 1
	    printf("iter = %2d  after p\n\t\tL1 R1 = ",i);
a428 1

d433 1
a433 1
XOR_2_start:
d436 1
a436 1
	R1 = L_save ^ R1 ;
d447 1
a447 1
#ifdef	DEBUG
d463 12
a474 9
/* copy the output to the ciphertext string; can be same as cleartext */
#ifdef	MUSTALIGN		/* ibm rt */
	if ((long) cipher & 3) {
	    L_save = L2;	/* cant bcopy a reg */
	    R_save = R2;
	    bcopy(&L_save,cipher++,sizeof(L_save));
	    bcopy(&R_save,cipher,sizeof(R_save));
	}
	else
d476 4
a479 4
	{
	    *cipher++ = L2;
	    *cipher = R2;
	}
d481 10
a490 10
#ifdef	DEBUG
	if (des_debug & 2) {
	    L1 = L2;
	    R1 = R2;
	    dbg_tmp[0] = L1;
	    dbg_tmp[1] = R1;
	    DBG_PRINT("done");
	    printf("iter = %2d  done\n\t\tL1 R1 = ",i);
	    C_Block_print(dbg_tmp);
	}
d493 1
a493 1
/* that's it, no errors can be returned */
d497 1
a497 1
#ifdef	DEBUG
d503 1
a503 1
    printf("iter = %2d  ",i);
d507 4
a510 4
	    hex[ll & 0xff], hex[(ll >> 8) & 0xff],
	    hex[lh & 0xff], hex[(lh >> 8) & 0xff],
	    hex[rl & 0xff], hex[(rl >> 8) & 0xff],
	    hex[rh & 0xff], hex[(rh >> 8) & 0xff]);
d513 4
a516 4
	    ll & 0xff, (ll >> 8) & 0xff,
	    lh & 0xff, (lh >> 8) & 0xff,
	    rl & 0xff, (rl >> 8) & 0xff,
	    rh & 0xff, (rh >> 8) & 0xff);
d519 1
a519 1
#endif	/* DEBUG */
@


4.6
log
@Bill's optimizations to the E permutation -- move multiple
bits at once.
@
text
@d37 1
a37 1
    "$Header: des.c,v 4.5 87/11/24 06:29:28 raeburn Locked $";
d120 3
a122 3
    unsigned int		*S_in_a_16_p = (unsigned int *) &S_in_16_a;
    unsigned int		*S_in_b_16_p = (unsigned int *) &S_in_16_b;
    unsigned int		*S_in_c_16_p = (unsigned int *) &S_in_16_c;
d145 6
a153 1
	/* XXX -- how to do this cleanly? */
d156 1
@


4.5
log
@Removed static variable declarations -- put everything on
the stack.
@
text
@d37 1
a37 1
    "$Header: des.c,v 4.4 87/11/24 06:17:10 raeburn Locked $";
d206 1
d208 20
a227 1
#else
@


4.4
log
@Reformatted; filenames of included files changed; "hex" array
#ifdef'ed on PC8086.  Numerous small changes to code.
@
text
@d9 2
a10 2
 *	$Source: /site/mit/kerberos/lib/des/RCS/des.c,v $
 *	$Author: steiner $
d37 1
a37 1
    "$Header$";
a47 1
static	unsigned long	dbg_tmp[2];
d111 4
a114 4
    static sbox_in_a		 S_in_a;
    static sbox_in_b		 S_in_b;
    static unsigned	long	*S_in_a_p = (unsigned long *) &S_in_a;
    static unsigned	long	*S_in_b_p = (unsigned long *) &S_in_b;
d117 6
a122 6
    static	sbox_in_16_a	S_in_16_a;
    static	sbox_in_16_b	S_in_16_b;
    static	sbox_in_16_c	S_in_16_c;
    static unsigned int		*S_in_a_16_p = (unsigned int *) &S_in_16_a;
    static unsigned int		*S_in_b_16_p = (unsigned int *) &S_in_16_b;
    static unsigned int		*S_in_c_16_p = (unsigned int *) &S_in_16_c;
d129 9
a137 6
    static sbox_out		S_out;
    static unsigned long	*S_out_p = (unsigned long *) &S_out;
    static unsigned long	R_save, L_save;
    static unsigned long	P_temp;
    register unsigned char	*P_temp_p = (unsigned char *) & P_temp;
    static unsigned char	*xor_temp;
@


4.3
log
@Moved ./des_conf.h to .../include/krb_conf.h; .../include/des.h
includes it now.
@
text
@d1 2
a2 1
/* des.c
d4 2
a5 2
 *	spm	8/85	MIT project athena
 *				copyright MIT	1985
d7 1
d9 1
a9 1
 *	$Source: /u3/kerberos.new/lib/des/bsd/RCS/des.c,v $
d11 1
a11 1
 *	$Locker: steiner $
d26 4
a29 4
 *			DES algorithm is defined in terms of bits of L followed by
 *			bits of R.
 *			bit 0  ==> lsb of L
 *			bit 63 ==> msb of R
d32 1
a32 1
 *  FROM L1,R1 TO L2,R2 to make bookeeping easier. 
d35 5
d42 1
a42 1
# include	"des_s_table.h"
d44 1
a44 1
# include	"des_p_table.h"
d49 2
a50 1
#define	DBG_PRINT(s)	if (debug & 2) \
d56 1
a56 1
extern	int	debug;
d59 37
a95 36
/* No, Im not insane, just the ------- cc86 io library is busted		   */
	static	char	*hex[256] = 
		{
		"00", "01", "02", "03", "04", "05", "06", "07", 
		"08", "09", "0a", "0b", "0c", "0d", "0e", "0f", 
		"10", "11", "12", "13", "14", "15", "16", "17", 
		"18", "19", "1a", "1b", "1c", "1d", "1e", "1f", 
		"20", "21", "22", "23", "24", "25", "26", "27", 
		"28", "29", "2a", "2b", "2c", "2d", "2e", "2f", 
		"30", "31", "32", "33", "34", "35", "36", "37", 
		"38", "39", "3a", "3b", "3c", "3d", "3e", "3f", 
		"40", "41", "42", "43", "44", "45", "46", "47", 
		"48", "49", "4a", "4b", "4c", "4d", "4e", "4f", 
		"50", "51", "52", "53", "54", "55", "56", "57", 
		"58", "59", "5a", "5b", "5c", "5d", "5e", "5f", 
		"60", "61", "62", "63", "64", "65", "66", "67", 
		"68", "69", "6a", "6b", "6c", "6d", "6e", "6f", 
		"70", "71", "72", "73", "74", "75", "76", "77", 
		"78", "79", "7a", "7b", "7c", "7d", "7e", "7f", 
		"80", "81", "82", "83", "84", "85", "86", "87", 
		"88", "89", "8a", "8b", "8c", "8d", "8e", "8f", 
		"90", "91", "92", "93", "94", "95", "96", "97", 
		"98", "99", "9a", "9b", "9c", "9d", "9e", "9f", 
		"a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", 
		"a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", 
		"b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", 
		"b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", 
		"c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", 
		"c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", 
		"d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", 
		"d8", "d9", "da", "db", "dc", "dd", "de", "df", 
		"e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", 
		"e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", 
		"f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", 
		"f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"
		};
d98 5
a102 5
  ecb_encrypt(clear, cipher, schedule, encrypt)
	unsigned long		*clear;	
	unsigned long		*cipher;
	int					encrypt;	/* 0 ==> decrypt, else encrypt		   */
	register Key_schedule schedule;	/* r11							   */
d105 1
a105 1
	/* better pass 8 bytes, length not checked here						   */
d107 4
a110 4
	register	unsigned long	R1, L1  ;	/*  R1 = r10, L1 = r9		   */
	register	unsigned long	R2, L2  ;	/*  R2 = r8, L2 = r7		   */
	long 	i;
	/* one more registers left on VAX, see below P_temp_p				   */
d112 4
a115 4
	static sbox_in_a		 S_in_a;
	static sbox_in_b		 S_in_b;
	static unsigned	long	*S_in_a_p = (unsigned long *) &S_in_a;
	static unsigned	long	*S_in_b_p = (unsigned long *) &S_in_b;
d118 6
a123 6
	static	sbox_in_16_a	S_in_16_a;
	static	sbox_in_16_b	S_in_16_b;
	static	sbox_in_16_c	S_in_16_c;
	static unsigned	int		*S_in_a_16_p = (unsigned int *) &S_in_16_a;
	static unsigned	int		*S_in_b_16_p = (unsigned int *) &S_in_16_b;
	static unsigned	int		*S_in_c_16_p = (unsigned int *) &S_in_16_c;
d127 1
a127 2
	fprintf(stderr,"\nDONT KNOW HOW TO DO THIS MACHINE TYPE--des.c");
	exit(-1);
d130 6
a135 6
	static sbox_out			 S_out;
	static unsigned	long	*S_out_p = (unsigned long *) &S_out;
	static unsigned long	R_save, L_save;
	static unsigned long	P_temp;
	register unsigned char	*P_temp_p = (unsigned char *) & P_temp;
	static	unsigned char	*xor_temp;
d137 19
a155 20

	/* use L1,R1 and L2,R2 as two sets of "64-bit" registers
	 * always work from L1,R1 input to L2,R2 output;
	 * init the cleartext into registers
	 */
#ifdef	MUSTALIGN				/* ibm rt								   */
	/* Make sure schedule is ok											   */
	if ((long) schedule & 3)
		{
		fprintf(stderr,"\ndes.c schedule arg pointer not aligned");
		exit(-1);
		}
	if ((long) clear & 3)
		{
		bcopy(clear++,&L_save,sizeof(L_save));
		bcopy(clear,&R_save,sizeof(R_save));
		L1 = L_save;
		R1 = R_save;
		}
	else
d157 1
a157 1
	{
d160 1
a160 1
	}
d163 9
a171 11
	if	(debug & 2)
		{
		fprintf(stdout,
		"\n\nAll values printed from low byte (bit 0) --> high byte (bit 63)");
		i = 0;
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		fprintf(stdout,
	"\n\niter = %2d  before IP\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		}		
d173 1
a173 1
	DBG_PRINT("before IP");
d175 1
a175 1
		
d178 5
a182 5
	/* all the Initial Permutation code is in the include file			   */
#include	"des_ip.c"
	/* reset input to L1,R1												   */
	L1 = L2;
	R1 = R2;
d184 3
a186 4
/* iterate through the inner loop										   */
	for ( i = 0; i <= (AUTH_DES_ITER-1); i++)
		{
	
d188 8
a195 10
	if (debug & 2)
		{
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		fprintf(stdout,
	"\n\niter = %2d  start loop\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		DBG_PRINT("start loop");
		}
	
d198 2
a199 2
		R_save = R1;
		L_save = L1;
d201 2
a202 2
E_start:
		/* apply the E permutation from R1 to L2, R2					   */
d204 1
a204 1
#include	"des_e.c"
d206 9
a214 9
/* E operations */
/* right to left */
	 asm("	rotl	$1,r10,r7");
	 L2 &= 077;
	 L2 |= (R1 <<3) & 07700;
	 L2 |= (R1 <<5) & 0770000;
	 L2 |= (R1 <<7) & 077000000;
	 L2 |= (R1 <<9) & 07700000000;
	 L2 |= (R1 <<11) & 030000000000;
d216 8
a223 8
	 asm("	rotl	$-17,r10,r8");
	 R2 &= 0176000;
	 asm("	rotl	$-21,r10,r0");
	 asm("	bicl2	$-16,r0");
	 asm("  bisl2	r0,r8");
	 asm("	rotl	$-19,r10,r0");
	 asm("	bicl2	$-1009,r0");
	 asm("  bisl2	r0,r8");
d227 3
a229 3
		/* reset input to L1,R1											   */
		L1 = L2;
		R1 = R2;
d232 8
a239 10
	if (debug & 2)
		{
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		DBG_PRINT("after e");
		fprintf(stdout,
	"\n\niter = %2d  after e\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		}
	
d242 19
a260 23
XOR_start:
		/* XOR with the key schedule, "schedule"
		 *
		 * if this is an encryption operation, use schedule[i],
		 * else use schedule [AUTH_DES_ITER-i-1]
		 *
		 * first XOR left half
		 */
		if (encrypt)
			{
			L1 ^= *(((unsigned long *) &schedule[i] )+0);
			/* now right half*/ 
			R1 ^= *(((unsigned long *) &schedule[i] )+1);
			}
		else
			{
			L1 ^= *(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] )+0);
			/* now right half*/ 
			R1 ^= *(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] )+1);
			}
		
			/* dont have to reset input to L1, R1						   */
		 
d262 3
d266 8
a273 10
		if (debug & 2)
			{
			dbg_tmp[0] = L1;
			dbg_tmp[1] = R1;
			DBG_PRINT("after xor");
			fprintf(stdout,
	"\n\niter = %2d  after xor\n\t\tL1 R1 =",i);
			C_Block_print(dbg_tmp);
			}
			
d276 3
a278 2
S_start:
		/* apply the S selection from L1, R1 to R2						   */
d280 1
a280 1
#include	"des_s.c"
d283 2
a284 2
/* S operations , cant use registers for bit field stuff*/
/* from S_in to S_out */
d287 16
a302 16
		*S_in_a_16_p = L1&0xffff;
		*S_in_b_16_p = (L1>>16)&0xffff;
		*S_in_c_16_p = R1&0xffff;
		(*(unsigned long *) &S_out) = (unsigned) S_adj[0][S_in_16_a.b0];
		S_out.b1 = (unsigned) S_adj[1][S_in_16_a.b1];
		/* b2 spans two words											   */
		S_out.b2 = (unsigned) 
  		 S_adj[2][(unsigned) S_in_16_a.b2 + (((unsigned) S_in_16_b.b2) << 4)];
		S_out.b3 = (unsigned) S_adj[3][S_in_16_b.b3];
		S_out.b4 = (unsigned) S_adj[4][S_in_16_b.b4];
		/* b5 spans both parts											   */
		S_out.b5 = (unsigned) 
		 S_adj[5][(unsigned) S_in_16_b.b5 + (((unsigned) S_in_16_c.b5) << 2)];
		S_out.b6 = (unsigned) S_adj[6][S_in_16_c.b6];
		S_out.b7 = (unsigned) S_adj[7][S_in_16_c.b7];
		R1 = *S_out_p;
d304 24
a327 23
	/* is a 32 bit sys													   */
#ifndef	VAXASM
		R2 =  (unsigned) S_adj[0][L1 & 077];
		L2 = (unsigned) S_adj[1][(L1 >> 6) & 077];
		R2 |= (L2 <<4 );
		L2 = (unsigned) S_adj[2][(L1 >> 12) & 077];
		R2 |= (L2 <<8);
		L2 = (unsigned) S_adj[3][(L1 >> 18) & 077];
		R2 |= (L2 <<12);
		L2 = (unsigned) S_adj[4][(L1 >> 24) & 077];
		R2 |= (L2 <<16);
		/* b5 spans both parts											   */
		L2 = (unsigned) 
			S_adj[5][(unsigned) ((L1 >>30) & 03) + ((R1 & 017) << 2)];
		R2 |= (L2 << 20);
		L2 = (unsigned) S_adj[6][(R1 >> 4) & 077];
		R2 |= (L2 <<24);
		L2 = (unsigned) S_adj[7][(R1 >> 10) & 077];
		R1 = R2 | (L2 <<28);
		/* reset input to L1, R1										   */
#else							/* vaxasm								   */
	/*  this is the c code produced above, with
     *  extzv replaced by rotl
d371 1
a371 1
#endif							/* vaxasm	   */
d376 8
a383 10
	if (debug & 2)
		{
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		DBG_PRINT("after s");
		fprintf(stdout,
	"\n\niter = %2d  after s\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		}
		
d386 5
a390 5
P_start:
		/* and then the p permutation from R1 into R2					   */
#include	"des_p.c"		
		/* reset the input to L1, R1									   */
		R1 = R2;
d394 8
a401 10
		if (debug & 2)
			{
			dbg_tmp[0] = L1;
			dbg_tmp[1] = R1;
			DBG_PRINT("after p");
			fprintf(stdout,
	"\n\niter = %2d  after p\n\t\tL1 R1 = ",i);
			C_Block_print(dbg_tmp);
			}
			
d404 2
a405 2
		/* R1 is the output value from the f()							   */
		/* move R[iter] to L[iter+1]									   */
d407 5
a411 6
		L1 = R_save;
		/* xor with left												   */
		R1 = L_save ^ R1 ;
		/* reset the input												   */
		}
		
d413 6
a418 7
	/* flip left and right before final permutation			   */
	L2 = R1;	/* flip						   */
	R2 = L1;
	/* reset the input*/ 
	L1 = L2;
	R1 = R2;
	
d421 8
a428 10
	if (debug & 2)
		{
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		DBG_PRINT("before FP");
		fprintf(stdout,
	"\n\niter = %2d  before FP\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		}
		
d432 3
a434 3
/* do the final permutation from L1R1 to L2R2							   */
/* all the fp code is in the include file								   */
#include	"des_fp.c"
d436 8
a443 9
/* copy the output to the ciphertext string; can be same as cleartext	   */
#ifdef	MUSTALIGN				/* ibm rt								   */
	if ((long) cipher & 3)
		{
		L_save = L2;				/* cant bcopy a reg					   */
		R_save = R2;
		bcopy(&L_save,cipher++,sizeof(L_save));
		bcopy(&R_save,cipher,sizeof(R_save));
		}
d447 2
a448 2
	*cipher++ = L2;
	*cipher = R2;
d452 9
a460 11
	if (debug & 2)
		{
		L1 = L2;
		R1 = R2;
		dbg_tmp[0] = L1;
		dbg_tmp[1] = R1;
		DBG_PRINT("done");
		fprintf(stdout,
	"\n\niter = %2d  done\n\t\tL1 R1 = ",i);
		C_Block_print(dbg_tmp);
		}
d463 2
a464 2
/* that's it, no errors can be returned									   */
return 0;
d467 5
a471 4
debug_print(string,i,ll,lh,rl,rh)
	char		*string;
	unsigned 	i;
	unsigned  ll,lh,rl,rh;
d473 14
a486 10
#ifdef	notdef
	fprintf(stdout,"\n\niter = %2d  ",i);
	fprintf(stdout,string);
	fprintf(stdout,
	"\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",
		hex[ll & 0xff], hex[(ll >> 8) & 0xff], hex[lh & 0xff],
		hex[(lh >> 8) & 0xff],
		hex[rl & 0xff], hex[(rl >> 8) & 0xff], hex[(rh) & 0xff],
		hex[(rh >> 8) & 0xff]);

d489 1
@


4.2
log
@Changed include files configuration and referencing.
@
text
@d7 1
a7 1
 *	$Source: /mit/s/t/steiner/kerberos/lib/des/bsd/RCS/des.c,v $
a9 37
 *	$Log:	des.c,v $
 * Revision 4.1  87/09/01  15:40:19  steiner
 * No change; starting version 4.
 * 
 * Revision 1.13  87/01/13  16:33:38  wesommer
 * Added include of des_conf.h
 * 
 * Revision 1.12  87/01/09  15:44:20  wesommer
 * Some later change appears to have gotten in..
 * 
 * Revision 1.11  86/08/14  23:10:23  spm
 * add alignment fix for RT
 * 
 * Revision 1.10  86/08/08  14:09:38  spm
 * cleanup debug printing
 * 
 * Revision 1.8  85/12/16  13:44:54  spm
 * *** empty log message ***
 * 
 * Revision 1.7  85/08/19  16:52:50  spm
 * *** empty log message ***
 * 
 * Revision 1.6  85/08/19  15:25:05  spm
 * fix print
 * 
 * Revision 1.5  85/08/16  17:41:53  spm
 * fix sbox for pc8086
 * 
 * Revision 1.4  85/08/16  12:48:16  spm
 * ok v1
 * 
 * Revision 1.3  85/08/14  10:22:10  spm
 * works; more debug stuff
 * 
 * Revision 1.1  85/08/11  14:15:13  spm
 * Initial revision
 * 
a32 1
#include "des_conf.h"
@


4.1
log
@No change; starting version 4.
@
text
@d8 1
a8 1
 *	$Author: wesommer $
d11 3
d70 1
a70 1
#include "./des_conf.h"
d72 2
a73 2
# include	"./des.h"
# include	"./des_s_table.h"
d75 1
a75 1
# include	"./des_p_table.h"
d212 1
a212 1
#include	"./des_ip.c"
d240 1
a240 1
#include	"./des_e.c"
d320 1
a320 1
#include	"./des_s.c"
d429 1
a429 1
#include	"./des_p.c"		
d481 1
a481 1
#include	"./des_fp.c"
@


1.13
log
@Added include of des_conf.h
@
text
@d7 1
a7 1
 *	$Source: /altsource/kerberos/lib/des/vax/RCS/des.c,v $
d9 1
a9 1
 *	$Locker: wesommer $
d11 3
@


1.12
log
@Some later change appears to have gotten in..
@
text
@d7 3
a9 3
 *	$Source: /mit/projects/auth/src/lib/des/vax/RCS/des.c,v $
 *	$Author: spm $
 *	$Locker: spm $
d11 3
d64 1
@


1.11
log
@add alignment fix for RT
@
text
@d9 1
a9 1
 *	$Locker:  $
d11 3
d128 2
a129 2
	register	i;
	/* no more registers left											   */
d154 1
a154 1
	static unsigned char	*P_temp_p = (unsigned char *) & P_temp;
@


1.10
log
@cleanup debug printing
@
text
@d11 3
d159 17
d178 1
d471 11
d484 1
@


1.9
log
@*** empty log message ***
@
text
@d63 1
d71 2
d165 2
a166 1
		
d168 2
a169 5
	"\n\niter = %2d  before IP\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);
d190 2
d193 2
a194 6
	"\n\niter = %2d  start loop\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
			hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
			hex[(L1 >> 24) & 0xff],
			hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
			hex[(R1 >> 24) & 0xff]);

d236 2
d240 2
a241 5
	"\n\niter = %2d  after e\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
			hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
			hex[(L1 >> 24) & 0xff],
			hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
			hex[(R1 >> 24) & 0xff]);
d273 2
d277 2
a278 5
	"\n\niter = %2d  after xor\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
				hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
				hex[(L1 >> 24) & 0xff],
				hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
				hex[(R1 >> 24) & 0xff]);
d383 2
d387 2
a388 5
	"\n\niter = %2d  after s\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
			hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
			hex[(L1 >> 24) & 0xff],
			hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
			hex[(R1 >> 24) & 0xff]);
d403 2
d407 2
a408 5
	"\n\niter = %2d  after p\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
				hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
				hex[(L1 >> 24) & 0xff],
				hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
				hex[(R1 >> 24) & 0xff]);
d423 2
a424 2
	/* flip left and right before final permutation						   */
	L2 = R1;					/* flip									   */
d434 2
d438 2
a439 5
	"\n\niter = %2d  before FP\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
			hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
			hex[(L1 >> 24) & 0xff],
			hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
			hex[(R1 >> 24) & 0xff]);
d458 2
d462 2
a463 5
	"\n\niter = %2d  done\n\t\tL1 = %s %s %s %s  R1 = %s %s %s %s",i,
			hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
			hex[(L1 >> 24) & 0xff],
			hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
			hex[(R1 >> 24) & 0xff]);
@


1.8
log
@*** empty log message ***
@
text
@d7 1
a7 1
 *	$Source: /mit/projects/auth/src/deslib/vax/RCS/des.c,v $
d9 1
a9 1
 *	$Locker: spm $
d11 3
d63 1
a63 1
#define	DBG_PRINT(s)	if (debug) \
d121 1
a121 1
#ifdef	VAX
d127 1
a127 1
#ifdef	PC8086
d135 2
a136 2
#ifndef	VAX
#ifndef	PC8086
d157 1
a157 1
	if	(debug)
d187 1
a187 1
	if (debug)
d206 1
a206 1
#ifndef	VAX
a210 1
#ifdef	VAXASM
a211 7
#else
	 L2 = (R1 << 1);
	 if (R1 & 0x80000000)
		 {
		 L2 |= 1;
		 }
#endif
a218 1
#ifdef	VAXASM
a226 10
#else
	 R2 = R1 >> 17;
	 if (R1 & 0x1)
		 {
		 R2 |= 0x8000;
		 }
	 R2 &= 0176000;
	 R2 |= (R1 >>21) & 017;
	 R2 |= (R1 >>19) & 01760;
#endif
d235 1
a235 1
	if (debug)
d273 1
a273 1
		if (debug)
d295 1
a295 1
#ifndef	VAX
d313 1
a313 1
	/* is a vax															   */
d384 1
a384 1
	if (debug)
d405 1
a405 1
		if (debug)
d437 1
a437 1
	if (debug)
d460 1
a460 1
	if (debug)
@


1.7
log
@*** empty log message ***
@
text
@d7 1
a7 1
 *	$Source: /usr/mit/spm/auth/deslib/RCS/des.c,v $
d11 3
d53 2
a54 2
# include	"des.h"
# include	"des_s_table.h"
d56 1
a56 1
# include	"des_p_table.h"
d174 1
a174 1
#include	"des_ip.c"
d204 1
a204 1
#include	"des_e.c"
d305 1
a305 1
#include	"des_s.c"
d415 1
a415 1
#include	"des_p.c"		
d469 1
a469 1
#include	"des_fp.c"
@


1.6
log
@fix print
@
text
@d11 3
d120 1
a120 1
#else
d129 2
d133 1
@


1.5
log
@fix sbox for pc8086
@
text
@d11 3
d117 1
a117 1
#endif
d126 3
a135 1
	fprintf(stdout,"\nclear = %s",clear);
d137 4
a140 2
	/* always work from L1,R1 input to L2,R2 output						   */
	/* init the cleartext into registers								   */
a149 1
		}		
d151 1
a151 1
	fprintf(stdout,
d157 1
d159 1
a160 1
	DBG_PRINT("before IP");
d175 3
a177 1
	fprintf(stdout,
d179 4
a182 4
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);
d184 3
a187 1
		DBG_PRINT("start loop");
d241 3
d245 1
a245 2
#ifdef	DEBUG
	fprintf(stdout,
d247 6
a252 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

a277 1
		DBG_PRINT("after xor");
d280 4
a283 1
	fprintf(stdout,
d285 6
a290 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

a388 1
	DBG_PRINT("after s");
d391 4
a394 1
	fprintf(stdout,
d396 6
a401 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

a409 1
		DBG_PRINT("after p");
d412 4
a415 1
	fprintf(stdout,
d417 6
a422 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

a441 1
	DBG_PRINT("before FP");
d444 4
a447 1
	fprintf(stdout,
d449 6
a454 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

d467 6
a472 7
	L1 = L2;
	R1 = R2;
#endif
	DBG_PRINT("done");

#ifdef	DEBUG
	fprintf(stdout,
d474 5
a478 5
		hex[L1 & 0xff], hex[(L1 >> 8) & 0xff], hex[(L1>>16) & 0xff],
		hex[(L1 >> 24) & 0xff],
		hex[R1 & 0xff], hex[(R1 >> 8) & 0xff], hex[(R1>>16) & 0xff],
		hex[(R1 >> 24) & 0xff]);

@


1.4
log
@ok v1
@
text
@d7 1
a7 1
 *	$Source: /usr/mit/spm/auth/test/RCS/des.c,v $
d11 3
d51 2
a52 1
#define	DBG_PRINT(s)	if (debug) debug_print(s,i,L1,R1)
d58 36
a94 1

d109 1
a111 1
	static sbox_out			 S_out;
d114 10
d130 2
d144 8
a152 1
		
d167 9
d231 7
d239 2
d266 10
d286 10
a295 7
		*S_in_a_p = L1;
		*S_in_b_p = R1;
		(*(unsigned long *) &S_out) = (unsigned) S_adj[0][S_in_a.b0];
		S_out.b1 = (unsigned) S_adj[1][S_in_a.b1];
		S_out.b2 = (unsigned) S_adj[2][S_in_a.b2];
		S_out.b3 = (unsigned) S_adj[3][S_in_a.b3];
		S_out.b4 = (unsigned) S_adj[4][S_in_a.b4];
d298 3
a300 3
				S_adj[5][(unsigned) S_in_a.b5 + (((unsigned) S_in_b.b5) << 2)];
		S_out.b6 = (unsigned) S_adj[6][S_in_b.b6];
		S_out.b7 = (unsigned) S_adj[7][S_in_b.b7];
d374 10
d392 10
d421 10
d446 10
d460 1
a460 1
debug_print(string,i,lt,rt)
d462 2
a463 2
	unsigned 	long	i;
	unsigned	long lt,rt;
d465 1
d469 5
a473 3
	"\n\t\tL1 = %02x %02x %02x %02x  R1 = %02X %02X %02x %02x",
		lt & 0xff, (lt >> 8) & 0xff, (lt>>16) & 0xff, (lt >> 24) & 0xff,
		rt & 0xff, (rt >> 8) & 0xff, (rt>>16) & 0xff, (rt >> 24) & 0xff);
d475 1
@


1.3
log
@works; more debug stuff
@
text
@d11 3
d41 1
a41 3
# include	<signal.h>
# include	<errno.h>
# include	"ks.h"
d46 11
a56 1
long
d60 1
a60 1
	long				encrypt;	/* 0 ==> decrypt, else encrypt		   */
d79 1
a80 1

d89 3
a91 1
		fprintf(stdout,"\n\n before IP \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d94 3
a96 1

d108 3
a110 6
#ifdef	DEBUG
		if	(debug)
			{
			fprintf(stdout,"\n\n start iter %d  \n\t\tL1 = %08X  R1 = %08X",i,L1,R1);
			}		
#endif
d163 1
a163 6
#ifdef	DEBUG
	if	(debug)
		{
		fprintf(stdout,"\n after e \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
		}		
#endif	
a174 5
#ifdef	DEBUG
			if (debug) fprintf(stdout,"\n addr sched = %08X %08X",
			(((unsigned long *) &schedule[i] ) + 0),
			(((unsigned long *) &schedule[i] ) + 1));
#endif
a180 5
#ifdef	DEBUG
			if (debug) fprintf(stdout,"\n addr sched = %08X %08X",
			(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] ) + 0),
			(((unsigned long *) &schedule[AUTH_DES_ITER-i-1] ) + 1));
#endif
d188 1
a188 6
#ifdef	DEBUG
	if	(debug)
		{
		fprintf(stdout,"\n after xor \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
		}		
#endif
a197 3
#ifdef	notdef
		L2 = 0; R2 = 0;
#endif
d283 1
a283 6
#ifdef	DEBUG
	if	(debug)
		{
		fprintf(stdout,"\n after s\n\t\tL1 = %08X  R1 = %08X",L1,R1);	
		}		
#endif
d291 2
a292 6
#ifdef	DEBUG
	if	(debug)
		{
		fprintf(stdout,"\nafter p\n\t\tL1 = %08X  R1 = %08X",L1,R1);	
		}		
#endif
d310 1
a310 6
#ifdef	DEBUG
	if	(debug)
		{
		fprintf(stdout,"\n before FP \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
		}		
#endif
d322 2
a323 4
	if	(debug)
		{
		fprintf(stdout,"\n done  \n\t\tL2 = %08X  R2 = %08X",L2,R2);	
		}		
d325 2
d328 14
@


1.2
log
@works, faster
@
text
@a36 1

d40 1
d42 4
a45 7

/* note -- more includes embedded below									   */
# include	"ks.h"

extern	long	debug;

void
d66 2
d78 1
a78 1
		fprintf(stderr,"\n\n before IP \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d96 1
a96 1
			fprintf(stderr,"\n\n start iter %d  \n\t\tL1 = %08X  R1 = %08X",i,L1,R1);
d154 1
a154 1
		fprintf(stderr,"\n after e \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d168 5
d179 5
d194 1
a194 1
		fprintf(stderr,"\n after xor \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d246 3
d297 1
a297 1
		fprintf(stderr,"\n after s\n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d310 1
a310 1
		fprintf(stderr,"\nafter p\n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d333 1
a333 1
		fprintf(stderr,"\n before FP \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d349 1
a349 1
		fprintf(stderr,"\n done  \n\t\tL2 = %08X  R2 = %08X",L2,R2);	
@


1.1
log
@Initial revision
@
text
@d1 3
a3 3
/* des.c																   */

/*	spm	8/85	MIT project athena
d7 7
a13 4
 *	$Source: $
 *	$Author: $
 *	$Locker:  $
 *	$Log:	 $
d20 1
a20 1
 *  without licence from the U.S. Commerce department.
d33 2
a34 2
 *	Always work FROM L1,R1 TO L2,R2 to make bookeeping easier. Optimize
 *  later if needed.
d53 1
a53 1
	register	Key_schedule schedule;	/* r11							   */
d59 1
a59 1
	register	unsigned long	R2, L2  ;	/*  R1 = r8, L1 = r7		   */
d76 1
d81 1
d83 2
d94 1
d99 1
a99 1

d102 2
d105 1
d107 41
d152 1
d157 1
a157 1
	
d159 1
d163 1
a163 1
		 * else use schedule [15-i]
d182 1
d187 1
d189 1
d197 1
d199 3
d204 1
a204 1
		S_out.b0 = (unsigned) S_adj[0][S_in_a.b0];
d214 21
a234 2
		R2 = *S_out_p;

d236 42
a277 2
		L1 = L2;
		R1 = R2;
d279 4
d285 1
a285 1
		fprintf(stderr,"\n after s IP \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d287 1
d289 1
a289 1

a292 1
		L1 = L2;
d295 1
d298 1
a298 1
		fprintf(stderr,"\n after p \n\t\tL1 = %08X  R1 = %08X",L1,R1);	
d300 1
d303 2
a304 1
		L2 = R_save;
d306 1
a306 1
		R2 = L_save ^ R1 ;
a307 2
		L1 = L2;
		R1 = R2;
d318 1
d323 1
d325 1
d331 2
a332 2
	*cipher = L2;
	*++cipher = R2;
d334 1
d339 1
a339 1

@
