head     4.22;
branch   ;
access   ;
symbols  PATCH8:4.19 PATCH7:4.19 KPATCH6:4.18 ASRSNAP1001:4.18 PATCH5:4.18 KPATCH4:4.17 KPATCH3:4.17 KPATCH2:4.17 KREL1:4.15 BETA5/24/88:4.11;
locks    ; strict;
comment  @ * @;


4.22
date     93.05.16.00.27.07;  author torek;  state Exp;
branches ;
next     4.21;

4.21
date     91.02.25.15.40.32;  author bostic;  state Exp;
branches ;
next     4.20;

4.20
date     90.06.25.20.59.31;  author kfall;  state Exp;
branches ;
next     4.19;

4.19
date     89.11.01.17.18.07;  author qjb;  state Exp;
branches ;
next     4.18;

4.18
date     89.07.25.17.15.25;  author qjb;  state Exp;
branches ;
next     4.17;

4.17
date     89.03.20.16.54.35;  author srz;  state Exp;
branches ;
next     4.16;

4.16
date     89.03.14.19.54.36;  author jon;  state Exp;
branches ;
next     4.15;

4.15
date     89.01.24.20.45.13;  author root;  state Exp;
branches ;
next     4.14;

4.14
date     89.01.24.20.40.14;  author root;  state Exp;
branches ;
next     4.13;

4.13
date     89.01.24.18.15.40;  author jon;  state Exp;
branches ;
next     4.12;

4.12
date     88.12.09.16.20.51;  author steiner;  state Exp;
branches ;
next     4.11;

4.11
date     88.03.24.18.20.34;  author steiner;  state Exp;
branches ;
next     4.10;

4.10
date     88.02.24.18.34.14;  author steiner;  state Exp;
branches ;
next     4.9;

4.9
date     88.01.14.14.03.43;  author steiner;  state Exp;
branches ;
next     4.8;

4.8
date     87.12.07.18.13.39;  author steiner;  state Exp;
branches ;
next     4.7;

4.7
date     87.12.07.18.11.35;  author steiner;  state Exp;
branches ;
next     4.6;

4.6
date     87.12.07.11.22.46;  author steiner;  state Exp;
branches ;
next     4.5;

4.5
date     87.11.04.12.27.20;  author steiner;  state Exp;
branches ;
next     4.4;

4.4
date     87.09.28.15.21.50;  author steiner;  state Exp;
branches ;
next     4.3;

4.3
date     87.09.14.16.46.08;  author steiner;  state Exp;
branches ;
next     4.2;

4.2
date     87.09.10.16.12.16;  author steiner;  state Exp;
branches ;
next     4.1;

4.1
date     87.09.01.14.16.47;  author steiner;  state Exp;
branches ;
next     3.7;

3.7
date     87.07.02.17.58.01;  author kubitron;  state Exp;
branches ;
next     3.6;

3.6
date     87.01.08.20.18.10;  author wesommer;  state Exp;
branches ;
next     3.5;

3.5
date     86.09.16.14.07.40;  author jis;  state Exp;
branches ;
next     3.4;

3.4
date     86.09.05.16.18.55;  author bcn;  state Exp;
branches ;
next     3.3;

3.3
date     86.08.24.13.19.52;  author spm;  state Exp;
branches ;
next     3.2;

3.2
date     86.08.22.15.14.12;  author bcn;  state Exp;
branches ;
next     3.1;

3.1
date     86.08.19.09.54.43;  author bcn;  state Exp;
branches ;
next     1.22;

1.22
date     86.08.11.10.34.04;  author bcn;  state Exp;
branches ;
next     1.21;

1.21
date     86.05.12.21.21.05;  author spm;  state Exp;
branches ;
next     1.20;

1.20
date     86.03.14.17.43.29;  author bcn;  state Exp;
branches ;
next     1.19;

1.19
date     86.03.14.15.29.32;  author spm;  state Exp;
branches ;
next     1.18;

1.18
date     86.03.14.14.37.13;  author spm;  state Exp;
branches ;
next     1.17;

1.17
date     86.01.07.12.29.07;  author spm;  state Exp;
branches ;
next     1.16;

1.16
date     85.11.26.11.38.43;  author spm;  state Exp;
branches ;
next     1.15;

1.15
date     85.11.24.14.04.44;  author bcn;  state Exp;
branches ;
next     1.14;

1.14
date     85.11.17.19.25.26;  author bcn;  state Exp;
branches ;
next     1.13;

1.13
date     85.11.15.16.38.50;  author spm;  state Exp;
branches ;
next     1.12;

1.12
date     85.11.15.13.56.52;  author bcn;  state Exp;
branches ;
next     1.11;

1.11
date     85.11.14.17.52.47;  author spm;  state Exp;
branches ;
next     1.10;

1.10
date     85.11.14.15.44.15;  author spm;  state Exp;
branches ;
next     1.9;

1.9
date     85.11.13.14.47.54;  author bcn;  state Exp;
branches ;
next     1.8;

1.8
date     85.11.13.10.58.09;  author bcn;  state Exp;
branches ;
next     1.7;

1.7
date     85.11.05.17.04.28;  author spm;  state Exp;
branches ;
next     1.6;

1.6
date     85.10.23.17.12.17;  author spm;  state Exp;
branches ;
next     1.5;

1.5
date     85.10.22.17.15.01;  author spm;  state Exp;
branches ;
next     1.4;

1.4
date     85.10.21.18.31.40;  author spm;  state Exp;
branches ;
next     1.3;

1.3
date     85.10.18.16.52.55;  author spm;  state Exp;
branches ;
next     1.2;

1.2
date     85.10.16.11.55.12;  author spm;  state Exp;
branches ;
next     1.1;

1.1
date     85.10.10.11.01.11;  author bcn;  state Exp;
branches ;
next     ;


desc
@Initial RCS checkin
@


4.22
log
@rm unused incorrect redeclaration of sys_errlist; ANSI lint
@
text
@/*
 * $Source: /usr/src/kerberosIV/kerberos/RCS/kerberos.c,v $
 * $Author: bostic $
 *
 * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute
 * of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#ifndef lint
static char *rcsid_kerberos_c =
"$Header: /usr/src/kerberosIV/kerberos/RCS/kerberos.c,v 4.21 91/02/25 15:40:32 bostic Exp Locker: torek $";
#endif  lint

#include <mit-copyright.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <signal.h>
#include <sgtty.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/file.h>
#include <ctype.h>
#include <string.h>

#include <des.h>
#include <krb.h>
#include <klog.h>
#include <prot.h>
#include <krb_db.h>
#include <kdc.h>

extern int errno;

int     f;

/* XXX several files in libkdb know about this */
char *progname;

static Key_schedule master_key_schedule;
static C_Block master_key;

static struct timeval kerb_time;
static Principal a_name_data;	/* for requesting user */
static Principal s_name_data;	/* for services requested */
static C_Block session_key;
static C_Block user_key;
static C_Block service_key;
static u_char master_key_version;
static char k_instance[INST_SZ];
static char log_text[128];
static char *lt;
static int more;

static int mflag;		/* Are we invoked manually? */
static int lflag;		/* Have we set an alterate log file? */
static char *log_file;		/* name of alt. log file */
static int nflag;		/* don't check max age */
static int rflag;		/* alternate realm specified */

/* fields within the received request packet */
static u_char req_msg_type;
static u_char req_version;
static char *req_name_ptr;
static char *req_inst_ptr;
static char *req_realm_ptr;
static u_char req_no_req;
static u_long req_time_ws;

int req_act_vno = KRB_PROT_VERSION; /* Temporary for version skew */

static char local_realm[REALM_SZ];

/* statistics */
static long q_bytes;		/* current bytes remaining in queue */
static long q_n;		/* how many consecutive non-zero
				 * q_bytes   */
static long max_q_bytes;
static long max_q_n;
static long n_auth_req;
static long n_appl_req;
static long n_packets;
static long n_user;
static long n_server;

static long max_age = -1;
static long pause_int = -1;

static void check_db_age();
static void hang();

/*
 * Print usage message and exit.
 */
static void usage()
{
    fprintf(stderr, "Usage: %s [-s] [-m] [-n] [-p pause_seconds]%s%s\n", progname, 
	    " [-a max_age] [-l log_file] [-r realm]"
	    ," [database_pathname]"
	    );
    exit(1);
}


main(argc, argv)
    int     argc;
    char  **argv;
{
    struct sockaddr_in from;
    register int n;
    int     on = 1;
    int     child;
    struct servent *sp;
    int     fromlen;
    static KTEXT_ST pkt_st;
    KTEXT   pkt = &pkt_st;
    Principal *p;
    int     more, kerror;
    C_Block key;
    int c;
    struct sockaddr_in sin;
    extern char *optarg;
    extern int optind;

    progname = argv[0];

    while ((c = getopt(argc, argv, "snmp:a:l:r:")) != EOF) {
	switch(c) {
	case 's':
	    /*
	     * Set parameters to slave server defaults.
	     */
	    if (max_age == -1 && !nflag)
		max_age = ONE_DAY;	/* 24 hours */
	    if (pause_int == -1)
		pause_int = FIVE_MINUTES; /* 5 minutes */
	    if (lflag == 0) {
		log_file = KRBSLAVELOG;
		lflag++;
	    }
	    break;
	case 'n':
	    max_age = -1;	/* don't check max age. */
	    nflag++;
	    break;
	case 'm':
	    mflag++;		/* running manually; prompt for master key */
	    break;
	case 'p':
	    /* Set pause interval. */
	    if (!isdigit(optarg[0]))
		usage();
	    pause_int = atoi(optarg);
	    if ((pause_int < 5) ||  (pause_int > ONE_HOUR)) {
		fprintf(stderr, "pause_int must be between 5 and 3600 seconds.\n");
		usage();
	    }
	    break;
	case 'a':
	    /* Set max age. */
	    if (!isdigit(optarg[0])) 
		usage();
	    max_age = atoi(optarg);
	    if ((max_age < ONE_HOUR) || (max_age > THREE_DAYS)) {
		fprintf(stderr, "max_age must be between one hour and three days, in seconds\n");
		usage();
	    }
	    break;
	case 'l':
	    /* Set alternate log file */
	    lflag++;
	    log_file = optarg;
	    break;
	case 'r':
	    /* Set realm name */
	    rflag++;
	    strcpy(local_realm, optarg);
	    break;
	default:
	    usage();
	    break;
	}
    }

    if (optind == (argc-1)) {
	if (kerb_db_set_name(argv[optind]) != 0) {
	    fprintf(stderr, "Could not set alternate database name\n");
	    exit(1);
	}
	optind++;
    }

    if (optind != argc)
	usage();
	
    printf("Kerberos server starting\n");
    
    if ((!nflag) && (max_age != -1))
	printf("\tMaximum database age: %d seconds\n", max_age);
    if (pause_int != -1)
	printf("\tSleep for %d seconds on error\n", pause_int);
    else
	printf("\tSleep forever on error\n");
    if (mflag)
	printf("\tMaster key will be entered manually\n");
    
    printf("\tLog file is %s\n", lflag ? log_file : KRBLOG);

    if (lflag)
	kset_logfile(log_file);
    
    /* find our hostname, and use it as the instance */
    if (gethostname(k_instance, INST_SZ)) {
	fprintf(stderr, "%s: gethostname error\n", progname);
	exit(1);
    }

    if ((sp = getservbyname("kerberos", "udp")) == 0) {
	fprintf(stderr, "%s: udp/kerberos unknown service\n", progname);
	exit(1);
    }
    bzero(&sin, sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_port = sp->s_port;

    if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
	fprintf(stderr, "%s: Can't open socket\n", progname);
	exit(1);
    }
    if (setsockopt(f, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on)) < 0)
	fprintf(stderr, "%s: setsockopt (SO_REUSEADDR)\n", progname);

    if (bind(f, (struct sockaddr *)&sin, S_AD_SZ) < 0) {
	fprintf(stderr, "%s: Can't bind socket\n", progname);
	exit(1);
    }
    /* do all the database and cache inits */
    if (n = kerb_init()) {
	if (mflag) {
	    printf("Kerberos db and cache init ");
	    printf("failed = %d ...exiting\n", n);
	    exit(-1);
	} else {
	    klog(L_KRB_PERR,
	    "Kerberos db and cache init failed = %d ...exiting", n);
	    hang();
	}
    }

    /* Make sure database isn't stale */
    check_db_age();
    
    /* setup master key */
    if (kdb_get_master_key (mflag, master_key, master_key_schedule) != 0) {
      klog (L_KRB_PERR, "kerberos: couldn't get master key.\n");
      exit (-1);
    }
    kerror = kdb_verify_master_key (master_key, master_key_schedule, stdout);
    if (kerror < 0) {
      klog (L_KRB_PERR, "Can't verify master key.");
      bzero (master_key, sizeof (master_key));
      bzero (master_key_schedule, sizeof (master_key_schedule));
      exit (-1);
    }

    master_key_version = (u_char) kerror;

    fprintf(stdout, "\nCurrent Kerberos master key version is %d\n",
	    master_key_version);

    if (!rflag) {
	/* Look up our local realm */
	krb_get_lrealm(local_realm, 1);
    }
    fprintf(stdout, "Local realm: %s\n", local_realm);
    fflush(stdout);

    if (set_tgtkey(local_realm)) {
	/* Ticket granting service unknown */
	klog(L_KRB_PERR, "Ticket granting ticket service unknown");
	fprintf(stderr, "Ticket granting ticket service unknown\n");
	exit(1);
    }
    if (mflag) {
	if ((child = fork()) != 0) {
	    printf("Kerberos started, PID=%d\n", child);
	    exit(0);
	}
	setup_disc();
    }
    /* receive loop */
    for (;;) {
	fromlen = S_AD_SZ;
	n = recvfrom(f, pkt->dat, MAX_PKT_LEN, 0,
	    (struct sockaddr *)&from, &fromlen);
	if (n > 0) {
	    pkt->length = n;
	    pkt->mbz = 0; /* force zeros to catch runaway strings */
	    /* see what is left in the input queue */
	    ioctl(f, FIONREAD, &q_bytes);
	    gettimeofday(&kerb_time, NULL);
	    q_n++;
	    max_q_n = max(max_q_n, q_n);
	    n_packets++;
	    klog(L_NET_INFO,
	 "q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d",
		 q_bytes, q_n, n, max_q_bytes, max_q_n, n_packets, 0);
	    max_q_bytes = max(max_q_bytes, q_bytes);
	    if (!q_bytes)
		q_n = 0;	/* reset consecutive packets */
	    kerberos(&from, pkt);
	} else
	    klog(L_NET_ERR,
	    "%s: bad recvfrom n = %d errno = %d", progname, n, errno, 0);
    }
}


kerberos(client, pkt)
    struct sockaddr_in *client;
    KTEXT   pkt;
{
    static KTEXT_ST rpkt_st;
    KTEXT   rpkt = &rpkt_st;
    static KTEXT_ST ciph_st;
    KTEXT   ciph = &ciph_st;
    static KTEXT_ST tk_st;
    KTEXT   tk = &tk_st;
    static KTEXT_ST auth_st;
    KTEXT   auth = &auth_st;
    AUTH_DAT ad_st;
    AUTH_DAT *ad = &ad_st;


    static struct in_addr client_host;
    static int msg_byte_order;
    static int swap_bytes;
    static u_char k_flags;
    char   *p_name, *instance;
    u_long  lifetime;
    int     i;
    C_Block key;
    Key_schedule key_s;
    char   *ptr;



    ciph->length = 0;

    client_host = client->sin_addr;

    /* eval macros and correct the byte order and alignment as needed */
    req_version = pkt_version(pkt);	/* 1 byte, version */
    req_msg_type = pkt_msg_type(pkt);	/* 1 byte, Kerberos msg type */

    req_act_vno = req_version;

    /* check packet version */
    if (req_version != KRB_PROT_VERSION) {
	lt = klog(L_KRB_PERR,
	"KRB prot version mismatch: KRB =%d request = %d",
		  KRB_PROT_VERSION, req_version, 0);
	/* send an error reply */
	kerb_err_reply(client, pkt, KERB_ERR_PKT_VER, lt);
	return;
    }
    msg_byte_order = req_msg_type & 1;

    swap_bytes = 0;
    if (msg_byte_order != HOST_BYTE_ORDER) {
	swap_bytes++;
    }
    klog(L_KRB_PINFO,
	"Prot version: %d, Byte order: %d, Message type: %d",
	 req_version, msg_byte_order, req_msg_type);

    switch (req_msg_type & ~1) {

    case AUTH_MSG_KDC_REQUEST:
	{
	    u_long  time_ws;	/* Workstation time */
	    u_long  req_life;	/* Requested liftime */
	    char   *service;	/* Service name */
	    char   *instance;	/* Service instance */
	    int     kerno;	/* Kerberos error number */
	    n_auth_req++;
	    tk->length = 0;
	    k_flags = 0;	/* various kerberos flags */


	    /* set up and correct for byte order and alignment */
	    req_name_ptr = (char *) pkt_a_name(pkt);
	    req_inst_ptr = (char *) pkt_a_inst(pkt);
	    req_realm_ptr = (char *) pkt_a_realm(pkt);
	    bcopy(pkt_time_ws(pkt), &req_time_ws, sizeof(req_time_ws));
	    /* time has to be diddled */
	    if (swap_bytes) {
		swap_u_long(req_time_ws);
	    }
	    ptr = (char *) pkt_time_ws(pkt) + 4;

	    req_life = (u_long) (*ptr++);

	    service = ptr;
	    instance = ptr + strlen(service) + 1;

	    rpkt = &rpkt_st;
	    klog(L_INI_REQ,
	    "Initial ticket request Host: %s User: \"%s\" \"%s\"",
	       inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);

	    if (i = check_princ(req_name_ptr, req_inst_ptr, 0,
		&a_name_data)) {
		kerb_err_reply(client, pkt, i, lt);
		return;
	    }
	    tk->length = 0;	/* init */
	    if (strcmp(service, "krbtgt"))
		klog(L_NTGT_INTK,
		    "INITIAL request from %s.%s for %s.%s",
		     req_name_ptr, req_inst_ptr, service, instance, 0);
	    /* this does all the checking */
	    if (i = check_princ(service, instance, lifetime,
		&s_name_data)) {
		kerb_err_reply(client, pkt, i, lt);
		return;
	    }
	    /* Bound requested lifetime with service and user */
	    lifetime = min(req_life, ((u_long) s_name_data.max_life));
	    lifetime = min(lifetime, ((u_long) a_name_data.max_life));
#ifdef NOENCRYPTION
	    bzero(session_key, sizeof(C_Block));
#else
	    /* random session key */
	    random_key(session_key);
#endif

	    /* unseal server's key from master key */
	    bcopy(&s_name_data.key_low, key, 4);
	    bcopy(&s_name_data.key_high, ((long *) key) + 1, 4);
	    kdb_encrypt_key(key, key, master_key,
			    master_key_schedule, DECRYPT);
	    /* construct and seal the ticket */
	    krb_create_ticket(tk, k_flags, a_name_data.name,
		a_name_data.instance, local_realm,
		 client_host.s_addr, session_key, lifetime, kerb_time.tv_sec,
			 s_name_data.name, s_name_data.instance, key);
	    bzero(key, sizeof(key));
	    bzero(key_s, sizeof(key_s));

	    /*
	     * get the user's key, unseal it from the server's key, and
	     * use it to seal the cipher 
	     */

	    /* a_name_data.key_low a_name_data.key_high */
	    bcopy(&a_name_data.key_low, key, 4);
	    bcopy(&a_name_data.key_high, ((long *) key) + 1, 4);

	    /* unseal the a_name key from the master key */
	    kdb_encrypt_key(key, key, master_key, 
			    master_key_schedule, DECRYPT);

	    create_ciph(ciph, session_key, s_name_data.name,
			s_name_data.instance, local_realm, lifetime,
		  s_name_data.key_version, tk, kerb_time.tv_sec, key);

	    /* clear session key */
	    bzero(session_key, sizeof(session_key));

	    bzero(key, sizeof(key));



	    /* always send a reply packet */
	    rpkt = create_auth_reply(req_name_ptr, req_inst_ptr,
		req_realm_ptr, req_time_ws, 0, a_name_data.exp_date,
		a_name_data.key_version, ciph);
	    sendto(f, rpkt->dat, rpkt->length, 0,
		(struct sockaddr *)client, S_AD_SZ);
	    bzero(&a_name_data, sizeof(a_name_data));
	    bzero(&s_name_data, sizeof(s_name_data));
	    break;
	}
    case AUTH_MSG_APPL_REQUEST:
	{
	    u_long  time_ws;	/* Workstation time */
	    u_long  req_life;	/* Requested liftime */
	    char   *service;	/* Service name */
	    char   *instance;	/* Service instance */
	    int     kerno;	/* Kerberos error number */
	    char    tktrlm[REALM_SZ];

	    n_appl_req++;
	    tk->length = 0;
	    k_flags = 0;	/* various kerberos flags */

	    auth->length = 4 + strlen(pkt->dat + 3);
	    auth->length += (int) *(pkt->dat + auth->length) +
		(int) *(pkt->dat + auth->length + 1) + 2;

	    bcopy(pkt->dat, auth->dat, auth->length);

	    strncpy(tktrlm, auth->dat + 3, REALM_SZ);
	    if (set_tgtkey(tktrlm)) {
		lt = klog(L_ERR_UNK,
		    "FAILED realm %s unknown. Host: %s ",
			  tktrlm, inet_ntoa(client_host));
		kerb_err_reply(client, pkt, kerno, lt);
		return;
	    }
	    kerno = krb_rd_req(auth, "ktbtgt", tktrlm, client_host.s_addr,
		ad, 0);

	    if (kerno) {
		klog(L_ERR_UNK, "FAILED krb_rd_req from %s: %s",
		     inet_ntoa(client_host), krb_err_txt[kerno]);
		kerb_err_reply(client, pkt, kerno, "krb_rd_req failed");
		return;
	    }
	    ptr = (char *) pkt->dat + auth->length;

	    bcopy(ptr, &time_ws, 4);
	    ptr += 4;

	    req_life = (u_long) (*ptr++);

	    service = ptr;
	    instance = ptr + strlen(service) + 1;

	    klog(L_APPL_REQ, "APPL Request %s.%s@@%s on %s for %s.%s",
	     ad->pname, ad->pinst, ad->prealm, inet_ntoa(client_host),
		 service, instance, 0);

	    if (strcmp(ad->prealm, tktrlm)) {
		kerb_err_reply(client, pkt, KERB_ERR_PRINCIPAL_UNKNOWN,
		     "Can't hop realms");
		return;
	    }
	    if (!strcmp(service, "changepw")) {
		kerb_err_reply(client, pkt, KERB_ERR_PRINCIPAL_UNKNOWN,
		     "Can't authorize password changed based on TGT");
		return;
	    }
	    kerno = check_princ(service, instance, req_life,
		&s_name_data);
	    if (kerno) {
		kerb_err_reply(client, pkt, kerno, lt);
		return;
	    }
	    /* Bound requested lifetime with service and user */
	    lifetime = min(req_life,
	      (ad->life - ((kerb_time.tv_sec - ad->time_sec) / 300)));
	    lifetime = min(lifetime, ((u_long) s_name_data.max_life));

	    /* unseal server's key from master key */
	    bcopy(&s_name_data.key_low, key, 4);
	    bcopy(&s_name_data.key_high, ((long *) key) + 1, 4);
	    kdb_encrypt_key(key, key, master_key,
			    master_key_schedule, DECRYPT);
	    /* construct and seal the ticket */

#ifdef NOENCRYPTION
	    bzero(session_key, sizeof(C_Block));
#else
	    /* random session key */
	    random_key(session_key);
#endif

	    krb_create_ticket(tk, k_flags, ad->pname, ad->pinst,
			      ad->prealm, client_host.s_addr,
			      session_key, lifetime, kerb_time.tv_sec,
			      s_name_data.name, s_name_data.instance,
			      key);
	    bzero(key, sizeof(key));
	    bzero(key_s, sizeof(key_s));

	    create_ciph(ciph, session_key, service, instance,
			local_realm,
			lifetime, s_name_data.key_version, tk,
			kerb_time.tv_sec, ad->session);

	    /* clear session key */
	    bzero(session_key, sizeof(session_key));

	    bzero(ad->session, sizeof(ad->session));

	    rpkt = create_auth_reply(ad->pname, ad->pinst,
				     ad->prealm, time_ws,
				     0, 0, 0, ciph);
	    sendto(f, rpkt->dat, rpkt->length, 0,
		(struct sockaddr *)client, S_AD_SZ);
	    bzero(&s_name_data, sizeof(s_name_data));
	    break;
	}


#ifdef notdef_DIE
    case AUTH_MSG_DIE:
	{
	    lt = klog(L_DEATH_REQ,
	        "Host: %s User: \"%s\" \"%s\" Kerberos killed",
	        inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);
	    exit(0);
	}
#endif notdef_DIE

    default:
	{
	    lt = klog(L_KRB_PERR,
		"Unknown message type: %d from %s port %u",
		req_msg_type, inet_ntoa(client_host),
		ntohs(client->sin_port));
	    break;
	}
    }
}


/*
 * setup_disc 
 *
 * disconnect all descriptors, remove ourself from the process
 * group that spawned us. 
 */

setup_disc()
{

    int     s;

    for (s = 0; s < 3; s++) {
	(void) close(s);
    }

    (void) open("/dev/null", 0);
    (void) dup2(0, 1);
    (void) dup2(0, 2);

    s = open("/dev/tty", 2);

    if (s >= 0) {
	ioctl(s, TIOCNOTTY, (struct sgttyb *) 0);
	(void) close(s);
    }
    (void) chdir("/tmp");
    return;
}


/*
 * kerb_er_reply creates an error reply packet and sends it to the
 * client. 
 */

kerb_err_reply(client, pkt, err, string)
    struct sockaddr_in *client;
    KTEXT   pkt;
    long    err;
    char   *string;

{
    static KTEXT_ST e_pkt_st;
    KTEXT   e_pkt = &e_pkt_st;
    static char e_msg[128];

    strcpy(e_msg, "\nKerberos error -- ");
    strcat(e_msg, string);
    cr_err_reply(e_pkt, req_name_ptr, req_inst_ptr, req_realm_ptr,
		 req_time_ws, err, e_msg);
    sendto(f, e_pkt->dat, e_pkt->length, 0, (struct sockaddr *)client, S_AD_SZ);

}

/*
 * Make sure that database isn't stale.
 *
 * Exit if it is; we don't want to tell lies.
 */

static void check_db_age()
{
    long age;
    
    if (max_age != -1) {
	/* Requires existance of kerb_get_db_age() */
	gettimeofday(&kerb_time, 0);
	age = kerb_get_db_age();
	if (age == 0) {
	    klog(L_KRB_PERR, "Database currently being updated!");
	    hang();
	}
	if ((age + max_age) < kerb_time.tv_sec) {
	    klog(L_KRB_PERR, "Database out of date!");
	    hang();
	    /* NOTREACHED */
	}
    }
}

check_princ(p_name, instance, lifetime, p)
    char   *p_name;
    char   *instance;
    unsigned lifetime;

    Principal *p;
{
    static int n;
    static int more;
    long trans;

    n = kerb_get_principal(p_name, instance, p, 1, &more);
    klog(L_ALL_REQ,
	 "Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d",
	 p_name, instance, lifetime, n, 0);
    
    if (n < 0) {
	lt = klog(L_KRB_PERR, "Database unavailable!");
	hang();
    }
    
    /*
     * if more than one p_name, pick one, randomly create a session key,
     * compute maximum lifetime, lookup authorizations if applicable,
     * and stuff into cipher. 
     */
    if (n == 0) {
	/* service unknown, log error, skip to next request */
	lt = klog(L_ERR_UNK, "UNKNOWN \"%s\" \"%s\"", p_name,
	    instance, 0);
	return KERB_ERR_PRINCIPAL_UNKNOWN;
    }
    if (more) {
	/* not unique, log error */
	lt = klog(L_ERR_NUN, "Principal NOT UNIQUE \"%s\" \"%s\"",
		  p_name, instance, 0);
	return KERB_ERR_PRINCIPAL_NOT_UNIQUE;
    }
    /* If the user's key is null, we want to return an error */
    if ((p->key_low == 0) && (p->key_high == 0)) {
	/* User has a null key */
	lt = klog(L_ERR_NKY, "Null key \"%s\" \"%s\"", p_name,
	    instance, 0);
	return KERB_ERR_NULL_KEY;
    }
    if (master_key_version != p->kdc_key_ver) {
	/* log error reply */
	lt = klog(L_ERR_MKV,
	    "Key vers incorrect, KRB = %d, \"%s\" \"%s\" = %d",
	    master_key_version, p->name, p->instance, p->kdc_key_ver,
	    0);
	return KERB_ERR_NAME_MAST_KEY_VER;
    }
    /* make sure the service hasn't expired */
    if ((u_long) p->exp_date < (u_long) kerb_time.tv_sec) {
	/* service did expire, log it */
	lt = klog(L_ERR_SEXP,
	    "EXPIRED \"%s\" \"%s\"  %s", p->name, p->instance,
	     stime(&(p->exp_date)), 0);
	return KERB_ERR_NAME_EXP;
    }
    /* ok is zero */
    return 0;
}


/* Set the key for krb_rd_req so we can check tgt */
set_tgtkey(r)
    char   *r;			/* Realm for desired key */
{
    int     n;
    static char lastrealm[REALM_SZ];
    Principal p_st;
    Principal *p = &p_st;
    C_Block key;

    if (!strcmp(lastrealm, r))
	return (KSUCCESS);

    log("Getting key for %s", r);

    n = kerb_get_principal("krbtgt", r, p, 1, &more);
    if (n == 0)
	return (KFAILURE);

    /* unseal tgt key from master key */
    bcopy(&p->key_low, key, 4);
    bcopy(&p->key_high, ((long *) key) + 1, 4);
    kdb_encrypt_key(key, key, master_key,
		    master_key_schedule, DECRYPT);
    krb_set_key(key, 0);
    strcpy(lastrealm, r);
    return (KSUCCESS);
}

static void
hang()
{
    if (pause_int == -1) {
	klog(L_KRB_PERR, "Kerberos will pause so as not to loop init");
	for (;;)
	    pause();
    } else {
	char buf[256];
	sprintf(buf,  "Kerberos will wait %d seconds before dying so as not to loop init", pause_int);
	klog(L_KRB_PERR, buf);
	sleep(pause_int);
	klog(L_KRB_PERR, "Do svedania....\n");
	exit(1);
    }
}
@


4.21
log
@ANSI fixes
@
text
@d3 1
a3 1
 * $Author: kfall $
d14 1
a14 1
"$Header: /usr/src/kerberosIV/kerberos/RCS/kerberos.c,v 4.20 90/06/25 20:59:31 kfall Exp Locker: bostic $";
d29 1
a39 1
struct sockaddr_in sin = {AF_INET};
a90 1
extern char *sys_errlist[];
d126 1
d227 2
@


4.20
log
@no significant change
@
text
@d2 2
a3 2
 * $Source: /usr/src/kerberosIV/src/server/RCS/kerberos.c,v $
 * $Author: qjb $
d14 1
a14 1
"$Header: /usr/src/kerberosIV/src/server/RCS/kerberos.c,v 4.19 89/11/01 17:18:07 qjb Exp Locker: kfall $";
d236 1
a236 1
    if (bind(f, &sin, S_AD_SZ, 0) < 0) {
d297 2
a298 1
	n = recvfrom(f, pkt->dat, MAX_PKT_LEN, 0, &from, &fromlen);
d482 2
a483 1
	    sendto(f, rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
d594 2
a595 1
	    sendto(f, rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
d674 1
a674 1
    sendto(f, e_pkt->dat, e_pkt->length, 0, client, S_AD_SZ);
@


4.19
log
@Made client_host a struct in_addr instead of a long for the benifit
of architectures in which there is more than one element in the 
in_addr structure.

Author: jtkohl
Auditor: qjb
@
text
@d2 1
a2 1
 * $Source: /afs/athena.mit.edu/astaff/project/kerberos/src/server/RCS/kerberos.c,v $
d14 1
a14 1
"$Header: /afs/athena.mit.edu/astaff/project/kerberos/src/server/RCS/kerberos.c,v 4.18 89/07/25 17:15:25 qjb Exp Locker: jtkohl $";
d30 1
a31 1
#include <des.h>
@


4.18
log
@session key wasn't being cleared in AUTH_MSG_APPL_REQUEST.  It is 
now.

Author: jtkohl
Auditor: qjb
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/server/RCS/kerberos.c,v $
 * $Author: srz $
d14 1
a14 1
"$Header: kerberos.c,v 4.17 89/03/20 16:54:35 jtkohl Locked $";
d337 1
a337 1
    static long client_host;
d352 1
a352 1
    client_host = client->sin_addr.s_addr;
d448 1
a448 1
		 client_host, session_key, lifetime, kerb_time.tv_sec,
d513 1
a513 1
	    kerno = krb_rd_req(auth, "ktbtgt", tktrlm, client_host,
d572 1
a572 1
			      ad->prealm, client_host,
@


4.17
log
@Programmer: Jon
Auditor: srz

Saving future generations from the realm hopping bug;  no real
difference for the moment, but if somebody changes things, we will
be safe.
@
text
@d3 1
a3 1
 * $Author: jon $
d14 1
a14 1
"$Header: kerberos.c,v 4.16 89/03/14 19:54:36 jon Locked $";
d583 5
@


4.16
log
@Important security fix.  Don't allow realm hopping.
Discovered by: bcn
Programmer: srz
Auditor: jon
@
text
@d2 2
a3 2
 * $Source: /site/mit/kerberos/src/server/RCS/kerberos.c,v $
 * $Author: root $
d14 1
a14 1
"$Header: kerberos.c,v 4.15 89/01/24 20:45:13 srz Locked $";
d572 1
a572 1
			      tktrlm, client_host,
@


4.15
log
@name change.
@
text
@d2 1
a2 1
 * $Source: /mit/kerberos/src/server/RCS/kerberos.c,v $
d14 1
a14 1
"$Header: kerberos.c,v 4.14 89/01/24 20:40:14 root Locked $";
d536 5
@


4.14
log
@fix typo
@
text
@d3 1
a3 1
 * $Author: jon $
d14 1
a14 1
"$Header: kerberos.c,v 4.13 89/01/24 18:15:40 root Locked $";
d276 1
a276 1
	get_krbrlm(local_realm, 1);
@


4.13
log
@Programmer:wesommer
Auditor: jon
incorporate the slave server into the main server
@
text
@d2 2
a3 2
 * $Source: /mit/wesommer/kslave/server/RCS/kerberos.c,v $
 * $Author: steiner $
d14 1
a14 1
"$Header: kerberos.c,v 4.12 88/12/09 16:20:51 wesommer Locked $";
d283 1
a283 1
	klog(K_KRB_PERR, "Ticket granting ticket service unknown");
@


4.12
log
@NOENCRYPTION changes.
programmer: jtkohl
auditor: steiner
@
text
@d2 1
a2 1
 * $Source: /mit/kerberos/src/server/RCS/kerberos.c,v $
d14 1
a14 1
"$Header: kerberos.c,v 4.11 88/03/24 18:20:34 jtkohl Locked $";
d28 1
a38 2
/**** OK above this point ****** */

d42 2
a43 2
char    prog[32];
char   *progname = prog;
d59 1
d61 4
d77 1
a77 1
static char lclrlm[REALM_SZ];
d90 1
a90 1
static void hang();
d92 2
d95 16
d126 3
d130 1
a130 2
    strcpy(prog, argv[0]);
    prog[31] = '\0';
d132 85
d219 1
a219 1
	fprintf(stderr, "%s: gethostname error\n", prog);
a221 4
    if (argc > 1)
	for (n = 1; n < argc; n++)
	    if (!strcmp(argv[n], "-m"))
		mflag++;
d224 1
a224 1
	fprintf(stderr, "%s: udp/kerberos unknown service\n", prog);
d230 1
a230 1
	fprintf(stderr, "%s: Can't open socket\n", prog);
d234 1
a234 1
	fprintf(stderr, "%s: setsockopt (SO_REUSEADDR)\n", prog);
d237 1
a237 1
	fprintf(stderr, "%s: Can not bind socket\n", prog);
d253 3
d271 1
a271 1
    fprintf(stdout, "\nCurrent Kerberos master key version is %d",
d274 5
a278 4
    /* Look up our local realm */
    get_krbrlm(lclrlm, 1);

    fprintf(stdout, "Local realm: %s\n", lclrlm);
d281 1
a281 1
    if (set_tgtkey(lclrlm)) {
d283 1
d316 1
a316 2
	    "%s: bad recvfrom n = %d errno = %d", prog, n, errno, 0);

a317 1

d447 1
a447 1
		a_name_data.instance, lclrlm,
d467 1
a467 1
			s_name_data.instance, lclrlm, lifetime,
d575 1
a575 1
			lclrlm,
d665 5
d671 20
d700 1
d704 1
a704 1
	"Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d",
d706 6
a711 1

d713 1
a713 1
     * if more than one p_name, pick one randomly create a session key,
d789 12
a800 3
    klog(L_KRB_PERR, "Kerberos will pause so as not to loop init");
    for (;;)
	pause();
@


4.11
log
@Encryption changed from master key schedule to master key
for byte order independence.
Programmer: jon.
Auditor: jtkohl.
@
text
@d14 1
a14 1
"$Header: kerberos.c,v 4.10 88/02/24 18:34:14 steiner Exp $";
d325 3
d330 1
d451 3
d456 1
@


4.10
log
@Copyright notice, etc.
@
text
@d14 1
a14 1
"$Header: kerberos.c,v 4.9 88/01/14 14:03:43 steiner Locked $";
d102 1
a102 1
    int     more;
d147 5
a151 15
    /* lookup the master key version */
    n = kerb_get_principal(KERB_M_NAME, KERB_M_INST, &s_name_data, 1,
	&more);
    if (n != 1) {
	if (mflag) {
	    fprintf(stderr,
    "\07%s: error on master key version lookup, %d found, more = %d\n",
		    progname, n, more);
	    exit(-1);
	} else {
	    klog(L_KRB_PERR,
    "\07%s: error on master key version lookup, %d found, more = %d",
		 progname, n, more);
	    hang();
	}
d153 6
a158 20
    /* set up the master key */
    master_key_version = s_name_data.kdc_key_ver;
    fprintf(stdout, "\nCurrent Kerberos master key version is %d",
	    master_key_version);
    if (mflag)
	des_read_password(master_key,
	"\nEnter current Kerberos master key: ", TRUE);
    else {
	int     kfile;
	kfile = open(MKEYFILE, O_RDONLY, 0600);
	if (kfile < 0) {
	    klog(L_KRB_PERR, "open failed on key file sys error: %s",
		 sys_errlist[errno]);
	    hang();
	}
	if (read(kfile, (char *) master_key, 8) != 8) {
	    klog(L_KRB_PERR, "I/O error on key file sys error: %s",
		 sys_errlist[errno]);
	    hang();
	}
a159 1
    key_sched(master_key, master_key_schedule);
d161 1
a161 27
    /*
     * now use the master key to decrypt the key in the db, had better
     * be the same! 
     */
    bcopy(&s_name_data.key_low, session_key, 4);
    bcopy(&s_name_data.key_high, ((long *) session_key) + 1, 4);
    pcbc_encrypt(session_key, session_key, (long) sizeof(session_key),
		 master_key_schedule, master_key_schedule, DECRYPT);
    /* the decrypted database key had better equal the master key */
    n = bcmp((char *) master_key, (char *) session_key,
	sizeof(master_key));
    bzero(master_key, sizeof(master_key));
    bzero(session_key, sizeof(session_key));
    if (n) {
	bzero(master_key_schedule, sizeof(master_key_schedule));
	if (mflag) {
	    fprintf(stderr,
	"%s: Invalid master key, does not match database\n", progname);
	    exit(-1);
	} else {
	    klog(L_KRB_PERR,
	    "Invalid master key, does not match database\n", progname);
	    hang();
	}
    }
    fprintf(stdout, "\nMaster key entered.  BEWARE!\n");
    fflush(stdout);
d163 2
d331 2
a332 2
	    pcbc_encrypt(key, key, (long) sizeof(key),
		master_key_schedule, master_key_schedule, DECRYPT);
d351 2
a352 2
	    pcbc_encrypt(key, key, (long) sizeof(key),
		master_key_schedule, master_key_schedule, DECRYPT);
d443 2
a444 3
	    pcbc_encrypt(key, key, (long) sizeof(key),
			 master_key_schedule,
			 master_key_schedule, DECRYPT);
d632 2
a633 3
    pcbc_encrypt(key, key, (long) sizeof(key),
		 master_key_schedule,
		 master_key_schedule, DECRYPT);
@


4.9
log
@Formatted.
@
text
@d2 1
a2 1
 * $Source: /mit/kerberos/server/RCS/kerberos.c,v $
d5 2
a6 1
 * Copyright 1985,1986 by the Massachusetts Institute of Technology 
d8 2
d14 1
a14 1
"$Header: kerberos.c,v 4.8 87/12/07 18:13:39 steiner Exp $";
d17 1
@


4.8
log
@Took out references to "Athena" and support for version 3.
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/server/RCS/kerberos.c,v $ $Author: steiner $
 * $Locker:  $ 
d11 1
a11 1
"$Header: kerberos.c,v 4.6 87/12/07 11:22:46 steiner Exp $";
d67 1
a67 1
int     req_act_vno = KRB_PROT_VERSION;	/* Temporary for version skew */
d134 2
a135 1
	    printf("\07\07Kerberos db and cache init failed = %d ...exiting\n", n);
d138 2
a139 1
	    klog(L_KRB_PERR, "\07\07Kerberos db and cache init failed = %d ...exiting", n);
d144 2
a145 1
    n = kerb_get_principal(KERB_M_NAME, KERB_M_INST, &s_name_data, 1, &more);
d149 1
a149 1
		    "\07%s: error on master key version lookup, %d found, more = %d\n",
d153 2
a154 1
	    klog(L_KRB_PERR, "\07%s: error on master key version lookup, %d found, more = %d",
d164 2
a165 1
	des_read_password(master_key, "\nEnter current Kerberos master key: ", TRUE);
d191 2
a192 1
    n = bcmp((char *) master_key, (char *) session_key, sizeof(master_key));
d199 1
a199 1
		    "\07\07%s: Invalid master key, does not match database\n", progname);
d202 2
a203 1
	    klog(L_KRB_PERR, "Invalid master key, does not match database\n", progname);
d235 1
a235 1
	    pkt->mbz = 0;	/* force zeros to catch runaway strings */
d243 1
a243 1
		 "q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d",
d250 2
a251 1
	    klog(L_NET_ERR, "%s: bad recvfrom n = %d errno = %d", prog, n, errno, 0);
d299 2
a300 1
	lt = klog(L_KRB_PERR, "KRB prot version mismatch: KRB =%d request = %d",
d312 2
a313 1
    klog(L_KRB_PINFO, "Prot version: %d, Byte order: %d, Message type: %d",
d319 1
a319 1
    {
d347 2
a348 1
	    klog(L_INI_REQ, "Initial ticket request Host: %s User: \"%s\" \"%s\"",
d351 2
a352 1
	    if (i = check_princ(req_name_ptr, req_inst_ptr, 0, &a_name_data)) {
d358 2
a359 1
		klog(L_NTGT_INTK, "INITIAL request from %s.%s for %s.%s",
d362 2
a363 1
	    if (i = check_princ(service, instance, lifetime, &s_name_data)) {
d376 2
a377 2
	    pcbc_encrypt(key, key, (long) sizeof(key), master_key_schedule,
			 master_key_schedule, DECRYPT);
d379 2
a380 1
	    krb_create_ticket(tk, k_flags, a_name_data.name, a_name_data.instance, lclrlm,
d396 2
a397 2
	    pcbc_encrypt(key, key, (long) sizeof(key), master_key_schedule,
			 master_key_schedule, DECRYPT);
d411 3
a413 3
	    rpkt = create_auth_reply(req_name_ptr, req_inst_ptr, req_realm_ptr,
				 req_time_ws, 0, a_name_data.exp_date,
				     a_name_data.key_version, ciph);
d440 2
a441 1
		lt = klog(L_ERR_UNK, "FAILED realm %s unknown. Host: %s ",
d446 2
a447 1
	    kerno = krb_rd_req(auth, "ktbtgt", tktrlm, client_host, ad, 0);
d474 2
a475 1
	    kerno = check_princ(service, instance, req_life, &s_name_data);
d521 3
a523 2
	    lt = klog(L_DEATH_REQ, "Host: %s User: \"%s\" \"%s\" Kerberos killed",
	       inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);
d530 4
a533 2
	    lt = klog(L_KRB_PERR, "Unknown message type: %d from %s port %u",
		      req_msg_type, inet_ntoa(client_host), ntohs(client->sin_port));
d543 2
a544 2
 * disconnect all descriptors, remove ourself from the process group that
 * spawned us. 
d607 2
a608 1
    klog(L_ALL_REQ, "Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d",
d618 2
a619 1
	lt = klog(L_ERR_UNK, "UNKNOWN \"%s\" \"%s\"", p_name, instance, 0);
d629 4
a632 2
    if ((p->key_low == 0) && (p->key_high == 0)) {	/* User has a null key */
	lt = klog(L_ERR_NKY, "Null key \"%s\" \"%s\"", p_name, instance, 0);
d637 4
a640 2
	lt = klog(L_ERR_MKV, "Key vers incorrect, KRB = %d, \"%s\" \"%s\" = %d",
	 master_key_version, p->name, p->instance, p->kdc_key_ver, 0);
d646 3
a648 2
	lt = klog(L_ERR_SEXP, "EXPIRED \"%s\" \"%s\"  %s", p->name, p->instance,
		  stime(&(p->exp_date)), 0);
d656 1
a656 1
/* Set the key for krb_rd_req so we can check ticket granting tickets */
d686 1
a686 1
static void 
@


4.7
log
@Formatted.
@
text
@d34 1
a34 1
/**** OK above this point *******/
d56 1
a56 1
static int mflag;		/* Are we invoked manually?  */
d290 1
a290 1
    if ((req_version != 3) && (req_version != 4)) {
d309 1
a309 110
	if (req_version == 3) {
	    int     tgtflag = 0;
	    n_auth_req++;
	    tk->length = 0;
	    k_flags = 0;	/* various kerberos flags */


	    /* set up and correct for byte order and alignment */
	    req_name_ptr = (char *) pkt_a_name(pkt);
	    req_inst_ptr = (char *) pkt_a_inst(pkt);
	    req_realm_ptr = (char *) pkt_a_realm(pkt);
	    req_no_req = pkt_no_req(pkt);	/* number of requests, 1
						 * byte */
	    bcopy(pkt_time_ws(pkt), &req_time_ws, sizeof(req_time_ws));
	    /* time has to be diddled */
	    if (swap_bytes) {
		swap_u_long(req_time_ws);
	    }
	    rpkt = &rpkt_st;
	    create_cipher(req_no_req, ciph);

	    klog(L_KRB_PWARN, "OLD VERSION tgt request Host: %s User: \"%s\" \"%s\"",
	       inet_ntoa(client_host), req_name_ptr, req_inst_ptr, 0);

	    if (i = check_princ(req_name_ptr, req_inst_ptr, 0, &a_name_data)) {
		kerb_err_reply(client, pkt, i, lt);
		return;
	    }
	    /* loop through the ticket requests */
	    for (i = 1; i <= req_no_req; i++) {
		tgtflag = 0;
		tk->length = 0;	/* init */
		lifetime = (u_long) get_request(pkt, i, &p_name, &instance);
		if (strcmp(p_name, "krbtgt"))
		    klog(L_NTGT_INTK, "INITIAL request from %s.%s for %s.%s",
			 req_name_ptr, req_inst_ptr, p_name, instance);
		else
		    tgtflag++;
		/* this does all the checking */
		if (!check_princ(p_name, (tgtflag ? KRB_REALM : instance),
				 lifetime, &s_name_data)) {
		    /* Bound requested lifetime with service and user */
		    lifetime = min(lifetime,
				   ((u_long) s_name_data.max_life));
		    lifetime = min(lifetime, ((u_long) a_name_data.max_life));
		    /* random session key */
		    random_key(session_key);

		    /* unseal server's key from master key */
		    bcopy(&s_name_data.key_low, key, 4);
		    bcopy(&s_name_data.key_high, ((long *) key) + 1, 4);
		    pcbc_encrypt(key, key, (long) sizeof(key),
				 master_key_schedule,
				 master_key_schedule, DECRYPT);
		    /* construct and seal the ticket */
		    krb_create_ticket(tk, k_flags, a_name_data.name,
			    a_name_data.instance, lclrlm, client_host,
				      session_key, lifetime,
				      kerb_time.tv_sec,
				      s_name_data.name, instance,
				      key);
		    bzero(key, sizeof(key));
		    bzero(key_s, sizeof(key_s));
		}
		/* add ticket to cipher, even if null */
		add_ticket(ciph, i, session_key, lifetime,
			   s_name_data.name, instance,
			   "", s_name_data.key_version, tk);

		/* clear session key */
		bzero(session_key, sizeof(session_key));
	    }			/* end ticket request loop */

	    /*
	     * All the tickets have been stuffed into the cipher last,
	     * jam the kdc time in too 
	     */
	    bcopy(&kerb_time.tv_sec, ciph->dat + ciph->length, 4);
	    ciph->length += 4;
	    ciph->length = ((ciph->length + 7) / 8) * 8;

	    /*
	     * get the user's key, unseal it from the server's key, and
	     * use it to seal the cipher 
	     */

	    /* a_name_data.key_low a_name_data.key_high */
	    bcopy(&a_name_data.key_low, key, 4);
	    bcopy(&a_name_data.key_high, ((long *) key) + 1, 4);

	    /* unseal the a_name key from the master key */
	    pcbc_encrypt(key, key, (long) sizeof(key), master_key_schedule,
			 master_key_schedule, DECRYPT);
	    key_sched(key, key_s);
	    pcbc_encrypt(ciph->dat, ciph->dat, (long) ciph->length, key_s, key,
			 ENCRYPT);
	    bzero(key, sizeof(key));



	    /* always send a reply packet */
	    rpkt = create_auth_reply(req_name_ptr, req_inst_ptr,
				     req_realm_ptr,
			req_time_ws, req_no_req, a_name_data.exp_date,
				     a_name_data.key_version, ciph);
	    sendto(f, rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
	    bzero(&a_name_data, sizeof(a_name_data));
	    bzero(&s_name_data, sizeof(s_name_data));
	    break;
	} else if (req_version == 4) {
a431 4
	    if (kerno == RD_AP_NOT_US)
		kerno = krb_rd_req(auth, "ktbtgt", "Athena", client_host, ad, 0);


d479 1
a479 2
			      ((req_version == 3) ? "Athena" : tktrlm),
			      client_host,
d487 1
a487 1
			((req_version == 3) ? "Athena" : lclrlm),
d493 1
a493 2
				     ((req_version == 3) ? 1 : 0),
				     0, 0, ciph);
@


4.6
log
@Changed routine names.
@
text
@d1 3
a3 6
/* 
 *  $Source: /u2/lockers/kerberos/server/RCS/kerberos.c,v $
 *  $Author: steiner $
 *  $Locker: steiner $
 * 
 * Copyright 1985,1986 by the Massachusetts Institute of Technology
d5 2
d11 1
a11 1
"$Header: kerberos.c,v 4.5 87/11/04 12:27:20 steiner Locked $";
d32 1
a32 1
extern  int errno;
d36 2
a37 2
struct  sockaddr_in sin = { AF_INET };
int         f;
d40 1
a40 1
char    *progname = prog;
d42 2
a43 2
static  Key_schedule    master_key_schedule;
static  C_Block         master_key;
d45 12
a56 12
static  struct timeval  kerb_time;
static  Principal  a_name_data; /*for requesting user */
static  Principal  s_name_data; /*for services requested*/
static  C_Block session_key;
static  C_Block user_key;
static  C_Block service_key;
static  u_char  master_key_version;
static  char    k_instance[INST_SZ];
static  char    log_text[128];
static  char	*lt;
static  int     more;
static  int	mflag;		/* Are we invoked manually?  */
d58 8
a65 8
/* fields within the received request packet                               */
static  u_char   req_msg_type;
static  u_char   req_version;
static  char    *req_name_ptr;
static  char    *req_inst_ptr;
static  char    *req_realm_ptr;
static  u_char   req_no_req;
static  u_long   req_time_ws;
d67 1
a67 1
int		req_act_vno = KRB_PROT_VERSION;        /* Temporary for version skew */
d69 1
a69 1
static	char	lclrlm[REALM_SZ];
d71 13
a83 12
/* statistics                                                              */
static  long    q_bytes;        /* current bytes remaining in queue        */
static  long    q_n;            /* how many consecutive non-zero q_bytes   */
static  long    max_q_bytes;
static  long    max_q_n;
static  long    n_auth_req;
static  long    n_appl_req;
static  long    n_packets;
static  long    n_user;
static  long    n_server;
static  void	hang();
extern  char    *sys_errlist[];
d86 2
a87 2
int argc;
char    **argv;
d89 11
a99 11
    struct sockaddr_in  from;
    register int        n;
    int                 on = 1;
    int                 child;
    struct servent      *sp;
    int                 fromlen;
    static KTEXT_ST     pkt_st;
    KTEXT               pkt = &pkt_st;
    Principal		*p;
    int			more;
    C_Block         	key;
d101 1
a101 1
    strcpy(prog,argv[0]);
d104 5
a108 7
    /* find our hostname, and use it as the instance                       */
    if (gethostname(k_instance,INST_SZ))
        {
        fprintf(stderr,"%s: gethostname error\n",prog);
        exit(1);
        }
    
d110 3
a112 2
      for (n = 1;n < argc;n++)
	if (!strcmp(argv[n],"-m")) mflag++;
d114 4
a117 4
    if ((sp = getservbyname("kerberos","udp")) == 0)
       {fprintf(stderr,"%s: udp/kerberos unknown service\n",prog);
        exit(1);}

d120 4
a123 4
    if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
       {fprintf(stderr,"%s: Can't open socket\n",prog);
        exit(1);}

d125 1
a125 1
        fprintf(stderr,"%s: setsockopt (SO_REUSEADDR)\n",prog);
d127 4
a130 4
    if (bind(f, &sin, S_AD_SZ, 0) < 0) 
       {fprintf(stderr,"%s: Can not bind socket\n",prog);
        exit(1);}

d133 6
a138 3
        if (mflag) {
	  printf("\07\07Kerberos db and cache init failed = %d ...exiting\n",n);
	  exit (-1);
a139 4
	else {
	  klog(L_KRB_PERR, "\07\07Kerberos db and cache init failed = %d ...exiting",n);
	  hang();
	}
a140 1
    
d142 1
a142 1
    n = kerb_get_principal(KERB_M_NAME,KERB_M_INST,&s_name_data,1,&more);
d144 10
a153 10
      if (mflag) {
	fprintf(stderr,
		"\07%s: error on master key version lookup, %d found, more = %d\n",
		progname,n,more);
	exit(-1);
      } else {
	klog (L_KRB_PERR,"\07%s: error on master key version lookup, %d found, more = %d",
	      progname,n,more);
	hang();
      }
a154 1
        
d157 2
a158 2
    fprintf(stdout,"\nCurrent Kerberos master key version is %d",
        master_key_version);
d160 1
a160 1
      des_read_password(master_key,"\nEnter current Kerberos master key: ",TRUE);
d162 12
a173 12
      int kfile;
      kfile = open(MKEYFILE,O_RDONLY,0600);
      if (kfile < 0) {
	klog(L_KRB_PERR,"open failed on key file sys error: %s",
	     sys_errlist[errno]);
	hang();
      }
      if (read(kfile,(char *)master_key,8) != 8) {
	klog(L_KRB_PERR,"I/O error on key file sys error: %s",
	     sys_errlist[errno]);
	hang();
      }
d175 1
a175 1
    key_sched(master_key,master_key_schedule);
d177 3
a179 2
    /* now use the master key to decrypt the key in the db, had better be
     * the same!
d181 5
a185 5
     bcopy(&s_name_data.key_low, session_key, 4);
     bcopy(&s_name_data.key_high, ((long *)session_key)+1, 4);
     pcbc_encrypt(session_key,session_key,(long) sizeof(session_key),
                master_key_schedule, master_key_schedule,DECRYPT);
    /* the decrypted database key had better equal the master key          */
d187 2
a188 2
    bzero(master_key,sizeof(master_key));   
    bzero(session_key,sizeof(session_key)); 
d190 9
a198 9
      bzero(master_key_schedule,sizeof(master_key_schedule));
      if (mflag) {
	fprintf(stderr,
		  "\07\07%s: Invalid master key, does not match database\n",progname);
	exit(-1);
      } else {
	klog(L_KRB_PERR,"Invalid master key, does not match database\n",progname);
	hang();
      }
d200 1
a200 2
    
    fprintf(stdout,"\nMaster key entered.  BEWARE!\n");
d203 1
a203 1
    
d205 1
a205 1
    get_krbrlm(lclrlm,1);
d207 1
a207 1
    fprintf(stdout,"Local realm: %s\n",lclrlm);
d210 3
a212 4
    if(set_tgtkey(lclrlm))
      {
        /* Ticket granting service unknown */
	fprintf(stderr,"Ticket granting ticket service unknown\n");
d214 1
a214 2
      }

d216 5
a220 5
      if ((child = fork()) != 0) {
        printf("Kerberos started, PID=%d\n",child);
	exit(0);
      }
      setup_disc(); 
a221 1

d223 21
a243 22
    for(;;)
      {
      fromlen = S_AD_SZ;
      n = recvfrom(f, pkt->dat, MAX_PKT_LEN, 0, &from, &fromlen);
      if (n > 0)
        {
        pkt->length = n;
        pkt->mbz = 0;           /* force zeros to catch runaway strings */
        /* see what is left in the input queue */
        ioctl(f,FIONREAD,&q_bytes);
        gettimeofday(&kerb_time,NULL);
        q_n++;
        max_q_n = max(max_q_n,q_n);
        n_packets++;
	klog(L_NET_INFO,
	     "q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d",
             q_bytes,q_n,n,max_q_bytes,max_q_n,n_packets,0);
        max_q_bytes = max(max_q_bytes,q_bytes);
        if (!q_bytes) q_n = 0;  /* reset consecutive packets               */
        kerberos(&from, pkt);
        }
      else klog(L_NET_ERR,"%s: bad recvfrom n = %d errno = %d",prog,n,errno,0);
d245 1
a245 1
    }             
d251 2
a252 2
struct sockaddr_in  	*client;
KTEXT       		pkt;
d254 10
a263 10
    static KTEXT_ST     rpkt_st;
    KTEXT               rpkt = &rpkt_st;
    static KTEXT_ST     ciph_st;
    KTEXT               ciph = &ciph_st;
    static KTEXT_ST     tk_st;
    KTEXT               tk = &tk_st;
    static KTEXT_ST	auth_st;
    KTEXT		auth = &auth_st;
    AUTH_DAT            ad_st;
    AUTH_DAT		*ad = &ad_st;
d266 10
a275 11
    static  long        client_host;
    static  int         msg_byte_order;
    static  int         swap_bytes;
    static  u_char      k_flags;
    char            	*p_name,*instance;
    u_long          	lifetime;
    int             	i;
    C_Block         	key;
    Key_schedule    	key_s;
    char		*ptr;
    
d278 1
a281 4
 
/* eval macros and correct the byte order and alignment as needed          */
    req_version = pkt_version(pkt); /* 1 byte, version                     */
    req_msg_type = pkt_msg_type(pkt);   /* 1 byte, Kerberos msg type       */
d283 4
d289 8
a296 10
   /* check packet version                                                */
    if ((req_version != 3 ) && (req_version != 4))
        {
	lt = klog(L_KRB_PERR,"KRB prot version mismatch: KRB =%d request = %d",
             KRB_PROT_VERSION,req_version,0);
        /*  send an error reply                                */
        kerb_err_reply(client,pkt,KERB_ERR_PKT_VER,lt);
        return;
        }
        
d300 5
a304 7
    if (msg_byte_order != HOST_BYTE_ORDER )
        {
        swap_bytes++;
        }
    
    klog(L_KRB_PINFO,"Prot version: %d, Byte order: %d, Message type: %d",
	 req_version,msg_byte_order,req_msg_type);
d306 1
a306 1
    switch(req_msg_type & ~1) { 
d309 5
a313 6
        if(req_version == 3)
        {
	int tgtflag = 0;
        n_auth_req++;
        tk->length = 0;
        k_flags = 0;            /* various kerberos flags                  */
d316 13
a328 11
        /* set up and correct for byte order and alignment                 */
        req_name_ptr = (char *) pkt_a_name(pkt);
        req_inst_ptr = (char *) pkt_a_inst(pkt);
        req_realm_ptr =(char *) pkt_a_realm(pkt);
        req_no_req  = pkt_no_req(pkt);  /* number of requests, 1 byte */    
        bcopy(pkt_time_ws(pkt),&req_time_ws,sizeof(req_time_ws));
        /* time has to be diddled                                          */
        if (swap_bytes) 
            {
            swap_u_long(req_time_ws);
            }
d330 2
a331 2
        rpkt = &rpkt_st;
        create_cipher(req_no_req,ciph);
d333 23
a355 2
	klog(L_KRB_PWARN,"OLD VERSION tgt request Host: %s User: \"%s\" \"%s\"",
            inet_ntoa(client_host), req_name_ptr, req_inst_ptr,0);
d357 20
a376 5
        if (i = check_princ(req_name_ptr,req_inst_ptr,0,&a_name_data))
            {
            kerb_err_reply(client,pkt,i,lt);
            return;
            }
d378 3
a380 20
        /* loop through the ticket requests                           */
        for (i=1;i<=req_no_req;i++)
            {
	    tgtflag = 0;
            tk->length = 0;    /* init                                */
            lifetime = (u_long) get_request(pkt,i,&p_name,&instance);
	    if(strcmp(p_name,"krbtgt"))
	       klog(L_NTGT_INTK,"INITIAL request from %s.%s for %s.%s",
		    req_name_ptr,req_inst_ptr,p_name,instance);
	    else tgtflag++;
            /* this does all the checking                                  */
            if (!check_princ(p_name,(tgtflag ? KRB_REALM : instance),
			     lifetime,&s_name_data))
                  {
                  /* Bound requested lifetime with service and user    */
                  lifetime = min(lifetime,
                        ((u_long)s_name_data.max_life));
                  lifetime = min(lifetime,((u_long)a_name_data.max_life));
                  /* random session key                              */
                  random_key(session_key);
d382 7
a388 16
                  /* unseal server's key from master key             */
                  bcopy(&s_name_data.key_low, key, 4);
                  bcopy(&s_name_data.key_high, ((long *)key)+1, 4);
                  pcbc_encrypt(key,key,(long) sizeof(key),
                    master_key_schedule,
                    master_key_schedule,DECRYPT);
                  /* construct and seal the ticket                   */
                  krb_create_ticket(tk,k_flags,a_name_data.name,
                        a_name_data.instance,lclrlm,client_host,
                        session_key,lifetime,
                        kerb_time.tv_sec,
                        s_name_data.name,instance,
                        key);
                  bzero(key,sizeof(key));
                  bzero(key_s,sizeof(key_s));
                  }
d390 4
a393 4
            /* add ticket to cipher, even if null                      */
            add_ticket(ciph,i,session_key,lifetime,
                s_name_data.name,instance,
                "",s_name_data.key_version,tk);
d395 3
a397 3
            /* clear session key                                       */
            bzero(session_key,sizeof(session_key));
            }                   /* end ticket request loop                 */
d399 7
a405 6
            /* All the tickets have been stuffed into the cipher
             * last, jam the kdc time in too
             */
             bcopy(&kerb_time.tv_sec,ciph->dat + ciph->length,4);
             ciph->length += 4;
             ciph->length = ((ciph->length+7)/8)*8;
a406 15
             /* get the user's key, unseal it from the server's key, and
              * use it to seal the cipher
              */
            
             /* a_name_data.key_low a_name_data.key_high                   */
             bcopy(&a_name_data.key_low, key, 4);
             bcopy(&a_name_data.key_high, ((long *)key)+1, 4);
    
            /* unseal the a_name key from the master key                   */
             pcbc_encrypt(key,key,(long) sizeof(key),master_key_schedule,
                 master_key_schedule,DECRYPT);
             key_sched(key,key_s);
             pcbc_encrypt(ciph->dat, ciph->dat,(long) ciph->length,key_s,key,
                ENCRYPT);
             bzero(key,sizeof(key));
d409 18
a427 20
        /* always send a reply packet                                      */
         rpkt = create_auth_reply(req_name_ptr,req_inst_ptr,
                                    req_realm_ptr,
                req_time_ws,req_no_req,a_name_data.exp_date,
                a_name_data.key_version,ciph);
         sendto(f,rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
         bzero(&a_name_data,sizeof(a_name_data));
         bzero(&s_name_data,sizeof(s_name_data));
         break;
         }
	else if(req_version == 4)
	  {
	 u_long		time_ws;	/* Workstation time		*/
	 u_long 	req_life;	/* Requested liftime		*/
	 char		*service;	/* Service name			*/
	 char		*instance;	/* Service instance		*/
	 int		kerno;		/* Kerberos error number	*/
	 n_auth_req++;
	 tk->length = 0;
	 k_flags = 0;            /* various kerberos flags                  */
d429 10
d440 1
a440 10
	 /* set up and correct for byte order and alignment                 */
	 req_name_ptr = (char *) pkt_a_name(pkt);
	 req_inst_ptr = (char *) pkt_a_inst(pkt);
	 req_realm_ptr =(char *) pkt_a_realm(pkt);
	 bcopy(pkt_time_ws(pkt),&req_time_ws,sizeof(req_time_ws));
	 /* time has to be diddled                                          */
	 if (swap_bytes) 
	   {
	     swap_u_long(req_time_ws);
	   }
d442 2
a443 1
	 ptr = (char *) pkt_time_ws(pkt) + 4;
d445 3
a447 4
	 req_life = (u_long) (*ptr++);
	 
	 service = ptr;
	 instance = ptr + strlen(service) + 1;
d449 18
a466 3
	 rpkt = &rpkt_st;
	 klog(L_INI_REQ,"Initial ticket request Host: %s User: \"%s\" \"%s\"",
	      inet_ntoa(client_host), req_name_ptr, req_inst_ptr,0);
d468 11
a478 5
	 if (i = check_princ(req_name_ptr,req_inst_ptr,0,&a_name_data))
	   {
	     kerb_err_reply(client,pkt,i,lt);
	     return;
	   }
d480 4
a483 8
	 tk->length = 0;    /* init                                */
	 if(strcmp(service,"krbtgt"))
	   klog(L_NTGT_INTK,"INITIAL request from %s.%s for %s.%s",
		req_name_ptr,req_inst_ptr,service,instance,0);
            /* this does all the checking                                  */
	 if (i = check_princ(service,instance,lifetime,&s_name_data))
	   {kerb_err_reply(client,pkt,i,lt);
	    return;}
d485 3
a487 17
	 /* Bound requested lifetime with service and user    */
	 lifetime = min(req_life,((u_long)s_name_data.max_life));
	 lifetime = min(lifetime,((u_long)a_name_data.max_life));
	 /* random session key                              */
	 random_key(session_key);
	 
	 /* unseal server's key from master key             */
	 bcopy(&s_name_data.key_low, key, 4);
	 bcopy(&s_name_data.key_high, ((long *)key)+1, 4);
	 pcbc_encrypt(key,key,(long) sizeof(key), master_key_schedule,
			  master_key_schedule,DECRYPT);
	 /* construct and seal the ticket                   */
	 krb_create_ticket(tk,k_flags,a_name_data.name,a_name_data.instance,lclrlm,
		       client_host,session_key,lifetime,kerb_time.tv_sec,
		       s_name_data.name,s_name_data.instance,key);
	 bzero(key,sizeof(key));
	 bzero(key_s,sizeof(key_s));
d489 3
a491 11
	 /* get the user's key, unseal it from the server's key, and
	  * use it to seal the cipher
	  */
            
	 /* a_name_data.key_low a_name_data.key_high                   */
	 bcopy(&a_name_data.key_low, key, 4);
	 bcopy(&a_name_data.key_high, ((long *)key)+1, 4);
    
	 /* unseal the a_name key from the master key                   */
	 pcbc_encrypt(key,key,(long) sizeof(key),master_key_schedule,
		      master_key_schedule,DECRYPT);
d493 3
a495 3
	 create_ciph(ciph,session_key,s_name_data.name,
		     s_name_data.instance,lclrlm,lifetime,
		     s_name_data.key_version,tk,kerb_time.tv_sec,key);
d497 2
a498 2
	 /* clear session key                                       */
	 bzero(session_key,sizeof(session_key));
d500 1
a500 1
	 bzero(key,sizeof(key));
d504 9
a512 10
	 /* always send a reply packet                                      */
         rpkt = create_auth_reply(req_name_ptr,req_inst_ptr,req_realm_ptr,
                req_time_ws,0,a_name_data.exp_date,
                a_name_data.key_version,ciph);
         sendto(f,rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
         bzero(&a_name_data,sizeof(a_name_data));
         bzero(&s_name_data,sizeof(s_name_data));
         break;
       }
     
d514 7
a520 7
        {
	 u_long		time_ws;	/* Workstation time		*/
	 u_long 	req_life;	/* Requested liftime		*/
	 char		*service;	/* Service name			*/
	 char		*instance;	/* Service instance		*/
	 int		kerno;		/* Kerberos error number	*/
	 char		tktrlm[REALM_SZ];
d522 3
a524 3
         n_appl_req++;
         tk->length = 0;
         k_flags = 0;            /* various kerberos flags */
d526 3
a528 3
	 auth->length = 4 + strlen(pkt->dat+3);
	 auth->length += (int) *(pkt->dat + auth->length) + 
	 	     (int) *(pkt->dat + auth->length + 1) + 2;
d530 1
a530 1
	 bcopy(pkt->dat,auth->dat,auth->length);
d532 8
a539 6
	 strncpy(tktrlm,auth->dat+3,REALM_SZ);
	 if(set_tgtkey(tktrlm))
	   {lt = klog(L_ERR_UNK,"FAILED realm %s unknown. Host: %s ",
			 tktrlm,inet_ntoa(client_host));
	    kerb_err_reply(client,pkt,kerno,lt);
	    return;}
d541 2
a542 1
	 kerno = krb_rd_req(auth,"ktbtgt",tktrlm,client_host,ad,0);
a543 2
	 if(kerno == RD_AP_NOT_US)
	   kerno = krb_rd_req(auth,"ktbtgt","Athena",client_host,ad,0);
d545 7
d553 2
a554 6
	 if(kerno) {klog(L_ERR_UNK,"FAILED krb_rd_req from %s: %s",
			 inet_ntoa(client_host), krb_err_txt[kerno]);
	            kerb_err_reply(client,pkt,kerno,"krb_rd_req failed");
		    return;}
	 
	 ptr = (char *) pkt->dat + auth->length;
d556 1
a556 2
	 bcopy(ptr,&time_ws,4);
	 ptr += 4;
d558 2
a559 4
	 req_life = (u_long) (*ptr++);
	 
	 service = ptr;
	 instance = ptr + strlen(service) + 1;
d561 3
a563 8
	 klog(L_APPL_REQ,"APPL Request %s.%s@@%s on %s for %s.%s",
	      ad->pname,ad->pinst,ad->prealm,inet_ntoa(client_host),
	      service,instance,0);
	 
	 if(!strcmp(service,"changepw"))
	   {kerb_err_reply(client,pkt,KERB_ERR_PRINCIPAL_UNKNOWN,
			  "Can't authorize password changed based on TGT");
	    return;}
d565 14
a578 3
	 kerno = check_princ(service,instance,req_life,&s_name_data);
	 if(kerno) {kerb_err_reply(client,pkt,kerno,lt);
		    return;}
d580 7
a586 4
	 /* Bound requested lifetime with service and user    */
	 lifetime = min(req_life,
			(ad->life - ((kerb_time.tv_sec - ad->time_sec)/300)));
	 lifetime = min(lifetime,((u_long)s_name_data.max_life));
d588 2
a589 7
	 /* unseal server's key from master key             */
	 bcopy(&s_name_data.key_low, key, 4);
	 bcopy(&s_name_data.key_high, ((long *)key)+1, 4);
	 pcbc_encrypt(key,key,(long) sizeof(key),
                    master_key_schedule,
                    master_key_schedule,DECRYPT);
	 /* construct and seal the ticket                   */
d591 8
a598 2
	 /* random session key                              */
	 random_key(session_key);
d600 4
a603 13
	 krb_create_ticket(tk,k_flags,ad->pname,ad->pinst,
		       ((req_version == 3) ? "Athena" : tktrlm),
		       client_host,
                        session_key,lifetime,kerb_time.tv_sec,
                        s_name_data.name,s_name_data.instance,
                        key);
	 bzero(key,sizeof(key));
	 bzero(key_s,sizeof(key_s));
	 
	 create_ciph(ciph,session_key,service,instance,
		     ((req_version == 3) ? "Athena" : lclrlm),
		     lifetime,s_name_data.key_version,tk,
		     kerb_time.tv_sec,ad->session);
d605 8
a612 8
         rpkt = create_auth_reply(ad->pname,ad->pinst,
				  ad->prealm,time_ws,
				  ((req_version == 3) ? 1 : 0),
				  0,0,ciph);
	 sendto(f,rpkt->dat,rpkt->length,0,client,S_AD_SZ);
	 bzero(&s_name_data,sizeof(s_name_data));
         break;
         }
d617 5
a621 5
        {
        lt = klog(L_DEATH_REQ,"Host: %s User: \"%s\" \"%s\" Kerberos killed",
            inet_ntoa(client_host),req_name_ptr,req_inst_ptr,0);
        exit(0);
        }
d625 5
a629 5
        {
	lt = klog(L_KRB_PERR,"Unknown message type: %d from %s port %u",
             req_msg_type,inet_ntoa(client_host),ntohs(client->sin_port));
        break;
        }
d634 2
a635 2
/* 
 * setup_disc
d637 2
a638 2
 * disconnect all descriptors, remove ourself from the process
 * group that spawned us.
d642 1
a642 1
   {
d644 1
a644 1
    int s;
d647 1
a647 1
    (void) close(s);
d657 2
a658 2
    ioctl(s, TIOCNOTTY, (struct sgttyb *) 0);
    (void) close(s);
a659 1

d666 2
a667 2
 * kerb_er_reply creates an error reply packet
 * and sends it to the client. 
d670 5
a674 1
kerb_err_reply(client,pkt,err,string)
d676 4
a679 9
    struct sockaddr_in  *client;
    KTEXT       	pkt;
    long                err;
    char                *string;
    
    {
     static  KTEXT_ST    e_pkt_st;
     KTEXT               e_pkt = &e_pkt_st;
     static  char        e_msg[128];
d681 5
a685 5
     strcpy(e_msg,"\nKerberos error -- ");
     strcat(e_msg,string);
     cr_err_reply(e_pkt,req_name_ptr,req_inst_ptr,req_realm_ptr,
                  req_time_ws,err,e_msg);
     sendto(f,e_pkt->dat, e_pkt->length, 0, client, S_AD_SZ);
d687 1
a687 7
     }
 
 
check_princ(p_name,instance,lifetime,p)
char    *p_name;
char    *instance;
unsigned lifetime;
d689 7
a695 1
Principal   *p;
d697 2
a698 2
    static  int n;
    static  int more;
d700 3
a702 3
    n = kerb_get_principal(p_name,instance,p,1,&more);
    klog(L_ALL_REQ,"Principal: \"%s\", Instance: \"%s\" Lifetime = %d n = %d",
         p_name,instance,lifetime,n,0);
d704 4
a707 4
    /* if more than one p_name, pick one randomly
     * create a session key, 
     * compute maximum lifetime, lookup authorizations if
     * applicable, and stuff into cipher.
d709 11
a719 15
    if (n == 0)
        {
        /* service unknown, log error, skip to next request    */
	lt = klog(L_ERR_UNK,"UNKNOWN \"%s\" \"%s\"",p_name,instance,0);
        return KERB_ERR_PRINCIPAL_UNKNOWN;
        }

    if (more)
        {
        /* not unique, log error */
	lt = klog(L_ERR_NUN,"Principal NOT UNIQUE \"%s\" \"%s\"",
		  p_name,instance,0);
        return KERB_ERR_PRINCIPAL_NOT_UNIQUE;
        }

d721 2
a722 3
    if ((p->key_low == 0) && (p->key_high == 0))
     {	/* User has a null key */
	lt = klog(L_ERR_NKY,"Null key \"%s\" \"%s\"",p_name,instance,0);
d724 14
a737 19
	}

    if (master_key_version != p->kdc_key_ver)
        {
        /* log error reply */
	lt = klog(L_ERR_MKV,"Key vers incorrect, KRB = %d, \"%s\" \"%s\" = %d",
                  master_key_version,p->name,p->instance,p->kdc_key_ver,0);
        return KERB_ERR_NAME_MAST_KEY_VER;
        }
             
    /* make sure the service hasn't expired               */
    if ((u_long) p->exp_date <  (u_long) kerb_time.tv_sec )
        {
        /* service did expire, log it */
        lt = klog(L_ERR_SEXP,"EXPIRED \"%s\" \"%s\"  %s",p->name, p->instance,
                  stime(&(p->exp_date)),0);
        return KERB_ERR_NAME_EXP;
        }

d745 1
a745 1
char	*r;	/* Realm for desired key */
d747 5
a751 5
  int		n;
  static char	lastrealm[REALM_SZ];
  Principal	p_st;
  Principal	*p = & p_st;
  C_Block      	key;
d753 2
a754 2
  if(!strcmp(lastrealm,r) )
    return(KSUCCESS);
d756 1
a756 1
  log("Getting key for %s",r);
d758 3
a760 2
  n = kerb_get_principal("krbtgt",r,p,1,&more);
  if (n == 0) return(KFAILURE);
d762 9
a770 9
  /* unseal tgt key from master key             */
  bcopy(&p->key_low, key, 4);
  bcopy(&p->key_high, ((long *)key)+1, 4);
  pcbc_encrypt(key,key,(long) sizeof(key),
	       master_key_schedule,
	       master_key_schedule,DECRYPT);
  krb_set_key(key,0);
  strcpy(lastrealm,r);
  return(KSUCCESS);
d773 2
a774 1
static void hang()
d776 3
a778 2
  klog(L_KRB_PERR,"Kerberos will pause so as not to loop init");
  for (;;) pause();
@


4.5
log
@Moved kdc.h to general include directory.
@
text
@d2 1
a2 1
 *  $Source: /u3/kerberos.new/kdc/RCS/kerberos.c,v $
d12 1
a12 1
"$Header: kerberos.c,v 4.4 87/09/28 15:21:50 steiner Locked $";
d381 1
a381 1
                  create_ticket(tk,k_flags,a_name_data.name,
d496 1
a496 1
	 create_ticket(tk,k_flags,a_name_data.name,a_name_data.instance,lclrlm,
d561 1
a561 1
	 kerno = rd_ap_req(auth,"ktbtgt",tktrlm,client_host,ad,0);
d564 1
a564 1
	   kerno = rd_ap_req(auth,"ktbtgt","Athena",client_host,ad,0);
d567 1
a567 1
	 if(kerno) {klog(L_ERR_UNK,"FAILED rd_ap_req from %s: %s",
d569 1
a569 1
	            kerb_err_reply(client,pkt,kerno,"rd_ap_req failed");
d611 1
a611 1
	 create_ticket(tk,k_flags,ad->pname,ad->pinst,
d775 1
a775 1
/* Set the key for rd_ap_req so we can check ticket granting tickets */
d799 1
a799 1
  set_serv_key(key,0);
@


4.4
log
@Collected #defines for this directory into kdc.h.
@
text
@d2 1
a2 1
 *  $Source: /mit/s/t/steiner/kerberos/kdc/RCS/kerberos.c,v $
d12 1
a12 1
"$Header: kerberos.c,v 4.3 87/09/14 16:46:08 steiner Locked $";
d31 1
a31 1
#include "kdc.h"
@


4.3
log
@Changed hardcoded "ATHENA.MIT.EDU" to KRB_REALM
(bug pointed out by Jim Bloom).
@
text
@d11 2
a12 3
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 4.2 87/09/10 16:12:16 steiner Locked $";
static char *CopyRight = 
        "Copyright 1985,1986 by the Massachusetts Institute of Technology";
d31 1
a35 7

#define S_AD_SZ     sizeof(struct sockaddr_in)
#define max(a,b)    (a>b ? a : b)
#define min(a,b)    (a<b ? a : b)
#define TRUE        1
#define FALSE       0
#define MKEYFILE    "/.k"
@


4.2
log
@Changed include files configuration and referencing.
@
text
@d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 4.1 87/09/01 14:16:47 steiner Locked $";
d371 1
a371 1
            if (!check_princ(p_name,(tgtflag ? "ATHENA.MIT.EDU" : instance),
@


4.1
log
@No change; starting version 4.
@
text
@d3 1
a3 1
 *  $Author: kubitron $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 3.7 87/07/02 17:58:01 steiner Locked $";
d29 3
a31 3
#include "../lib/krb/klog.h"
#include "prot.h"
#include "kerb_db.h"
@


3.7
log
@Remove 'long' return declaration from kerb_err_reply().  This
routine doesn't return anything anyway, and High C was complaining
because kerb_err_reply is never treated as if it returns long.
@
text
@d2 3
a4 3
 *  $Source: /source/4.3/athena.lib/kerberos/kdc/RCS/kerberos.c,v $
 *  $Author: wesommer $
 *  $Locker: kubitron $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 3.6 87/01/08 20:18:10 kubitron Locked $";
@


3.6
log
@change read_password to des_read_password
@
text
@d2 3
a4 3
 *  $Source: /source/kerberos/kdc/RCS/kerberos.c,v $
 *  $Author: jis $
 *  $Locker: wesommer $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 3.5 86/09/16 14:07:40 wesommer Locked $";
d697 1
a697 1
long    
@


3.5
log
@Added ability to run under "init". Master key now stored in "/.k"
Added the "-m" flag to get old behavior. 
@
text
@d2 3
a4 3
 *  $Source: /mit/projects/auth/src/kdc/RCS/kerberos.c,v $
 *  $Author: spm $
 *  $Locker: bcn $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 3.3 86/08/24 13:19:52 spm Exp $";
d171 1
a171 1
      read_password(master_key,"\nEnter current Kerberos master key: ",TRUE);
@


3.4
log
@Now supports inter-realm communications.
@
text
@d25 1
d42 1
d64 1
d89 2
d94 1
a94 1
char    *argv[];
d118 4
d140 10
a149 4
    if (n = kerb_init())
        {printf("\07\07Kerberos db and cache init failed = %d ...exiting\n",n);
        exit(1);
        }
d151 14
a164 9
     /* lookup the master key version */
     n = kerb_get_principal(KERB_M_NAME,KERB_M_INST,&s_name_data,1,&more);
     if (n != 1)
         {
         fprintf(stderr,
            "\07%s: error on master key version lookup, %d found, more = %d\n",
            progname,n,more);
        exit(-1);
        }
d170 16
a185 1
    read_password(master_key,"\nEnter current Kerberos master key: ",TRUE);
d199 11
a209 7
    if (n)
        {
        bzero(master_key_schedule,sizeof(master_key_schedule));
        fprintf(stderr,
        "\07\07%s: Invalid master key, does not match database\n",progname);
        exit(-1);
        }
d228 7
a234 3
    if ((child = fork()) != 0)
        {printf("Kerberos started, PID=%d\n",child);
         exit(0);}
a235 2
    setup_disc(); 

d811 5
@


3.3
log
@RT byte order no longer an error condition.
@
text
@d3 1
a3 1
 *  $Author: bcn $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 3.1 86/08/19 09:54:43 bcn Exp $";
d182 2
a183 4
    /* Set the key for rd_ap_req so we can check ticket granting tickets */
    n = kerb_get_principal("krbtgt",lclrlm,p,1,&more);
    if (n == 0)
        {
d187 1
a187 1
        }
a188 10

    /* unseal tgt key from master key             */
           bcopy(&p->key_low, key, 4);
           bcopy(&p->key_high, ((long *)key)+1, 4);
           pcbc_encrypt(key,key,(long) sizeof(key),
             master_key_schedule,
             master_key_schedule,DECRYPT);
    set_serv_key(key,0);


d481 1
a481 1
		     s_name_data.instance,"Athena",lifetime,
d508 1
a518 1
	 kerno = rd_ap_req(auth,"ktbtgt",lclrlm,client_host,ad,0);
d520 9
a532 1
	 /* Change the log message */
a551 5
	 if(!strcmp(service,"krbtgt"))
	   {kerb_err_reply(client,pkt,KERB_ERR_PRINCIPAL_UNKNOWN,
			  "Can't reissue ticket granting ticket");
	    return;}

d562 3
a564 1
	 lifetime = min(req_life,((u_long)s_name_data.max_life));
d578 1
a578 1
		       ((req_version == 3) ? "Athena" : lclrlm),
a599 1
/**** OK beyond this point *******/
d739 31
@


3.2
log
@Change a log message.
@
text
@a290 6
        /* not supported yet
         * send an error reply
         */
        lt = klog(L_KRB_PERR," Bad byte order %d",msg_byte_order,0);
        kerb_err_reply(client,pkt,KERB_ERR_BYTE_ORDER,lt);
        return;
@


3.1
log
@This version has support fo both version 3 and 4 of the protocol.
It also has the necessary hacks to rename the Athena realm into
ATHENA.MIT.EDU
@
text
@d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.22 86/08/11 10:34:04 bcn Exp $";
d543 2
a544 1
	 if(kerno) {klog(L_ERR_UNK,"rd_ap_req failed: %d",kerno);
@


1.22
log
@Now includes support for ticket granting tickets.
@
text
@a0 1

d3 1
a3 1
 *  $Author: spm $
d11 1
a11 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.21 86/05/12 21:21:05 spm Exp $";
d28 1
a28 1
#include "klog.h"
d72 1
d74 2
d172 1
a172 1
    fprintf(stdout,"\nmaster key entered.  BEWARE!\07\07\n");
d176 6
d183 1
a183 1
    n = kerb_get_principal("krbtgt","Athena",p,1,&more);
a234 1
/*** OK from here to next comment ***/
a250 1
/*** OK above this point ***/
d273 1
d276 1
a276 1
    if (req_version != KRB_PROT_VERSION )
d299 2
a300 1
    log("req_msg_typ = %d",req_msg_type);
d305 1
d307 1
d328 1
a328 1
	klog(L_TGT_REQ,"Login request Host: %s User: \'%s\' \'%s\'",
a336 2
        lt = klog("WS Timestamp: %s",stime(&req_time_ws));

d340 1
d343 4
d348 2
a349 1
            if (!check_princ(p_name,instance,lifetime,&s_name_data))
d366 1
a366 1
                        a_name_data.instance,"",client_host,
d369 1
a369 1
                        s_name_data.name,s_name_data.instance,
d377 1
a377 1
                s_name_data.name,s_name_data.instance,
d419 99
d536 1
d538 8
a545 2
	 kerno = rd_ap_req(auth,"ktbtgt","Athena",client_host,ad,0);
	 if(kerno) kerb_err_reply(client,pkt,kerno,"rd_ap_req failed");
d557 3
a559 2
	 log("APPL Request %s.%s@@%s for %s.%s",ad->pname,ad->pinst,ad->prealm,
	     service,instance);
d561 10
d572 2
a573 1
	 if(kerno) kerb_err_reply(client,pkt,kerno,lt);
d589 3
a591 1
	 create_ticket(tk,k_flags,ad->pname,ad->pinst,"",client_host,
d598 2
a599 1
	 create_ciph(ciph,session_key,service,instance,"Athena",
d604 3
a606 1
				  ad->prealm,time_ws,1,0,0,ciph);
d617 2
a618 2
        lt = klog"Host: %s User: \"%s\" \"%s\" Kerberos killed",
            inet_ntoa(client_host),req_name_ptr,req_inst_ptr);
d625 1
a625 1
	lt = klog("Unknown message type: %d from %s port %u",
d703 1
a703 1
         p_name,instance,lifetime,n);
@


1.21
log
@*** empty log message ***
@
text
@d1 1
d4 2
a5 5
 *  $Author: bcn $
 *  $Locker: spm $
 *      $Log:	kerberos.c,v $
 * Revision 1.20  86/03/14  17:43:29  bcn
 * Removed tlist from reply and clean up some of the mallocs.
d7 1
a7 56
 * Revision 1.19  86/03/14  15:29:32  spm
 * cleaned up ifdefs and print format
 * 
 * Revision 1.17  86/01/07  12:29:07  spm
 * changed cbc mode to pcbc mode
 * 
 * Revision 1.16  85/11/26  11:38:43  spm
 * changed set_key to des_set_key
 * 
 * Revision 1.15  85/11/24  14:04:44  bcn
 * Changed to run under 4.3:
 *   Arguments to setsock_opt changed.
 *   S_un.S_addr ==> s_addr.
 * 
 * Revision 1.14  85/11/17  19:25:26  bcn
 * Change #include "kerberos.h" -> #include <krb.h>
 * 
 * Revision 1.13  85/11/15  16:38:50  spm
 * more byte order
 * 
 * Revision 1.12  85/11/15  13:56:52  bcn
 * Pass tlist to create_auth_reply.
 * 
 * Revision 1.11  85/11/14  17:52:47  spm
 * more rev 2 protocol
 * 
 * Revision 1.10  85/11/14  15:44:15  spm
 * byte ordering
 * 
 * Revision 1.9  85/11/13  14:47:54  bcn
 * Upgrade to protocol version number 2.
 * 
 * Revision 1.8  85/11/13  10:58:09  bcn
 * Add null ("") realm in call to create_ticket.
 * 
 * Revision 1.7  85/11/05  17:04:28  spm
 * add time_kdc to end of cipher
 * 
 * Revision 1.6  85/10/23  17:12:17  spm
 * finish create ticket stuff, still need to add auth db
 * 
 * Revision 1.5  85/10/22  17:15:01  spm
 * added some of the ticket creation and encryption
 * 
 * Revision 1.4  85/10/21  18:31:40  spm
 * added check for exp_date
 * 
 * Revision 1.3  85/10/18  16:52:55  spm
 * add master key handling
 * 
 * Revision 1.2  85/10/16  11:55:12  spm
 * add real passwords 
 * 
 * Revision 1.1  85/10/10  11:01:11  bcn
 * Initial revision
 * 
a8 2
 * Copyright 1985 by the Massachusetts Institute of Technology
 *
d12 1
a12 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.20 86/03/14 17:43:29 bcn Exp $";
d14 1
a14 1
        "Copyright 1985 by the Massachusetts Institute of Technology";
a16 2


d28 2
a30 1
#include "des.h"
d33 1
a33 1
extern	int	errno;
d35 2
d38 2
a39 2
#define	max(a,b)	(a>b ? a : b)
#define	min(a,b)	(a<b ? a : b)
a44 1
int         debug = 0;
d53 2
a54 2
static  Principal  a_name_data;	/*for requesting user */
static  Principal  s_name_data;	/*for services requested*/
d59 4
a62 3
static	char	k_instance[INST_SZ];
static	char	log_text[128];
static	int		more;
d64 8
a71 8
/* fields within the received request packet							   */
static	u_char	 req_msg_type;
static	u_char	 req_version;
static	char	*req_name_ptr;
static	char	*req_inst_ptr;
static	char	*req_realm_ptr;
static	u_char	 req_no_req;
static	u_long	 req_time_ws;
d74 10
a83 10
/* statistics															   */
static	long	q_bytes;		/* current bytes remaining in queue		   */
static	long	q_n;			/* how many consecutive non-zero q_bytes   */
static	long	max_q_bytes;
static	long	max_q_n;
static	long	n_auth_req;
static	long	n_appl_req;
static	long	n_packets;
static	long	n_user;
static	long	n_server;
d91 2
a92 2
    int					on = 1;
    int         		child;
d94 2
a95 2
    int         		fromlen;
    static KTEXT_ST		pkt_st;
d97 3
d104 7
a110 7
	/* find our hostname, and use it as the instance					   */
	if (gethostname(k_instance,INST_SZ))
		{
		fprintf(stderr,"%s: gethostname error\n",prog);
		exit(1);
		}
	
a127 8
#ifdef  notdef
    if ((child = fork()) != 0)
        {printf("Kerberos started, PID=%d\n",child);
         exit(0);}

    setup_disc();
#endif

d173 27
a199 1
/* receive loop															   */
d202 1
a202 1
	  fromlen = S_AD_SZ;
d204 18
a221 25
	  if (n > 0)
		{
		pkt->length = n;
		pkt->mbz = 0;			/* force zeros to catch runaway strings */
		/* see what is left in the input que						   */
		ioctl(f,FIONREAD,&q_bytes);
		gettimeofday(&kerb_time,NULL);
		q_n++;
		max_q_n = max(max_q_n,q_n);
		n_packets++;
		sprintf(log_text,
			" q_byt %d, q_n %d, rd_byt %d, mx_q_b %d, mx_q_n %d, n_pkt %d",
			q_bytes,q_n,n,max_q_bytes,max_q_n,n_packets);
		max_q_bytes = max(max_q_bytes,q_bytes);
		new_log(kerb_time.tv_sec,log_text);
		if (!q_bytes) q_n = 0;	/* reset consecutive packets			   */
		kerberos(&from, pkt);
		}
	  else
		{
		sprintf(log_text,"%s: bad recvfrom n = %d errno = %d",
			  prog,n,errno);
		new_log(0,log_text);
		}
	}			  
d223 2
d227 2
d230 2
a231 2
struct sockaddr_in  *client;
KTEXT       pkt;
d233 23
a255 6
    static KTEXT_ST  	rpkt_data;
    KTEXT	      		rpkt = &rpkt_data;
    static KTEXT_ST		ciph_data;
    KTEXT	        	ciph = &ciph_data;
    static KTEXT_ST     tk_data;
    KTEXT 				tk = &tk_data;
a256 9
    static  long    	client_host;
    static  int     	msg_byte_order;
	static	int			swap_bytes;
	static	u_char		k_flags;
	char        	*p_name,*instance;
    u_long		  	lifetime;
    int         	i;
    C_Block     	key;
    Key_schedule   	key_s;
d258 1
d263 3
a265 3
/* eval macros and correct the byte order and alignment as needed		   */
	req_version = pkt_version(pkt);	/* 1 byte, version					   */
	req_msg_type = pkt_msg_type(pkt);	/* 1 byte, Kerberos msg type	   */
d267 1
d271 2
a272 3
		sprintf(log_text,
			" KRB protocol version mismatch: KRB =%d request = %d",
			KRB_PROT_VERSION,req_version);
d274 1
a274 2
        kerb_err_reply(client,pkt,KERB_ERR_PKT_VER,log_text);
        new_log(0,log_text);
d278 1
a278 1
	msg_byte_order = req_msg_type & 1;
d280 14
a293 13
	swap_bytes = 0;
	if (msg_byte_order != HOST_BYTE_ORDER )
		{
		swap_bytes++;
		/* not supported yet
		 * send an error reply
		 */
		sprintf(log_text," Bad byte order %d",msg_byte_order);
		kerb_err_reply(client,pkt,KERB_ERR_BYTE_ORDER,log_text);
		new_log(0,log_text);
		return;
		}
	
d297 4
a300 4
		{
		n_auth_req++;
		tk->length = 0;
		k_flags = 0;			/* various kerberos flags				   */
a301 11
/* set up and correct for byte order and alignment						   */
		req_name_ptr = (char *) pkt_a_name(pkt);
		req_inst_ptr = (char *) pkt_a_inst(pkt);
		req_realm_ptr =(char *) pkt_a_realm(pkt);
		req_no_req  = pkt_no_req(pkt);	/* number of requests, 1 byte */	
		bcopy(pkt_time_ws(pkt),&req_time_ws,sizeof(req_time_ws));
		/* time has to be diddled										   */
		if (swap_bytes)	
			{
			swap_u_long(req_time_ws);
			}
d303 11
a313 2
		rpkt = &rpkt_data;
		create_cipher(req_no_req,ciph);
d315 2
a316 4
		sprintf(log_text,
			" Login request Host: %s User: \'%s\' \'%s\'",
			inet_ntoa(client_host), req_name_ptr, req_inst_ptr);
		new_log(0,log_text);
d318 2
a319 5
		if (i = check_princ(req_name_ptr,req_inst_ptr,0,&a_name_data))
			{
			kerb_err_reply(client,pkt,i,log_text);
			return;
			}
d321 5
d327 1
a327 2
		sprintf(log_text," WS Timestamp: %s",stime(&req_time_ws));
		new_log(0,log_text);
d329 3
a331 3
		/* loop through the ticket requests                           */
		for (i=1;i<=req_no_req;i++)
			{
d334 2
a335 2
			/* this does all the checking								   */
			if (!check_princ(p_name,instance,lifetime,&s_name_data))
d339 1
a339 1
				   		((u_long)s_name_data.max_life));
d348 1
a348 1
					master_key_schedule,
d352 3
a354 3
						a_name_data.instance,"",client_host,
                    	session_key,lifetime,
                    	kerb_time.tv_sec,
d362 2
a363 2
			add_ticket(ciph,i,session_key,lifetime,
				s_name_data.name,s_name_data.instance,
d368 1
a368 1
            }					/* end ticket request loop				   */
d390 1
a390 1
			 	ENCRYPT);
d397 3
a399 3
									req_realm_ptr,
			 	req_time_ws,req_no_req,
				a_name_data.key_version,ciph);
d401 2
a402 2
		 bzero(&a_name_data,sizeof(a_name_data));
		 bzero(&s_name_data,sizeof(s_name_data));
d404 22
a425 1
		 }
d427 51
d479 3
a481 4
		{
		sprintf(log_text," Host: %s User: \'%s\' \'%s\' Kerberos killed",
		 	inet_ntoa(client_host),req_name_ptr,req_inst_ptr);
        new_log(0,log_text);
d483 2
a484 1
		}
d487 3
a489 4
		{
		sprintf(log_text," Unknown message type: %d from %s port %u",
			req_msg_type,inet_ntoa(client_host),ntohs(client->sin_port));
        new_log(0,log_text);
d491 1
a491 1
		}
a495 1

d500 1
a500 1
 * group that spawned us
d504 2
a505 1
{
d523 1
a523 1
    (void) chdir("/dev");
d528 6
a533 1
long    kerb_err_reply(client,pkt,err,string)
d536 1
a536 1
    KTEXT		pkt;
d541 3
a543 6
    /* this routine create an error reply packet and sends it to the client
     * pointed to.
     */
     	static	KTEXT_ST	e_pkt_st;
	KTEXT			e_pkt = &e_pkt_st;
	static	char	e_msg[128];
d545 4
a548 4
	 strcpy(e_msg,"\nKerberos error -- ");
	 strcat(e_msg,string);
     cr_err_reply(e_pkt,req_name_ptr,req_inst_ptr,
							req_realm_ptr,req_time_ws,err,e_msg);
d555 2
a556 2
char	*p_name;
char	*instance;
d559 1
a559 1
Principal	*p;
d561 2
a562 2
	static	int	n;
	static	int more;
d564 15
a578 19
	n = kerb_get_principal(p_name,instance,p,1,&more);
	sprintf(log_text,
		" Principal: \'%s\', Instance: \'%s\' Lifetime = %d n = %d",
		p_name,instance,lifetime,n);
	new_log(0,log_text);
                
	/* if more than one p_name, pick one randomly
	 * create a session key, 
	 * compute maximum lifetime, lookup authorizations if
	 * applicable, and stuff into cipher.
	 */
	if (n == 0)
		{
		/* service unknown, log error, skip to next request	   */
		sprintf(log_text," UNKNOWN \'%s\' \'%s\'",
		p_name,instance);
		new_log(0,log_text);
		return KERB_ERR_PRINCIPAL_UNKNOWN;
		}
d580 7
d588 6
a593 7
	if (more)
		{
		/* not unique, log error					   */
		sprintf(log_text," NOT UNIQUE principal \'%s\' \'%s\'");
		new_log(0,log_text);
		return KERB_ERR_PRINCIPAL_NOT_UNIQUE;
		}
d595 7
a601 10
	if (master_key_version != p->kdc_key_ver)
		{
		/* log error reply                               */
		sprintf(log_text,
		" KRB key version mismatch, KRB = %d, \'%s\' \'%s\' = %d",
		master_key_version,p->name,
		p->instance,p->kdc_key_ver);
		new_log(0,log_text);
		return KERB_ERR_NAME_MAST_KEY_VER;
		}
d603 8
a610 10
	/* make sure the service hasn't expired               */
	if ((u_long) p->exp_date < 	(u_long) kerb_time.tv_sec )
		{
		/* service did expire, log it							   */
		sprintf(log_text," EXPIRED \'%s\' \'%s\'  %s",
		p->name, p->instance,
		stime(&(p->exp_date)));
		new_log(0,log_text);
		return KERB_ERR_NAME_EXP;
		}
d612 2
a613 2
	/* ok is zero												   */
	return 0;
@


1.20
log
@Removed tlist from reply and clean up some of the mallocs.
@
text
@d3 2
a4 2
 *  $Author: spm $
 *  $Locker:  $
d6 3
d71 1
a71 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.19 86/03/14 15:29:32 spm Exp $";
d122 10
d149 2
a150 2
    int			on = 1;
    int         	child;
d152 2
a153 2
    int         	fromlen;
    static KTEXT_ST	pkt_st;
d198 1
a198 1
     n = kerb_get_principal(KERB_M_NAME,KERB_M_INST,s_name_data,1,&more);
d244 1
d274 3
a276 3
    KTEXT	      	rpkt = &rpkt_data;
    static KTEXT_ST	ciph_data;
    KTEXT	        ciph = &ciph_data;
d278 1
a278 1
    KTEXT 		tk = &tk_data;
d283 2
a284 1
    char        	*p_name,*instance;
d293 7
a299 2
    /* check packet version                                                */
    if (pkt_version(pkt) != KRB_PROT_VERSION )
d303 1
a303 1
			KRB_PROT_VERSION,pkt_version(pkt));
d310 1
a310 1
	msg_byte_order = pkt_msg_type(pkt) & 1;
d325 1
a325 1
    switch(pkt_msg_type(pkt) & ~1) { 
d331 14
d346 1
a346 1
		create_cipher(pkt_no_req(pkt),ciph);
d350 1
a350 1
			inet_ntoa(client_host), pkt_a_name(pkt), pkt_a_inst(pkt));
d353 1
a353 1
		if (i = check_princ(pkt_a_name(pkt),pkt_a_inst(pkt),0,&a_name_data))
d360 1
a360 1
		sprintf(log_text," WS Timestamp: %s",stime(pkt_time_ws(pkt)));
d364 1
a364 1
		for (i=1;i<=pkt_no_req(pkt);i++)
d385 1
a385 1
                  create_ticket(tk,a_name_data.name,
d428 1
d430 3
a432 3
         rpkt = create_auth_reply(pkt_a_name(pkt),pkt_a_inst(pkt),
									pkt_a_realm(pkt),
			 	pkt_time_ws(pkt),pkt_no_req(pkt),
d443 1
a443 1
		 	inet_ntoa(client_host),pkt_a_name(pkt),pkt_a_inst(pkt));
d451 1
a451 1
			pkt_msg_type(pkt),inet_ntoa(client_host),ntohs(client->sin_port));
d508 2
a509 3
	 strcat(e_msg,"\n");
     cr_err_reply(e_pkt,pkt_a_name(pkt),pkt_a_inst(pkt),
							pkt_a_realm(pkt),pkt_time_ws(pkt),err,e_msg);
d571 1
a571 1
		stime(p->exp_date));
@


1.19
log
@cleaned up ifdefs and print format
@
text
@d4 1
a4 1
 *  $Locker: spm $
d6 3
d68 1
a68 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.17 86/01/07 12:29:07 spm Exp $";
d140 2
a141 1
    PACKT               pkt = (PACKT) malloc(sizeof(PKT_ST));
d257 1
a257 1
struct packet       *pkt;
d259 2
a260 2
    static PKT_ST  	rpkt_data;
    static PACKT      	rpkt;
d262 1
a262 3
    static KTEXT        ciph = &ciph_data;
    static KTEXT_ST	tlist_data;
    static KTEXT	tlist = &tlist_data;
d264 1
a264 1
    static KTEXT        tk = &tk_data;
a275 1
    tlist->length = 0;
d362 1
a362 1
			add_ticket(tlist,ciph,i,session_key,lifetime,
d364 1
a364 1
                s_name_data.key_version,"",tk);
d397 1
a397 1
			 	pkt_time_ws(pkt),pkt_no_req(pkt),tlist, 
d459 1
a459 1
    struct packet       *pkt;
d467 2
a468 1
	static	PACKT	e_pkt;
a470 1
	 if (e_pkt == NULL)    e_pkt = (PACKT) malloc(sizeof(PKT_ST));
@


1.18
log
@fixed for new names, works.
@
text
@a104 1
#define MAX_P_NAME  10
d106 2
a107 2
static  Principal  a_name_data;
static  Principal  p_name_data[MAX_P_NAME];
d114 1
d145 1
a145 1
		fprintf(stderr,"\n%s: gethostname error",prog);
d176 1
a176 1
        {printf("\n\07\07Kerberos db and cache init failed = %d ...exiting",n);
d181 1
a181 1
     n = kerb_get_principal(KERB_M_NAME,KERB_M_INST,p_name_data,MAX_P_NAME);
d185 2
a186 2
            "\n\07\07%s: error on master key version lookup, %d found",
            progname,n);
d191 1
a191 1
    master_key_version = p_name_data[0].kdc_key_ver;
d200 2
a201 2
     bcopy(&p_name_data[0].key_low, session_key, 4);
     bcopy(&p_name_data[0].key_high, ((long *)session_key)+1, 4);
d212 1
a212 1
        "\n\07\07%s: Invalid master key, does not match database",progname);
d216 1
a216 1
    fprintf(stdout,"\nmaster key entered.  BEWARE!\07\07");
a269 1
    int         	n;
d318 1
a318 1
		if (n = check_princ(pkt_a_name(pkt),pkt_a_inst(pkt),0,&a_name_data))
d320 1
a320 1
			kerb_err_reply(client,pkt,n,log_text);
a323 16
#ifdef	notdef
		/*  look up the a_name specified                                  */
		n = kerb_get_principal((pkt_a_name(pkt)),pkt_a_inst(pkt),&a_name_data,1);
#ifdef	notdef
		sprintf(log_text," get_name \'%s\' \'%s\' found = %d",pkt_a_name(pkt),
		pkt_a_inst(pkt),n);
		new_log(0,log_text);
#endif
		/* We want exactly one answer, user not expired, 
		* and correct master key version
		*/
		if (!n)
			{
			/* If there is no such name, could map it to some default based on
			* net address, but not currently.  TODO.
			*/
a324 44
			sprintf(log_text," Principal \'%s\' \'%s\' unknown",
				pkt_a_name(pkt),pkt_a_inst(pkt));
				kerb_err_reply(client,pkt,KERB_ERR_PRINCIPAL_UNKNOWN,log_text);
			new_log(0,log_text);
			return;
			}			 

		if ( n != 1 )
			{
			sprintf(log_text," Principal \'%s\' \'%s\' not unique",
			pkt_a_name(pkt),pkt_a_inst(pkt));
			kerb_err_reply(client,pkt,KERB_ERR_PRINCIPAL_NOT_UNIQUE,log_text);
			new_log(0,log_text);
			return;
			}			 

		/*  make sure we are using the same master key  */
		if (master_key_version != a_name_data.kdc_key_ver)
			{
			sprintf(log_text,
				" KRB key version mismatch, KRB = %d, \'%s\' \'%s\' = %d",
				master_key_version,a_name_data.name,a_name_data.instance,
				a_name_data.kdc_key_ver);
			/* send error reply                                       */
			kerb_err_reply(client,pkt,KERB_ERR_NAME_MAST_KEY_VER,log_text);
			new_log(0,log_text);
			return;
			}
             
		/* make sure the name hasn't expired                          */
		if ((u_long) a_name_data.exp_date < 
			(u_long)  kerb_time.tv_sec )
			/* user has expired, dont give tickets*/
			{
			/* send an error reply                                    */
			sprintf(log_text," Principal \'%s\' \'%s\' expired %s",
				a_name_data.name,a_name_data.instance,
			stime(&a_name_data.exp_date));
			kerb_err_reply(client,pkt,KERB_ERR_NAME_EXP,log_text);
			new_log(0,log_text);
			return; 
			}           
#endif

a332 56

#ifdef	notdef
            /* look up p_name and instance in the service db. */ 
            n = kerb_get_principal(p_name,instance,p_name_data,MAX_P_NAME);
            sprintf(log_text,
			" Service: \'%s\', Instance: \'%s\' Lifetime = %d n = %d",
            	p_name,instance,lifetime,n);
            new_log(0,log_text);
                
             /* if more than one p_name, pick one randomly
              * create a session key, 
              * compute maximum lifetime, lookup authorizations if
              * applicable, and stuff into cipher.
              */
			if (n == 0)
                 {
                 /* service unknown, log error, skip to next request	   */
				 sprintf(log_text," Service \'%s\' \'%s\' Unknown",
					 p_name,instance);
				 new_log(0,log_text);
	           	}


			if (n > 1)
                 {
                 /* not unique, log error, pick first					   */
				 sprintf(log_text," Service \'%s\' \'%s\' not unique");
				 new_log(0,log_text);
	           	}

			n = 0;				/* just use the first one anyhow		   */

		    if (master_key_version != p_name_data[n].kdc_key_ver)
                {
                /* log error reply                               */
				sprintf(log_text,
				" KRB key version mismatch, KRB = %d, \'%s\' \'%s\' = %d",
					master_key_version,p_name_data[n].name,
					p_name_data[n].instance,p_name_data[n].kdc_key_ver);
                    new_log(0,log_text);
                }
             
             /* make sure the service hasn't expired               */
             if ((u_long) p_name_data[n].exp_date < 
                 (u_long) kerb_time.tv_sec )
				  {
				  /* service did expire, log it							   */
				  sprintf(log_text," Service \'%s\' \'%s\' expired %s",
				  	p_name_data[n].name, p_name_data[n].instance,
					stime(p_name_data[n].exp_date));
				  new_log(0,log_text);
				  }

             else      /* service has NOT expired, give tickets*/
#endif
			n = 0;
d334 1
a334 1
			if (!check_princ(p_name,instance,lifetime,&p_name_data))
d338 1
a338 1
				   		((u_long)p_name_data[n].max_life));
d344 2
a345 2
                  bcopy(&p_name_data[n].key_low, key, 4);
                  bcopy(&p_name_data[n].key_high, ((long *)key)+1, 4);
d354 1
a354 1
                        p_name_data[n].name,p_name_data[n].instance,
d362 2
a363 2
				p_name_data[n].name,p_name_data[n].instance,
                p_name_data[n].key_version,"",tk);
d400 1
a400 1
		 bzero(&p_name_data,sizeof(p_name_data));
d406 2
a407 2
		sprintf(log_text," Host: User: %-8s %-8s Kerberos killed",
		 	pkt_a_name(pkt),pkt_a_inst(pkt));
d414 2
a415 1
		sprintf(log_text," Unknown message type: %d",pkt_msg_type(pkt));
d472 1
d488 3
a490 1
	n = kerb_get_principal(p_name,instance,p,MAX_P_NAME);
d511 1
a511 1
	if (n > 1)
d513 1
a513 1
		/* not unique, log error, pick first					   */
a518 2
	n = 0;				/* just use the first one anyhow		   */

d531 1
a531 2
	if ((u_long) p->exp_date < 
	(u_long) kerb_time.tv_sec )
@


1.17
log
@changed cbc mode to pcbc mode
@
text
@d6 3
d65 1
a65 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.16 85/11/26 11:38:43 spm Exp $";
d84 2
a85 2
#include "/projects/auth/include/des.h"
#include "/projects/auth/include/kerb_db.h"
d87 2
d90 2
a91 1
#define min(a,b)    (a<b? a : b)
a96 1
char            buff[BUFSIZ];
d105 1
a105 1
#define MAX_S_NAME  10
d107 2
a108 2
static  A_name  a_name_data;
static  S_name  s_name_data[MAX_S_NAME];
d112 3
a114 1
static  unsigned char   master_key_version;
d116 11
d142 7
d150 1
a150 1
       {fprintf(stderr,"Kerberos: udp/kerberos unknown service\n");
d156 1
a156 1
       {fprintf(stderr,"Kerberos: Can't open socket\n");
d160 1
a160 1
        fprintf(stderr,"Kerberos: setsockopt (SO_REUSEADDR)\n");
d163 1
a163 1
       {fprintf(stderr,"Kerberos: Can not bind socket\n");
d181 1
a181 1
     n = kerb_get_service(KERB_SERVICE,KERB_INSTANCE,s_name_data,MAX_S_NAME);
d191 1
a191 1
    master_key_version = s_name_data[0].auth_key_ver;
d195 1
a195 1
    des_set_key(master_key,master_key_schedule);
d200 4
a203 4
     bcopy(&s_name_data[0].key_low, session_key, 4);
     bcopy(&s_name_data[0].key_high, ((long *)session_key)+1, 4);
     pcbc_encrypt(session_key,session_key,sizeof(session_key),
                master_key_schedule, master_key_schedule,0);
d219 1
d221 27
a247 1
      {n = 0;
a248 8
       while (n <= 0)
          {fromlen = S_AD_SZ;
           n = recvfrom(f, buff, BUFSIZ, 0, &from, &fromlen);}

       bcopy(buff,pkt->dat,n);
       pkt->length = n;
       kerberos(&from, pkt);}

a263 2
    static  short   	perm = 0;
    static  short   	quota = 0;
d266 3
a268 2
    char        	*s_name,*instance;
    int         	lifetime;
d272 1
a272 1
    Key_schedule    	key_s;
a275 1
    gettimeofday(&kerb_time,NULL);
d281 3
d285 2
a286 3
        kerb_err_reply(client,pkt,KERB_ERR_PKT_VER,
        "Bad request protocol version",pkt_version(pkt));
        log("Bad version number: %d",pkt_version(pkt));
d292 1
d295 1
d299 3
a301 3
		kerb_err_reply(client,pkt,KERB_ERR_BYTE_ORDER,
			"Alternate byte order not supported yet",msg_byte_order);
		log("Bad byte order %d",msg_byte_order);
d308 5
d314 4
a317 3
         tk->length = 0;
         rpkt = &rpkt_data;
         create_cipher(pkt_no_req(pkt),ciph);
d319 5
a323 3
         /*  look up the a_name specified                                  */
         n = kerb_get_name((pkt_a_name(pkt)),&a_name_data,1);
         log(". get_name %s found = %d",pkt_a_name(pkt),n);
d325 16
a340 3
         /* If there is no such name, can map it to some default based on
          * net address.  TODO.
          */
d342 28
a369 20
         /* We want exactly one answer, user not expired, 
          * and correct master key version
          */
         if ( (n == 1))
             {
             log("Host: User: %-8s Login request...", pkt_a_name(pkt));
             log(".  Timestamp: %s",stime(pkt_time_ws(pkt)));
                /*  make sure we are using the same master key  */
                if (master_key_version != a_name_data.auth_key_ver)
                 {
                 fprintf(stderr,
                "\n\07\07bad master key version, kerberos = %d, a_name = %d",
                 master_key_version,a_name_data.auth_key_ver);
                 /* send error reply                                       */
                 kerb_err_reply(client,pkt,KERB_ERR_NAME_MAST_KEY_VER,
                    "bad master key version",a_name_data.auth_key_ver);
                 log(".  bad master key version: %d",
                     a_name_data.auth_key_ver);
                 return;
                 }
d371 14
a384 12
             /* make sure the name hasn't expired                          */
            if ((unsigned long ) a_name_data.exp_date < 
                (unsigned long)  kerb_time.tv_sec )
                /* user has expired, dont give tickets*/
                {
                /* send an error reply                                    */
                kerb_err_reply(client,pkt,KERB_ERR_NAME_EXP,
                    "Athena name expired at 0x",a_name_data.exp_date);
                    
                log(". a_name expired at 0x%X",a_name_data.exp_date);
                return; 
                }           
d386 23
a408 2
             /* loop through the ticket requests                           */
             for (i=1;i<=pkt_no_req(pkt);i++)
d410 6
a415 7
                 lifetime = get_request(pkt,i,&s_name,&instance);
                 /* look up s_name and instance in the service db. */ 
                 n = kerb_get_service(s_name,instance,s_name_data,MAX_S_NAME);
                 log(".  Life: %d, Service: %s, Instance: %s",
                     lifetime,s_name,instance);
                
                 tk->length = 0;    /* init                                */
d417 18
a434 23
                 /* if more than one s_name, pick one, TODO
                  * create a session key, 
                  * compute maximum lifetime, lookup authorizations if
                  * applicable, and stuff into cipher.
                  */
                 --n;
                 if (n >= 0)
                    {
                    /* select the best one of the n !!                     */
                    n = 0;      /* TODO                                    */
                        
                    if (master_key_version != s_name_data[n].auth_key_ver)
                         {
                         fprintf(stderr,
                "\n\07\07bad master key version, kerberos = %d, s_name = %d",
                         master_key_version,s_name_data[n].auth_key_ver);
                         /* send error reply                               */
                     kerb_err_reply(client,pkt,KERB_ERR_SERV_MAST_KEY_VER,
                    "bad master key version",s_name_data[n].auth_key_ver);
                         log(".  bad master key version: %d",
                         s_name_data[n].auth_key_ver);
                         return;
                         }
d436 10
a445 10
                     /* make sure the service hasn't expired               */
                    if ((unsigned long) s_name_data[n].exp_date >= 
                        (unsigned long) kerb_time.tv_sec )
                        /* service has NOT expired, give tickets*/
                        {
                        /* Bound requested lifetime with service max       */
                        lifetime = min(lifetime,s_name_data[n].max_life);
        
                        /* random session key                              */
                         random_key(session_key);
d447 12
a458 26
                        /* set default perm and quotas
                         * TODO
                         */
                        
                        /* if this service has athena-managed authorizations
                         * look them up
                         */
                        if (s_name_data[n].attributes & KERB_S_ATT_AUTH_DB)
                            {
                            /* TODO -- look up in db/cache                 */
                            }
                        /* unseal server's key from master key             */
                        bcopy(&s_name_data[n].key_low, key, 4);
                        bcopy(&s_name_data[n].key_high, ((long *)key)+1, 4);
                        pcbc_encrypt(key,key,sizeof(key),master_key_schedule,
                            master_key_schedule,0);
                        /* construct and seal the ticket                   */
                        create_ticket(tk,a_name_data.a_name,"",client_host,
                            session_key,perm,quota,lifetime,
                            kerb_time.tv_sec,
                            s_name_data[n].s_name,s_name_data[n].s_instance,
                            key);
                        bzero(key,sizeof(key));
                        bzero(key_s,sizeof(key_s));
                        }
                    }
d460 16
a475 4
                /* add ticket to cipher, even if null                      */
                add_ticket(tlist,ciph,i,session_key,lifetime,
			s_name_data[n].s_name,s_name_data[n].s_instance,
                        s_name_data[n].key_version,tk);
d477 4
a480 3
                /* clear session key                                       */
                bzero(session_key,sizeof(session_key));
                }
d482 4
d502 5
a506 4
             pcbc_encrypt(key,key,sizeof(key),master_key_schedule,
                 master_key_schedule,0);
             des_set_key(key,key_s);
             pcbc_encrypt(ciph->dat,ciph->dat,ciph->length,key_s,key,1);
a507 6
             }
         else
             {
             /* just null cipher length since name is unknown              */
             ciph->length = 0;
             }  
d509 1
d511 4
a514 3
         rpkt = create_auth_reply(pkt_a_name(pkt),pkt_a_realm(pkt),
	 	pkt_time_ws(pkt),pkt_no_req(pkt),tlist, 
		a_name_data.key_version,ciph);
d516 2
a517 1

d519 2
a520 1

d522 6
a527 3
         log("Host: User: %-8s Kerberos killed",pkt_a_name(pkt));
             exit(0);
             break;
d530 5
a534 3
             log("Unknown message type: %d",pkt_msg_type(pkt));
         break;

d539 1
d571 1
a571 1
long    kerb_err_reply(c,p,err,string,val)
d573 2
a574 2
    struct sockaddr_in  *c;
    struct packet       *p;
a576 1
    long                val;
a580 1
     * TODO
d582 10
d595 65
@


1.16
log
@changed set_key to des_set_key
@
text
@d3 1
a3 1
 *  $Author: bcn $
d6 3
d62 1
a62 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.15 85/11/24 14:04:44 bcn Exp $";
d177 1
a177 1
     cbc_encrypt(session_key,session_key,sizeof(session_key),
d369 1
a369 1
                        cbc_encrypt(key,key,sizeof(key),master_key_schedule,
d407 1
a407 1
             cbc_encrypt(key,key,sizeof(key),master_key_schedule,
d410 1
a410 1
             cbc_encrypt(ciph->dat,ciph->dat,ciph->length,key_s,key,1);
@


1.15
log
@Changed to run under 4.3:
  Arguments to setsock_opt changed.
  S_un.S_addr ==> s_addr.
@
text
@d4 1
a4 1
 *  $Locker: bcn $
d6 5
d59 1
a59 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.14 85/11/17 19:25:26 bcn Exp $";
d167 1
a167 1
    set_key(master_key,master_key_schedule);
d406 1
a406 1
             set_key(key,key_s);
@


1.14
log
@Change #include "kerberos.h" -> #include <krb.h>
@
text
@d3 1
a3 1
 *  $Author: spm $
d6 3
d54 1
a54 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.13 85/11/15 16:38:50 spm Exp $";
d107 2
a108 1
    int         child;
d110 1
a110 1
    int         fromlen;
d126 1
a126 1
    if (setsockopt(f, SOL_SOCKET, SO_REUSEADDR, 0, 0) < 0)
d141 1
a141 1
/* do all the database and cache inits                     */
d147 1
a147 1
        /* lookup the master key version                                       */
d157 1
a157 1
/* set up the master key                                                   */
d205 6
a210 6
    static TEXT_ST	ciph_data;
    static TEXT         ciph = &ciph_data;
    static TEXT_ST	tlist_data;
    static TEXT		tlist = &tlist_data;
    static TEXT_ST      tk_data;
    static TEXT         tk = &tk_data;
d212 10
a221 10
    static  short   perm = 0;
    static  short   quota = 0;
    static  long    client_host;
	static	int		msg_byte_order;
    char        *s_name,*instance;
    int         lifetime;
    int         i;
    int         n;
    C_Block     key;
    Key_schedule    key_s;
d227 1
a227 1
    client_host = client->sin_addr.S_un.S_addr;
@


1.13
log
@more byte order
@
text
@d3 2
a4 2
 *  $Author: bcn $
 *  $Locker: spm $
d6 3
d51 1
a51 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.12 85/11/15 13:56:52 bcn Exp $";
d68 1
a68 1
#include "kerberos.h"
@


1.12
log
@Pass tlist to create_auth_reply.
@
text
@d3 2
a4 2
 *  $Author: spm $
 *  $Locker:  $
d6 3
d48 1
a48 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.11 85/11/14 17:52:47 spm Exp $";
d233 1
a233 1
	if (msg_byte_order != byte_order())
@


1.11
log
@more rev 2 protocol
@
text
@d4 1
a4 1
 *  $Locker: spm $
d6 3
d45 1
a45 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.10 85/11/14 15:44:15 spm Exp $";
d403 2
a404 1
		 		pkt_time_ws(pkt),n,"", a_name_data.key_version,ciph);
@


1.10
log
@byte ordering
@
text
@d3 1
a3 1
 *  $Author: bcn $
d6 3
d42 1
a42 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.9 85/11/13 14:47:54 bcn Exp $";
d227 1
a227 1
	if (msg_byte_order != HOST_BYTE_ORDER)
d334 1
a334 1
                        /* set default prem and quotas
d399 2
a400 2
         rpkt = create_auth_reply(pkt_a_name(pkt),pkt_time_ws(pkt),
              a_name_data.key_version,ciph);
@


1.9
log
@Upgrade to protocol version number 2.
@
text
@d4 5
a8 2
 *  $Locker: bcn $
 *      $Log:   kerberos.c,v $
d39 1
a39 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.8 85/11/13 10:58:09 bcn Exp $";
d199 1
d222 14
a235 1
    switch(pkt_msg_type(pkt)) { 
@


1.8
log
@Add null ("") realm in call to create_ticket.
@
text
@d2 7
a8 4
 * 	$Source: /mit/projects/auth/src/kdc/RCS/kerberos.c,v $
 * 	$Author: spm $
 * 	$Locker: bcn $
 *    	$Log:	kerberos.c,v $
d36 1
a36 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.7 85/11/05 17:04:28 spm Exp $";
d38 2
a39 2
	    "Copyright 1985 by the Massachusetts Institute of Technology";
#endif	lint
d58 4
a61 4
#define S_AD_SZ 	sizeof(struct sockaddr_in)
#define	min(a,b)	(a<b? a : b)
#define	TRUE		1
#define	FALSE		0
d63 4
a66 4
struct 	sockaddr_in	sin = { AF_INET };
int			f;
char			buff[BUFSIZ];
int			debug = 0;
d68 2
a69 2
char	prog[32];
char	*progname = prog;
d71 2
a72 2
static	Key_schedule	master_key_schedule;
static	C_Block			master_key;
d74 8
a81 8
#define	MAX_S_NAME	10
static	struct timeval	kerb_time;
static	A_name	a_name_data;
static	S_name	s_name_data[MAX_S_NAME];
static	C_Block	session_key;
static	C_Block	user_key;
static	C_Block	service_key;
static	unsigned char	master_key_version;
d84 2
a85 2
int	argc;
char	*argv[];
d87 6
a92 6
	struct sockaddr_in	from;
	register int		n;
	int			child;
	struct servent		*sp;
	int			fromlen;
	PACKT		        pkt = (PACKT) malloc(sizeof(PKT_ST));
d94 2
a95 2
	strcpy(prog,argv[0]);
	prog[31] = '\0';
d97 3
a99 3
	if ((sp = getservbyname("kerberos","udp")) == 0)
	   {fprintf(stderr,"Kerberos: udp/kerberos unknown service\n");
	    exit(1);}
d101 1
a101 1
	sin.sin_port = sp->s_port;
d103 3
a105 3
	if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
	   {fprintf(stderr,"Kerberos: Can't open socket\n");
	    exit(1);}
d107 2
a108 2
	if (setsockopt(f, SOL_SOCKET, SO_REUSEADDR, 0, 0) < 0)
	    fprintf(stderr,"Kerberos: setsockopt (SO_REUSEADDR)\n");
d110 3
a112 3
	if (bind(f, &sin, S_AD_SZ, 0) < 0) 
	   {fprintf(stderr,"Kerberos: Can not bind socket\n");
	    exit(1);}
d114 4
a117 4
#ifdef	notdef
	if ((child = fork()) != 0)
		{printf("Kerberos started, PID=%d\n",child);
		 exit(0);}
d119 1
a119 1
	setup_disc();
d122 22
a143 22
/* do all the database and cache inits					   */
	if (n = kerb_init())
		{printf("\n\07\07Kerberos db and cache init failed = %d ...exiting",n);
		exit(1);
		}
	
		/* lookup the master key version									   */
	 n = kerb_get_service(KERB_SERVICE,KERB_INSTANCE,s_name_data,MAX_S_NAME);
	 if (n != 1)
		 {
		 fprintf(stderr,
			"\n\07\07%s: error on master key version lookup, %d found",
			progname,n);
		exit(-1);
		}
		
/* set up the master key												   */
	master_key_version = s_name_data[0].auth_key_ver;
	fprintf(stdout,"\nCurrent Kerberos master key version is %d",
		master_key_version);
	read_password(master_key,"\nEnter current Kerberos master key: ",TRUE);
	set_key(master_key,master_key_schedule);
d145 21
a165 21
	/* now use the master key to decrypt the key in the db, had better be
	 * the same!
	 */
	 bcopy(&s_name_data[0].key_low, session_key, 4);
	 bcopy(&s_name_data[0].key_high, ((long *)session_key)+1, 4);
	 cbc_encrypt(session_key,session_key,sizeof(session_key),
				master_key_schedule, master_key_schedule,0);
	/* the decrypted database key had better equal the master key		   */
	n = bcmp((char *) master_key, (char *) session_key, sizeof(master_key));
	bzero(master_key,sizeof(master_key));	
	bzero(session_key,sizeof(session_key));	
	if (n)
		{
		bzero(master_key_schedule,sizeof(master_key_schedule));
		fprintf(stderr,
		"\n\07\07%s: Invalid master key, does not match database",progname);
		exit(-1);
		}
	
	fprintf(stdout,"\nmaster key entered.  BEWARE!\07\07");
	fflush(stdout);
d167 2
a168 2
	for(;;)
	  {n = 0;
d170 3
a172 3
	   while (n <= 0)
	      {fromlen = S_AD_SZ;
	       n = recvfrom(f, buff, BUFSIZ, 0, &from, &fromlen);}
d174 3
a176 3
	   bcopy(buff,pkt->dat,n);
	   pkt->length = n;
	   kerberos(&from, pkt);}
d181 2
a182 2
struct sockaddr_in	*client;
struct packet		*pkt;
d184 18
a201 14
    static	PKT_ST	rpkt_data;
	PACKT		rpkt;
    TEXT		ciph;
	static struct 	text	tk_data;
    static TEXT		tk = &tk_data;
	static  short	perm = 0;
	static	short	quota = 0;
	static	long	client_host;
    char		*s_name,*instance;
    int			lifetime;
    int			i;
	int			n;
    C_Block		key;
    Key_schedule	key_s;
d203 3
a205 1
	gettimeofday(&kerb_time,NULL);
d207 11
a217 11
	client_host = client->sin_addr.S_un.S_addr;
	/* check packet version												   */
	if (pkt_version(pkt) != KRB_PROT_VERSION )
		{
		/*  send an error reply 							   */
		kerb_err_reply(client,pkt,KERB_ERR_PKT_VER,
		"Bad request protocol version",pkt_version(pkt));
		log("Bad version number: %d",pkt_version(pkt));
		return;
		}
		
d220 1
a220 1
	case AUTH_MSG_KDC_REQUEST:
d222 1
a222 1
		 tk->length = 0;
d224 1
a224 1
	     ciph = create_cipher(pkt_no_req(pkt));
d226 3
a228 3
		 /*  look up the a_name specified								   */
		 n = kerb_get_name((pkt_a_name(pkt)),&a_name_data,1);
		 log(". get_name %s found = %d",pkt_a_name(pkt),n);
d230 3
a232 3
		 /* If there is no such name, can map it to some default based on
		  * net address.  TODO.
		  */
d234 33
a266 33
		 /* We want exactly one answer, user not expired, 
		  * and correct master key version
		  */
		 if ( (n == 1))
			 {
		     log("Host: User: %-8s Login request...", pkt_a_name(pkt));
		     log(".  Timestamp: %s",stime(pkt_time_ws(pkt)));
				/*  make sure we are using the same master key	*/
				if (master_key_version != a_name_data.auth_key_ver)
				 {
				 fprintf(stderr,
				"\n\07\07bad master key version, kerberos = %d, a_name = %d",
				 master_key_version,a_name_data.auth_key_ver);
				 /* send error reply									   */
				 kerb_err_reply(client,pkt,KERB_ERR_NAME_MAST_KEY_VER,
				 	"bad master key version",a_name_data.auth_key_ver);
			     log(".  bad master key version: %d",
					 a_name_data.auth_key_ver);
				 return;
				 }
			 
			 /* make sure the name hasn't expired						   */
			if ((unsigned long ) a_name_data.exp_date < 
				(unsigned long)	 kerb_time.tv_sec )
				/* user has expired, dont give tickets*/
				{
				/* send and error reply									   */
				kerb_err_reply(client,pkt,KERB_ERR_NAME_EXP,
					"Athena name expired at 0x",a_name_data.exp_date);
					
				log(". a_name expired at 0x%X",a_name_data.exp_date);
				return;	
				}			
d268 10
a277 45
			 /* loop through the ticket requests						   */
	    	 for (i=1;i<=pkt_no_req(pkt);i++)
	        	 {
				 lifetime = get_request(pkt,i,&s_name,&instance);
				 /* look up s_name and instance in the service db. */ 
				 n = kerb_get_service(s_name,instance,s_name_data,MAX_S_NAME);
				 log(".  Life: %d, Service: %s, Instance: %s",
			    	 lifetime,s_name,instance);
				
				 tk->length = 0;	/* init								   */

				 /* if more than one s_name, pick one, TODO
				  * create a session key, 
				  * compute maximum lifetime, lookup authorizations if
				  * applicable, and stuff into cipher.
				  */
				 --n;
				 if (n >= 0)
					{
					/* select the best one of the n !!					   */
					n = 0;		/* TODO									   */
						
					if (master_key_version != s_name_data[n].auth_key_ver)
						 {
						 fprintf(stderr,
				"\n\07\07bad master key version, kerberos = %d, s_name = %d",
						 master_key_version,s_name_data[n].auth_key_ver);
						 /* send error reply							   */
					 kerb_err_reply(client,pkt,KERB_ERR_SERV_MAST_KEY_VER,
				 	"bad master key version",s_name_data[n].auth_key_ver);
					     log(".  bad master key version: %d",
						 s_name_data[n].auth_key_ver);
						 return;
						 }
			 
					 /* make sure the service hasn't expired			   */
					if ((unsigned long) s_name_data[n].exp_date >= 
						(unsigned long)	kerb_time.tv_sec )
						/* service has NOT expired, give tickets*/
						{
						/* Bound requested lifetime with service max	   */
						lifetime = min(lifetime,s_name_data[n].max_life);
		
						/* random session key							   */
						 random_key(session_key);
d279 34
a312 26
						/* set default prem and quotas
						 * TODO
						 */
						
						/* if this service has athena-managed authorizations
						 * look them up
						 */
						if (s_name_data[n].attributes & KERB_S_ATT_AUTH_DB)
							{
							/* TODO	-- look up in db/cache				   */
							}
						/* unseal server's key from master key			   */
						bcopy(&s_name_data[n].key_low, key, 4);
						bcopy(&s_name_data[n].key_high, ((long *)key)+1, 4);
						cbc_encrypt(key,key,sizeof(key),master_key_schedule,
				 			master_key_schedule,0);
						/* construct and seal the ticket				   */
						create_ticket(tk,a_name_data.a_name,"",client_host,
							session_key,perm,quota,lifetime,
							kerb_time.tv_sec,
							s_name_data[n].s_name,s_name_data[n].s_instance,
							key);
			 			bzero(key,sizeof(key));
						bzero(key_s,sizeof(key_s));
						}
					}
d314 26
a339 3
				/* add ticket to cipher, even if null					   */
				add_ticket(ciph,i,session_key,lifetime,
							s_name_data[n].key_version,tk);
d341 4
a344 3
				/* clear session key									   */
				bzero(session_key,sizeof(session_key));
			 	}
d346 3
a348 6
			/* All the tickets have been stuffed into the cipher
			 * last, jam the kdc time in too
			 */
			 bcopy(&kerb_time.tv_sec,ciph->dat + ciph->length,4);
			 ciph->length += 4;
		     ciph->length = ((ciph->length+7)/8)*8;
d350 6
a355 20
			 /* get the user's key, unseal it from the server's key, and
			  * use it to seal the cipher
			  */
			
			 /* a_name_data.key_low a_name_data.key_high				   */
			 bcopy(&a_name_data.key_low, key, 4);
			 bcopy(&a_name_data.key_high, ((long *)key)+1, 4);
	
			/* unseal the a_name key from the master key				   */
			 cbc_encrypt(key,key,sizeof(key),master_key_schedule,
				 master_key_schedule,0);
		     set_key(key,key_s);
		     cbc_encrypt(ciph->dat,ciph->dat,ciph->length,key_s,key,1);
			 bzero(key,sizeof(key));
			 }
		 else
			 {
			 /* just null cipher length since name is unknown			   */
		     ciph->length = 0;
			 }	
d357 20
a376 4
		/* always send a reply packet									   */
	     rpkt = create_auth_reply(pkt_a_name(pkt),pkt_time_ws(pkt),
		      a_name_data.key_version,ciph);
	     sendto(f,rpkt->dat, rpkt->length, 0, client, S_AD_SZ);
d378 4
a381 1
	     break;
d383 4
a386 2
	case AUTH_MSG_DIE:
	     log("Host: User: %-8s Kerberos killed",pkt_a_name(pkt));
d390 1
a390 1
	default:
d392 1
a392 1
	     break;
d394 1
a394 1
	}
d410 1
a410 1
	(void) close(s);
d420 2
a421 2
	ioctl(s, TIOCNOTTY, (struct sgttyb *) 0);
	(void) close(s);
d429 1
a429 1
long	kerb_err_reply(c,p,err,string,val)
d431 12
a442 12
	struct sockaddr_in	*c;
	struct packet		*p;
	long				err;
	char				*string;
	long				val;
	
	{
	/* this routine create an error reply packet and sends it to the client
	 * pointed to.
	 * TODO
 	 */
	 }
@


1.7
log
@add time_kdc to end of cipher
@
text
@d4 1
a4 1
 * 	$Locker: spm $
d6 3
d33 1
a33 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.6 85/10/23 17:12:17 spm Exp $";
d322 1
a322 1
						create_ticket(tk,a_name_data.a_name,client_host,
d433 1
@


1.6
log
@finish create ticket stuff, still need to add auth db
@
text
@d6 3
d30 1
a30 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.5 85/10/22 17:15:01 spm Exp $";
d337 5
a341 1
			/* All the tickets have been stuffed into the cipher		   */
a351 4
#ifdef	notdef
		     string_to_key("test",key);
		     log(".  Key at 1: %s",key);
#endif
@


1.5
log
@added some of the ticket creation and encryption
@
text
@d6 3
d27 1
a27 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.4 85/10/21 18:31:40 spm Exp $";
d180 3
d192 1
d308 1
a308 1
							/* TODO									   */
a309 2
						/* construct the ticket							   */
	
d315 6
a320 3
						/* now use it to seal the ticket				   */
					    set_key(key,key_s);
		    			cbc_encrypt(tk->dat,tk->dat,tk->length,key_s,key,1);
@


1.4
log
@added check for exp_date
@
text
@d6 3
d24 1
a24 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.3 85/10/18 16:52:55 spm Exp $";
d112 1
a112 1
		{printf("Kerberos init failed = %d ...exiting",n);
d121 2
a122 2
	"\n\07\07%s: error on master key version lookup, %d found",
				progname,n);
d146 1
d189 3
a191 1
		/* eventually send an error packet								   */
a194 1
	
a200 1

a201 1

d219 1
a219 1
/*			 make sure we understand the master key	*/
d225 3
d238 6
a243 1
				return;			/* or err message TODO					   */
d257 1
a257 1
				 /* if more than one s_name, pick one,
d268 13
d292 24
a315 5
						/* get a ticket
						 * f(n, lifetime, client) and globals:
						 * a_name_data, s_name_data, session_key, kerb_time
						 */			
						 }
d320 1
a320 1
							s_name_data[n-1].key_version,tk);
d339 1
a340 1
		     log(".  Key at 1: %s",key);
a344 1
		     log(".  Key at 2: %s",key);
a346 1
		     log(".  Key at 3: %s",key);
d404 16
@


1.3
log
@add master key handling
@
text
@d4 1
a4 1
 * 	$Locker:  $
d6 3
d21 1
a21 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.2 85/10/16 11:55:12 spm Exp $";
d209 3
a211 1
		 /* We want exactly one answer, and correct master key version	   */
d228 7
a234 1
			 /* TODO													   */
d257 7
a263 2
					/* Bound requested lifetime with service max	   */
					lifetime = min(lifetime,s_name_data[n].max_life);
d265 2
a266 2
					/* random session key								   */
					 random_key(session_key);
d268 5
a272 4
					/* get a ticket
					 * f(n, lifetime, client) and globals:
					 * a_name_data, s_name_data, session_key, kerb_time
					 */			
d278 3
a282 3
			/* clear session key										   */
			bzero(session_key,sizeof(session_key));

a289 1

@


1.2
log
@add real passwords 
@
text
@d3 2
a4 2
 * 	$Author: bcn $
 * 	$Locker: spm $
d6 3
d18 1
a18 1
static char *rcsid_kerberos_c = "$Header: kerberos.c,v 1.1 85/10/10 11:01:11 bcn Exp $";
a52 1
static	C_Block 		master_key;
d54 1
d56 9
d110 10
d121 4
a124 1
	read_password(master_key,"\nEnter Kerberos master key: ",TRUE);
d126 10
d137 9
a145 1
	fprintf(stdout,"\nmaster key entered.  BEWARE!");
a160 8
#define	MAX_S_NAME	10
static	struct timeval	kerb_time;
static	A_name	a_name_data;
static	S_name	s_name_data[MAX_S_NAME];
static	C_Block	session_key;
static	C_Block	user_key;
static	C_Block	service_key;

d206 2
a207 2
		 /* We want exactly one answer									   */
		 if ( n == 1)
d211 13
d282 3
d288 1
@


1.1
log
@Initial revision
@
text
@d2 7
a8 4
 * 	$Source: $
 * 	$Author: $
 * 	$Locker: $
 *    	$Log:	 $
d15 1
a15 1
static char *rcsid_kerberos_c = "$Header: $";
d39 2
d50 3
d98 7
d224 1
d227 4
d232 1
@
