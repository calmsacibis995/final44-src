head	4.18;
access;
symbols
	PATCH8:4.16
	PATCH7:4.16
	KPATCH6:4.16
	ASRSNAP1001:4.16
	PATCH5:4.16
	KPATCH4:4.16
	KPATCH3:4.16
	KPATCH2:4.16
	KREL1:4.15
	BETA5/24/88:4.12;
locks; strict;
comment	@ * @;


4.18
date	95.02.25.03.57.21;	author sklower;	state Exp;
branches;
next	4.17;

4.17
date	90.05.12.00.58.48;	author kfall;	state Exp;
branches;
next	4.16;

4.16
date	89.03.22.14.52.06;	author jtkohl;	state Exp;
branches;
next	4.15;

4.15
date	89.01.19.22.24.39;	author wesommer;	state Exp;
branches;
next	4.14;

4.14
date	88.12.05.15.21.42;	author steiner;	state Exp;
branches;
next	4.13;

4.13
date	88.12.01.14.25.18;	author jtkohl;	state Exp;
branches;
next	4.12;

4.12
date	88.04.15.15.07.26;	author steiner;	state Exp;
branches;
next	4.11;

4.11
date	88.02.24.18.15.37;	author steiner;	state Exp;
branches;
next	4.10;

4.10
date	88.01.12.21.23.38;	author steiner;	state Exp;
branches;
next	4.9;

4.9
date	87.12.06.11.25.09;	author steiner;	state Exp;
branches;
next	4.8;

4.8
date	87.12.06.10.31.17;	author steiner;	state Exp;
branches;
next	4.7;

4.7
date	87.10.29.10.46.40;	author jtkohl;	state Exp;
branches;
next	4.6;

4.6
date	87.10.28.16.05.04;	author steiner;	state Exp;
branches;
next	4.5;

4.5
date	87.10.28.15.58.58;	author steiner;	state Exp;
branches;
next	4.4;

4.4
date	87.10.20.17.12.14;	author jtkohl;	state Exp;
branches;
next	4.3;

4.3
date	87.09.14.16.25.11;	author steiner;	state Exp;
branches;
next	4.2;

4.2
date	87.09.10.16.20.58;	author steiner;	state Exp;
branches;
next	4.1;

4.1
date	87.09.01.15.47.20;	author steiner;	state Exp;
branches;
next	3.8;

3.8
date	86.09.05.16.07.15;	author bcn;	state Exp;
branches;
next	3.7;

3.7
date	86.08.22.16.30.43;	author bcn;	state Exp;
branches;
next	3.6;

3.6
date	86.06.18.14.13.51;	author bcn;	state Exp;
branches;
next	3.5;

3.5
date	86.05.23.13.11.27;	author spm;	state Exp;
branches;
next	3.4;

3.4
date	86.05.14.14.45.23;	author bcn;	state Exp;
branches;
next	3.3;

3.3
date	86.04.04.17.57.32;	author spm;	state Exp;
branches;
next	3.2;

3.2
date	86.04.02.16.39.40;	author bcn;	state Exp;
branches;
next	3.1;

3.1
date	86.03.28.09.54.18;	author bcn;	state Exp;
branches;
next	1.16;

1.16
date	86.03.25.15.52.13;	author spm;	state Exp;
branches;
next	1.15;

1.15
date	86.03.24.13.58.07;	author bcn;	state Exp;
branches;
next	1.14;

1.14
date	86.01.11.13.57.54;	author spm;	state Exp;
branches;
next	1.13;

1.13
date	86.01.10.16.38.57;	author spm;	state Exp;
branches;
next	1.12;

1.12
date	86.01.07.20.21.12;	author spm;	state Exp;
branches;
next	1.11;

1.11
date	86.01.07.12.38.29;	author spm;	state Exp;
branches;
next	1.10;

1.10
date	85.12.06.20.57.14;	author bcn;	state Exp;
branches;
next	1.9;

1.9
date	85.12.06.15.09.16;	author bcn;	state Exp;
branches;
next	1.8;

1.8
date	85.12.04.10.18.54;	author bcn;	state Exp;
branches;
next	1.7;

1.7
date	85.11.26.13.28.06;	author spm;	state Exp;
branches;
next	1.6;

1.6
date	85.11.25.14.36.04;	author bcn;	state Exp;
branches;
next	1.5;

1.5
date	85.11.17.20.49.00;	author bcn;	state Exp;
branches;
next	1.4;

1.4
date	85.11.15.16.43.35;	author spm;	state Exp;
branches;
next	1.3;

1.3
date	85.11.14.17.55.25;	author spm;	state Exp;
branches;
next	1.2;

1.2
date	85.11.13.11.02.30;	author bcn;	state Exp;
branches;
next	1.1;

1.1
date	85.11.03.20.11.50;	author bcn;	state Exp;
branches;
next	;


desc
@Create and decompose authenticators.
@


4.18
log
@fix from Dave Glowacki for multihomed hosts
@
text
@/*
 * $Source: /usr/src/kerberosIV/krb/RCS/rd_req.c,v $
 * $Author: kfall $
 *
 * Copyright 1985, 1986, 1987, 1988 by the Massachusetts Institute
 * of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#ifndef lint
static char *rcsid_rd_req_c =
"$Header: /usr/src/kerberosIV/krb/RCS/rd_req.c,v 4.17 1990/05/12 00:58:48 kfall Exp sklower $";
#endif /* lint */

#include <mit-copyright.h>
#include <des.h>
#include <krb.h>
#include <prot.h>
#include <sys/time.h>
#include <strings.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

extern int krb_ap_req_debug;

static struct timeval t_local = { 0, 0 };

/*
 * Keep the following information around for subsequent calls
 * to this routine by the same server using the same key.
 */

static Key_schedule serv_key;	/* Key sched to decrypt ticket */
static C_Block ky;              /* Initialization vector */
static int st_kvno;		/* version number for this key */
static char st_rlm[REALM_SZ];	/* server's realm */
static char st_nam[ANAME_SZ];	/* service name */
static char st_inst[INST_SZ];	/* server's instance */

static int check_multihome __P((u_int32_t, u_int32_t));

/*
 * This file contains two functions.  krb_set_key() takes a DES
 * key or password string and returns a DES key (either the original
 * key, or the password converted into a DES key) and a key schedule
 * for it.
 *
 * krb_rd_req() reads an authentication request and returns information
 * about the identity of the requestor, or an indication that the
 * identity information was not authentic.
 */

/*
 * krb_set_key() takes as its first argument either a DES key or a
 * password string.  The "cvt" argument indicates how the first
 * argument "key" is to be interpreted: if "cvt" is null, "key" is
 * taken to be a DES key; if "cvt" is non-null, "key" is taken to
 * be a password string, and is converted into a DES key using
 * string_to_key().  In either case, the resulting key is returned
 * in the external static variable "ky".  A key schedule is
 * generated for "ky" and returned in the external static variable
 * "serv_key".
 *
 * This routine returns the return value of des_key_sched.
 *
 * krb_set_key() needs to be in the same .o file as krb_rd_req() so that
 * the key set by krb_set_key() is available in private storage for
 * krb_rd_req().
 */

int
krb_set_key(key,cvt)
    char *key;
    int cvt;
{
#ifdef NOENCRYPTION
    bzero(ky, sizeof(ky));
    return KSUCCESS;
#else /* Encrypt */
    if (cvt)
        string_to_key(key,ky);
    else
        bcopy(key,(char *)ky,8);
    return(des_key_sched(ky,serv_key));
#endif /* NOENCRYPTION */
}

/*
 * check_multihome() takes as arguments the network address of the
 * originating host and the network address extracted from the ticket.
 * It uses the first address to get a list of all possible addresses for
 * the originating host, and then compares the tkt_addr to each in hope
 * of finding a match.
 *
 * This routine returns 0 if a match was found, -1 otherwise.
 *
 */

static int
check_multihome(from_addr, tkt_addr)
u_int32_t from_addr;		/* Net address of originating host */
u_int32_t tkt_addr;		/* Address extracted from ticket */
{
	struct hostent *hent;
	char **addr;
	int i;

	hent = gethostbyaddr((char *)&from_addr, 4, AF_INET);
	if (!hent)
		return(-1);

	hent = gethostbyname(hent->h_name);
	if (!hent)
		return(-1);

	addr = hent->h_addr_list;
	for (i = 0; addr && addr[i]; i++) {
		if (krb_ap_req_debug)
			log("Checking address %08x",*(u_int32_t *)addr[i]);
		if (tkt_addr == *(u_int32_t *)addr[i])
			return(0);
	}

	return(-1);
}

/*
 * krb_rd_req() takes an AUTH_MSG_APPL_REQUEST or
 * AUTH_MSG_APPL_REQUEST_MUTUAL message created by krb_mk_req(),
 * checks its integrity and returns a judgement as to the requestor's
 * identity.
 *
 * The "authent" argument is a pointer to the received message.
 * The "service" and "instance" arguments name the receiving server,
 * and are used to get the service's ticket to decrypt the ticket
 * in the message, and to compare against the server name inside the
 * ticket.  "from_addr" is the network address of the host from which
 * the message was received; this is checked against the network
 * address in the ticket.  If "from_addr" is zero, the check is not
 * performed.  "ad" is an AUTH_DAT structure which is
 * filled in with information about the sender's identity according
 * to the authenticator and ticket sent in the message.  Finally,
 * "fn" contains the name of the file containing the server's key.
 * (If "fn" is NULL, the server's key is assumed to have been set
 * by krb_set_key().  If "fn" is the null string ("") the default
 * file KEYFILE, defined in "krb.h", is used.)
 *
 * krb_rd_req() returns RD_AP_OK if the authentication information
 * was genuine, or one of the following error codes (defined in
 * "krb.h"):
 *
 *	RD_AP_VERSION		- wrong protocol version number
 *	RD_AP_MSG_TYPE		- wrong message type
 *	RD_AP_UNDEC		- couldn't decipher the message
 *	RD_AP_INCON		- inconsistencies found
 *	RD_AP_BADD		- wrong network address
 *	RD_AP_TIME		- client time (in authenticator)
 *				  too far off server time
 *	RD_AP_NYV		- Kerberos time (in ticket) too
 *				  far off server time
 *	RD_AP_EXP		- ticket expired
 *
 * For the message format, see krb_mk_req().
 *
 * Mutual authentication is not implemented.
 */

krb_rd_req(authent,service,instance,from_addr,ad,fn)
    register KTEXT authent;	/* The received message */
    char *service;		/* Service name */
    char *instance;		/* Service instance */
    long from_addr;		/* Net address of originating host */
    AUTH_DAT *ad;		/* Structure to be filled in */
    char *fn;			/* Filename to get keys from */
{
    static KTEXT_ST ticket;     /* Temp storage for ticket */
    static KTEXT tkt = &ticket;
    static KTEXT_ST req_id_st;  /* Temp storage for authenticator */
    register KTEXT req_id = &req_id_st;

    char realm[REALM_SZ];	/* Realm of issuing kerberos */
    static Key_schedule seskey_sched; /* Key sched for session key */
    unsigned char skey[KKEY_SZ]; /* Session key from ticket */
    char sname[SNAME_SZ];	/* Service name from ticket */
    char iname[INST_SZ];	/* Instance name from ticket */
    char r_aname[ANAME_SZ];	/* Client name from authenticator */
    char r_inst[INST_SZ];	/* Client instance from authenticator */
    char r_realm[REALM_SZ];	/* Client realm from authenticator */
    unsigned int r_time_ms;     /* Fine time from authenticator */
    unsigned long r_time_sec;   /* Coarse time from authenticator */
    register char *ptr;		/* For stepping through */
    unsigned long delta_t;      /* Time in authenticator - local time */
    long tkt_age;		/* Age of ticket */
    static int swap_bytes;	/* Need to swap bytes? */
    static int mutual;		/* Mutual authentication requested? */
    static unsigned char s_kvno;/* Version number of the server's key
				 * Kerberos used to encrypt ticket */
    int status;

    if (authent->length <= 0)
	return(RD_AP_MODIFIED);

    ptr = (char *) authent->dat;

    /* get msg version, type and byte order, and server key version */

    /* check version */
    if (KRB_PROT_VERSION != (unsigned int) *ptr++)
        return(RD_AP_VERSION);

    /* byte order */
    swap_bytes = 0;
    if ((*ptr & 1) != HOST_BYTE_ORDER)
        swap_bytes++;

    /* check msg type */
    mutual = 0;
    switch (*ptr++ & ~1) {
    case AUTH_MSG_APPL_REQUEST:
        break;
    case AUTH_MSG_APPL_REQUEST_MUTUAL:
        mutual++;
        break;
    default:
        return(RD_AP_MSG_TYPE);
    }

#ifdef lint
    /* XXX mutual is set but not used; why??? */
    /* this is a crock to get lint to shut up */
    if (mutual)
        mutual = 0;
#endif /* lint */
    s_kvno = *ptr++;		/* get server key version */
    (void) strcpy(realm,ptr);   /* And the realm of the issuing KDC */
    ptr += strlen(ptr) + 1;     /* skip the realm "hint" */

    /*
     * If "fn" is NULL, key info should already be set; don't
     * bother with ticket file.  Otherwise, check to see if we
     * already have key info for the given server and key version
     * (saved in the static st_* variables).  If not, go get it
     * from the ticket file.  If "fn" is the null string, use the
     * default ticket file.
     */
    if (fn && (strcmp(st_nam,service) || strcmp(st_inst,instance) ||
               strcmp(st_rlm,realm) || (st_kvno != s_kvno))) {
        if (*fn == 0) fn = KEYFILE;
        st_kvno = s_kvno;
#ifndef NOENCRYPTION
        if (read_service_key(service,instance,realm,(int) s_kvno,
                            fn,(char *)skey))
            return(RD_AP_UNDEC);
        if (status = krb_set_key((char *)skey,0))
	    return(status);
#endif /* !NOENCRYPTION */
        (void) strcpy(st_rlm,realm);
        (void) strcpy(st_nam,service);
        (void) strcpy(st_inst,instance);
    }

    /* Get ticket from authenticator */
    tkt->length = (int) *ptr++;
    if ((tkt->length + (ptr+1 - (char *) authent->dat)) > authent->length)
	return(RD_AP_MODIFIED);
    bcopy(ptr+1,(char *)(tkt->dat),tkt->length);

    if (krb_ap_req_debug)
        log("ticket->length: %d",tkt->length);

#ifndef NOENCRYPTION
    /* Decrypt and take apart ticket */
#endif

    if (decomp_ticket(tkt,&ad->k_flags,ad->pname,ad->pinst,ad->prealm,
                      &(ad->address),ad->session, &(ad->life),
                      &(ad->time_sec),sname,iname,ky,serv_key))
        return(RD_AP_UNDEC);

    if (krb_ap_req_debug) {
        log("Ticket Contents.");
        log(" Aname:   %s.%s",ad->pname,
            ((int)*(ad->prealm) ? ad->prealm : "Athena"));
        log(" Service: %s%s%s",sname,((int)*iname ? "." : ""),iname);
    }

    /* Extract the authenticator */
    req_id->length = (int) *(ptr++);
    if ((req_id->length + (ptr + tkt->length - (char *) authent->dat)) >
	authent->length)
	return(RD_AP_MODIFIED);
    bcopy(ptr + tkt->length, (char *)(req_id->dat),req_id->length);

#ifndef NOENCRYPTION
    /* And decrypt it with the session key from the ticket */
    if (krb_ap_req_debug) log("About to decrypt authenticator");
    key_sched(ad->session,seskey_sched);
    pcbc_encrypt((C_Block *)req_id->dat,(C_Block *)req_id->dat,
                 (long) req_id->length, seskey_sched,ad->session,DES_DECRYPT);
    if (krb_ap_req_debug) log("Done.");
#endif /* NOENCRYPTION */

#define check_ptr() if ((ptr - (char *) req_id->dat) > req_id->length) return(RD_AP_MODIFIED);

    ptr = (char *) req_id->dat;
    (void) strcpy(r_aname,ptr);	/* Authentication name */
    ptr += strlen(r_aname)+1;
    check_ptr();
    (void) strcpy(r_inst,ptr);	/* Authentication instance */
    ptr += strlen(r_inst)+1;
    check_ptr();
    (void) strcpy(r_realm,ptr);	/* Authentication name */
    ptr += strlen(r_realm)+1;
    check_ptr();
    bcopy(ptr,(char *)&ad->checksum,4);	/* Checksum */
    ptr += 4;
    check_ptr();
    if (swap_bytes) swap_u_long(ad->checksum);
    r_time_ms = *(ptr++);	/* Time (fine) */
#ifdef lint
    /* XXX r_time_ms is set but not used.  why??? */
    /* this is a crock to get lint to shut up */
    if (r_time_ms)
        r_time_ms = 0;
#endif /* lint */
    check_ptr();
    /* assume sizeof(r_time_sec) == 4 ?? */
    bcopy(ptr,(char *)&r_time_sec,4); /* Time (coarse) */
    if (swap_bytes) swap_u_long(r_time_sec);

    /* Check for authenticity of the request */
    if (krb_ap_req_debug)
        log("Pname:   %s %s",ad->pname,r_aname);
    if (strcmp(ad->pname,r_aname) != 0)
        return(RD_AP_INCON);
    if (strcmp(ad->pinst,r_inst) != 0)
        return(RD_AP_INCON);
    if (krb_ap_req_debug)
        log("Realm:   %s %s",ad->prealm,r_realm);
    if ((strcmp(ad->prealm,r_realm) != 0))
        return(RD_AP_INCON);

    if (krb_ap_req_debug)
        log("Address: %d %d",ad->address,from_addr);
    if (from_addr && (ad->address != from_addr) &&
		check_multihome(from_addr,ad->address))
        return(RD_AP_BADD);

    (void) gettimeofday(&t_local,(struct timezone *) 0);
    delta_t = abs((int)(t_local.tv_sec - r_time_sec));
    if (delta_t > CLOCK_SKEW) {
        if (krb_ap_req_debug)
            log("Time out of range: %d - %d = %d",
                t_local.tv_sec,r_time_sec,delta_t);
        return(RD_AP_TIME);
    }

    /* Now check for expiration of ticket */

    tkt_age = t_local.tv_sec - ad->time_sec;
    if (krb_ap_req_debug)
        log("Time: %d Issue Date: %d Diff: %d Life %x",
            t_local.tv_sec,ad->time_sec,tkt_age,ad->life);

    if (t_local.tv_sec < ad->time_sec) {
        if ((ad->time_sec - t_local.tv_sec) > CLOCK_SKEW)
            return(RD_AP_NYV);
    }
    else if ((t_local.tv_sec - ad->time_sec) > 5 * 60 * ad->life)
        return(RD_AP_EXP);

    /* All seems OK */
    ad->reply.length = 0;

    return(RD_AP_OK);
}
@


4.17
log
@fix dependency on des.h (must come 1st, before krb.h)
@
text
@d2 2
a3 2
 * $Source: /usr/src/kerberosIV/src/lib/krb/RCS/rd_req.c,v $
 * $Author: jtkohl $
d14 1
a14 1
"$Header: /usr/src/kerberosIV/src/lib/krb/RCS/rd_req.c,v 4.16 89/03/22 14:52:06 jtkohl Exp Locker: kfall $";
d23 3
d43 2
d91 10
d102 28
d348 2
a349 1
    if (from_addr && (ad->address != from_addr))
@


4.16
log
@#ifdef NOENCRYPTION for comments
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/rd_req.c,v $
 * $Author: wesommer $
d14 1
a14 1
"$Header: rd_req.c,v 4.15 89/01/19 22:24:39 jtkohl Locked $";
@


4.15
log
@Add range checking; remove v3 protocol turds.
Clean up return values here and there.
@
text
@d3 1
a3 1
 * $Author: steiner $
d14 1
a14 1
"$Header: rd_req.c,v 4.14 88/12/05 15:21:42 jtkohl Locked $";
d231 1
d233 1
@


4.14
log
@Added #ifdef NOENCRYPTION code (to send stuff
in the clear in case no DES library present).
Programmer: jtkohl
Auditor: steiner
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d14 1
a14 1
"$Header: rd_req.c,v 4.13 88/12/01 14:25:18 jtkohl Locked $";
d62 1
a62 1
 * The return value of this routine is not defined.
d69 1
d76 1
d82 1
a82 1
    key_sched(ky,serv_key);
d99 2
a100 1
 * address in the ticket.  "ad" is an AUTH_DAT structure which is
d129 1
a129 1
    KTEXT authent;		/* The received message */
d139 1
a139 1
    static KTEXT req_id = &req_id_st;
d151 1
a151 1
    static char *ptr;		/* For stepping through */
d158 1
a158 1
    unsigned int pvers;		/* Protocol version number */
d160 3
d168 1
a168 2
    pvers = (unsigned int) *ptr++;
    if ((KRB_PROT_VERSION != pvers) && (3 != pvers))
d214 2
a215 1
        krb_set_key((char *)skey,0);
d224 2
d247 3
d257 1
a257 1
                 (long) req_id->length, seskey_sched,ad->session,0);
d260 3
d266 1
d269 1
d272 1
d275 1
d284 1
d298 1
a298 1
    if (pvers != 3 && (strcmp(ad->prealm,r_realm) != 0))
a330 3

    if (pvers == 3 && !strcmp(ad->prealm,"Athena"))
        (void) strcpy(ad->prealm,KRB_REALM);
@


4.13
log
@Programmer: Jennifer Steiner
Auditor: John Kohl
changes: improve documentation of code
@
text
@d3 1
a3 1
 * $Author: steiner $
d14 1
a14 1
"$Header: rd_req.c,v 4.12 88/04/15 15:07:26 steiner Locked $";
d73 3
d81 1
d205 1
d210 1
d241 1
d248 1
@


4.12
log
@Fixed byte order problem with ticket lifetimes.
Programmer: jon.
Auditor: wesommer.
@
text
@d14 1
a14 1
"$Header: rd_req.c,v 4.11 88/02/24 18:15:37 steiner Exp $";
d28 5
d35 4
a38 4
static int st_kvno;		/* kvno for this key */
static char st_rlm[REALM_SZ];	/* Realm for this key */
static char st_nam[ANAME_SZ];	/* Name of service key is for */
static char st_inst[INST_SZ];	/* And the instance */
d41 4
a44 4
 * krb_set_key takes as an argument a des key.  It then creates
 * a key schedule from it and save the original key to be used as an
 * initialization vector.  It is used to set the servers key which
 * must be used to decrypt tickets.
d46 15
a60 3
 * If called with a non-nero second argument, krb_set_key will
 * first convert the input from a string of arbitrary length
 * to a des key by folding it back on itself as necessary.
d62 1
a62 3
 * This routine needs to be in the same .o file as krb_rd_req so that
 * the key set by krb_set_key is available in private storage for
 * krb_rd_req.
d64 3
d68 1
d82 4
a85 5
 * krb_rd_req takes an authenticator, a service name, an instace, the
 * address of the host originating the request, and a pointer to a
 * structure of type AUTH_DAT which is filled in with information
 * obtained from the authenticator and the name of the file to use to
 * find keys.
d87 32
a118 3
 * The peer procedure on the other end is mk_ap_request.  When making
 * any changes to this routine it is important to make corresponding
 * changes to mk_ap_request.
d122 1
a122 1
    KTEXT authent;		/* The authenticator */
d131 1
a131 1
    static KTEXT_ST req_id_st;  /* Temp storage for req_id */
d139 5
a143 5
    char r_aname[ANAME_SZ];	/* Aname from req_id */
    char r_inst[INST_SZ];	/* Instance from req_id */
    char r_realm[REALM_SZ];	/* Realm from req_id */
    unsigned int r_time_ms;     /* Fine time from req_id */
    unsigned long r_time_sec;   /* Coarse time from req_id */
d145 1
a145 1
    unsigned long delta_t;      /* time in req_id - time */
d147 5
a151 4
    static int swap_bytes;
    static int mutual;
    static unsigned char s_kvno;
    unsigned int pvers;
d189 8
d231 1
a231 1
    /* Get the request id from the authenticator */
d235 2
a236 2
    /* And decrypt it */
    if (krb_ap_req_debug) log("About to decrypt req_id");
@


4.11
log
@Copyright notice, etc.
@
text
@d14 1
a14 1
"$Header: rd_req.c,v 4.10 88/01/12 21:23:38 steiner Locked $";
d164 1
a164 1
                      &(ad->address),ad->session,(short *)&(ad->life),
d236 2
a237 2
        log("Time: %d Issue Date: %d Diff: %d",
            t_local.tv_sec,ad->time_sec,tkt_age);
@


4.10
log
@Formatting changes.
Programmer: Ken.
Auditor: Jon.
@
text
@d2 2
a3 3
 *      $Source: /mit/kerberos/lib/krb/RCS/rd_req.c,v $
 *      $Author: jtkohl $
 *      $Locker: steiner $
d5 2
a6 1
 * Copyright 1985,1986 by the Massachusetts Institute of Technology
d8 2
d13 2
a14 2
static char *rcsid_rd_ap_req_c =
    "$Header: rd_req.c,v 4.7 87/10/29 10:46:40 steiner Locked $";
d17 1
@


4.9
log
@Changed user routine names to krb_xxxxxxx
@
text
@d1 1
a1 1
/* 
d3 1
a3 1
 *      $Author: steiner $
d11 3
a13 3
static char rcsid[] =
    "$Header: rd_req.c,v 4.8 87/12/06 10:31:17 steiner Locked $";
#endif  lint
d15 5
a19 6
#include        <des.h>
#include        <krb.h>
#include        <prot.h>
#include	<stdio.h>
#include 	<sys/time.h>
#include	<strings.h>
d21 1
a21 1
extern  int     krb_ap_req_debug;
d23 1
a23 6
static  Key_schedule    serv_key;       /* Key sched to decrypt ticket  */
static  C_Block         ky;		/* Initialization vector        */
static	int		st_kvno;	/* kvno for this key		*/
static	char		st_rlm[REALM_SZ];/* Realm for this key		*/
static	char		st_nam[ANAME_SZ];/* Name of service key is for	*/
static	char		st_inst[INST_SZ];/* And the instance		*/
d25 7
d33 2
a34 2
 * krb_set_key takes as an argument a des key.  It then creates a key
 * schedule from it and save the original key to be used as an
d38 3
a40 3
 * If called with a non-nero second argument, krb_set_key will first
 * convert the input from a string of arbitrary length to a des key by
 * folding it back on itself as necessary.
d52 1
a52 1
	string_to_key(key,ky);
d54 1
a54 1
	bcopy(key,(char *)ky,8);
d58 1
d72 6
a77 6
    KTEXT       authent;	/* The authenticator */
    char        *service;	/* Service name */
    char        *instance;	/* Service instance */
    long	from_addr;	/* Net addr of originating station */
    AUTH_DAT    *ad;		/* Structure to be filled in */
    char	*fn;		/* Filename to get keys from */
d79 4
a82 4
    KTEXT_ST ticket;     /* Temp storage for ticket */
    KTEXT    tkt = &ticket;
    KTEXT_ST req_id_st;  /* Temp storage for req_id */
    KTEXT    req_id = &req_id_st;
d84 17
a100 20
    char		realm[REALM_SZ];/* Realm of issuing kerberos */
    Key_schedule	seskey_sched;	/* Key sched for session key */
    unsigned char	skey[KKEY_SZ];	/* Session key from ticket */
    char                sname[SNAME_SZ];/* Service name from ticket */
    char                iname[INST_SZ]; /* Instance name from ticket */
    char		r_aname[ANAME_SZ]; /* Aname from req_id */
    char                r_inst[INST_SZ];   /* Instance from req_id */
    char		r_realm[REALM_SZ]; /* Realm from req_id */
    unsigned int	r_time_ms;	/* Fine time from req_id */
    unsigned long	r_time_sec;	/* Coarse time from req_id */
    char		*ptr;		/* For stepping through */
    unsigned long	delta_t;	/* time in req_id - time */
    long		tkt_age;	/* Age of ticket */
    int			swap_bytes;
#ifdef notdef
    int			mutual;
#endif
    unsigned char s_kvno;
    unsigned int	pvers;
    struct timeval	t_local;
d105 1
a105 1
	
d108 2
a109 2
    if (KRB_PROT_VERSION != pvers)
	return(RD_AP_VERSION);
d114 1
a114 1
	swap_bytes++;
a116 1
#ifdef notdef
a117 1
#endif
d120 1
a120 1
	break;
d122 2
a123 4
#ifdef notdef
	mutual++;
#endif
	break;
d125 1
a125 1
	return(RD_AP_MSG_TYPE);
d128 6
d135 2
a136 2
    (void) strcpy(realm,ptr);  	/* realm of the issuing kerberos */
    ptr += strlen(ptr) + 1;	/* skip the realm "hint" */
d138 11
a148 12
    if (fn && (strcmp(st_nam,service) || strcmp(st_inst,instance) || 
	       strcmp(st_rlm,realm) || (st_kvno != s_kvno))) {
	if (*fn == 0)
	    fn = KEYFILE;
	st_kvno = s_kvno;
	if (read_service_key(service,instance,realm,(int) s_kvno,
			     fn,(char *)skey))
	    return(RD_AP_UNDEC);
	krb_set_key((char *)skey,0);
	(void) strcpy(st_rlm,realm);
	(void) strcpy(st_nam,service);
	(void) strcpy(st_inst,instance);
d156 1
a156 1
	fprintf(stderr,"ticket->length: %d\n",tkt->length);
d161 3
a163 3
		      &(ad->address),ad->session,(short *)&(ad->life),
		      &(ad->time_sec),sname,iname,ky,serv_key))
	return(RD_AP_UNDEC);
d166 4
a169 5
	fprintf(stderr,"Ticket Contents.\n");
	fprintf(stderr," Aname:   %s.%s\n", ad->pname, ad->prealm);
	fprintf(stderr,
		" Service: %s%s%s\n",sname,((int)*iname ? "." : ""),
		iname);
d177 1
a177 2
    if (krb_ap_req_debug)
	fprintf(stderr,"About to decrypt req_id\n");
d180 2
a181 3
		 (long) req_id->length, seskey_sched,ad->session,0);
    if (krb_ap_req_debug)
	fprintf(stderr,"Done.\n");
d183 1
a183 1
    (void) strcpy(r_aname,ptr);		/* Authentication name */
d185 1
a185 1
    (void) strcpy(r_inst,ptr);		/* Authentication instance */
d187 1
a187 1
    (void) strcpy(r_realm,ptr);		/* Authentication name */
d191 2
a192 3
    if (swap_bytes)
	swap_u_long(ad->checksum); 
    r_time_ms = *(ptr++);		/* Time (fine) */
d197 2
a198 2
	r_time_ms = 0;
#endif lint
d200 3
a202 4
    bcopy(ptr,(char *)&r_time_sec,4);	/* Time (coarse) */
    if (swap_bytes)
	swap_u_long(r_time_sec);
	
d205 5
a209 3
	fprintf(stderr,"Pname:   %s %s\n",ad->pname,r_aname);
    if (strcmp(ad->pname,r_aname) != 0) return(RD_AP_INCON);	
    if (strcmp(ad->pinst,r_inst) != 0) return(RD_AP_INCON);
d211 3
a213 3
	fprintf(stderr,"Realm:   %s %s\n",ad->prealm,r_realm);
    if (strcmp(ad->prealm,r_realm) != 0)
	return(RD_AP_INCON);
d216 3
a218 2
	fprintf(stderr,"Address: %d %d\n",ad->address,from_addr);
    if (from_addr && (ad->address != from_addr)) return(RD_AP_BADD);
d223 4
a226 4
	if (krb_ap_req_debug) 
	    fprintf(stderr,"Time out of range: %d - %d = %d\n",
		   t_local.tv_sec,r_time_sec,delta_t);
	return(RD_AP_TIME);
d232 3
a234 3
    if (krb_ap_req_debug) 
	fprintf(stderr,"Time: %d Issue Date: %d Diff: %d\n",
	       t_local.tv_sec,ad->time_sec,tkt_age);
d237 2
a238 2
	if ((ad->time_sec - t_local.tv_sec) > CLOCK_SKEW)
	    return(RD_AP_NYV);
d241 2
a242 2
	return(RD_AP_EXP);
    
d245 3
@


4.8
log
@Ken's changes -- formatting, others?
@
text
@d2 3
a4 3
 *      $Source: /mit/kerberos/lib/krb/RCS/rd_ap_req.c,v $
 *      $Author: jtkohl $
 *      $Locker: raeburn $
d12 1
a12 1
    "$Header: rd_ap_req.c,v 4.7 87/10/29 10:46:40 raeburn Locked $";
d32 1
a32 1
 * set_serv_key takes as an argument a des key.  It then creates a key
d37 1
a37 1
 * If called with a non-nero second argument, set_serv_key will first
d41 3
a43 3
 * This routine needs to be in the same .o file as rd_ap_req so that
 * the key set by set_serv_key is available in private storage for
 * rd_ap_req.
d46 1
a46 1
set_serv_key(key,cvt)
d58 1
a58 1
 * rd_ap_req takes an authenticator, a service name, an instace, the
d69 1
a69 1
rd_ap_req(authent,service,instance,from_addr,ad,fn)
d145 1
a145 1
	set_serv_key((char *)skey,0);
@


4.7
log
@cleanup & lint cleanup
@
text
@d2 3
a4 3
 *      $Source: /u3/kerberos.new/lib/krb/RCS/rd_ap_req.c,v $
 *      $Author: steiner $
 *      $Locker: jtkohl $
d11 2
a12 2
static char *rcsid_rd_ap_req_c =
"$Header: rd_ap_req.c,v 4.6 87/10/28 16:05:04 jtkohl Locked $";
d18 1
a23 2
static struct  	timeval t_local = { 0, 0 };

d32 2
a33 2
 * set_serv_key takes as an argument a des key.  It then creates
 * a key schedule from it and save the original key to be used as an
d37 4
a40 4
 * If called with a non-nero second argument, set_serv_key will
 * first convert the input from a string of arbitrary length
 * to a des key by folding it back on itself as necessary.
 * 
d42 2
a43 1
 * the key set by set_serv_key is available in private storage for rd_ap_req.
d47 2
a48 2
char    *key;
int	cvt;
d50 5
a54 5
	if (cvt)
		string_to_key(key,ky);
	else
		bcopy(key,(char *)ky,8);
        key_sched(ky,serv_key);
a56 1

d59 2
a60 2
 * address of the host originating the request, and a pointer to s
 * structure of type AUTH_DAT which is filled in with information 
d70 6
a75 6
KTEXT       authent;    /* The authenticator                    */
char        *service;   /* Service name                         */
char        *instance;  /* Service instance                     */
long	    from_addr;	/* Net address of originating station	*/
AUTH_DAT    *ad;	/* Structure to be filled in		*/
char	    *fn;	/* Filename to get keys from 		*/
d77 4
a80 4
    static      KTEXT_ST ticket;     /* Temp storage for ticket */
    static      KTEXT    tkt = &ticket;
    static      KTEXT_ST req_id_st;  /* Temp storage for req_id */
    static      KTEXT    req_id = &req_id_st;
d82 18
a99 16
    char		realm[REALM_SZ];/* Realm of issuing kerberos    */
    static Key_schedule	seskey_sched;	/* Key sched for session key	*/
    unsigned char	skey[KKEY_SZ];	/* Session key from ticket 	*/
    char                sname[SNAME_SZ];/* Service name from ticket     */
    char                iname[INST_SZ]; /* Instance name from ticket    */
    char		r_aname[ANAME_SZ]; /* Aname from req_id		*/
    char                r_inst[INST_SZ];   /* Instance from req_id 	*/
    char		r_realm[REALM_SZ]; /* Realm from req_id		*/
    unsigned int	r_time_ms;	/* Fine time from req_id	*/
    unsigned long	r_time_sec;	/* Coarse time from req_id	*/
    static char *ptr;			/* For stepping through 	*/
    unsigned long	delta_t;	/* time in req_id - time	*/
    long		tkt_age;	/* Age of ticket		*/
    static int		swap_bytes;
    static int		mutual;
    static unsigned char s_kvno;
d101 1
d109 2
a110 3
    if ((KRB_PROT_VERSION != pvers) && (3 != pvers)) {
	    return(RD_AP_VERSION);
    }
d114 2
a115 1
    if ((*ptr & 1) != HOST_BYTE_ORDER) swap_bytes++;
d118 1
d120 1
d123 1
a123 1
            break;
d125 4
a128 2
	    mutual++;
            break;
d130 1
a130 1
	    return(RD_AP_MSG_TYPE);
a131 10
	
#ifdef lint
    /* XXX mutual is set but not used; why??? */
    /* this is a crock to get  lint to shut up */
    if (mutual)
	    mutual = 0;
#endif lint
    s_kvno = *ptr++;		/* get server key version		*/
    (void) strcpy(realm,ptr);  	/* And the realm of the issuing kerberos*/
    ptr += strlen(ptr) + 1;	/* skip the realm "hint"	   	*/
d133 4
d138 11
a148 10
    			strcmp(st_rlm,realm) || (st_kvno != s_kvno))) {
	    if (*fn == 0) fn = KEYFILE;
	    st_kvno = s_kvno;
	    if(read_service_key(service,instance,realm,(int) s_kvno,
				fn,(char *)skey))
		    return(RD_AP_UNDEC);
	    set_serv_key((char *)skey,0);
	    (void) strcpy(st_rlm,realm);
	    (void) strcpy(st_nam,service);
	    (void) strcpy(st_inst,instance);
d150 1
a150 1
    
d155 2
a156 1
    if (krb_ap_req_debug) log("ticket->length: %d",tkt->length);
d159 1
a159 1
    
d163 1
a163 1
	    return(RD_AP_UNDEC);
d166 5
a170 4
	    log("Ticket Contents.");
	    log(" Aname:   %s.%s",ad->pname,
		((int)*(ad->prealm) ? ad->prealm : "Athena"));
	    log(" Service: %s%s%s",sname,((int)*iname ? "." : ""),iname);
d178 2
a179 1
    if (krb_ap_req_debug) log("About to decrypt req_id");
d183 2
a184 1
    if (krb_ap_req_debug) log("Done.");
d194 2
a195 1
    if (swap_bytes) swap_u_long(ad->checksum); 
d201 1
a201 1
	    r_time_ms = 0;
d205 2
a206 1
    if (swap_bytes) swap_u_long(r_time_sec);
d209 2
a210 1
    if (krb_ap_req_debug) log("Pname:   %s %s",ad->pname,r_aname);
d213 4
a216 2
    if (krb_ap_req_debug) log("Realm:   %s %s",ad->prealm,r_realm);
    if (pvers != 3 && (strcmp(ad->prealm,r_realm) != 0)) return(RD_AP_INCON);
d218 2
a219 1
    if (krb_ap_req_debug) log("Address: %d %d",ad->address,from_addr);
d225 4
a228 4
	    if (krb_ap_req_debug) 
		    log("Time out of range: %d - %d = %d",
			t_local.tv_sec,r_time_sec,delta_t);
	    return(RD_AP_TIME);
d235 2
a236 2
	    log("Time: %d Issue Date: %d Diff: %d",
		t_local.tv_sec,ad->time_sec,tkt_age);
d239 3
a241 2
	    if((ad->time_sec - t_local.tv_sec) > CLOCK_SKEW)
		    return(RD_AP_NYV);}
d243 1
a243 1
	    return(RD_AP_EXP);
a246 3

    if(pvers == 3 && !strcmp(ad->prealm,"Athena"))
	    (void) strcpy(ad->prealm,KRB_REALM);
@


4.6
log
@Took byteorder.h out; that info is now in krb_conf.h.
@
text
@d4 1
a4 1
 *      $Locker: steiner $
d12 1
a12 1
"$Header: rd_ap_req.c,v 4.5 87/10/28 15:58:58 steiner Locked $";
d103 1
a103 1
    /* get msg version, type and byte order, and server key version	   */
d105 1
a105 1
    /* check version						   */
d107 3
a109 4
    if ((KRB_PROT_VERSION != pvers) && (3 != pvers))
	{
	return RD_AP_VERSION;
	}
d111 1
a111 1
    /* byte order							   */
d115 1
a115 1
    /* check msg type						   */
d117 2
a118 4
    switch (*ptr++ & ~1)
 	{
 	case AUTH_MSG_APPL_REQUEST:
	    {
d120 2
a121 4
            }
	case AUTH_MSG_APPL_REQUEST_MUTUAL:
            {
            mutual++;
d123 3
a125 6
	    }
	default:
	    {
	    return RD_AP_MSG_TYPE;
	    }
	}
d127 6
d138 12
a149 12
    			strcmp(st_rlm,realm) || (st_kvno != s_kvno)))
    	{if (*fn == 0) fn = KEYFILE;
	 st_kvno = s_kvno;
	 if(read_service_key(service,instance,realm,(int) s_kvno,
			     fn,(char *)skey))
		 return(RD_AP_UNDEC);
	 set_serv_key((char *)skey,0);
	 (void) strcpy(st_rlm,realm);
	 (void) strcpy(st_nam,service);
	 (void) strcpy(st_inst,instance);
	 }

d154 1
a154 1
    if(krb_ap_req_debug) log("ticket->length: %d",tkt->length);
d158 3
a160 3
    if(decomp_ticket(tkt,&ad->k_flags,ad->pname,ad->pinst,ad->prealm,
    		     &(ad->address),ad->session,(short *)&(ad->life),
		     &(ad->time_sec),sname,iname,ky,serv_key))
d191 6
d203 2
a204 2
    if(strcmp(ad->pname,r_aname) != 0) return(RD_AP_INCON);	
    if(strcmp(ad->pinst,r_inst) != 0) return(RD_AP_INCON);
d206 1
a206 1
    if(pvers != 3 && (strcmp(ad->prealm,r_realm) != 0)) return(RD_AP_INCON);
d213 6
a218 5
    if (delta_t > CLOCK_SKEW) 
    	{if (krb_ap_req_debug) 
            log("Time out of range: %d - %d = %d",
		t_local.tv_sec,r_time_sec,delta_t);
	 return(RD_AP_TIME);}
d224 2
a225 2
    	log("Time: %d Issue Date: %d Diff: %d",
	    t_local.tv_sec,ad->time_sec,tkt_age);
d227 3
a229 3
    if (t_local.tv_sec < ad->time_sec)
      {if((ad->time_sec - t_local.tv_sec) > CLOCK_SKEW)
	 return(RD_AP_NYV);}
d231 1
a231 1
      return(RD_AP_EXP);
d237 1
a237 1
      (void) strcpy(ad->prealm,KRB_REALM);
@


4.5
log
@jtkohl's changes.
@
text
@d2 3
a4 3
 *      $Source: /paris/u3/kerberos.new/lib/krb/RCS/rd_ap_req.c,v $
 *      $Author: jtkohl $
 *      $Locker: jtkohl $
d11 2
a12 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 4.4 87/10/20 17:12:14 jtkohl Locked $";
a17 1
#include	<byteorder.h>
@


4.4
log
@lint fixes.
@
text
@d2 2
a3 2
 *      $Source: /u3/kerberos.new/lib/krb/RCS/rd_ap_req.c,v $
 *      $Author: steiner $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 4.3 87/09/14 16:25:11 jtkohl Locked $";
d21 1
a21 1
extern  int     ap_req_debug;
d42 3
d156 1
a156 1
    if(ap_req_debug) log("ticket->length: %d",tkt->length);
d165 1
a165 1
    if (ap_req_debug) {
d177 1
a177 1
    if (ap_req_debug) log("About to decrypt req_id");
d181 1
a181 1
    if (ap_req_debug) log("Done.");
d198 1
a198 1
    if (ap_req_debug) log("Pname:   %s %s",ad->pname,r_aname);
d201 1
a201 1
    if (ap_req_debug) log("Realm:   %s %s",ad->prealm,r_realm);
d204 1
a204 1
    if (ap_req_debug) log("Address: %d %d",ad->address,from_addr);
d210 1
a210 1
    	{if (ap_req_debug) 
d218 1
a218 1
    if (ap_req_debug) 
@


4.3
log
@Replaced hardcoded "ATHENA.MIT.EDU" with KRB_REALM
(bug pointed out by Jim Bloom).
@
text
@d2 1
a2 1
 *      $Source: /mit/s/t/steiner/kerberos/lib/krb/RCS/rd_ap_req.c,v $
d4 1
a4 1
 *      $Locker: steiner $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 4.2 87/09/10 16:20:58 steiner Locked $";
d17 1
d19 1
a23 1
static struct  	timezone tz = { 0, 0 };
d47 4
a50 2
	if (cvt) string_to_key(key,ky);
	else bcopy(key,ky,8);
a80 1
    static C_Block	session;	/* Session key from ticket 	*/
d90 1
a90 1
    static unsigned char *ptr;		/* For stepping through 	*/
d98 1
a98 1
    ptr = (unsigned char *) authent->dat;
d133 1
a133 1
    strcpy(realm,ptr);  	/* And the realm of the issuing kerberos*/
d140 2
a141 1
	 if(read_service_key(service,instance,realm,s_kvno,fn,skey))
d143 4
a146 4
	 set_serv_key(skey,0);
	 strcpy(st_rlm,realm);
	 strcpy(st_nam,service);
	 strcpy(st_inst,instance);
d151 1
a151 1
    bcopy(ptr+1,tkt->dat,tkt->length);
d158 3
a160 3
    		     &(ad->address),ad->session,&(ad->life),&(ad->time_sec),
		     sname,iname,ky,serv_key))
       	return(RD_AP_UNDEC);
d162 6
a167 7
    if (ap_req_debug)
        {
         log("Ticket Contents.");
         log(" Aname:   %s.%s",ad->pname,
	      ((int)*(ad->prealm) ? ad->prealm : "Athena"));
         log(" Service: %s%s%s",sname,((int)*iname ? "." : ""),iname);
        }
d171 1
a171 1
    bcopy(ptr + tkt->length, req_id->dat,req_id->length);
d176 2
a177 2
    pcbc_encrypt(req_id->dat,req_id->dat,(long) req_id->length,
				seskey_sched,ad->session,0);
d179 2
a180 2
    ptr = (unsigned char *) req_id->dat;
    strcpy(r_aname,ptr);                        /* Authentication name  */
d182 1
a182 1
    strcpy(r_inst,ptr);                         /* Authentication instance */
d184 1
a184 1
    strcpy(r_realm,ptr);                        /* Authentication name  */
d186 1
a186 1
    bcopy(ptr,&ad->checksum,4);		        /* Checksum		*/
d189 3
a191 2
    r_time_ms = *(ptr++);			/* Time (fine)  	*/
    bcopy(ptr,&r_time_sec,4);			/* Time (coarse)	*/
d204 2
a205 2
    gettimeofday(&t_local,&tz);
    delta_t = abs(t_local.tv_sec - r_time_sec);
d229 1
a229 1
      strcpy(ad->prealm,KRB_REALM);
@


4.2
log
@Changed include files configuration and referencing.
@
text
@d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 4.1 87/09/01 15:47:20 steiner Locked $";
d226 1
a226 1
      strcpy(ad->prealm,"ATHENA.MIT.EDU");
@


4.1
log
@No change; starting version 4.
@
text
@d3 1
a3 1
 *      $Author: bcn $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.8 86/09/05 16:07:15 steiner Locked $";
d16 1
a16 1
#include        "prot.h"
@


3.8
log
@Fixed time skew problem.
@
text
@d2 1
a2 1
 *      $Source: /mit/projects/auth/src/lib/krb/RCS/rd_ap_req.c,v $
d4 1
a4 1
 *      $Locker: bcn $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.7 86/08/22 16:30:43 bcn Exp $";
@


3.7
log
@Work on getting realms to work, and a time skew bug fixed.
@
text
@d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.6 86/06/18 14:13:51 bcn Exp Foo$";
a45 3
#ifdef	DEBUG					/* sensitive							   */
	if (ap_req_debug) log("cvt = %d, key = \"%s\"",cvt,key);
#endif
d80 1
a80 2
    unsigned char	skey[KKEY_SZ];		/* Session key from ticket 	*/
    unsigned short      life;           /* Lifetime of ticket           */
d155 2
a156 2
    		     &(ad->address),ad->session,&life,&(ad->time_sec),sname,
		     iname,ky,serv_key))
d219 1
a219 1
    else if ((t_local.tv_sec - ad->time_sec) > 5 * 60 * life)
@


3.6
log
@Key obtained from readservkey is now incrypted.
@
text
@d3 2
a4 2
 *      $Author: spm $
 *      $Locker:  $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.5 86/05/23 13:11:27 spm Exp $";
d83 1
a83 1
    unsigned char		skey[KKEY_SZ];		/* Session key from ticket 	*/
d98 1
d105 2
a106 1
    if (KRB_PROT_VERSION != *ptr++)
d143 1
a143 5
	 	{log("Can't read service key");
		 return(RD_AP_UNDEC);}
#ifdef	DEBUG
	 if (ap_req_debug) log("fn = %s key = %s",fn,skey);
#endif
d200 1
a200 1
    if(strcmp(ad->prealm,r_realm) != 0) return(RD_AP_INCON);
d220 6
a225 7
    if (tkt_age < -(CLOCK_SKEW)) 
    	{if (ap_req_debug) log("Ticket Expired (Out of range)");
	 return(RD_AP_EXP);}
    if (tkt_age > 5 * 60 * life) 
    	{if (ap_req_debug) log("Ticket Expired");
	 return(RD_AP_EXP);}

d228 4
@


3.5
log
@*** empty log message ***
@
text
@d3 2
a4 2
 *      $Author: bcn $
 *      $Locker: spm $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.4 86/05/14 14:45:23 bcn Exp $";
d146 1
a146 1
	 set_serv_key(skey,1);
@


3.4
log
@rd_ap_req now gets keys on its own if necessary.  The argument
were also changed to support the specification of a filename
if desired.
@
text
@d3 2
a4 2
 *      $Author: spm $
 *      $Locker: bcn $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.3 86/04/04 17:57:32 spm Exp $";
d46 3
d143 3
@


3.3
log
@key from char[8] to C_Block
@
text
@d3 2
a4 2
 *      $Author: bcn $
 *      $Locker: spm $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.2 86/04/02 16:39:40 bcn Exp $";
d25 5
a29 1
static  C_Block         ky;          /* Initialization vector        */
d56 2
a57 1
 * obtained from the authenticator.
d64 1
a64 1
rd_ap_req(authent,service,instance,from_addr,ad)
d70 1
d77 2
a78 1
    static C_Block		session;	/* Session key from ticket 	*/
d80 1
d129 3
a131 2
    s_kvno = *ptr++;	/* get server key version		   */
    ptr += strlen(ptr) + 1;	/* skip the realm "hint"	   */
d133 13
d153 1
@


3.2
log
@Changed arguments to rd_ap_req so that it now
takes a structure of type AUHT_DAT instead of
individual variables to be filled in.
@
text
@d4 1
a4 1
 *      $Locker: bcn $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 3.1 86/03/28 09:54:18 bcn Exp $";
d25 1
a25 1
static  char            ky[8];          /* Initialization vector        */
d71 1
a71 1
    static char		session[8];	/* Session key from ticket 	*/
@


3.1
log
@Update to protocol revision 3 complete.
@
text
@d3 2
a4 2
 *      $Author: spm $
 *      $Locker:  $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.16 86/03/25 15:52:13 spm Exp $";
d14 1
a16 1
#include        "/projects/auth/include/des.h"
d50 3
a52 3
 * address of the host originating the request, and pointers to various
 * variables which are to be set to information obtained from the
 * authenticator.
d59 6
a64 14
rd_ap_req(authent,service,instance,from_addr,k_flags,pname,pinst,prealm,
	  checksum,time_ms,time_sec,address)
KTEXT   authent;        /* The authenticator                    */
char    *service;       /* Service name                         */
char    *instance;      /* Service instance                     */
long	from_addr;	/* Net address of origination station	*/
unsigned char    *k_flags;   /* Kerberos flags   (filled in)    */
char    *pname;         /* Authentication name   (filled in)    */
char    *pinst;         /* Instance              (filled in)    */
char    *prealm;        /* Authentication domain (filled in)    */
unsigned long    *checksum;      /* Checksum              (filled in)    */
unsigned short   *time_ms;       /* Time (fine)           (filled in)    */
unsigned long    *time_sec;      /* Time (coarse)         (filled in)    */ 
long    *address;       /* Network address       (filled in)    */
d71 2
a72 2
    static	char     session[8]; /* Session key from ticket */
    static      Key_schedule seskey_sched;/* Key sched for session key	*/
d77 2
a78 2
    char                r_inst[INST_SZ];/* Principal's instance from rid*/
    char		r_realm[REALM_SZ]; /* realm from req_id		*/
d82 1
a82 1
    unsigned long	delta_t;	/* |time in req_id - time	*/
d131 3
a133 2
    if(decomp_ticket(tkt,k_flags,pname,pinst,prealm,address,session,
       		     &life,time_sec,sname,iname,ky,serv_key))
d139 2
a140 1
         log(" Aname:   %s.%s",pname,((int)*prealm ? prealm : "Athena"));
d150 1
a150 1
    key_sched(session,seskey_sched);
d152 1
a152 1
				seskey_sched,session,0);
d161 1
a161 1
    bcopy(ptr,checksum,4);		        /* Checksum		*/
d163 1
a163 1
    if (swap_bytes) swap_u_long(*checksum); 
d169 5
a173 5
    if (ap_req_debug) log("Pname:   %s %s",pname,r_aname);
    if(strcmp(pname,r_aname) != 0) return(RD_AP_INCON);	
    if (ap_req_debug) log("Realm:   %s %s",prealm,r_realm);
    if(strcmp(pinst,r_inst) != 0) return(RD_AP_INCON);
    if(strcmp(prealm,r_realm) != 0) return(RD_AP_INCON);
d175 2
a176 2
    if (ap_req_debug) log("Address: %d %d",*address,from_addr);
    if (from_addr && (*address != from_addr)) return(RD_AP_BADD);
d188 1
a188 1
    tkt_age = t_local.tv_sec - *time_sec;
d191 1
a191 1
	    t_local.tv_sec,*time_sec,tkt_age);
d201 1
@


1.16
log
@add byte order and alignment stuff
@
text
@d4 1
a4 2
 *      $Locker: bcn $
 *      $Log:	rd_ap_req.c,v $
d11 1
a11 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.14 86/01/11 13:57:54 spm Exp $";
d43 1
d130 1
a130 1
    ptr += strlen(*ptr) + 1;	/* skip the realm "hint"	   */
d134 1
a134 1
    bcopy(ptr,tkt->dat,tkt->length);
d151 1
a151 2
    req_id->length = (int) *(++ptr);	/* skip ticket length		   */
    ptr++;			/* skip req_id length			   */
d155 1
d159 1
d168 5
a172 4
    if (swap_bytes) swap_u_long(*checksum)
    r_time_ms = *(ptr+4);			/* Time (fine)  	*/
    bcopy(ptr+5,&r_time_sec,4);			/* Time (coarse)	*/
    if (swap_bytes) swap_u_long(r_time_sec)
d175 1
a175 1
    if (ap_req_debug) log("An: %s %s",pname,r_aname);
d177 1
a177 1
    if (ap_req_debug) log("Ar: %s %s",prealm,r_realm);
d181 1
a181 1
    if (ap_req_debug) log("Ad1: %d %d",*address,from_addr);
d187 3
a189 1
    	{if (ap_req_debug) log("Time out of range");
@


1.15
log
@Updates to rev 3 of protocol.
@
text
@d59 2
a60 2
rd_ap_req(authent,service,instance,from_addr,pname,pinst,prealm,
	  checksum,time_ms,time_sec,address,perm,quota)
d65 1
d69 3
a71 3
long    *checksum;      /* Checksum              (filled in)    */
short   *time_ms;       /* Time (fine)           (filled in)    */
long    *time_sec;      /* Time (coarse)         (filled in)    */ 
a72 2
short   *perm;          /* Permissions           (filled in)    */
short   *quota;         /* Quota                 (filled in)    */
d87 3
a89 3
    int			r_time_ms;	/* Fine time from req_id	*/
    long		r_time_sec;	/* Coarse time from req_id	*/
    char		*ptr;		/* For stepping through req_id	*/
d92 3
d96 36
d133 2
a134 2
    tkt->length = (int) *(authent->dat+ 4 + strlen(apreq_realm(authent)));
    bcopy(authent->dat+6+strlen(apreq_realm(authent)),tkt->dat,tkt->length);
d139 1
a139 1
    if(decomp_ticket(tkt,pname,pinst,prealm,address,session,perm,quota,
d151 3
a153 3
    req_id->length = (int) *(authent->dat+ 5 + strlen(apreq_realm(authent)));
    bcopy(authent->dat+6+strlen(apreq_realm(authent))+tkt->length,
	  req_id->dat,req_id->length);
d159 1
a159 1
    ptr = req_id->dat;
d167 1
d170 2
a171 1

@


1.14
log
@delete & address of operator in bcopy(...checksum...)
@
text
@d4 1
a4 1
 *      $Locker: spm $
a5 41
 * Revision 1.13  86/01/10  16:38:57  spm
 * change calling sequence for decomp_ticket.
 * 
 * Revision 1.12  86/01/07  20:21:12  spm
 * cast to (long) length for pcbc
 * 
 * Revision 1.11  86/01/07  12:38:29  spm
 * change cbc mode to pcbc mode
 * 
 * Revision 1.10  85/12/06  20:57:14  bcn
 * tz and t_local were made static.
 * Check added for error return from decomp_ticket.
 * 
 * Revision 1.9  85/12/06  15:09:16  bcn
 * Add argument to set_serv_key to control whether string_to_key is used.
 * 
 * Revision 1.8  85/12/04  10:18:54  bcn
 * Add time checks and lifetime checks, etc.
 * 
 * Revision 1.7  85/11/26  13:28:06  spm
 * change set_key to des_set_key
 * 
 * Revision 1.6  85/11/25  14:36:04  bcn
 * Add check for req_id.  Changed arguments.
 * 
 * Revision 1.5  85/11/17  20:49:00  bcn
 * Separate mk_ap_req and rd_ap_req into different file to make
 * ready for libkrb.  Also documented and cleaned up some code.
 * 
 * Revision 1.4  85/11/15  16:43:35  spm
 * *** empty log message ***
 * 
 * Revision 1.3  85/11/14  17:55:25  spm
 * add byte_order()
 * 
 * Revision 1.2  85/11/13  11:02:30  bcn
 * Add realm to information contained in ticket for rd_ap_req.
 * 
 * Revision 1.1  85/11/03  20:11:50  bcn
 * Initial revision
 * 
d7 1
a7 1
 * Copyright 1985 by the Massachusetts Institute of Technology
d12 1
a12 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.13 86/01/10 16:38:57 spm Exp $";
d16 1
d44 1
a44 1
        des_set_key(ky,serv_key);
d59 1
a59 1
rd_ap_req(authent,service,instance,from_addr,aname,realm,
d65 3
a67 2
char    *aname;         /* Authentication name   (filled in)    */
char    *realm;         /* Authentication domain (filled in)    */
d86 1
d95 2
a96 2
    tkt->length = (int) *(authent->dat+3);
    bcopy(authent->dat+5,tkt->dat,tkt->length);
d101 1
a101 1
    if(decomp_ticket(tkt,aname,realm,address,session,perm,quota,
d108 1
a108 1
         log(" Aname:   %s.%s",aname,((int)*realm ? realm : "Athena"));
d113 3
a115 2
    req_id->length = (int) *(authent->dat+4);
    bcopy(authent->dat+5+tkt->length,req_id->dat,req_id->length);
d118 1
a118 1
    des_set_key(session,seskey_sched);
d124 2
d133 5
a137 4
    if (ap_req_debug) log("An: %s %s",aname,r_aname);
    if(strcmp(aname,r_aname) != 0) return(RD_AP_INCON);	
    if (ap_req_debug) log("Ar: %s %s",realm,r_realm);
    if(strcmp(realm,r_realm) != 0) return(RD_AP_INCON);
@


1.13
log
@change calling sequence for decomp_ticket.
@
text
@d6 3
d53 1
a53 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.12 86/01/07 20:21:12 spm Exp $";
d163 1
a163 1
    bcopy(ptr,&checksum,4);		        /* Checksum		*/
@


1.12
log
@cast to (long) length for pcbc
@
text
@d6 3
d50 1
a50 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.11 86/01/07 12:38:29 spm Exp $";
d137 1
a137 1
       		     &life,time_sec,sname,iname,ky))
@


1.11
log
@change cbc mode to pcbc mode
@
text
@d3 1
a3 1
 *      $Author: bcn $
d6 3
d47 1
a47 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.10 85/12/06 20:57:14 bcn Exp $";
d150 2
a151 1
    pcbc_encrypt(req_id->dat,req_id->dat,req_id->length,seskey_sched,session,0);
@


1.10
log
@tz and t_local were made static.
Check added for error return from decomp_ticket.
@
text
@d4 1
a4 1
 *      $Locker:  $
d6 4
d44 1
a44 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.9 85/12/06 15:09:16 bcn Exp $";
d147 1
a147 1
    cbc_encrypt(req_id->dat,req_id->dat,req_id->length,seskey_sched,session,0);
@


1.9
log
@Add arguemtn to set_serv_key to control whether string_to_key is used.
@
text
@d4 1
a4 1
 *      $Locker: bcn $
d6 3
d40 1
a40 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.8 85/12/04 10:18:54 bcn Exp $";
a47 2
struct  	timeval t_local = { 0, 0 };
struct  	timezone tz = { 0, 0 };
d49 3
a120 1
    log("tl %d",tkt->length);
d126 3
a128 2
    decomp_ticket(tkt,aname,realm,address,session,perm,quota,
                  &life,time_sec,sname,iname,ky);        
@


1.8
log
@Add time checks and lifetime checks, etc.
@
text
@d3 2
a4 2
 *      $Author: spm $
 *      $Locker:  $
d6 3
d37 1
a37 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.7 85/11/26 13:28:06 spm Exp $";
d57 4
d62 1
a62 1
set_serv_key(key)
d64 1
d66 1
a66 1
        string_to_key(key,ky);
@


1.7
log
@change set_key to des_set_key
@
text
@d3 2
a4 2
 *      $Author: bcn $
 *      $Locker: spm $
d6 3
d34 1
a34 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.6 85/11/25 14:36:04 bcn Exp $";
d94 2
a95 2
	static    char                session[8];     /* Session key from ticket      */
	static    Key_schedule		seskey_sched;	/* Key sched for session key	*/
d105 1
d109 1
a129 1
    log("Session: %d %d %d %d %d %d %d %d",(int) *session,(int) *(session+1),(int)*(session+2),(int)*(session+3),(int)*(session+4),(int)*(session+5),(int)*(session+6),(int)*(session+7));
a130 3
    log("key sched: %d %d %d %d",seskey_sched[0],seskey_sched[1],
		seskey_sched[2],seskey_sched[3]);
    log("Req_id->dat: %d %d %d %d",(int)* req_id->dat,(int)*(req_id->dat+1),(int)*(req_id->dat+2),(int)*(req_id->dat+3));
a131 2
    log("Req_id->dat: %d %d %d %d",(int)* req_id->dat,(int)*(req_id->dat+1),(int)*(req_id->dat+2),(int)*(req_id->dat+3));
    log("req_id length: %d",req_id->length);
d142 1
a142 1
    log("An: %s %s",aname,r_aname);
d144 1
a144 1
    log("Ar: %s %s",realm,r_realm);
d147 1
a147 1
    log("Ad1: %d %d",*address,from_addr);
d152 17
a168 1
    if (delta_t > 5*60) return(RD_AP_TIME);
@


1.6
log
@Add check for req_id.  Changed arguments.
@
text
@d4 1
a4 1
 *      $Locker: bcn $
d6 3
d31 1
a31 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.5 85/11/17 20:49:00 bcn Exp $";
d56 1
a56 1
        set_key(ky,serv_key);
d91 2
a92 2
    char                session[8];     /* Session key from ticket      */
    Key_schedule	seskey_sched;	/* Key sched for session key	*/
d126 3
a128 1
    setkey(session,seskey_sched);
a129 1
    log("key sched: %d %d %d %d",(int)* (char *)seskey_sched,(int)*(char *)(seskey_sched+1),(int)*(char *)(seskey_sched+2),(int)*(char *)(seskey_sched+3));
@


1.5
log
@Separate mk_ap_req and rd_ap_req into different file to make
ready for libkrb.  Also documented and cleaned up some code.
@
text
@d3 1
a3 1
 *      $Author: spm $
d5 5
a9 1
 *      $Log:   rd_ap_req.c,v $
d28 1
a28 1
static char *rcsid_rd_ap_req_c = "$Header: rd_ap_req.c,v 1.4 85/11/15 16:43:35 spm Exp $";
d31 1
a31 2
#include        "krb.h"
#include        "prot.h"
d33 1
d36 2
d58 4
a61 3
 * rd_ap_req takes an authenticator, a service name, an instace and
 * pointers to various variables which are to be set to information
 * obtained from the authenticator.
d68 3
a70 3
rd_ap_req(authent,service,instance,aname,realm,checksum,
          time_ms,time_sec,address,perm,quota)
TEXT    authent;        /* The authenticator                    */
d73 1
d83 4
a86 2
    static      TEXT_ST ticket;         /* Temp storage for ticket */
    static      TEXT    tkt = &ticket;
d89 1
d93 6
d113 2
a114 2
         log(" Aname:   %s.%s",aname,((int)*realm ? "Athena" : realm));
         log(" Service: %s%s%s",sname,((int)*iname ? "" : "."),iname);
d117 36
a152 1
    /* check of the request ID goes here. */
@


1.4
log
@*** empty log message ***
@
text
@d2 7
a8 4
 * 	$Source: /mit/projects/auth/src/client/RCS/sprot.c,v $
 * 	$Author: spm $
 * 	$Locker: spm $
 *    	$Log:	sprot.c,v $
d24 2
a25 2
static char *rcsid_sprot_c = "$Header: sprot.c,v 1.3 85/11/14 17:55:25 spm Exp $";
#endif	lint
d27 3
a29 3
#include	"/projects/auth/src/kdc/prot.h"
#include	"sprot.h"
#include 	"/projects/auth/include/des.h"
d31 1
a31 2
static	Key_schedule	serv_key;
static	char		ky[8];		/* temporary hack */
d33 10
d44 1
a44 1
char	*key;
d46 2
a47 2
	string_to_key(key,ky);
	set_key(ky,serv_key);
d51 23
a73 8
mk_ap_req(authent,service,instance,aname,checksum,time_ms,time_sec)
TEXT	authent;
char	*service;
char	*instance;
char	*aname;
long	checksum;
short	time_ms;
long	time_sec;
d75 2
a76 13
	static	TEXT_ST	req_st;
	TEXT	req_id = &req_st;
	char	*v =  authent->dat;
	char	*t =  (authent->dat+1);
	char	*kv =  (authent->dat+2);
	char	*tl =  (authent->dat+3);
	char	*idl =  (authent->dat+4);
	char	session[8];
	int	*lifetime;
	int	*kvno;
	TEXT	ticket;
	long	issue_date;	
	Key_schedule	key_s;
d78 4
a81 19
	*v = (char) KRB_PROT_VERSION;
	*t = (char) AUTH_MSG_APPL_REQUEST;
	*t |= HOST_BYTE_ORDER;
	retrieve(service,instance,session,lifetime,kvno,ticket,&issue_date);
	*kv = (char) kvno;
	*tl = (char) ticket->length;
	bcopy(ticket->dat,authent->dat+5,ticket->length);
	authent->length = 5 + ticket->length;
	printf("Ticket->length = %d\n",ticket->length);
	printf("Issue date: %d\n",issue_date);
	
	strcpy(req_id->dat,aname);
	req_id->length = strlen(aname)+1;
	bcopy(&checksum,req_id->dat+req_id->length,4);
	*(req_id->dat+req_id->length+4) = (char) time_ms;
	bcopy(&time_sec,req_id->dat+req_id->length+5,4);
	req_id->length += 9;
	
        req_id->length = ((req_id->length+7)/8)*8;
d83 3
a85 8
	set_key(session,key_s);
	cbc_encrypt(req_id->dat,req_id->dat,req_id->length,key_s,session,1);
	bcopy(req_id->dat,authent->dat+authent->length,req_id->length);
	authent->length += req_id->length;
	*idl = (char) req_id->length;
	printf("Authent->length = %d\n",authent->length);
	printf("idl = %d, tl = %d\n",(int) *idl, (int) *(idl-1));
}
d87 1
a87 19
rd_ap_req(authent,service,instance,aname,realm,checksum,time_ms,time_sec,address,perm,quota)
TEXT	authent;
char	*service;
char	*instance;
char	*aname;
char	*realm;
long	*checksum;
short	*time_ms;
long	*time_sec;
long	*address;
short	*perm;
short	*quota;
{
	static	TEXT_ST	ticket;
	static	TEXT	tkt = &ticket;
	char		session[8];
	unsigned short	life;
	char		sname[40];
	char		iname[40];
d89 3
a91 5
	tkt->length = (int) *(authent->dat+3);
	bcopy(authent->dat+5,tkt->dat,tkt->length);
	log("ticket->length: %d",tkt->length);
	decomp_ticket(tkt,aname,realm,address,session,perm,quota,life,time_sec,sname,iname,ky);
	
d93 8
@


1.3
log
@add byte_order()
@
text
@d3 1
a3 1
 * 	$Author: bcn $
d6 3
d21 1
a21 1
static char *rcsid_sprot_c = "$Header: sprot.c,v 1.2 85/11/13 11:02:30 bcn Exp $";
d64 1
a64 1
	*t |= byte_order();
@


1.2
log
@Add realm to information contained in ticket for rd_ap_req.
@
text
@d4 1
a4 1
 * 	$Locker: bcn $
d6 3
d18 1
a18 1
static char *rcsid_sprot_c = "$Header: sprot.c,v 1.1 85/11/03 20:11:50 bcn Exp $";
d61 1
@


1.1
log
@Initial revision
@
text
@d2 7
a8 4
 * 	$Source: $
 * 	$Author: $
 * 	$Locker: $
 *    	$Log:	 $
d15 1
a15 1
static char *rcsid_sprot_c = "$Header: $";
d84 1
a84 1
rd_ap_req(authent,service,instance,aname,checksum,time_ms,time_sec,address,perm,quota)
d89 1
d107 1
a107 1
	decomp_ticket(tkt,aname,address,session,perm,quota,life,time_sec,sname,iname,ky);
@
