head     4.22;
branch   ;
access   ;
symbols  PATCH8:4.20 PATCH7:4.19 KPATCH6:4.19 ASRSNAP1001:4.19 PATCH5:4.19 KPATCH4:4.18 KPATCH3:4.17 KPATCH2:4.15 KREL1:4.15 BETA5/24/88:4.11;
locks    ; strict;
comment  @ * @;


4.22
date     92.07.19.13.23.29;  author bostic;  state Exp;
branches ;
next     4.21;

4.21
date     90.06.25.20.57.21;  author kfall;  state Exp;
branches ;
next     4.20;

4.20
date     90.01.02.13.40.37;  author jtkohl;  state Exp;
branches ;
next     4.19;

4.19
date     89.07.25.17.53.42;  author qjb;  state Exp;
branches ;
next     4.18;

4.18
date     89.05.25.15.47.55;  author jtkohl;  state Exp;
branches ;
next     4.17;

4.17
date     89.05.17.11.04.18;  author jtkohl;  state Exp;
branches ;
next     4.16;

4.16
date     89.05.16.14.58.47;  author wesommer;  state Exp;
branches ;
next     4.15;

4.15
date     89.01.23.09.24.55;  author jtkohl;  state Exp;
branches ;
next     4.14;

4.14
date     89.01.05.11.51.25;  author raeburn;  state Exp;
branches ;
next     4.13;

4.13
date     88.12.01.14.35.57;  author jtkohl;  state Exp;
branches ;
next     4.12;

4.12
date     88.05.25.16.53.16;  author steiner;  state Exp;
branches ;
next     4.11;

4.11
date     88.02.29.11.44.45;  author steiner;  state Exp;
branches ;
next     4.10;

4.10
date     88.02.24.18.16.17;  author steiner;  state Exp;
branches ;
next     4.9;

4.9
date     88.01.12.21.24.18;  author steiner;  state Exp;
branches ;
next     4.8;

4.8
date     87.12.06.11.25.37;  author steiner;  state Exp;
branches ;
next     4.7;

4.7
date     87.11.08.03.48.13;  author raeburn;  state Exp;
branches ;
next     4.6;

4.6
date     87.10.29.10.48.09;  author jtkohl;  state Exp;
branches ;
next     4.5;

4.5
date     87.10.20.17.12.48;  author jtkohl;  state Exp;
branches ;
next     4.4;

4.4
date     87.10.16.18.53.42;  author steiner;  state Exp;
branches ;
next     4.3;

4.3
date     87.09.30.15.49.34;  author steiner;  state Exp;
branches ;
next     4.2;

4.2
date     87.09.10.16.21.10;  author steiner;  state Exp;
branches ;
next     4.1;

4.1
date     87.09.01.15.47.44;  author steiner;  state Exp;
branches ;
next     3.4;

3.4
date     86.12.01.16.10.38;  author root;  state Exp;
branches ;
next     3.3;

3.3
date     86.09.05.16.05.14;  author bcn;  state Exp;
branches ;
next     3.2;

3.2
date     86.08.12.12.22.23;  author bcn;  state Exp;
branches ;
next     3.1;

3.1
date     86.03.28.10.05.23;  author bcn;  state Exp;
branches ;
next     1.6;

1.6
date     85.12.06.14.15.36;  author bcn;  state Exp;
branches ;
next     1.5;

1.5
date     85.12.04.10.07.57;  author bcn;  state Exp;
branches ;
next     1.4;

1.4
date     85.11.11.15.51.04;  author spm;  state Exp;
branches ;
next     1.3;

1.3
date     85.11.11.11.44.32;  author spm;  state Exp;
branches ;
next     1.2;

1.2
date     85.11.08.14.56.08;  author bcn;  state Exp;
branches ;
next     1.1;

1.1
date     85.10.10.11.18.33;  author bcn;  state Exp;
branches ;
next     ;


desc
@Initial RCS checkin
@


4.22
log
@check in for Kevin Fall by TK, not really sure what he did
@
text
@/*
 * $Source: /usr/src/kerberosIV/krb/RCS/send_to_kdc.c,v $
 * $Author: kfall $
 *
 * Copyright 1987, 1988 by the Massachusetts Institute of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#ifndef lint
static char rcsid_send_to_kdc_c[] =
"$Id: send_to_kdc.c,v 4.21 90/06/25 20:57:21 kfall Exp Locker: kfall $";
#endif /* lint */

#include <mit-copyright.h>

#include <des.h>
#include <krb.h>
#include <prot.h>

#include <stdio.h>
#include <errno.h>
#include <sys/time.h>
#include <sys/types.h>
#ifdef lint
#include <sys/uio.h>            /* struct iovec to make lint happy */
#endif /* lint */
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <strings.h>

#define S_AD_SZ sizeof(struct sockaddr_in)

extern int errno;
extern int krb_debug;

extern char *malloc(), *calloc(), *realloc();

int krb_udp_port = 0;

/* CLIENT_KRB_TIMEOUT indicates the time to wait before
 * retrying a server.  It's defined in "krb.h".
 */
static struct timeval timeout = { CLIENT_KRB_TIMEOUT, 0};
static char *prog = "send_to_kdc";
static send_recv();

/*
 * This file contains two routines, send_to_kdc() and send_recv().
 * send_recv() is a static routine used by send_to_kdc().
 */

/*
 * send_to_kdc() sends a message to the Kerberos authentication
 * server(s) in the given realm and returns the reply message.
 * The "pkt" argument points to the message to be sent to Kerberos;
 * the "rpkt" argument will be filled in with Kerberos' reply.
 * The "realm" argument indicates the realm of the Kerberos server(s)
 * to transact with.  If the realm is null, the local realm is used.
 *
 * If more than one Kerberos server is known for a given realm,
 * different servers will be queried until one of them replies.
 * Several attempts (retries) are made for each server before
 * giving up entirely.
 *
 * If an answer was received from a Kerberos host, KSUCCESS is
 * returned.  The following errors can be returned:
 *
 * SKDC_CANT    - can't get local realm
 *              - can't find "kerberos" in /etc/services database
 *              - can't open socket
 *              - can't bind socket
 *              - all ports in use
 *              - couldn't find any Kerberos host
 *
 * SKDC_RETRY   - couldn't get an answer from any Kerberos server,
 *		  after several retries
 */

send_to_kdc(pkt,rpkt,realm)
    KTEXT pkt;
    KTEXT rpkt;
    char *realm;
{
    int i, f;
    int no_host; /* was a kerberos host found? */
    int retry;
    int n_hosts;
    int retval;
    struct sockaddr_in to;
    struct hostent *host, *hostlist = NULL;
    char *cp;
    char krbhst[MAX_HSTNM];
    char lrealm[REALM_SZ];

    /*
     * If "realm" is non-null, use that, otherwise get the
     * local realm.
     */
    if (realm)
	(void) strcpy(lrealm, realm);
    else
	if (krb_get_lrealm(lrealm,0) != KSUCCESS) {
	    if (krb_debug)
		fprintf(stderr, "%s: can't get local realm\n", prog);
	    return(SKDC_CANT);
	}
    if (krb_debug)
        printf("lrealm is %s\n", lrealm);
    if (krb_udp_port == 0) {
        register struct servent *sp;
        if ((sp = getservbyname("kerberos","udp")) == 0) {
            if (krb_debug)
                fprintf(stderr, "%s: Can't get kerberos/udp service\n",
                        prog);
            return(SKDC_CANT);
        }
        krb_udp_port = sp->s_port;
        if (krb_debug)
            printf("krb_udp_port is %d\n", krb_udp_port);
    }
    bzero((char *)&to, S_AD_SZ);
    hostlist = (struct hostent *) malloc(sizeof(struct hostent));
    if (!hostlist)
        return (/*errno */SKDC_CANT);
    if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        if (krb_debug)
            fprintf(stderr,"%s: Can't open socket\n", prog);
        return(SKDC_CANT);
    }
    /* from now on, exit through rtn label for cleanup */

    no_host = 1;
    n_hosts = 0;
    for (i = 1; krb_get_krbhst(krbhst, lrealm, i) == KSUCCESS; ++i) {
        if (krb_debug) {
            printf("Getting host entry for %s...",krbhst);
            (void) fflush(stdout);
        }
        host = gethostbyname(krbhst);
        if (krb_debug) {
            printf("%s.\n",
                   host ? "Got it" : "Didn't get it");
            (void) fflush(stdout);
        }
        if (!host)
            continue;
        no_host = 0;    /* found at least one */
        n_hosts++;
        /* preserve host network address to check later
         * (would be better to preserve *all* addresses,
         * take care of that later)
         */
        hostlist = (struct hostent *)
            realloc((char *)hostlist,
                    (unsigned)
                    sizeof(struct hostent)*(n_hosts));
        if (!hostlist)
            return /*errno */SKDC_CANT;
        bcopy((char *)host, (char *)&hostlist[n_hosts-1],
              sizeof(struct hostent));
        host = &hostlist[n_hosts-1];
        cp = malloc((unsigned)host->h_length);
        if (!cp) {
            retval = /*errno */SKDC_CANT;
            goto rtn;
        }
        bcopy((char *)host->h_addr, cp, host->h_length);
/* At least Sun OS version 3.2 (or worse) and Ultrix version 2.2
   (or worse) only return one name ... */
#ifdef h_addr
        host->h_addr_list = (char **)malloc(sizeof(char *));
        if (!host->h_addr_list) {
            retval = /*errno */SKDC_CANT;
            goto rtn;
        }
#endif
        host->h_addr = cp;
        to.sin_family = host->h_addrtype;
        bcopy(host->h_addr, (char *)&to.sin_addr,
              host->h_length);
        to.sin_port = krb_udp_port;
        if (send_recv(pkt, rpkt, f, &to, hostlist)) {
            retval = KSUCCESS;
            goto rtn;
        }
        if (krb_debug) {
            printf("Timeout, error, or wrong descriptor\n");
            (void) fflush(stdout);
        }
    }
    if (no_host) {
	if (krb_debug)
	    fprintf(stderr, "%s: can't find any Kerberos host.\n",
		    prog);
        retval = SKDC_CANT;
        goto rtn;
    }
    /* retry each host in sequence */
    for (retry = 0; retry < CLIENT_KRB_RETRY; ++retry) {
        for (host = hostlist, i = 0; i < n_hosts; host++, i++) {
            to.sin_family = host->h_addrtype;
            bcopy(host->h_addr, (char *)&to.sin_addr,
                  host->h_length);
            if (send_recv(pkt, rpkt, f, &to, hostlist)) {
                retval = KSUCCESS;
                goto rtn;
            }
        }
    }
    retval = SKDC_RETRY;
rtn:
    (void) close(f);
    if (hostlist) {
        register struct hostent *hp;
        for (hp = hostlist, i = 0; i < n_hosts; hp++, i++)
#ifdef h_addr
            if (hp->h_addr_list) {
#endif
                if (hp->h_addr)
                    free(hp->h_addr);
#ifdef h_addr
                free((char *)hp->h_addr_list);
            }
#endif
        free((char *)hostlist);
    }
    return(retval);
}

/*
 * try to send out and receive message.
 * return 1 on success, 0 on failure
 */

static send_recv(pkt,rpkt,f,_to,addrs)
    KTEXT pkt;
    KTEXT rpkt;
    int f;
    struct sockaddr_in *_to;
    struct hostent *addrs;
{
    fd_set readfds;
    register struct hostent *hp;
    struct sockaddr_in from;
    int sin_size;
    int numsent;

    if (krb_debug) {
        if (_to->sin_family == AF_INET)
            printf("Sending message to %s...",
                   inet_ntoa(_to->sin_addr));
        else
            printf("Sending message...");
        (void) fflush(stdout);
    }
    if ((numsent = sendto(f,(char *)(pkt->dat), pkt->length, 0, 
			  (struct sockaddr *)_to,
                          S_AD_SZ)) != pkt->length) {
        if (krb_debug)
            printf("sent only %d/%d\n",numsent, pkt->length);
        return 0;
    }
    if (krb_debug) {
        printf("Sent\nWaiting for reply...");
        (void) fflush(stdout);
    }
    FD_ZERO(&readfds);
    FD_SET(f, &readfds);
    errno = 0;
    /* select - either recv is ready, or timeout */
    /* see if timeout or error or wrong descriptor */
    if (select(f + 1, &readfds, (fd_set *)0, (fd_set *)0, &timeout) < 1
        || !FD_ISSET(f, &readfds)) {
        if (krb_debug) {
            fprintf(stderr, "select failed: readfds=%x",
                    readfds);
            perror("");
        }
        return 0;
    }
    sin_size = sizeof(from);
    if (recvfrom(f, (char *)(rpkt->dat), sizeof(rpkt->dat), 0,
		 (struct sockaddr *)&from, &sin_size)
        < 0) {
        if (krb_debug)
            perror("recvfrom");
        return 0;
    }
    if (krb_debug) {
        printf("received packet from %s\n", inet_ntoa(from.sin_addr));
        fflush(stdout);
    }
    for (hp = addrs; hp->h_name != (char *)NULL; hp++) {
        if (!bcmp(hp->h_addr, (char *)&from.sin_addr.s_addr,
                  hp->h_length)) {
            if (krb_debug) {
                printf("Received it\n");
                (void) fflush(stdout);
            }
            return 1;
        }
        if (krb_debug)
            fprintf(stderr,
                    "packet not from %x\n",
                    hp->h_addr);
    }
    if (krb_debug)
        fprintf(stderr, "%s: received packet from wrong host! (%x)\n",
                "send_to_kdc(send_rcv)", from.sin_addr.s_addr);
    return 0;
}
@


4.21
log
@include des.h
@
text
@d2 2
a3 2
 * $Source: /usr/src/kerberosIV/src/lib/krb/RCS/send_to_kdc.c,v $
 * $Author: jtkohl $
d13 1
a13 1
"$Id: send_to_kdc.c,v 4.20 90/01/02 13:40:37 jtkohl Exp Locker: kfall $";
d93 1
a93 1
    struct hostent *host, *hostlist;
d105 1
a105 1
	if (krb_get_lrealm(lrealm,1)) {
a135 1
    /* get an initial allocation */
d159 1
a159 1
                    sizeof(struct hostent)*(n_hosts+1));
d173 1
a173 1
#if !(defined(ULTRIX022) || (defined(SunOS) && SunOS < 40))
d179 1
a179 1
#endif /* ULTRIX022 || SunOS */
a180 2
        bzero((char *)&hostlist[n_hosts],
              sizeof(struct hostent));
d203 1
a203 1
        for (host = hostlist; host->h_name != (char *)NULL; host++) {
d218 2
a219 2
        for (hp = hostlist; hp->h_name; hp++)
#if !(defined(ULTRIX022) || (defined(SunOS) && SunOS < 40))
d221 1
a221 1
#endif /* ULTRIX022 || SunOS */
d224 1
a224 1
#if !(defined(ULTRIX022) || (defined(SunOS) && SunOS < 40))
d227 1
a227 1
#endif /* ULTRIX022 || SunOS */
@


4.20
log
@change $Header to $Id
@
text
@d2 2
a3 2
 * $Source: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/send_to_kdc.c,v $
 * $Author: qjb $
d13 1
a13 1
"$Id: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/send_to_kdc.c,v 4.19 89/07/25 17:53:42 qjb Exp Locker: jtkohl $";
d18 1
@


4.19
log
@Conditional code based on ultrix or sun fixed
variable to in send_recv was changed to _to because
the mips machine couldn't handle a variable called to.
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/send_to_kdc.c,v $
 * $Author: jtkohl $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.18 89/05/25 15:47:55 jtkohl Exp $";
@


4.18
log
@re-apply fix from rev 4.16 (lost in a shuffle)
@
text
@d13 1
a13 1
"$Header: send_to_kdc.c,v 4.17 89/05/17 11:04:18 jtkohl Locked $";
d173 1
a173 1
#if !(defined(sun) || defined(ultrix))
d179 1
a179 1
#endif	/* !(defined(sun) || defined(ultrix)) */
d221 1
a221 1
#if !(defined(sun) || defined(ultrix))
d223 1
a223 1
#endif	/* !(defined(sun) || defined(ultrix)) */
d226 1
a226 1
#if !(defined(sun) || defined(ultrix))
d229 1
a229 1
#endif	/* !(defined(sun) || defined(ultrix)) */
d240 1
a240 1
static send_recv(pkt,rpkt,f,to,addrs)
d244 1
a244 1
    struct sockaddr_in *to;
d254 1
a254 1
        if (to->sin_family == AF_INET)
d256 1
a256 1
                   inet_ntoa(to->sin_addr));
d262 1
a262 1
			  (struct sockaddr *)to,
@


4.17
log
@fix argument casts on networking system calls
Programmer: Jon Rochlis
@
text
@d3 1
a3 1
 * $Author: wesommer $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.16 89/05/16 14:58:47 jtkohl Locked $";
d287 1
a287 1
    if (recvfrom(f, (char *)(rpkt->dat), BUFSIZ, 0,
@


4.16
log
@Programmer: John Kohl.,
The accepted size of a response was bigger than the buffer, which could
cause problems with overwriting data.
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.15 89/01/23 09:24:55 jtkohl Locked $";
d261 2
a262 1
    if ((numsent = sendto(f,(char *)(pkt->dat), pkt->length, 0, to,
d287 2
a288 1
    if (recvfrom(f, (char *)(rpkt->dat), sizeof(rpkt->dat), 0, &from, &sin_size)
@


4.15
log
@Programmer/Auditor: John Kohl
changes: name changes to krb_xxx
@
text
@d3 1
a3 1
 * $Author: raeburn $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.14 89/01/05 11:51:25 jtkohl Locked $";
d286 1
a286 1
    if (recvfrom(f, (char *)(rpkt->dat), BUFSIZ, 0, &from, &sin_size)
@


4.14
log
@(jtkohl) conditionalized no-hosts fprintf on krb_debug; fixed
code not handling null realm name properly.
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.13 88/12/01 14:35:57 jtkohl Locked $";
d104 1
a104 1
	if (get_krbrlm(lrealm,1)) {
d137 1
a137 1
    for (i = 1; get_krbhst(krbhst, lrealm, i) == KSUCCESS; ++i) {
@


4.13
log
@Programmer: Jennifer Steiner
Auditor: John Kohl
changes: improve documentation of code
@
text
@d3 1
a3 1
 * $Author: steiner $
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.12 88/05/25 16:53:16 steiner Locked $";
d99 1
a99 1
     * local realm.  XXX this is broken
d101 8
a108 6
    if (!realm && get_krbrlm(lrealm,1)) {
        if (krb_debug)
            fprintf(stderr, "%s: can't get local realm\n", prog);
        return(SKDC_CANT);
    }
    (void) strcpy(lrealm,realm);
d197 3
a199 2
        fprintf(stderr, "%s: can't find any Kerberos host.\n",
                prog);
@


4.12
log
@Ultrix changes.
Programmer: jon.
Auditor: jtkohl.
@
text
@a8 29
 *
 * send_to_kdc: send the given packet to the Kerberos of the given
 * realm, and return the response in the other given packet.
 *
 * If the realm is null, the local realm is used.  The server's name
 * is looked up in /etc/services.  A socket is opened, a port is
 * bound.
 *
 * A Kerberos host machine is found via get_krbhst, and a message is
 * sent to it.  If a reply is received, it is returned in the reply
 * packet and the routine returns KSUCCESS.  If no reply is received
 * in the allocated time, a new host machine is tried, and so on,
 * until "get_krbhst" runs out of hosts to try or a message is
 * received.  Note that a message can be received from a machine tried
 * in an earlier loop, not just the latest host being tried.
 *
 * If an answer was received from a Kerberos host, KSUCCESS is
 * returned.  The following errors can be returned (should have
 * different values):
 *
 * SKDC_CANT    - can't get local realm
 *              - can't find "kerberos" in services database
 *              - can't open socket
 *              - can't bind socket
 *              - all ports in use
 *              - couldn't determine any Kerberos host
 *
 * SKDC_RETRY   - couldn't get an answer from anyone, after several
 *                retries
d13 1
a13 1
"$Header: send_to_kdc.c,v 4.11 88/02/29 11:44:45 steiner Exp $";
d42 3
d49 32
d97 4
d236 1
@


4.11
log
@Fixes (re: h_addr_list) for Sun.
Also, initialized errno to 0.
Programmer: Charley Marker.
Auditor: jon.
@
text
@d42 1
a42 1
"$Header: send_to_kdc.c,v 4.10 88/02/24 18:16:17 steiner Locked $";
d159 3
a161 1
#ifndef	sun
d167 1
a167 1
#endif	/* sun */
d208 1
a208 1
#ifndef	sun
d210 1
a210 1
#endif	/* sun */
d213 1
a213 1
#ifndef	sun
d216 1
a216 1
#endif	/* sun */
@


4.10
log
@Copyright notice, etc.
@
text
@d42 1
a42 1
"$Header: send_to_kdc.c,v 4.9 88/01/12 21:24:18 steiner Locked $";
d159 1
d165 1
d206 1
d208 1
d211 1
d214 1
d257 1
@


4.9
log
@Formatting changes.
Programmer: Ken.
Auditor: Jon.
@
text
@d2 1
a2 1
 * $Source: /mit/kerberos/lib/krb/RCS/send_to_kdc.c,v $
d5 1
a5 1
 * Copyright 1987 by the Massachusetts Institute of Technology.
d7 2
a8 2
 * For copying and distribution information,
 * please see the file <mit-copyright.h>.
d41 2
a42 2
static char rcsid_module_c[] =
    "$Header: send_to_kdc.c,v 4.8 87/12/06 11:25:37 steiner Exp $";
@


4.8
log
@Changed user routine names to krb_xxxxxxx
@
text
@d1 3
a3 2
/* $Source: /mit/kerberos/lib/krb/RCS/send_to_kdc.c,v $
 * $Author: raeburn $
d10 2
a11 2
 * send_to_kdc: send the given packet to the Kerberos of the given realm,
 * and return the response in the other given packet.
d13 3
a15 2
 * If the realm is null, the local realm is used.  The server's name is
 * looked up in /etc/services.  A socket is opened, a port is bound.
d17 7
a23 7
 * A Kerberos host machine is found via get_krbhst, and a message is sent
 * to it.  If a reply is received, it is returned in the reply packet and
 * the routine returns KSUCCESS.  If no reply is received in the allocated
 * time, a new host machine is tried, and so on, until "get_krbhst" runs
 * out of hosts to try or a message is received.  Note that a message can
 * be received from a machine tried in an earlier loop, not just the latest
 * host being tried.
d25 3
a27 2
 * If an answer was received from a Kerberos host, KSUCCESS is returned.
 * The following errors can be returned (should have different values):
d29 9
a37 8
 * SKDC_CANT	- can't get local realm
 *		- can't find "kerberos" in services database
 *		- can't open socket
 *		- can't bind socket
 *		- all ports in use
 *		- couldn't determine any Kerberos host
 * 
 * SKDC_RETRY	- couldn't get an answer from anyone, after several retries
d40 1
a40 1
#ifndef	lint
d42 2
a43 2
"$Header: send_to_kdc.c,v 4.7 87/11/08 03:48:13 steiner Locked $";
#endif	lint
d45 1
a45 1
#include	<mit-copyright.h>
d55 2
a56 2
#include <sys/uio.h>			/* struct iovec to make lint happy */
#endif lint
d62 1
a62 1
#define S_AD_SZ 	sizeof(struct sockaddr_in)
d64 2
a65 2
extern int		errno;
extern int		krb_debug;
d76 3
a78 3
KTEXT		pkt;
KTEXT		rpkt;
char		*realm;
d80 10
a89 10
	int			i, f;
	int			no_host; /* was a kerberos host found? */
	int			retry;
	int			n_hosts;
	int			retval;
	struct sockaddr_in	to;
	struct hostent		*host, *hostlist;
	char			*cp;
	char			krbhst[MAX_HSTNM];
	char			lrealm[REALM_SZ];
d91 108
a198 110
	if (!realm && get_krbrlm(lrealm,1)) {
		if (krb_debug)
			fprintf(stderr,
				"%s: can't get local realm\n", prog);
		return(SKDC_CANT);
	}
	(void) strcpy(lrealm,realm);
	if (krb_debug) 
		printf("lrealm is %s\n", lrealm);
	if (krb_udp_port == 0) {
		register struct servent *sp;
		if ((sp = getservbyname("kerberos","udp")) == 0) {
			if (krb_debug)
				fprintf(stderr,
					"%s: Can't get kerberos/udp service\n",
					prog);
			return(SKDC_CANT);
		}
		krb_udp_port = sp->s_port;
		if (krb_debug)
			printf("krb_udp_port is %d\n", krb_udp_port);
	}
	bzero((char *)&to, S_AD_SZ);
	hostlist = (struct hostent *) malloc(sizeof(struct hostent));
	if (!hostlist)
		return (/*errno*/SKDC_CANT);
	if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
		if (krb_debug)
			fprintf(stderr,"%s: Can't open socket\n", prog);
		return(SKDC_CANT);
	}
	/* from now on, exit through rtn label for cleanup */

	no_host = 1;
	/* get an initial allocation */
	n_hosts = 0;
	for (i = 1; get_krbhst(krbhst, lrealm, i) == KSUCCESS; ++i) {
		if (krb_debug) {
			printf("Getting host entry for %s...",krbhst);
			(void) fflush(stdout);
		}
		host = gethostbyname(krbhst);
		if (krb_debug) {
			printf("%s.\n",
			       host ? "Got it" : "Didn't get it");
			(void) fflush(stdout);
		}
		if (!host)
			continue;
		no_host = 0;	/* found at least one */
		n_hosts++;
		/* preserve host network address to check later
		 * (would be better to preserve *all* addresses,
		 * take care of that later)
		 */
		hostlist = (struct hostent *)
			realloc((char *)hostlist,
				(unsigned)
				sizeof(struct hostent)*(n_hosts+1));
		if (!hostlist)
			return /*errno*/SKDC_CANT;
		bcopy((char *)host, (char *)&hostlist[n_hosts-1],
		      sizeof(struct hostent));
		host = &hostlist[n_hosts-1];
		cp = malloc((unsigned)host->h_length);
		if (!cp) {
			retval = /*errno*/SKDC_CANT;
			goto rtn;
		}
		bcopy((char *)host->h_addr, cp, host->h_length);
		host->h_addr_list = (char **)malloc(sizeof(char *));
		if (!host->h_addr_list) {
			retval = /*errno*/SKDC_CANT;
			goto rtn;
		}
		host->h_addr = cp;
		bzero((char *)&hostlist[n_hosts],
		      sizeof(struct hostent)); 
		to.sin_family = host->h_addrtype;
		bcopy(host->h_addr, (char *)&to.sin_addr,
		      host->h_length);
		to.sin_port = krb_udp_port;
		if (send_recv(pkt, rpkt, f, &to, hostlist)) {
			retval = KSUCCESS;
			goto rtn;
		}
		if (krb_debug) {
			printf("Timeout, error, or wrong descriptor\n");
			(void) fflush(stdout);
		}
	}
	if (no_host) {
		fprintf(stderr, "%s: can't find any Kerberos host.\n",
			prog);
		retval = SKDC_CANT;
		goto rtn;
	}
	/* retry each host in sequence */
	for (retry = 0; retry < CLIENT_KRB_RETRY; ++retry) {
		for (host = hostlist; host->h_name != (char *)NULL; host++) {
			to.sin_family = host->h_addrtype;
			bcopy(host->h_addr, (char *)&to.sin_addr,
			      host->h_length);
			if (send_recv(pkt, rpkt, f, &to, hostlist)) {
				retval = KSUCCESS;
				goto rtn;
			}
		}
	}
	retval = SKDC_RETRY;
d200 12
a211 12
	(void) close(f);
	if (hostlist) {
		register struct hostent *hp;
		for (hp = hostlist; hp->h_name; hp++)
			if (hp->h_addr_list) {
				if (hp->h_addr)
					free(hp->h_addr);
				free((char *)hp->h_addr_list);
			}
		free((char *)hostlist);
	}
	return(retval);
d214 2
a215 1
/* try to send out and receive message.
d218 6
a223 7
static
send_recv(pkt, rpkt,f,to,addrs)
KTEXT		pkt;
KTEXT		rpkt;
int		f;
struct sockaddr_in *to;
struct hostent *addrs;
d225 5
a229 5
	fd_set readfds;
	register struct hostent *hp;
	struct sockaddr_in from;
	int sin_size;
	int numsent;
d231 60
a290 61
	if (krb_debug) {
		if (to->sin_family == AF_INET)
			printf("Sending message to %s...",
			       inet_ntoa(to->sin_addr));
		else
			printf("Sending message...");
		(void) fflush(stdout);
	}
	if ((numsent = sendto(f,(char *)(pkt->dat), pkt->length, 0, to,
			      S_AD_SZ)) != pkt->length) {
		if (krb_debug)
			printf("sent only %d/%d\n",numsent, pkt->length);
		return 0;
	}
	if (krb_debug) {
		printf("Sent\nWaiting for reply...");
		(void) fflush(stdout);
	}
	FD_ZERO(&readfds);
	FD_SET(f, &readfds);
	/* select - either recv is ready, or timeout	*/
	/* see if timeout or error or wrong descriptor */
	if (select(f + 1, &readfds, (fd_set *)0, (fd_set *)0, &timeout) < 1 ||
	    !FD_ISSET(f, &readfds)) {
		if (krb_debug) {
			fprintf(stderr, "select failed: readfds=%x",
				readfds);
			perror("");
		}
		return 0;
	}
	sin_size = sizeof(from);
	if (recvfrom(f, (char *)(rpkt->dat), BUFSIZ, 0, &from, &sin_size)
	    < 0) {
		if (krb_debug)
			perror("recvfrom");
		return 0;
	}
	if (krb_debug) {
		printf("received packet from %s\n", inet_ntoa(from.sin_addr));
		fflush(stdout);
	}
	for (hp = addrs; hp->h_name != (char *)NULL; hp++) {
		if (!bcmp(hp->h_addr, (char *)&from.sin_addr.s_addr,
			  hp->h_length)) {
			if (krb_debug) {
				printf("Received it\n");
				(void) fflush(stdout);
			}
			return 1;
		}
		if (krb_debug)
			fprintf(stderr,
				"packet not from %x\n",
				hp->h_addr);
	}
	if (krb_debug)
		fprintf(stderr,
			"%s: received packet from wrong host! (%x)\n",
			"send_to_kdc(send_rcv)", from.sin_addr.s_addr);
	return 0;	
@


4.7
log
@Checks IP address of incoming packets; once again tries all
servers, rather than last resolved.  Caches value from lookup of
kerberos/udp service.
@
text
@d1 2
a2 2
/* $Source: /paris/u3/kerberos.new/lib/krb/RCS/send_to_kdc.c,v $
 * $Author: jtkohl $
d38 1
a38 1
"$Header: send_to_kdc.c,v 4.6 87/10/29 10:48:09 raeburn Locked $";
d179 2
a180 4
		if (krb_debug)
			fprintf(stderr,
				"%s: can't find any Kerberos host.\n",
				prog);
@


4.6
log
@change name of debug
@
text
@d1 1
a1 1
/* $Source: /u3/kerberos.new/lib/krb/RCS/send_to_kdc.c,v $
d38 1
a38 1
"$Header: send_to_kdc.c,v 4.5 87/10/20 17:12:48 jtkohl Locked $";
a58 2
#define LO_PORT		8002
#define HI_PORT		9000
d63 5
a67 4
static struct sockaddr_in to = {AF_INET};
static struct sockaddr_in sin = {AF_INET};
static struct sockaddr_in from;
static int f;
d76 1
a76 1
	int			i;
d79 5
a83 3
	int			lport;
	struct servent		*sp;
	struct hostent		*host;
d88 3
a90 1
		fprintf(stderr, "%s: can't get local realm\n", prog);
d93 1
a93 2
	else
		(void) strcpy(lrealm,realm);
d96 12
a107 3
	if ((sp = getservbyname("kerberos","udp")) == 0) {
		fprintf(stderr,"%s: udp/kerberos unknown service\n", prog);
		return(SKDC_CANT);
d110 3
d114 2
a115 1
		fprintf(stderr,"%s: Can't open socket\n", prog);
d118 2
a119 18
	sin.sin_addr.s_addr = INADDR_ANY;
	for (lport = LO_PORT; lport < HI_PORT; ++lport) {
		sin.sin_port = htons((u_short)lport);
		if (bind(f, &sin, S_AD_SZ) >= 0)
			break;
		if (errno != EADDRINUSE && errno != EADDRNOTAVAIL) {
			fprintf(stderr,"%s: Can't bind socket\n", prog);
			(void) close(f);
			return(SKDC_CANT);
		}
	}
	if (krb_debug)
		printf("lport is %d\n", lport);
	if (lport >= HI_PORT) {
		fprintf(stderr, "%s: All ports in use\n", prog);
		(void) close(f);
		return(SKDC_CANT);
	}
d121 2
d130 2
a131 1
			printf("%s.\n", host ? "Got it" : "Didn't get it");
d134 1
a134 3
		if (host)
			no_host = 0;	/* found at least one */
		else
d136 29
d166 7
a172 4
		bcopy(host->h_addr, (char *)&to.sin_addr, host->h_length);
		to.sin_port = sp->s_port;
		if (send_recv(pkt, rpkt))
			return KSUCCESS;
d179 6
a184 2
		fprintf(stderr, "%s: can't find any Kerberos host.\n", prog);
		return(SKDC_CANT);
d186 14
a199 4
	/* retry */
	for (retry = 0; retry < CLIENT_KRB_RETRY; ++retry)
		if (send_recv(pkt, rpkt))
			return KSUCCESS;
d201 11
a211 1
	return(SKDC_RETRY);
d214 3
a216 1
/* try to send out and receive message.  return 1 on success, 0 on failure */
d218 1
a218 1
send_recv(pkt, rpkt)
d221 3
d226 3
a228 1
	struct timeval timeout;
a230 3
	timeout.tv_sec = CLIENT_KRB_TIMEOUT;
	timeout.tv_usec = 0;

d232 5
a236 1
		printf("Sending message...");
d239 1
a239 1
	if ((numsent = sendto(f,(char *)(pkt->dat), pkt->length, 0, &to,
d246 1
a246 2
		printf("Sent\n");
		printf("Waiting for reply...");
d254 6
a259 1
	    !FD_ISSET(f, &readfds))
d261 6
a266 3
	if (recvfrom(f, (char *)(rpkt->dat), BUFSIZ, 0, &from,
		     &(rpkt->length)) < 0) {
		perror("recvfrom");
d270 2
a271 2
		printf("Received it\n");
		(void) fflush(stdout);
d273 19
a291 2
	(void) close(f);
	return 1;
@


4.5
log
@lint fixes.
@
text
@d2 1
a2 1
 * $Author: steiner $
d38 1
a38 1
"$Header: send_to_kdc.c,v 4.4 87/10/16 18:53:42 jtkohl Locked $";
d50 3
d63 1
a63 1
extern int		debug;
d70 1
d92 1
a92 1
	if (debug) 
d114 1
a114 1
	if (debug)
d123 1
a123 1
		if (debug) {
d128 1
a128 1
		if (debug) {
d141 1
a141 1
		if (debug) {
d159 1
d171 1
a171 1
	if (debug) {
d177 2
a178 2
		if (debug)
			printf("sent only %d/%d\n",numsent, pkt->length)
d180 2
a181 1
	if (debug) {
d198 1
a198 1
	if (debug) {
@


4.4
log
@Cleaned up, fixed "select", etc.
@
text
@d38 1
a38 1
"$Header: send_to_kdc.c,v 4.4 87/10/16 18:50:03 steiner Exp $";
d53 1
d87 1
a87 1
		strcpy(lrealm,realm);
d94 1
a94 1
	bzero(&to, S_AD_SZ);
d106 1
a106 1
			close(f);
d114 1
a114 1
		close(f);
d121 1
a121 1
			fflush(stdout);
d126 1
a126 1
			fflush(stdout);
d133 1
a133 1
		bcopy(host->h_addr, &to.sin_addr, host->h_length);
d139 1
a139 1
			fflush(stdout);
d150 1
a150 1
	close(f);
d161 2
a162 1
	
d168 1
a168 1
		fflush(stdout);
d170 5
a174 1
	sendto(f,pkt->dat, pkt->length, 0, &to, S_AD_SZ);
d178 1
a178 1
		fflush(stdout);
d184 2
a185 2
	if (select(f + 1, &readfds, NULL, NULL, &timeout) < 1 ||
           !FD_ISSET(f, &readfds))
d187 2
a188 1
	if (recvfrom(f, rpkt->dat, BUFSIZ, 0, &from, &(rpkt->length)) < 0) {
d194 1
a194 1
		fflush(stdout);
d196 1
a196 1
	close(f);
@


4.3
log
@Reformatted.
@
text
@d1 2
a2 2
/* $Source$
 * $Author$
d9 25
a33 1
 * send_to_kdc:
d38 1
a38 1
"$Header$";
d55 2
d61 5
a65 10
struct sockaddr_in	sin = { AF_INET }; 
struct sockaddr_in	to = { AF_INET };
int			f;
char			buf[BUFSIZ];
static	struct timeval	timeout = { CLIENT_KRB_TIMEOUT,0 };
unsigned long		readfds;
unsigned long		writefds;
unsigned long		exceptfds;
unsigned long		nfds;
unsigned long		nfound;
d72 2
a73 2
	struct sockaddr_in	from;
	int			n,i;
a75 1
	int			fromlen;
d81 4
a84 4

	if (!realm)
		if (get_krbrlm(lrealm,1))
			return(SKDC_CANT);
d87 2
a88 1

d90 1
a90 1
		fprintf(stderr,"client: udp/kerberos unknown service\n");
a92 1

a93 1

d95 1
a95 1
		fprintf(stderr,"client: Can't open socket\n");
a97 1

d99 1
a99 4
	
	lport = 8002;

	for (;;) {
d104 1
a104 1
			fprintf(stderr,"client: Can't bind socket\n");
a107 5
		if(++lport >= 9000) {
			fprintf(stderr, "client: All ports in use\n");
			close(f);
			return(SKDC_CANT);
		}
d109 10
a118 7

	n = 0;
	retry = 0;
	while ( (n <= 0) && (retry < CLIENT_KRB_RETRY)) {
		i = 1;
		while ((n <= 0) && (get_krbhst(krbhst,lrealm,i++) == 0)) {
			if (debug) {
a120 41
			}
		
			host = gethostbyname(krbhst);
			if (debug) {
				printf("Done\n");
				fflush(stdout);
			}
			
			if (!host) continue;
			
			to.sin_family = host->h_addrtype;
			bcopy(host->h_addr, &to.sin_addr, host->h_length);
			to.sin_port = sp->s_port;
			if (debug) {
				printf("Sending message...");
				fflush(stdout);
			}
			
			fromlen = S_AD_SZ;
			
			sendto(f,pkt->dat, pkt->length, 0, &to, S_AD_SZ);
			if (debug) {
				printf("Sent\n");
				printf("Waiting for reply...");
				fflush(stdout);
			}
			
			readfds = 1 << f;
			nfds = f + 1;
			/* select - either recv is ready, or timeout	*/
			nfound =select(nfds, &readfds, &writefds, &exceptfds,
				&timeout);
			
			/* see if timeout or error	*/
			if ( nfound <= 0)
				continue;
			if (! (readfds & (1<<f)))
				continue;
			/* wrong descriptor		   */
			n = recvfrom(f, rpkt->dat, BUFSIZ, 0, &from,
				&(rpkt->length));
d122 30
a151 2
		retry++;
	 }
d153 7
a159 4
	if (n <= 0) {
		close(f);
		return(SKDC_RETRY);
	}
d161 3
d165 1
a165 1
		printf("Got it\n");
d168 21
d190 1
a190 1
	return(SKDC_OK);
@


4.2
log
@Changed include files configuration and referencing.
@
text
@d1 2
a2 4
/* 
 * 	$Source: /mit/s/t/steiner/kerberos/lib/krb/RCS/send_to_kdc.c,v $
 * 	$Author: steiner $
 * 	$Locker: steiner $
d4 1
a4 1
 * Copyright 1985,1986 by the Massachusetts Institute of Technology
d6 4
d12 3
a14 2
#ifndef lint
static char *rcsid_send_to_kdc_c = "$Header: send_to_kdc.c,v 4.1 87/09/01 15:47:44 steiner Locked $";
d17 2
d33 1
a33 1
extern	int		debug;
d63 4
a66 2
	  {if (get_krbrlm(lrealm,1)) return(SKDC_CANT);}
	else strcpy(lrealm,realm);
d68 4
a71 3
	if ((sp = getservbyname("kerberos","udp")) == 0)
	   {fprintf(stderr,"client: udp/kerberos unknown service\n");
	    return(SKDC_CANT);}
d75 4
a78 3
	if ((f = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
	  {fprintf(stderr,"client: Can't open socket\n");
	   return(SKDC_CANT);}
d84 15
a98 13
	for (;;)
	  {sin.sin_port = htons((u_short)lport);
	   if (bind(f, &sin, S_AD_SZ) >= 0)
	     break;
	   if (errno != EADDRINUSE && errno != EADDRNOTAVAIL)
	     {fprintf(stderr,"client: Can't bind socket\n");
	      close(f);
	      return(SKDC_CANT);}
	   if(++lport >= 9000)
	     {fprintf(stderr, "client: All ports in use\n");
	      close(f);
	      return(SKDC_CANT);}
	 }
a99 1
	
d102 7
a108 28
	while ( (n <= 0) && (retry < CLIENT_KRB_RETRY))
          {i = 1;
	   while ((n <= 0) && (get_krbhst(krbhst,lrealm,i++) == 0))
	   {if (debug)
	      {
		printf("Getting host entry for %s...",krbhst);
		fflush(stdout);
	      }
	   
	   host = gethostbyname(krbhst);
	    if (debug)
	      {
		printf("Done\n");
		fflush(stdout);
	      }
	   
	    if (!host) continue;
	   
	    to.sin_family = host->h_addrtype;
	    bcopy(host->h_addr, &to.sin_addr, host->h_length);
	    to.sin_port = sp->s_port;
	    if (debug)
	      {
		printf("Sending message...");
		fflush(stdout);
	      }
	    
	    fromlen = S_AD_SZ;
d110 41
a150 19
	    sendto(f,pkt->dat, pkt->length, 0, &to, S_AD_SZ);
	    if (debug) 
	      {
		printf("Sent\n");
		printf("Waiting for reply...");
		fflush(stdout);
	      }
	   
	    readfds = 1 << f;
	    nfds = f + 1;
	    /* select- either recv is ready, or timeout		*/
	    nfound =select(nfds,&readfds,&writefds,&exceptfds,&timeout);
	    
	    /* see if timeout or error	*/
	    if ( nfound <= 0) continue;
	    if (! (readfds & (1<<f))) continue;	/* wrong descriptor			   */
	    n = recvfrom(f, rpkt->dat, BUFSIZ, 0, &from, &(rpkt->length));
	  }
	   retry++;
d152 2
a153 3
	
	if (n <= 0)
		{
d156 1
a156 1
		}
d158 1
a158 2
	if (debug)
		{
d161 1
a161 1
		}
a164 1

@


4.1
log
@No change; starting version 4.
@
text
@d3 1
a3 1
 * 	$Author: root $
d11 1
a11 1
static char *rcsid_send_to_kdc_c = "$Header: send_to_kdc.c,v 3.4 86/12/01 16:10:38 steiner Locked $";
d15 1
a15 1
#include "prot.h"
@


3.4
log
@Fixed loop on ports: no longer terminates with "All ports in use"
after one try.
@
text
@d2 3
a4 3
 * 	$Source: /source/kerberos/lib/krb/RCS/send_to_kdc.c,v $
 * 	$Author: bcn $
 * 	$Locker: root $
d11 1
a11 1
static char *rcsid_send_to_kdc_c = "$Header: send_to_kdc.c,v 3.3 86/09/05 16:05:14 root Locked $";
@


3.3
log
@Send_to_kdc now takes a realm as an argument, and it will
attempt to contact multiple kerberi if necessary.
@
text
@d2 1
a2 1
 * 	$Source: /mit/projects/auth/src/lib/krb/RCS/vxsend_to_kdc.c,v $
d4 1
a4 1
 * 	$Locker: bcn $
d11 1
a11 1
static char *rcsid_send_to_kdc_c = "$Header: send_to_kdc.c,v 3.2 86/08/12 12:22:23 bcn Exp $";
d83 1
a83 1
	   if(++lport <= 9000)
@


3.2
log
@Errors now return kerberos error codes.
@
text
@d11 1
a11 1
static char *rcsid_vxsend_to_kdc_c = "$Header: vxsend_to_kdc.c,v 3.1 86/03/28 10:05:23 bcn Exp $";
a26 2
char	*get_krbhst();

d32 2
a33 2
int					f;
char				buf[BUFSIZ];
d41 1
a41 1
send_to_kdc(pkt,rpkt)
d44 1
d47 1
a47 1
	register int		n;
d53 2
a54 1
	char			*krbhst;
d57 4
d63 1
a63 1
	    return(NULL);}
d68 2
a69 2
	   {fprintf(stderr,"client: Can't open socket\n");
	    return(SKDC_CANT);}
d78 1
a78 1
		break;
d80 3
a82 3
	   	{fprintf(stderr,"client: Can't bind socket\n");
		 close(f);
		 return(SKDC_CANT);}
d84 4
a87 4
	   	{fprintf(stderr, "client: All ports in use\n");
		 close(f);
		 return(SKDC_CANT);}
	   }
d90 7
a96 12
	krbhst = get_krbhst(1);

	if (!krbhst)
		{
		 printf("Error reading host file\n");
		 fflush(stdout);
		 close(f);
		 return(SKDC_CANT);
		}

	if (debug)
		{
d99 6
a104 6
		}

	host = gethostbyname(krbhst);
	if (debug)
		{
		printf("Done\nHost = %o\n",host);
d106 9
a114 9
		}
	
	if (!host) return(SKDC_CANT);

	to.sin_family = host->h_addrtype;
	bcopy(host->h_addr, &to.sin_addr, host->h_length);
	to.sin_port = sp->s_port;
	if (debug)
		{
d117 3
a119 6
		}

	n = 0;
	retry = 0;
	while ( (n <= 0) && (retry < CLIENT_KRB_RETRY))
	   {fromlen = S_AD_SZ;
d121 16
a136 17
		sendto(f,pkt->dat, pkt->length, 0, &to, S_AD_SZ);
		if (debug) 
			{
			printf("Sent\n");
			printf("Waiting for reply...");
			fflush(stdout);
			}

		readfds = 1 << f;
		nfds = f + 1;
		retry++;
		/* select- either recv is ready, or timeout		*/
		nfound =select(nfds,&readfds,&writefds,&exceptfds,&timeout);

			/* see if timeout or error	*/
		if ( nfound <= 0) continue;
		if (! (readfds & (1<<f))) continue;	/* wrong descriptor			   */
d138 3
a140 1
		}
a143 1
		printf("\n\07\07ERROR - Kerberos login retry count exceeded");
@


3.1
log
@Update to protocol revision 3 complete.
@
text
@d11 1
a11 1
static char *rcsid_vxsend_to_kdc_c = "$Header: vxsend_to_kdc.c,v 1.6 85/12/06 14:15:36 bcn Exp $";
d65 1
a65 1
	    return(NULL);}
d77 2
a78 1
		 return(NULL);}
d81 2
a82 1
		 return(NULL);}
d92 2
a93 1
		 return(NULL);
d109 2
d148 2
a149 1
		return -1;
d157 2
a158 1
	return 0;
@


1.6
log
@Updated to get host to send to from get_krbhst.
@
text
@a4 13
 *    	$Log:	vxsend_to_kdc.c,v $
 * Revision 1.5  85/12/04  10:07:57  bcn
 * Moved into libkrb.
 * 
 * Revision 1.4  85/11/11  15:51:04  spm
 * add retries, select, and timeouts
 * 
 * Revision 1.2  85/11/08  14:56:08  bcn
 * Fix inconsitency with rpkt argument to send_to_kdc
 * 
 * Revision 1.1  85/10/10  11:18:33  bcn
 * Initial revision
 * 
d6 1
a6 1
 * Copyright 1985 by the Massachusetts Institute of Technology
d11 1
a11 1
static char *rcsid_vxsend_to_kdc_c = "$Header: vxsend_to_kdc.c,v 1.5 85/12/04 10:07:57 bcn Exp $";
d44 2
a45 2
struct packet	*pkt;
PACKT		rpkt;
@


1.5
log
@Moved into libkrb.
@
text
@d3 1
a3 1
 * 	$Author: spm $
d6 3
d24 1
a24 1
static char *rcsid_vxsend_to_kdc_c = "$Header: vxsend_to_kdc.c,v 1.4 85/11/11 15:51:04 spm Exp $";
d40 1
d67 1
d96 10
d108 1
a108 1
		printf("Getting host entry for %s...",KRB_HOST);
d111 2
a112 2
	
	host = gethostbyname(KRB_HOST);
@


1.4
log
@add retries, select, and timeouts
@
text
@d2 7
a8 4
 * 	$Source: /mit/projects/auth/src/client/RCS/vxdepcl.c,v $
 * 	$Author: bcn $
 * 	$Locker: spm $
 *    	$Log:	vxdepcl.c,v $
d21 1
a21 1
static char *rcsid_vxdepcl_c = "$Header: vxdepcl.c,v 1.2 85/11/08 14:56:08 bcn Exp $";
d24 2
a25 2
#include "client.h"
#include "../kdc/prot.h"
@


1.3
log
@cleanup messages
@
text
@d26 1
a26 1

d40 8
a47 2
int			f;
char			buf[BUFSIZ];
a48 1

d55 1
d109 1
a109 7
	sendto(f,pkt->dat, pkt->length, 0, &to, S_AD_SZ);
	if (debug) 
		{
		printf("Sent\n");
		printf("Waiting for reply...");
		fflush(stdout);
		}
d111 2
a112 2

	while (n <= 0)
d114 8
a121 1
	    n = recvfrom(f, rpkt->dat, BUFSIZ, 0, &from, &(rpkt->length));}
d123 18
@


1.2
log
@Fix inconsitency with rpkt argument to send_to_kdc
@
text
@d4 1
a4 1
 * 	$Locker: bcn $
d6 3
d18 1
a18 1
static char *rcsid_vxdepcl_c = "$Header: vxdepcl.c,v 1.1 85/10/10 11:18:33 bcn Exp $";
d36 1
d82 6
a87 5

#ifdef DEBUG
	printf("Getting host entry for %s...",KRB_HOST);
	fflush(stdout);
#endif
d89 6
a94 4
#ifdef DEBUG
	printf("Done\nHost = %o\n",host);
	fflush(stdout);
#endif
d98 5
a102 4
#ifdef DEBUG
	printf("Sending message...");
	fflush(stdout);
#endif
d104 6
a109 5
#ifdef DEBUG
	printf("Sent\n");
	printf("Waiting for reply...");
	fflush(stdout);
#endif
d116 6
a121 4
#ifdef DEBUG
	printf("Got it\n");
	fflush(stdout);
#endif
@


1.1
log
@Initial revision
@
text
@d2 7
a8 4
 * 	$Source: $
 * 	$Author: $
 * 	$Locker: $
 *    	$Log:	 $
d15 1
a15 1
static char *rcsid_vxdepcl_c = "$Header: $";
d40 1
a40 1
send_to_kdc(pkt,rbuff,rlen)
d42 1
a42 2
char		*rbuff;
int		*rlen;
d105 1
a105 1
	    n = recvfrom(f, rbuff, BUFSIZ, 0, &from, &rlen);}
@
