head     4.6;
branch   ;
access   ;
symbols  PATCH8:4.4 PATCH7:4.4 KPATCH6:4.4 ASRSNAP1001:4.4 PATCH5:4.4 KPATCH4:4.4 KPATCH3:4.4 KPATCH2:4.4 KREL1:4.4 BETA5/24/88:1.3;
locks    ; strict;
comment  @ * @;


4.6
date     92.07.19.13.24.07;  author bostic;  state Exp;
branches ;
next     4.5;

4.5
date     90.06.25.20.57.24;  author kfall;  state Exp;
branches ;
next     4.4;

4.4
date     89.01.23.09.25.06;  author jtkohl;  state Exp;
branches ;
next     4.3;

4.3
date     89.01.19.13.52.52;  author steiner;  state Exp;
branches ;
next     4.2;

4.2
date     88.12.05.15.22.02;  author steiner;  state Exp;
branches ;
next     4.1;

4.1
date     88.12.01.14.38.09;  author jtkohl;  state Exp;
branches ;
next     1.3;

1.3
date     88.02.24.18.16.26;  author steiner;  state Exp;
branches ;
next     1.2;

1.2
date     88.02.05.18.40.46;  author steiner;  state Exp;
branches ;
next     1.1;

1.1
date     88.01.22.15.51.51;  author steiner;  state Exp;
branches ;
next     ;


desc
@Routine for transmitting Kerberos ticket.
Programmer: jtkohl.
Auditor: wesommer.
@


4.6
log
@check in for Kevin Fall by TK; change krb_get_lrealm call
@
text
@/*
 * $Source: /usr/src/kerberosIV/krb/RCS/sendauth.c,v $
 * $Author: kfall $
 *
 * Copyright 1987, 1988 by the Massachusetts Institute of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 *
 */

#ifndef	lint
static char rcsid_sendauth_c[] =
"$Header: /usr/src/kerberosIV/krb/RCS/sendauth.c,v 4.5 90/06/25 20:57:24 kfall Exp Locker: kfall $";
#endif	lint

#include <mit-copyright.h>

#include <des.h>
#include <krb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <syslog.h>
#include <errno.h>
#include <stdio.h>
#include <strings.h>

#define	KRB_SENDAUTH_VERS "AUTHV0.1" /* MUST be KRB_SENDAUTH_VLEN chars */
/*
 * If the protocol changes, you will need to change the version string
 * and make appropriate changes in krb_recvauth.c
 */

extern int errno;

extern char *krb_get_phost();

/*
 * This file contains two routines: krb_sendauth() and krb_sendsrv().
 *
 * krb_sendauth() transmits a ticket over a file descriptor for a
 * desired service, instance, and realm, doing mutual authentication
 * with the server if desired.
 *
 * krb_sendsvc() sends a service name to a remote knetd server.
 */

/*
 * The first argument to krb_sendauth() contains a bitfield of
 * options (the options are defined in "krb.h"):
 *
 * KOPT_DONT_CANON	Don't canonicalize instance as a hostname.
 *			(If this option is not chosen, krb_get_phost()
 *			is called to canonicalize it.)
 *
 * KOPT_DONT_MK_REQ 	Don't request server ticket from Kerberos.
 *			A ticket must be supplied in the "ticket"
 *			argument.
 *			(If this option is not chosen, and there
 *			is no ticket for the given server in the
 *			ticket cache, one will be fetched using
 *			krb_mk_req() and returned in "ticket".)
 *
 * KOPT_DO_MUTUAL	Do mutual authentication, requiring that the
 * 			receiving server return the checksum+1 encrypted
 *			in the session key.  The mutual authentication
 *			is done using krb_mk_priv() on the other side
 *			(see "recvauth.c") and krb_rd_priv() on this
 *			side.
 *
 * The "fd" argument is a file descriptor to write to the remote
 * server on.  The "ticket" argument is used to store the new ticket
 * from the krb_mk_req() call. If the KOPT_DONT_MK_REQ options is
 * chosen, the ticket must be supplied in the "ticket" argument.
 * The "service", "inst", and "realm" arguments identify the ticket.
 * If "realm" is null, the local realm is used.
 *
 * The following arguments are only needed if the KOPT_DO_MUTUAL option
 * is chosen:
 *
 *   The "checksum" argument is a number that the server will add 1 to
 *   to authenticate itself back to the client; the "msg_data" argument
 *   holds the returned mutual-authentication message from the server
 *   (i.e., the checksum+1); the "cred" structure is used to hold the
 *   session key of the server, extracted from the ticket file, for use
 *   in decrypting the mutual authentication message from the server;
 *   and "schedule" holds the key schedule for that decryption.  The
 *   the local and server addresses are given in "laddr" and "faddr".
 *
 * The application protocol version number (of up to KRB_SENDAUTH_VLEN
 * characters) is passed in "version".
 *
 * If all goes well, KSUCCESS is returned, otherwise some error code.
 *
 * The format of the message sent to the server is:
 *
 * Size			Variable		Field
 * ----			--------		-----
 *
 * KRB_SENDAUTH_VLEN	KRB_SENDAUTH_VER	sendauth protocol
 * bytes					version number
 *
 * KRB_SENDAUTH_VLEN	version			application protocol
 * bytes					version number
 *
 * 4 bytes		ticket->length		length of ticket
 *
 * ticket->length	ticket->dat		ticket itself
 */

/*
 * XXX: Note that krb_rd_priv() is coded in such a way that
 * "msg_data->app_data" will be pointing into "priv_buf", which
 * will disappear when krb_sendauth() returns.
 */

int
krb_sendauth(options, fd, ticket, service, inst, realm, checksum,
	msg_data, cred, schedule, laddr, faddr, version)
long options;			 /* bit-pattern of options */
int fd;				 /* file descriptor to write onto */
KTEXT ticket;			 /* where to put ticket (return); or
				  * supplied in case of KOPT_DONT_MK_REQ */
char *service, *inst, *realm;	 /* service name, instance, realm */
u_long checksum;		 /* checksum to include in request */
MSG_DAT *msg_data;		 /* mutual auth MSG_DAT (return) */
CREDENTIALS *cred;		 /* credentials (return) */
Key_schedule schedule;		 /* key schedule (return) */
struct sockaddr_in *laddr;	 /* local address */
struct sockaddr_in *faddr;	 /* address of foreign host on fd */
char *version;			 /* version string */
{
    int rem, i, cc;
    char srv_inst[INST_SZ];
    char krb_realm[REALM_SZ];
    char buf[BUFSIZ];
    long tkt_len;
    u_char priv_buf[1024];
    u_long cksum;

    rem=KSUCCESS;

    /* get current realm if not passed in */
    if (!realm) {
	rem = krb_get_lrealm(krb_realm,0);
	if (rem != KSUCCESS)
	    return(rem);
	realm = krb_realm;
    }

    /* copy instance into local storage, canonicalizing if desired */
    if (options & KOPT_DONT_CANON)
	(void) strncpy(srv_inst, inst, INST_SZ);
    else
	(void) strncpy(srv_inst, krb_get_phost(inst), INST_SZ);

    /* get the ticket if desired */
    if (!(options & KOPT_DONT_MK_REQ)) {
	rem = krb_mk_req(ticket, service, srv_inst, realm, checksum);
	if (rem != KSUCCESS)
	    return(rem);
    }

#ifdef ATHENA_COMPAT
    /* this is only for compatibility with old servers */
    if (options & KOPT_DO_OLDSTYLE) {
	(void) sprintf(buf,"%d ",ticket->length);
	(void) write(fd, buf, strlen(buf));
	(void) write(fd, (char *) ticket->dat, ticket->length);
	return(rem);
    }
#endif ATHENA_COMPAT
    /* if mutual auth, get credentials so we have service session
       keys for decryption below */
    if (options & KOPT_DO_MUTUAL)
	if (cc = krb_get_cred(service, srv_inst, realm, cred))
	    return(cc);

    /* zero the buffer */
    (void) bzero(buf, BUFSIZ);

    /* insert version strings */
    (void) strncpy(buf, KRB_SENDAUTH_VERS, KRB_SENDAUTH_VLEN);
    (void) strncpy(buf+KRB_SENDAUTH_VLEN, version, KRB_SENDAUTH_VLEN);

    /* increment past vers strings */
    i = 2*KRB_SENDAUTH_VLEN;

    /* put ticket length into buffer */
    tkt_len = htonl((unsigned long) ticket->length);
    (void) bcopy((char *) &tkt_len, buf+i, sizeof(tkt_len));
    i += sizeof(tkt_len);

    /* put ticket into buffer */
    (void) bcopy((char *) ticket->dat, buf+i, ticket->length);
    i += ticket->length;

    /* write the request to the server */
    if ((cc = krb_net_write(fd, buf, i)) != i)
	return(cc);

    /* mutual authentication, if desired */
    if (options & KOPT_DO_MUTUAL) {
	/* get the length of the reply */
	if (krb_net_read(fd, (char *) &tkt_len, sizeof(tkt_len)) !=
	    sizeof(tkt_len))
	    return(errno);
	tkt_len = ntohl((unsigned long)tkt_len);

	/* if the length is negative, the server failed to recognize us. */
	if (tkt_len < 0)
	    return(KFAILURE);	 /* XXX */
	/* read the reply... */
	if (krb_net_read(fd, (char *)priv_buf, (int) tkt_len) != (int) tkt_len)
	    return(errno);

	/* ...and decrypt it */
#ifndef NOENCRYPTION
  	key_sched(cred->session, schedule);
#endif /* !NOENCRYPTION */
	if (cc = krb_rd_priv(priv_buf,(unsigned long) tkt_len, schedule,
			     cred->session, faddr, laddr, msg_data))
	    return(cc);

	/* fetch the (modified) checksum */
	(void) bcopy((char *)msg_data->app_data, (char *)&cksum,
		     sizeof(cksum));
	cksum = ntohl(cksum);

	/* if it doesn't match, fail */
	if (cksum != checksum + 1)
	    return(KFAILURE);	 /* XXX */
    }
    return(KSUCCESS);
}

#ifdef ATHENA_COMPAT
/*
 * krb_sendsvc
 */

int
krb_sendsvc(fd, service)
int fd;
char *service;
{
    /* write the service name length and then the service name to
       the fd */
    long serv_length;
    int cc;

    serv_length = htonl((unsigned long)strlen(service));
    if ((cc = krb_net_write(fd, (char *) &serv_length,
	sizeof(serv_length)))
	!= sizeof(serv_length))
	return(cc);
    if ((cc = krb_net_write(fd, service, strlen(service)))
	!= strlen(service))
	return(cc);
    return(KSUCCESS);
}
#endif ATHENA_COMPAT
@


4.5
log
@include des.h
@
text
@d2 2
a3 2
 * $Source: /usr/src/kerberosIV/src/lib/krb/RCS/sendauth.c,v $
 * $Author: jtkohl $
d14 1
a14 1
"$Header: /usr/src/kerberosIV/src/lib/krb/RCS/sendauth.c,v 4.4 89/01/23 09:25:06 jtkohl Exp Locker: kfall $";
d145 1
a145 1
	rem = krb_get_lrealm(krb_realm,1);
@


4.4
log
@Programmer/Auditor: John Kohl
changes: name changes to krb_xxx
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/sendauth.c,v $
 * $Author: steiner $
d14 1
a14 1
"$Header: sendauth.c,v 4.3 89/01/19 13:52:52 jtkohl Locked $";
d19 1
@


4.3
log
@Programmer: jtkohl
Auditor: steiner
#define'd version number length to KRB_SENDAUTH_VLEN, in krb.h.
@
text
@d14 1
a14 1
"$Header: sendauth.c,v 4.2 88/12/05 15:22:02 jtkohl Locked $";
d35 1
a35 1
extern char *get_phost();
d52 1
a52 1
 *			(If this option is not chosen, get_phost()
d144 1
a144 1
	rem = get_krbrlm(krb_realm,1);
d154 1
a154 1
	(void) strncpy(srv_inst, get_phost(inst), INST_SZ);
@


4.2
log
@Added #ifdef NOENCRYPTION code (to send stuff
in the clear in case no DES library present).
Programmer: jtkohl
Auditor: steiner
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d14 1
a14 1
"$Header: sendauth.c,v 4.1 88/12/01 14:38:09 jtkohl Locked $";
d27 1
a27 2
#define VERSION_LENGTH	  8
#define	KRB_SENDAUTH_VERS "AUTHV0.1" /* MUST be VERSION_LENGTH chars */
d89 2
a90 2
 * The application protocol version number (of up to 8 characters) is
 * passed in "version".
d99 2
a100 2
 * 8 bytes		KRB_SENDAUTH_VER	sendauth protocol
 *						version number
d102 2
a103 2
 * 8 bytes		version			application protocol
 *						version number
d182 2
a183 2
    (void) strncpy(buf, KRB_SENDAUTH_VERS, VERSION_LENGTH);
    (void) strncpy(buf+VERSION_LENGTH, version, VERSION_LENGTH);
d186 1
a186 1
    i = 16;
@


4.1
log
@Programmer: Jennifer Steiner
Auditor: John Kohl
changes: improve documentation of code
@
text
@d3 1
a3 1
 * $Author: steiner $
d14 1
a14 1
"$Header: sendauth.c,v 1.3 88/02/24 18:16:26 steiner Locked $";
d218 3
a220 1
	key_sched(cred->session, schedule);
@


1.3
log
@Copyright notice, etc.
@
text
@a9 13
 * krb_sendauth:
 * transmit a ticket over a file descriptor for a desired
 * service,inst,realm.
 * if desired, don't canonicalize instance as a hostname.
 * if desired, use the existing ticket.
 * if desired, do mutual authentication, requiring that the
 * receiving server transmit the checksum+1 encrypted in the
 * session key.
 * return failure codes if appropriate, or KSUCCESS if we
 * successfully do all we are asked.
 *
 * krb_sendsvc:
 * send a service name to a remote knetd server 
d14 1
a14 1
"$Header: sendauth.c,v 1.2 88/02/05 18:40:46 steiner Locked $";
d37 1
d39 7
a45 1
 * krb_sendauth
d48 69
d122 2
a123 1
KTEXT ticket;			 /* where to put ticket (return) */
d173 2
a174 2
    /* if mutual auth, get credentials so we have service keys for
       decryption below */
d217 1
a217 1
	/* ...and decrpyt it */
@


1.2
log
@Made realm an argument; took out magic numbers.
Programmer: jtkohl.
Auditor: jon.
@
text
@d5 1
a5 1
 * Copyright 1987 by the Massachusetts Institute of Technology.
d7 2
a8 2
 * For copying and distribution information,
 * please see the file <mit-copyright.h>.
a22 1
 *
d26 2
a27 2
static char rcsid_krb_sendauth_c[] =
"$Header: sendauth.c,v 1.1 88/01/22 15:51:51 jtkohl Locked $";
d30 1
a30 1
#include	<mit-copyright.h>
@


1.1
log
@Initial revision
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/snd_rcvauth.c,v $
 * $Author: jtkohl $
d16 2
a17 1
 * receiving server transmit the checksum+1 encrypted in the session key.
d28 1
a28 1
"$Header: snd_rcvauth.c,v 1.1 88/01/19 13:47:47 jtkohl Locked $";
d41 2
a42 1
#define	KRB_SENDAUTH_VERS	"AUTHV0.1" /* MUST be 8 chars */
d56 2
a57 2
krb_sendauth(options, fd, ticket, service, inst, realm, checksum, msg_data,
	     cred, schedule, laddr, faddr, version)
d80 2
a81 2
    /* get current realm if desired */
    if (!(options & KOPT_DONT_USE_LREALM)) {
d101 1
a101 1
#ifdef COMPAT
d109 1
a109 1
#endif COMPAT
d120 2
a121 2
    (void) strncpy(buf, KRB_SENDAUTH_VERS, 8);
    (void) strncpy(buf+8, version, 8);
d172 1
a172 1
#ifdef COMPAT
d188 2
a189 1
    if ((cc = krb_net_write(fd, (char *) &serv_length, sizeof(serv_length)))
d192 2
a193 1
    if ((cc = krb_net_write(fd, service, strlen(service))) != strlen(service))
d197 1
a197 18
#endif COMPAT

/* The following must come at the end of the program in order for EMACS	 */
/* to read the new defaults for editing this file.  These defaults try	 */
/* to impose some restrictions on the coding style so as to maintain a	 */
/* standard.								 */

/* Local Variables:			 */
/* mode:c				 */
/* c-indent-level:4			 */
/* c-argdecl-indent:0			 */
/* comment-column:33			 */
/* c-label-offset:-4			 */
/* c-continued-statement-indent:0	 */
/* c-continued-statement-offset:4	 */
/* c-auto-newline:nil			 */
/* c-brace-offset:0			 */
/* End:					 */
@
