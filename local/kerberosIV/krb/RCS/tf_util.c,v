head     4.10;
branch   ;
access   ;
symbols  PATCH8:4.8 PATCH7:4.6 KPATCH6:4.6 ASRSNAP1001:4.4 PATCH5:4.4 KPATCH4:4.4 KPATCH3:4.4 KPATCH2:4.3 KREL1:4.3 BETA5/24/88:1.8;
locks    ; strict;
comment  @ * @;


4.10
date     93.05.21.17.45.38;  author bostic;  state Exp;
branches ;
next     4.9;

4.9
date     92.07.19.13.24.44;  author bostic;  state Exp;
branches ;
next     4.8;

4.8
date     90.01.02.13.34.27;  author jtkohl;  state Exp;
branches ;
next     4.7;

4.7
date     89.12.30.21.29.37;  author qjb;  state Exp;
branches ;
next     4.6;

4.6
date     89.10.02.16.22.49;  author jtkohl;  state Exp;
branches ;
next     4.5;

4.5
date     89.10.02.16.20.27;  author jtkohl;  state Exp;
branches ;
next     4.4;

4.4
date     89.05.17.11.08.56;  author jtkohl;  state Exp;
branches ;
next     4.3;

4.3
date     89.01.13.17.51.22;  author rfrench;  state Exp;
branches ;
next     4.2;

4.2
date     89.01.05.12.08.17;  author raeburn;  state Exp;
branches ;
next     4.1;

4.1
date     88.12.01.14.41.24;  author jtkohl;  state Exp;
branches ;
next     1.12;

1.12
date     88.11.08.14.36.38;  author steiner;  state Exp;
branches ;
next     1.11;

1.11
date     88.07.14.12.13.54;  author shanzer;  state Exp;
branches ;
next     1.10;

1.10
date     88.06.03.13.44.08;  author steiner;  state Exp;
branches ;
next     1.9;

1.9
date     88.05.26.15.45.16;  author steiner;  state Exp;
branches ;
next     1.8;

1.8
date     88.05.18.17.14.57;  author steiner;  state Exp;
branches ;
next     1.7;

1.7
date     88.04.27.15.06.41;  author steiner;  state Exp;
branches ;
next     1.6;

1.6
date     88.04.25.13.41.34;  author jtkohl;  state Exp;
branches ;
next     1.5;

1.5
date     88.04.14.14.37.31;  author steiner;  state Exp;
branches ;
next     1.4;

1.4
date     88.02.24.18.16.37;  author steiner;  state Exp;
branches ;
next     1.3;

1.3
date     88.01.12.21.24.41;  author steiner;  state Exp;
branches ;
next     1.2;

1.2
date     87.10.20.17.13.00;  author jtkohl;  state Exp;
branches ;
next     1.1;

1.1
date     87.09.22.13.55.57;  author steiner;  state Exp;
branches ;
next     ;


desc
@Utilities for manipulating ticket file.
@


4.10
log
@lseek takes an off_t, not a long
symptom is bad TGT file error message
@
text
@/*
 * $Source: /usr/src/kerberosIV/krb/RCS/tf_util.c,v $
 * $Author: bostic $
 *
 * Copyright 1987, 1988 by the Massachusetts Institute of Technology.
 *
 * For copying and distribution information, please see the file
 * <mit-copyright.h>.
 */

#ifndef lint
static char rcsid_tf_util_c[] =
"$Id: tf_util.c,v 4.9 92/07/19 13:24:44 bostic Exp Locker: bostic $";
#endif /* lint */

#include <mit-copyright.h>

#include <stdio.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/file.h>
#include <des.h>
#include <krb.h>

#ifdef TKT_SHMEM
#include <sys/param.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#endif /* TKT_SHMEM */

#define TOO_BIG -1
#define TF_LCK_RETRY ((unsigned)2)	/* seconds to sleep before
					 * retry if ticket file is
					 * locked */
extern  errno;
extern int krb_debug;

#ifdef TKT_SHMEM
char *krb_shm_addr = 0;
static char *tmp_shm_addr = 0;
static char krb_dummy_skey[8] = {0,0,0,0,0,0,0,0};

char *shmat();
#endif /* TKT_SHMEM */

/*
 * fd must be initialized to something that won't ever occur as a real
 * file descriptor. Since open(2) returns only non-negative numbers as
 * valid file descriptors, and tf_init always stuffs the return value
 * from open in here even if it is an error flag, we must
 * 	a. Initialize fd to a negative number, to indicate that it is
 * 	   not initially valid.
 *	b. When checking for a valid fd, assume that negative values
 *	   are invalid (ie. when deciding whether tf_init has been
 *	   called.)
 *	c. In tf_close, be sure it gets reinitialized to a negative
 *	   number. 
 */
static  fd = -1;
static	curpos;				/* Position in tfbfr */
static	lastpos;			/* End of tfbfr */
static	char tfbfr[BUFSIZ];		/* Buffer for ticket data */

static tf_gets(), tf_read();

/*
 * This file contains routines for manipulating the ticket cache file.
 *
 * The ticket file is in the following format:
 *
 *      principal's name        (null-terminated string)
 *      principal's instance    (null-terminated string)
 *      CREDENTIAL_1
 *      CREDENTIAL_2
 *      ...
 *      CREDENTIAL_n
 *      EOF
 *
 *      Where "CREDENTIAL_x" consists of the following fixed-length
 *      fields from the CREDENTIALS structure (see "krb.h"):
 *
 *              char            service[ANAME_SZ]
 *              char            instance[INST_SZ]
 *              char            realm[REALM_SZ]
 *              C_Block         session
 *              int             lifetime
 *              int             kvno
 *              KTEXT_ST        ticket_st
 *              long            issue_date
 *
 * Short description of routines:
 *
 * tf_init() opens the ticket file and locks it.
 *
 * tf_get_pname() returns the principal's name.
 *
 * tf_get_pinst() returns the principal's instance (may be null).
 *
 * tf_get_cred() returns the next CREDENTIALS record.
 *
 * tf_save_cred() appends a new CREDENTIAL record to the ticket file.
 *
 * tf_close() closes the ticket file and releases the lock.
 *
 * tf_gets() returns the next null-terminated string.  It's an internal
 * routine used by tf_get_pname(), tf_get_pinst(), and tf_get_cred().
 *
 * tf_read() reads a given number of bytes.  It's an internal routine
 * used by tf_get_cred().
 */

/*
 * tf_init() should be called before the other ticket file routines.
 * It takes the name of the ticket file to use, "tf_name", and a
 * read/write flag "rw" as arguments. 
 *
 * It tries to open the ticket file, checks the mode, and if everything
 * is okay, locks the file.  If it's opened for reading, the lock is
 * shared.  If it's opened for writing, the lock is exclusive. 
 *
 * Returns KSUCCESS if all went well, otherwise one of the following: 
 *
 * NO_TKT_FIL   - file wasn't there
 * TKT_FIL_ACC  - file was in wrong mode, etc.
 * TKT_FIL_LCK  - couldn't lock the file, even after a retry
 */

tf_init(tf_name, rw)
    char   *tf_name;
{
    int     wflag;
    uid_t   me, getuid();
    struct stat stat_buf;
#ifdef TKT_SHMEM
    char shmidname[MAXPATHLEN]; 
    FILE *sfp;
    int shmid;
#endif

    switch (rw) {
    case R_TKT_FIL:
	wflag = 0;
	break;
    case W_TKT_FIL:
	wflag = 1;
	break;
    default:
	if (krb_debug) fprintf(stderr, "tf_init: illegal parameter\n");
	return TKT_FIL_ACC;
    }
    if (lstat(tf_name, &stat_buf) < 0)
	switch (errno) {
	case ENOENT:
	    return NO_TKT_FIL;
	default:
	    return TKT_FIL_ACC;
	}
    me = getuid();
    if ((stat_buf.st_uid != me && me != 0) ||
	((stat_buf.st_mode & S_IFMT) != S_IFREG))
	return TKT_FIL_ACC;
#ifdef TKT_SHMEM
    (void) strcpy(shmidname, tf_name);
    (void) strcat(shmidname, ".shm");
    if (stat(shmidname,&stat_buf) < 0)
	return(TKT_FIL_ACC);
    if ((stat_buf.st_uid != me && me != 0) ||
	((stat_buf.st_mode & S_IFMT) != S_IFREG))
	return TKT_FIL_ACC;
#endif /* TKT_SHMEM */

    /*
     * If "wflag" is set, open the ticket file in append-writeonly mode
     * and lock the ticket file in exclusive mode.  If unable to lock
     * the file, sleep and try again.  If we fail again, return with the
     * proper error message. 
     */

    curpos = sizeof(tfbfr);

#ifdef TKT_SHMEM
    sfp = fopen(shmidname, "r");	/* only need read/write on the
					   actual tickets */
    if (sfp == 0)
    	return TKT_FIL_ACC;
    shmid = -1;
    {
	char buf[BUFSIZ];
	int val;			/* useful for debugging fscanf */
	/* We provide our own buffer here since some STDIO libraries
	   barf on unbuffered input with fscanf() */

	setbuf(sfp, buf);
	if ((val = fscanf(sfp,"%d",&shmid)) != 1) {
	    (void) fclose(sfp);
	    return TKT_FIL_ACC;
	}
	if (shmid < 0) {
	    (void) fclose(sfp);
	    return TKT_FIL_ACC;
	}
	(void) fclose(sfp);
    }
    /*
    * global krb_shm_addr is initialized to 0.  Ultrix bombs when you try and
    * attach the same segment twice so we need this check.
    */
    if (!krb_shm_addr) {
    	if ((krb_shm_addr = shmat(shmid,0,0)) == -1){
		if (krb_debug)
		    fprintf(stderr,
			    "cannot attach shared memory for segment %d\n",
			    shmid);
		krb_shm_addr = 0;	/* reset so we catch further errors */
		return TKT_FIL_ACC;
	    }
    }
    tmp_shm_addr = krb_shm_addr;
#endif /* TKT_SHMEM */
    
    if (wflag) {
	fd = open(tf_name, O_RDWR, 0600);
	if (fd < 0) {
	    return TKT_FIL_ACC;
	}
	if (flock(fd, LOCK_EX | LOCK_NB) < 0) {
	    sleep(TF_LCK_RETRY);
	    if (flock(fd, LOCK_EX | LOCK_NB) < 0) {
		(void) close(fd);
		fd = -1;
		return TKT_FIL_LCK;
	    }
	}
	return KSUCCESS;
    }
    /*
     * Otherwise "wflag" is not set and the ticket file should be opened
     * for read-only operations and locked for shared access. 
     */

    fd = open(tf_name, O_RDONLY, 0600);
    if (fd < 0) {
	return TKT_FIL_ACC;
    }
    if (flock(fd, LOCK_SH | LOCK_NB) < 0) {
	sleep(TF_LCK_RETRY);
	if (flock(fd, LOCK_SH | LOCK_NB) < 0) {
	    (void) close(fd);
	    fd = -1;
	    return TKT_FIL_LCK;
	}
    }
    return KSUCCESS;
}

/*
 * tf_get_pname() reads the principal's name from the ticket file. It
 * should only be called after tf_init() has been called.  The
 * principal's name is filled into the "p" parameter.  If all goes well,
 * KSUCCESS is returned.  If tf_init() wasn't called, TKT_FIL_INI is
 * returned.  If the name was null, or EOF was encountered, or the name
 * was longer than ANAME_SZ, TKT_FIL_FMT is returned. 
 */

tf_get_pname(p)
    char   *p;
{
    if (fd < 0) {
	if (krb_debug)
	    fprintf(stderr, "tf_get_pname called before tf_init.\n");
	return TKT_FIL_INI;
    }
    if (tf_gets(p, ANAME_SZ) < 2)	/* can't be just a null */
	return TKT_FIL_FMT;
    return KSUCCESS;
}

/*
 * tf_get_pinst() reads the principal's instance from a ticket file.
 * It should only be called after tf_init() and tf_get_pname() have been
 * called.  The instance is filled into the "inst" parameter.  If all
 * goes well, KSUCCESS is returned.  If tf_init() wasn't called,
 * TKT_FIL_INI is returned.  If EOF was encountered, or the instance
 * was longer than ANAME_SZ, TKT_FIL_FMT is returned.  Note that the
 * instance may be null. 
 */

tf_get_pinst(inst)
    char   *inst;
{
    if (fd < 0) {
	if (krb_debug)
	    fprintf(stderr, "tf_get_pinst called before tf_init.\n");
	return TKT_FIL_INI;
    }
    if (tf_gets(inst, INST_SZ) < 1)
	return TKT_FIL_FMT;
    return KSUCCESS;
}

/*
 * tf_get_cred() reads a CREDENTIALS record from a ticket file and fills
 * in the given structure "c".  It should only be called after tf_init(),
 * tf_get_pname(), and tf_get_pinst() have been called. If all goes well,
 * KSUCCESS is returned.  Possible error codes are: 
 *
 * TKT_FIL_INI  - tf_init wasn't called first
 * TKT_FIL_FMT  - bad format
 * EOF          - end of file encountered
 */

tf_get_cred(c)
    CREDENTIALS *c;
{
    KTEXT   ticket = &c->ticket_st;	/* pointer to ticket */
    int     k_errno;

    if (fd < 0) {
	if (krb_debug)
	    fprintf(stderr, "tf_get_cred called before tf_init.\n");
	return TKT_FIL_INI;
    }
    if ((k_errno = tf_gets(c->service, SNAME_SZ)) < 2)
	switch (k_errno) {
	case TOO_BIG:
	case 1:		/* can't be just a null */
	    tf_close();
	    return TKT_FIL_FMT;
	case 0:
	    return EOF;
	}
    if ((k_errno = tf_gets(c->instance, INST_SZ)) < 1)
	switch (k_errno) {
	case TOO_BIG:
	    return TKT_FIL_FMT;
	case 0:
	    return EOF;
	}
    if ((k_errno = tf_gets(c->realm, REALM_SZ)) < 2)
	switch (k_errno) {
	case TOO_BIG:
	case 1:		/* can't be just a null */
	    tf_close();
	    return TKT_FIL_FMT;
	case 0:
	    return EOF;
	}
    if (
	tf_read((char *) (c->session), KEY_SZ) < 1 ||
	tf_read((char *) &(c->lifetime), sizeof(c->lifetime)) < 1 ||
	tf_read((char *) &(c->kvno), sizeof(c->kvno)) < 1 ||
	tf_read((char *) &(ticket->length), sizeof(ticket->length))
	< 1 ||
    /* don't try to read a silly amount into ticket->dat */
	ticket->length > MAX_KTXT_LEN ||
	tf_read((char *) (ticket->dat), ticket->length) < 1 ||
	tf_read((char *) &(c->issue_date), sizeof(c->issue_date)) < 1
	) {
	tf_close();
	return TKT_FIL_FMT;
    }
#ifdef TKT_SHMEM
    bcopy(tmp_shm_addr,c->session,KEY_SZ);
    tmp_shm_addr += KEY_SZ;
#endif /* TKT_SHMEM */
    return KSUCCESS;
}

/*
 * tf_close() closes the ticket file and sets "fd" to -1. If "fd" is
 * not a valid file descriptor, it just returns.  It also clears the
 * buffer used to read tickets.
 *
 * The return value is not defined.
 */

tf_close()
{
    if (!(fd < 0)) {
#ifdef TKT_SHMEM
	if (shmdt(krb_shm_addr)) {
	    /* what kind of error? */
	    if (krb_debug)
		fprintf(stderr, "shmdt 0x%x: errno %d",krb_shm_addr, errno);
	} else {
	    krb_shm_addr = 0;
	}
#endif TKT_SHMEM
	(void) flock(fd, LOCK_UN);
	(void) close(fd);
	fd = -1;		/* see declaration of fd above */
    }
    bzero(tfbfr, sizeof(tfbfr));
}

/*
 * tf_gets() is an internal routine.  It takes a string "s" and a count
 * "n", and reads from the file until either it has read "n" characters,
 * or until it reads a null byte. When finished, what has been read exists
 * in "s". If it encounters EOF or an error, it closes the ticket file. 
 *
 * Possible return values are:
 *
 * n            the number of bytes read (including null terminator)
 *              when all goes well
 *
 * 0            end of file or read error
 *
 * TOO_BIG      if "count" characters are read and no null is
 *		encountered. This is an indication that the ticket
 *		file is seriously ill.
 */

static 
tf_gets(s, n)
    register char *s;
{
    register count;

    if (fd < 0) {
	if (krb_debug)
	    fprintf(stderr, "tf_gets called before tf_init.\n");
	return TKT_FIL_INI;
    }
    for (count = n - 1; count > 0; --count) {
	if (curpos >= sizeof(tfbfr)) {
	    lastpos = read(fd, tfbfr, sizeof(tfbfr));
	    curpos = 0;
	}
	if (curpos == lastpos) {
	    tf_close();
	    return 0;
	}
	*s = tfbfr[curpos++];
	if (*s++ == '\0')
	    return (n - count);
    }
    tf_close();
    return TOO_BIG;
}

/*
 * tf_read() is an internal routine.  It takes a string "s" and a count
 * "n", and reads from the file until "n" bytes have been read.  When
 * finished, what has been read exists in "s".  If it encounters EOF or
 * an error, it closes the ticket file.
 *
 * Possible return values are:
 *
 * n		the number of bytes read when all goes well
 *
 * 0		on end of file or read error
 */

static
tf_read(s, n)
    register char *s;
    register n;
{
    register count;
    
    for (count = n; count > 0; --count) {
	if (curpos >= sizeof(tfbfr)) {
	    lastpos = read(fd, tfbfr, sizeof(tfbfr));
	    curpos = 0;
	}
	if (curpos == lastpos) {
	    tf_close();
	    return 0;
	}
	*s++ = tfbfr[curpos++];
    }
    return n;
}
     
char   *tkt_string();

/*
 * tf_save_cred() appends an incoming ticket to the end of the ticket
 * file.  You must call tf_init() before calling tf_save_cred().
 *
 * The "service", "instance", and "realm" arguments specify the
 * server's name; "session" contains the session key to be used with
 * the ticket; "kvno" is the server key version number in which the
 * ticket is encrypted, "ticket" contains the actual ticket, and
 * "issue_date" is the time the ticket was requested (local host's time).
 *
 * Returns KSUCCESS if all goes well, TKT_FIL_INI if tf_init() wasn't
 * called previously, and KFAILURE for anything else that went wrong.
 */

tf_save_cred(service, instance, realm, session, lifetime, kvno,
	     ticket, issue_date)
    char   *service;		/* Service name */
    char   *instance;		/* Instance */
    char   *realm;		/* Auth domain */
    C_Block session;		/* Session key */
    int     lifetime;		/* Lifetime */
    int     kvno;		/* Key version number */
    KTEXT   ticket;		/* The ticket itself */
    long    issue_date;		/* The issue time */
{

    off_t   lseek();
    int     count;		/* count for write */
#ifdef TKT_SHMEM
    int	    *skey_check;
#endif /* TKT_SHMEM */

    if (fd < 0) {		/* fd is ticket file as set by tf_init */
	  if (krb_debug)
	      fprintf(stderr, "tf_save_cred called before tf_init.\n");
	  return TKT_FIL_INI;
    }
    /* Find the end of the ticket file */
    (void) lseek(fd, (off_t)0, 2);
#ifdef TKT_SHMEM
    /* scan to end of existing keys: pick first 'empty' slot.
       we assume that no real keys will be completely zero (it's a weak
       key under DES) */

    skey_check = (int *) krb_shm_addr;

    while (*skey_check && *(skey_check+1))
	skey_check += 2;
    tmp_shm_addr = (char *)skey_check;
#endif /* TKT_SHMEM */

    /* Write the ticket and associated data */
    /* Service */
    count = strlen(service) + 1;
    if (write(fd, service, count) != count)
	goto bad;
    /* Instance */
    count = strlen(instance) + 1;
    if (write(fd, instance, count) != count)
	goto bad;
    /* Realm */
    count = strlen(realm) + 1;
    if (write(fd, realm, count) != count)
	goto bad;
    /* Session key */
#ifdef TKT_SHMEM
    bcopy(session,tmp_shm_addr,8);
    tmp_shm_addr+=8;
    if (write(fd,krb_dummy_skey,8) != 8)
	goto bad;
#else /* ! TKT_SHMEM */
    if (write(fd, (char *) session, 8) != 8)
	goto bad;
#endif /* TKT_SHMEM */
    /* Lifetime */
    if (write(fd, (char *) &lifetime, sizeof(int)) != sizeof(int))
	goto bad;
    /* Key vno */
    if (write(fd, (char *) &kvno, sizeof(int)) != sizeof(int))
	goto bad;
    /* Tkt length */
    if (write(fd, (char *) &(ticket->length), sizeof(int)) !=
	sizeof(int))
	goto bad;
    /* Ticket */
    count = ticket->length;
    if (write(fd, (char *) (ticket->dat), count) != count)
	goto bad;
    /* Issue date */
    if (write(fd, (char *) &issue_date, sizeof(long))
	!= sizeof(long))
	goto bad;

    /* Actually, we should check each write for success */
    return (KSUCCESS);
bad:
    return (KFAILURE);
}
@


4.9
log
@checked in for John Kohl by TK; set krb_shm_addr
@
text
@d2 2
a3 2
 * $Source: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/tf_util.c,v $
 * $Author: jon $
d13 1
a13 1
"$Id: tf_util.c,v 4.8 90/01/02 13:34:27 jtkohl Exp Locker: jtkohl $";
d517 1
a517 1
    (void) lseek(fd, 0L, 2);
@


4.8
log
@shmdt() should be inside check for valid open ticket file
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/tf_util.c,v $
 * $Author: qjb $
d13 1
a13 1
"$Id: tf_util.c,v 4.7 89/12/30 21:29:37 qjb Exp Locker: jtkohl $";
d23 1
d215 1
@


4.7
log
@Add buffer for reading from ticket file for the benifit of libraries
that can't handle unbuffered input in some cases

Remember to try to detach the shared memory segment when closing 
a ticket file.
@
text
@d2 2
a3 2
 * $Source: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/tf_util.c,v $
 * $Author: jtkohl $
d13 1
a13 1
"$Id: tf_util.c,v 4.6 89/10/02 16:22:49 jtkohl Exp $";
d378 1
d380 7
a386 7
    if (shmdt(krb_shm_addr)) {
	/* what kind of error? */
	if (krb_debug)
	    fprintf(stderr, "shmdt 0x%x: errno %d",krb_shm_addr, errno);
    } else {
	krb_shm_addr = 0;
    }
a387 1
    if (!(fd < 0)) {
@


4.6
log
@change $Header to $Id
@
text
@d13 1
a13 1
"$Id: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/tf_util.c,v 4.5 89/10/02 16:20:27 jtkohl Exp Locker: jtkohl $";
d187 15
a201 1
    if (fscanf(sfp,"%d",&shmid) != 1) {
a202 1
    	return TKT_FIL_ACC;
a203 6
    if (shmid < 0) {
	(void) fclose(sfp);
    	return TKT_FIL_ACC;
    }
    (void) fclose(sfp);

d378 9
@


4.5
log
@Programmer: Dan Kolkowitz
Auditor: John Kohl
add shared memory code
@
text
@d13 1
a13 1
"$Header: /afs/athena.mit.edu/astaff/project/kerberos/src/lib/krb/RCS/tf_util.c,v 4.4 89/05/17 11:08:56 jtkohl Exp Locker: jtkohl $";
@


4.4
log
@need to declare tf_gets() and tf_read() as static before use
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/src/lib/krb/RCS/tf_util.c,v $
 * $Author: rfrench $
d13 1
a13 1
"$Header: tf_util.c,v 4.3 89/01/13 17:51:22 rfrench Exp $";
d25 6
d38 8
d134 5
d162 9
d180 32
d354 4
d489 3
d500 4
d505 7
d526 6
d534 1
@


4.3
log
@Programmer: jtkohl
Auditor: rfrench
Clears ticket reading buffer before returning
@
text
@d3 1
a3 1
 * $Author: raeburn $
d13 1
a13 1
"$Header: tf_util.c,v 4.2 89/01/05 12:08:17 jtkohl Locked $";
d49 2
@


4.2
log
@(jtkohl) conditionalized printing of error messages on krb_debug;
also return error code rather than exiting on bad parameters
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d13 1
a13 1
"$Header: tf_util.c,v 4.1 88/12/01 14:41:24 jtkohl Locked $";
d297 2
a298 1
 * not a valid file descriptor, it just returns. 
d310 1
@


4.1
log
@Programmer: Jennifer Steiner
Auditor: John Kohl
changes: improve documentation of code
@
text
@d3 1
a3 1
 * $Author: steiner $
d13 1
a13 1
"$Header: tf_util.c,v 1.12 88/11/08 14:36:38 steiner Locked $";
d30 1
d127 2
a128 2
	fprintf(stderr, "tf_init: illegal parameter\n");
	exit(-1);
d199 2
a200 1
	fprintf(stderr, "tf_get_pname called before tf_init.\n");
d222 2
a223 1
	fprintf(stderr, "tf_get_pinst called before tf_init.\n");
d249 2
a250 1
	fprintf(stderr, "tf_get_cred called before tf_init.\n");
d333 1
a333 1
    register count, i;
d336 2
a337 1
	fprintf(stderr, "tf_gets called before tf_init.\n");
d423 3
a425 2
	fprintf(stderr, "tf_save_cred called before tf_init.\n");
	return TKT_FIL_INI;
@


1.12
log
@Revised ticket file access to refuse if it's
a symbolic link, socket, etc.
Programmer: jtkohl
Auditor: steiner
@
text
@d3 1
a3 1
 * $Author: shanzer $
a8 41
 *
 * This file contains tools for manipulating the tickets file.
 *
 * Description of ticket file format:
 *
 *      principal's name        (null-terminated string)
 *      principal's instance    (null-terminated string)
 *      CREDENTIAL_1
 *      CREDENTIAL_2
 *      ...
 *      CREDENTIAL_n
 *      EOF
 *
 *      Where "CREDENTIAL_x" consists of the following fixed-length
 *      fields from the CREDENTIALS structure (see file <krb.h>):
 *
 *              char            service[ANAME_SZ]
 *              char            instance[INST_SZ]
 *              char            realm[REALM_SZ]
 *              C_Block         session
 *              int             lifetime
 *              int             kvno
 *              KTEXT_ST        ticket_st
 *              long            issue_date
 *
 * Short description of routines:
 *
 * tf_init opens the ticket file and locks it.
 *
 * tf_get_pname returns the principal's name.
 *
 * tf_get_pinst returns the principal's instance (may be null).
 *
 * tf_get_cred returns the next CREDENTIALS record.
 *
 * tf_save_cred appends new CREDENTIAL records to the ticket file.
 *
 * tf_close closes the ticket file and releases the lock.
 *
 * tf_gets returns the next null-terminated string.  It's an internal
 * routine used by tf_get_pname, tf_get_pinst, and tf_get_cred.
d13 1
a13 1
"$Header: tf_util.c,v 1.11 88/07/14 12:13:54 shanzer Exp $";
d50 1
a50 3
 * tf_init should be called before the other ticket file routines.  It
 * takes the name of the ticket file to use, and a read/write flag as
 * arguments. 
d52 50
a101 2
 * It tries to open the ticket file, checks the mode and if everything is
 * okay, locks the file.  If it's opened for reading, the lock is
d142 4
a145 5
     * If wflag set for ticket file to accept the write operation,
     * open the ticket file in append-writeonly fashion and lock ticket
     * file in exclusive mode.  If unable to lock the file, sleep and
     * try again.  If we fail again, return with the proper error
     * message. 
d166 2
a167 2
     * Otherwise wflag is not set and the ticket file should be opened
     * for read only operations and locked for shared access. 
d186 4
a189 4
 * This routine reads the principal's name from a ticket file. It
 * should only be called after tf_init has been called.  The
 * principal's name is filled into the p parameter.  If all goes well,
 * KSUCCESS is returned.  If tf_init wasn't called, TKT_FIL_INI is
d207 4
a210 4
 * This routine reads the principal's instance from a ticket file.  It
 * should only be called after tf_init and tf_get_pname have been
 * called.  The instance is filled into the inst parameter.  If all
 * goes well, KSUCCESS is returned.  If tf_init wasn't called,
d229 3
a231 3
 * This routine reads a CREDENTIALS record from a ticket file and fills
 * in the given structure.  It should only be called after tf_init,
 * tf_get_pname, and tf_get_pinst have been called. If all goes well,
d292 4
a295 2
 * tf_close closes the ticket file and sets "fd" to 0. If fd is not a
 * valid file descriptor it just returns. 
d308 4
a311 4
 * tf_gets is an internal routine.  It takes a string and a count, and
 * reads from the file until either it has read count characters, or
 * until it reads a null byte. When finished, what has been read exists
 * in s. If it encounters EOF or an error, it closes the ticket file. 
d313 2
d316 1
a316 1
 *              is returned when all goes well.
d318 1
a318 1
 * 0            is returned on end of file or read error
d320 3
a322 4
 * TOO_BIG      is returned if count characters are read
 *              and no null is encountered.  This is an
 *              indication that the ticket file is seriously
 *              ill.
d353 4
a356 4
 * tf_read is an internal routine.  It takes a string and a count, and
 * reads from the file until count bytes have been read.  When finished,
 * what has been read exists in s.  If it encounters EOF or an error,
 * it closes the ticket file.
d358 1
a358 1
 * n		the number of bytes read is returned if all goes well.
d360 3
a362 1
 * 0		is returned on end of file or read error
d389 11
a399 3
 * tf_save_cred appends an incoming ticket to the end of the ticket
 * file.  You must call tf_init before calling tf_save_cred. I believe
 * that tf_save_cred is used only in the save_credentials function. 
@


1.11
log
@Fixed some leaks for file locking.
Programmers: eichin/jtkohl
Auditor: shanzer
@
text
@d3 1
a3 1
 * $Author: steiner $
d54 1
a54 1
"$Header: tf_util.c,v 1.10++ 88/06/03 13:44:08 eichin Fix $";
d132 2
a133 2
    if (stat_buf.st_uid != me && me != 0 || !(stat_buf.st_mode &
					      S_IFREG))
@


1.10
log
@Check for read error.
Programmer: steiner.
Auditor: jon.
@
text
@d54 1
a54 1
"$Header: tf_util.c,v 1.8 88/05/18 17:14:57 steiner Exp $";
d72 14
a85 1
static  fd;
d154 2
d173 2
d193 1
a193 1
    if (!fd) {
d215 1
a215 1
    if (!fd) {
d241 1
a241 1
    if (!fd) {
d288 2
a289 2
 * tf_close closes the ticket file and sets "fd" to 0. If fd is null it
 * just returns. 
d294 2
a295 1
    if (fd) {
d297 1
a297 1
	fd = 0;
d324 1
a324 1
    if (!fd) {
d400 1
a400 1
    if (!fd) {			/* fd is ticket file as set by tf_init */
@


1.9
log
@tf_read added.  Reads BUFSIZ bytes at a time
instead of one at a time.  Debug stuff taken out.
Programmer: rfrench.
Auditor: jon.
@
text
@d315 1
a315 1
	if (curpos == lastpos || lastpos < 0) {
d350 1
a350 1
	if (curpos == lastpos || lastpos < 0) {
@


1.8
log
@Changed open to read/write mode as opposed to append
when doing save_credentials.
Programmer: steiner.
Auditors:  wesommer, jon.
@
text
@a49 2
 *
 * Author:  Jennifer Steiner, MIT Project Athena, Sept 1987.
d54 1
a54 1
"$Header: tf_util.c,v 1.7 88/04/27 15:06:41 steiner Exp $";
d73 3
d131 2
d254 4
a257 4
	read(fd, (char *) (c->session), KEY_SZ) < 1 ||
	read(fd, (char *) &(c->lifetime), sizeof(c->lifetime)) < 1 ||
	read(fd, (char *) &(c->kvno), sizeof(c->kvno)) < 1 ||
	read(fd, (char *) &(ticket->length), sizeof(ticket->length))
d261 2
a262 2
	read(fd, (char *) (ticket->dat), ticket->length) < 1 ||
	read(fd, (char *) &(c->issue_date), sizeof(c->issue_date)) < 1
d304 1
a304 1
    register count;
d310 10
a319 1
    for (count = n - 1; read(fd, s, 1) > 0 && count; --count)
a321 4
    /* untimely EOF */
    if (count) {
	tf_close();
	return 0;
d323 2
a324 5
    if (*s) {
	tf_close();
	return TOO_BIG;
    }
    return (n - count);
d327 15
a341 2
#ifdef TF_DEBUG
main()
d343 14
a356 15
    int     k_errno;
    char    pname[ANAME_SZ], pinst[INST_SZ];
    CREDENTIALS c;

    k_errno = tf_init(TKT_FILE, R_TKT_FIL);
    fprintf(stderr, "tf_init: %s\n", tf_err_txt[k_errno]);

    k_errno = tf_get_pname(pname);
    fprintf(stderr, "tf_get_pname: %s\n", tf_err_txt[k_errno]);

    k_errno = tf_get_pinst(pinst);
    fprintf(stderr, "tf_get_pinst: %s\n", tf_err_txt[k_errno]);

    while (!(k_errno = tf_get_cred(&c)))
	fprintf(stderr, "got %s\n", c.service);
d358 1
a358 2
#endif				/* TF_DEBUG */

@


1.7
log
@Allow reading and writing when opening tf for writing.
Programmer: steiner.
Auditor: jtkohl.
@
text
@d3 1
a3 1
 * $Author: jtkohl $
d56 1
a56 1
"$Header: tf_util.c,v 1.6 88/04/25 13:41:34 jtkohl Exp $";
d123 1
a123 1
     * If wflag set for ticket file to acccept the write operation,
d125 1
a125 1
     * file in esclusive mode.  If unable to lock the file, sleep and
d131 1
a131 1
	fd = open(tf_name, O_APPEND, 0600);
@


1.6
log
@formatting fixes
@
text
@d3 1
a3 1
 * $Author: steiner $
d56 1
a56 1
"$Header: tf_util.c,v 1.5 88/04/14 14:37:31 jtkohl Locked $";
d131 1
a131 1
	fd = open(tf_name, O_APPEND | O_WRONLY, 0600);
@


1.5
log
@Added tf_save_cred routine.
Programmer: billb.
Auditor: jtkohl.
@
text
@d56 1
a56 1
"$Header: tf_util.c,v 1.4 88/02/24 18:16:37 steiner Exp $";
d69 4
a72 3
#define TF_LCK_RETRY ((unsigned)2) /* seconds to sleep before retry
				    * if ticket file is locked */
extern errno;
d74 1
a74 1
static fd;
d77 3
a79 3
 * tf_init should be called before the other ticket file
 * routines.  It takes the name of the ticket file to use,
 * and a read/write flag as arguments.
d81 3
a83 4
 * It tries to open the ticket file, checks the mode and if
 * everything is okay, locks the file.  If it's opened for
 * reading, the lock is shared.  If it's opened for writing,
 * the lock is exclusive.
d85 1
a85 2
 * Returns KSUCCESS if all went well, otherwise one of the
 * following:
d93 1
a93 1
    char *tf_name;
d95 2
a96 2
    int wflag;
    uid_t me, getuid();
d101 2
a102 2
        wflag = 0;
        break;
d104 2
a105 2
        wflag = 1;
        break;
d107 2
a108 2
        fprintf(stderr, "tf_init: illegal parameter\n");
        exit (-1);
d111 6
a116 6
        switch(errno) {
        case ENOENT:
            return NO_TKT_FIL;
        default:
            return TKT_FIL_ACC;
        }
d119 2
a120 2
                                              S_IFREG))
        return TKT_FIL_ACC;
d122 1
a122 1
    /* 
d124 4
a127 4
     * open the ticket file in append-writeonly fashion and
     * lock ticket file in esclusive mode.  If unable to lock
     * the file, sleep and try again.  If we fail again, return
     * with the proper error message.
d130 1
a130 2
    if (wflag)
      {
d132 1
a132 2
	if (fd < 0)
	  {
d134 2
a135 3
	  }
	if (flock(fd, LOCK_EX | LOCK_NB) < 0)
	  {
d137 1
a137 2
	    if (flock(fd, LOCK_EX | LOCK_NB) < 0)
	      {
d139 2
a140 2
	      }
	  }
d142 2
a143 3
      }

    /* 
d145 1
a145 1
     * for read only operations and locked for shared access.
d149 1
a149 2
    if (fd < 0)
      {
d151 2
a152 3
      }
    if (flock(fd, LOCK_SH | LOCK_NB) < 0)
      {
d154 1
a154 2
	if (flock(fd, LOCK_SH | LOCK_NB) < 0)
	  {
d156 2
a157 2
	  }
      }
d162 6
a167 6
 * This routine reads the principal's name from a ticket file.
 * It should only be called after tf_init has been called.  The
 * principal's name is filled into the p parameter.  If all goes
 * well, KSUCCESS is returned.  If tf_init wasn't called, TKT_FIL_INI
 * is returned.  If the name was null, or EOF was encountered, or the
 * name was longer than ANAME_SZ, TKT_FIL_FMT is returned.
d171 1
a171 1
    char *p;
d174 2
a175 2
        fprintf(stderr, "tf_get_pname called before tf_init.\n");
        return TKT_FIL_INI;
d177 2
a178 2
    if (tf_gets(p, ANAME_SZ) < 2)       /* can't be just a null */
        return TKT_FIL_FMT;
d189 1
a189 1
 * instance may be null.
d193 1
a193 1
    char *inst;
d196 2
a197 2
        fprintf(stderr, "tf_get_pinst called before tf_init.\n");
        return TKT_FIL_INI;
d200 1
a200 1
        return TKT_FIL_FMT;
d205 4
a208 5
 * This routine reads a CREDENTIALS record from a ticket file and
 * fills in the given structure.  It should only be called after
 * tf_init, tf_get_pname, and tf_get_pinst have been called.
 * If all goes well, KSUCCESS is returned.  Possible error codes
 * are:
d218 2
a219 2
    KTEXT ticket = &c->ticket_st;       /* pointer to ticket */
    int k_errno;
d222 2
a223 2
        fprintf(stderr, "tf_get_cred called before tf_init.\n");
        return TKT_FIL_INI;
d226 8
a233 8
        switch (k_errno) {
        case TOO_BIG:
        case 1:                 /* can't be just a null */
            tf_close();
            return TKT_FIL_FMT;
        case 0:
            return EOF;
        }
d235 6
a240 6
        switch(k_errno) {
        case TOO_BIG:
            return TKT_FIL_FMT;
        case 0:
            return EOF;
        }
d242 8
a249 8
        switch (k_errno) {
        case TOO_BIG:
        case 1:                 /* can't be just a null */
            tf_close();
            return TKT_FIL_FMT;
        case 0:
            return EOF;
        }
d251 4
a254 4
        read(fd, (char *)(c->session), KEY_SZ) < 1 ||
        read(fd, (char *) &(c->lifetime), sizeof(c->lifetime)) < 1 ||
        read(fd, (char *) &(c->kvno), sizeof(c->kvno)) < 1 ||
        read(fd, (char *) &(ticket->length), sizeof(ticket->length))
d256 7
a262 7
        /* don't try to read a silly amount into ticket->dat */
        ticket->length > MAX_KTXT_LEN ||
        read(fd, (char *) (ticket->dat), ticket->length) < 1 ||
        read(fd, (char *) &(c->issue_date), sizeof(c->issue_date)) < 1
        ) {
        tf_close();
        return TKT_FIL_FMT;
d268 2
a269 2
 * tf_close closes the ticket file and sets "fd" to 0.
 * If fd is null it just returns.
d275 2
a276 2
        (void) close(fd);
        fd = 0;
d281 4
a284 5
 * tf_gets is an internal routine.  It takes a string and a
 * count, and reads from the file until either it has read
 * count characters, or until it reads a null byte.
 * When finished, what has been read exists in s.
 * If it encounters EOF or an error, it closes the ticket file.
d297 2
a298 1
static tf_gets(s, n)
d304 2
a305 2
        fprintf(stderr, "tf_gets called before tf_init.\n");
        return TKT_FIL_INI;
d308 2
a309 2
        if (*s++ == '\0')
            return (n - count);
d312 2
a313 2
        tf_close();
        return 0;
d316 2
a317 2
        tf_close();
        return TOO_BIG;
d325 2
a326 2
    int k_errno;
    char pname[ANAME_SZ], pinst[INST_SZ];
d338 2
a339 2
    while(!(k_errno = tf_get_cred(&c)))
        fprintf(stderr, "got %s\n", c.service);
d341 1
a341 1
#endif /* TF_DEBUG */
d343 1
a343 1
char *tkt_string();
d346 3
a348 3
 * tf_save_cred appends an incoming ticket to the end of the
 * ticket file.  You must call tf_init before calling tf_save_cred.
 * I believe that tf_save_cred is used only in the save_credentials function.
d352 9
a360 9
                 ticket, issue_date)
    char *service;              /* Service name */
    char *instance;             /* Instance */
    char *realm;                /* Auth domain */
    C_Block session;            /* Session key */
    int lifetime;               /* Lifetime */
    int kvno;                   /* Key version number */
    KTEXT ticket;               /* The ticket itself */
    long issue_date;            /* The issue time */
d363 2
a364 2
    off_t lseek();
    int count;                  /* count for write */
d366 1
a366 2
    if (!fd)  /* fd is ticket file as set by tf_init */
      {
d369 1
a369 2
      }

d371 1
a371 1
    (void) lseek(fd,0L,2);
d375 3
a377 3
    count = strlen(service)+1;
    if (write(fd,service,count) != count)
        goto bad;
d379 3
a381 3
    count = strlen(instance)+1;
    if (write(fd,instance,count) != count)
        goto bad;
d383 3
a385 3
    count = strlen(realm)+1;
    if (write(fd,realm,count) != count)
        goto bad;
d387 2
a388 2
    if (write(fd, (char *)session, 8) != 8)
        goto bad;
d390 2
a391 2
    if (write(fd,(char *)&lifetime,sizeof(int)) != sizeof(int))
        goto bad;
d393 2
a394 2
    if (write(fd,(char *)&kvno,sizeof(int)) != sizeof(int))
        goto bad;
d396 3
a398 3
    if (write(fd,(char *)&(ticket->length),sizeof(int)) !=
        sizeof(int))
        goto bad;
d401 2
a402 2
    if (write(fd,(char *)(ticket->dat),count) != count)
        goto bad;
d404 3
a406 3
    if (write(fd,(char *)&issue_date,sizeof(long))
        != sizeof(long))
        goto bad;
d409 1
a409 1
    return(KSUCCESS);
d411 1
a411 1
    return(KFAILURE);
@


1.4
log
@Copyright notice, etc.
@
text
@d44 2
d56 1
a56 1
"$Header: tf_util.c,v 1.3 88/01/12 21:24:41 steiner Locked $";
d122 45
a166 9
    if ((fd = open(tf_name, wflag ? O_APPEND : O_RDONLY)) < 0)
        return TKT_FIL_ACC;
    if (flock(fd, (wflag ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0)
        sleep(TF_LCK_RETRY);
    /* try again */
    if (flock(fd, (wflag ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0) {
        tf_close();
        return TKT_FIL_LCK;
    }
d352 73
@


1.3
log
@Formatting changes.
Programmer: Ken.
Auditor: Jon.
@
text
@d2 2
a3 2
 * $Source: /mit/kerberos/lib/krb/RCS/tf_util.c,v $
 * $Author: jtkohl $
d5 1
a5 1
 * Copyright 1987 by the Massachusetts Institute of Technology.
d7 2
a8 2
 * For copying and distribution information,
 * please see the file <mit-copyright.h>.
d52 5
a58 4
#ifndef lint
static char rcsid_module_c[] =
    "$Header: tf_util.c,v 1.2 87/10/20 17:13:00 steiner Locked $";
#endif /* lint */
@


1.2
log
@lint fixes.
@
text
@d1 3
a3 2
/* $Source: /u3/kerberos.new/lib/krb/RCS/tf_util.c,v $
 * $Author: steiner $
d14 7
a20 7
 *	principal's name	(null-terminated string)
 *	principal's instance	(null-terminated string)
 *	CREDENTIAL_1
 *	CREDENTIAL_2
 *	...
 *	CREDENTIAL_n
 *	EOF
d22 2
a23 2
 *	Where "CREDENTIAL_x" consists of the following fixed-length
 *	fields from the CREDENTIALS structure (see file <krb.h>):
d25 8
a32 8
 *		char		service[ANAME_SZ]
 *		char		instance[INST_SZ]
 *		char		realm[REALM_SZ]
 *		C_Block		session
 *		int		lifetime
 *		int		kvno
 *		KTEXT_ST	ticket_st
 *		long		issue_date
d52 1
a52 1
#include	<mit-copyright.h>
d54 1
a54 1
#ifndef	lint
d56 8
a63 8
"$Header: tf_util.c,v 1.1 87/09/22 13:55:57 jtkohl Locked $";
#endif	lint
#include	<stdio.h>
#include	<errno.h>
#include	<sys/types.h> 
#include	<sys/stat.h>
#include	<sys/file.h>
#include	<krb.h>
d65 3
a67 3
#define TOO_BIG		-1
#define	TF_LCK_RETRY	((unsigned)2)	/* seconds to sleep before retry */
					/* if ticket file is locked */
d72 2
a73 1
/* tf_init should be called before the other ticket file
d85 3
a87 3
 * NO_TKT_FIL	- file wasn't there
 * TKT_FIL_ACC	- file was in wrong mode, etc.
 * TKT_FIL_LCK	- couldn't lock the file, even after a retry
d91 1
a91 1
char *tf_name;
d93 3
a95 3
	int wflag;
	uid_t me, getuid();
	struct stat stat_buf;
d97 32
a128 32
	switch (rw) {
	case R_TKT_FIL:
		wflag = 0;
		break;
	case W_TKT_FIL:
		wflag = 1;
		break;
	default:
		fprintf(stderr, "tf_init: illegal parameter\n");
			exit (-1);
	}
	if (lstat(tf_name, &stat_buf) < 0)
		switch(errno) {
			case ENOENT:
				return NO_TKT_FIL;
			default:
				return TKT_FIL_ACC;
		}
	me = getuid();
	if (stat_buf.st_uid != me && me != 0 || !(stat_buf.st_mode &
	    S_IFREG))
		return TKT_FIL_ACC;
	if ((fd = open(tf_name, wflag ? O_APPEND : O_RDONLY)) < 0)
		return TKT_FIL_ACC;
	if (flock(fd, (wflag ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0)
		sleep(TF_LCK_RETRY);
	/* try again */
	if (flock(fd, (wflag ? LOCK_EX : LOCK_SH) | LOCK_NB) < 0) {
		tf_close();
		return TKT_FIL_LCK;
	}
	return KSUCCESS;
d131 2
a132 1
/* This routine reads the principal's name from a ticket file.
d141 1
a141 1
char *p;
d143 7
a149 7
	if (!fd) {
		fprintf(stderr, "tf_get_pname called before tf_init.\n");
		return TKT_FIL_INI;
	}
	if (tf_gets(p, ANAME_SZ) < 2)	/* can't be just a null */
		return TKT_FIL_FMT;
	return KSUCCESS;
d152 8
a159 6
/* This routine reads the principal's instance from a ticket file.
 * It should only be called after tf_init and tf_get_pname have been
 * called.  The instance is filled into the inst parameter.  If all goes
 * well, KSUCCESS is returned.  If tf_init wasn't called, TKT_FIL_INI
 * is returned.  If EOF was encountered, or the instance was longer than
 * ANAME_SZ, TKT_FIL_FMT is returned.  Note that the instance may be null.
d163 1
a163 1
char *inst;
d165 7
a171 7
	if (!fd) {
		fprintf(stderr, "tf_get_pinst called before tf_init.\n");
		return TKT_FIL_INI;
	}
	if (tf_gets(inst, INST_SZ) < 1)
		return TKT_FIL_FMT;
	return KSUCCESS;
d174 2
a175 1
/* This routine reads a CREDENTIALS record from a ticket file and
d181 3
a183 3
 * TKT_FIL_INI	- tf_init wasn't called first
 * TKT_FIL_FMT	- bad format
 * EOF		- end of file encountered
d187 1
a187 1
CREDENTIALS *c;
d189 2
a190 2
	KTEXT ticket = &c->ticket_st;	/* pointer to ticket */
	int k_errno;
d192 44
a235 43
	if (!fd) {
		fprintf(stderr, "tf_get_cred called before tf_init.\n");
		return TKT_FIL_INI;
	}
	if ((k_errno = tf_gets(c->service, SNAME_SZ)) < 2)
		switch (k_errno) {
		case TOO_BIG:
		case 1:			/* can't be just a null */
			tf_close();
			return TKT_FIL_FMT;
		case 0:
			return EOF;
		}
	if ((k_errno = tf_gets(c->instance, INST_SZ)) < 1)
		switch(k_errno) {
		case TOO_BIG:
			return TKT_FIL_FMT;
		case 0:
			return EOF;
		}
	if ((k_errno = tf_gets(c->realm, REALM_SZ)) < 2)
		switch (k_errno) {
		case TOO_BIG:
		case 1:			/* can't be just a null */
			tf_close();
			return TKT_FIL_FMT;
		case 0:
			return EOF;
		}
	if (
	read(fd, (char *)(c->session), KEY_SZ) < 1 ||
	read(fd, (char *) &(c->lifetime), sizeof(c->lifetime)) < 1 ||
	read(fd, (char *) &(c->kvno), sizeof(c->kvno)) < 1 ||
	read(fd, (char *) &(ticket->length), sizeof(ticket->length)) < 1 ||
	/* don't try to read a silly amount into ticket->dat */
	ticket->length > MAX_KTXT_LEN ||
	read(fd, (char *) (ticket->dat), ticket->length) < 1 ||
	read(fd, (char *) &(c->issue_date), sizeof(c->issue_date)) < 1
	) {
		tf_close();
		return TKT_FIL_FMT;
	}
	return KSUCCESS;
d237 3
a239 2
	
/* tf_close closes the ticket file and sets "fd" to 0.
d245 4
a248 4
	if (fd) {
		(void) close(fd);
		fd = 0;
	}
d251 2
a252 1
/* tf_gets is an internal routine.  It takes a string and a
d258 2
a259 2
 * n		the number of bytes read (including null terminator)
 *		is returned when all goes well.
d261 1
a261 1
 * 0		is returned on end of file or read error
d263 4
a266 4
 * TOO_BIG	is returned if count characters are read
 *		and no null is encountered.  This is an
 *		indication that the ticket file is seriously
 *		ill.
d269 2
a270 3
static
tf_gets(s, n)
register char *s;
d272 1
a272 1
	register count;
d274 17
a290 17
	if (!fd) {
		fprintf(stderr, "tf_gets called before tf_init.\n");
		return TKT_FIL_INI;
	}
	for (count = n - 1; read(fd, s, 1) > 0 && count; --count)
		if (*s++ == '\0')
			return (n - count);
	/* untimely EOF */
	if (count) {
		tf_close();
		return 0;
	}
	if (*s) {
		tf_close();
		return TOO_BIG;
	}
	return (n - count);
d296 3
a298 3
	int k_errno;
	char pname[ANAME_SZ], pinst[INST_SZ];
	CREDENTIALS c;
d300 2
a301 2
	k_errno = tf_init(TKT_FILE, R_TKT_FIL);
	fprintf(stderr, "tf_init: %s\n", tf_err_txt[k_errno]);
d303 2
a304 2
	k_errno = tf_get_pname(pname);
	fprintf(stderr, "tf_get_pname: %s\n", tf_err_txt[k_errno]);
d306 2
a307 2
	k_errno = tf_get_pinst(pinst);
	fprintf(stderr, "tf_get_pinst: %s\n", tf_err_txt[k_errno]);
d309 2
a310 2
	while(!(k_errno = tf_get_cred(&c)))
		fprintf(stderr, "got %s\n", c.service);
d312 1
a312 1
#endif TF_DEBUG
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* $Source$
 * $Author$
d55 1
a55 1
"$Header$";
d91 2
a92 1
	int i, me, wflag;
d216 4
a219 4
	read(fd, c->session, KEY_SZ) < 1 ||
	read(fd, &(c->lifetime), sizeof(c->lifetime)) < 1 ||
	read(fd, &(c->kvno), sizeof(c->kvno)) < 1 ||
	read(fd, &(ticket->length), sizeof(ticket->length)) < 1 ||
d222 2
a223 2
	read(fd, ticket->dat, ticket->length) < 1 ||
	read(fd, &(c->issue_date), sizeof(c->issue_date)) < 1
d238 1
a238 1
		close(fd);
@
