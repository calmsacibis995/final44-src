.TH RPI l "26 January 1985"
.\" @(#)RPI
.SH NAME
\fIRpi\fP \- local front end for using pi with \fImaitrd\fP
.br
\fISpi\fP \- server front end for using pi with \fIgarcon\fP
.SH SYNOPSIS
.B Rpi
[
.B \+gvd +o [file] -[pi options]
]
.br
.B Spi
[
.B \+gv -[pi options]
]
.br
.SH DESCRIPTION
.I Rpi
is a user friendly interface for using pi
with the maitrd/garcon load balancing software.
It finds an available machine for processing,
transfers whatever files are needed by pi,
and brings back any output generated by the remote pi.
Before beginning the compile, \fIRpi\fP copies
any existing obj file to obj.bak.  
.br

In its simplest form, it is invoked just as pi is:
.br

.ce 1
Rpi prog.p

.br
Since pi requires as input a file ending in .p, Rpi does not
call up pi immediately, but instead requests to run \fISpi\fP
on the server machine.  \fIRpi\fP and \fISpi\fP transfer whatever
source files are needed and whatever object files are
created back and forth to one another.  \fISpi\fP creates a 
temporary work directory on the server end.  It is here where
the pi is actually performed.  Pi error messages are 
routed back to the user through stderr.  If the compilation
was successful (an obj file exists in the remote work
directory), the obj file is moved back to the current
working directory.  Only a single status message  from the remote
machine gives any indication that the program is not
being compiled locally.

.br
\fISpi\fP  can not be used directly, as it expects data
to be headed with filestat information.  In this manner,
multiple files can be passed though a single pipe.

.br
Pascal include files cause numerous headaches with remote
processing.  The source files must all be scanned for #include
directives.  As all work is done in a single directory on the remote end,
including files from a directory other than the current
one can cause "minor" problems.  Pathnames are stripped to
their basename, so this means that the pascal runtime system 
and pdx will not be able to reconcile the path names of included
files properly when the program is run locally and crashes.  It is 
suggested that all included files be kept in the same directory 
as the source program (symbolic links will suffice).
.br
.SH OPTIONS
.TP
.B \+g
When the server has completed compiling, it will
normally clean up whatever workspace it required.
If the \+g option is used, garbage generated by
the compilation will be left behind, and the
workspace path will be given upon program termination.
This is only really useful for debugging.
.br
.TP
.B \+o
Normally, \fIRpi\fP output will go into obj. 
This option allows you to specify the output file.
.br
.TP
.B \+v
This puts \fIRpi\fP into verbose mode.  It can sometimes
be fun to watch if you like this sort of stuff.
.br
.TP
.B \+d
This sets a debugging flag.  It is not used for much. \+v is
better.
.br
.TP
.B \-[pi options]
Any switches preceeded by a \- will be passed through
untouched to the pi program.

.br
.SH ERRORS
If, for any detectable reason, the remote end can not perform the
compilation (host dies, failed exec, etc...), the compilation
will be performed locally.
.br
.SH SEE ALSO
maitrd(8), garcon(8), client(1), setmaitrd(1), socket(2), pi(1)
.br
.SH BUGS
.br
The problem with include files can be fixed by patching
the symbol table of the obj file created on the remote end.
This needs to be done.
.br
The (g)arbage switch is really useless unless there
is the capability to return the entire temporary
directory back to the local machine.
.br
Error messages from the compiler are sent to standard error.
This is consistent with every other program in UNIX, but
inconsistent with pi, which normally sends everything
to standard out and nothing to standard error.  Any 
output from Rpi must be redirected with "|&" or ">&".
