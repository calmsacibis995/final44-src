
------- SCCS -------

------- acctdef.h -------
*** /tmp/d02415	Thu Aug  4 14:12:09 1988
--- acctdef.h	Fri Jan  8 23:58:06 1988
***************
*** 0 ****
--- 1,46 ----
+ /*	@(#)acctdef.h	1.5 of 4/19/82	*/
+ /*
+  *	defines, typedefs, etc. used by acct programs
+  */
+ 
+ 
+ /*
+  *	acct only typedefs
+  */
+ /* typedef	unsigned short	uid_t; - marc */
+ 
+ #if u3b || u3b5
+ #define HZ	100
+ #else
+ #define HZ	60
+ #endif
+ 
+ #define LSZ	12	/* sizeof line name */
+ #define NSZ	8	/* sizeof login name */
+ #define P	0	/* prime time */
+ #define NP	1	/* nonprime time */
+ 
+ /*
+  *	limits which may have to be increased if systems get larger
+  */
+ #define SSIZE	1000	/* max number of sessions in 1 acct run */
+ #define TSIZE	100	/* max number of line names in 1 acct run */
+ #define USIZE	500	/* max number of distinct login names in 1 acct run */
+ 
+ #define EQN(s1, s2)	(strncmp(s1, s2, sizeof(s1)) == 0)
+ #define CPYN(s1, s2)	strncpy(s1, s2, sizeof(s1))
+ 
+ #define SECSINDAY	86400L
+ #define SECS(tics)	((double) tics)/HZ
+ #define MINS(secs)	((double) secs)/60
+ #define MINT(tics)	((double) tics)/(60*HZ)
+ 
+ #ifdef pdp11
+ #define KCORE(clicks)	((double) clicks/16)
+ #endif
+ #ifdef vax
+ #define KCORE(clicks)	((double) clicks/2)
+ #endif
+ #if u3b || u3b5
+ #define KCORE(clicks)	((double) clicks*2)
+ #endif

------- apollo.c -------
No differences encountered

------- args.c -------
*** /tmp/d02421	Thu Aug  4 14:12:10 1988
--- args.c	Sat Sep 19 17:13:45 1987
***************
*** 27,37 ****
  static char flagadr[12];
  static const char flagchar[] = {
  	'x',	'n',	'v',	't',	's',	'i',	'e',	'r',	'k',
! 	'u', 'f',	'a',	'm',	'h',	'c',	0
  };
  static const optflag flagval[]  = {
   EXECPR,	NOEXEC,	READPR,	ONEFLG, STDFLG,	INTFLG,	ERRFLG,	RSHFLG,	KEYFLG,
! 	NOSET,	NOGLOB,	ALLEXP,	MONITOR, HASHALL, CFLAG, 0
  };
  
  /* ========	option handling	======== */
--- 27,37 ----
  static char flagadr[12];
  static const char flagchar[] = {
  	'x',	'n',	'v',	't',	's',	'i',	'e',	'r',	'k',
! 	'u', 'f',	'a',	'm',	'h',	'c', 'l',	0
  };
  static const optflag flagval[]  = {
   EXECPR,	NOEXEC,	READPR,	ONEFLG, STDFLG,	INTFLG,	ERRFLG,	RSHFLG,	KEYFLG,
! 	NOSET,	NOGLOB,	ALLEXP,	MONITOR, HASHALL, CFLAG, LOGINSH, 0
  };
  
  /* ========	option handling	======== */

------- blok.c -------
No differences encountered

------- brkincr.h -------
*** /tmp/d02427	Thu Aug  4 14:12:12 1988
--- brkincr.h	Sat Sep 19 17:13:45 1987
***************
*** 7,13 ****
   */
  
  #define BRKINCR		0400*sizeof(int)
! #define BRKMAX		0400000
  #define MINTRAP		0
  #define MAXTRAP		NSIG+1
  #define SIGSLOW		1
--- 7,14 ----
   */
  
  #define BRKINCR		0400*sizeof(int)
! /*#define BRKMAX		0400000*/
! #define BRKMAX		(0x400000L)	/* 4 meg */
  #define MINTRAP		0
  #define MAXTRAP		NSIG+1
  #define SIGSLOW		1

------- builtin.c -------
*** /tmp/d02430	Thu Aug  4 14:12:13 1988
--- builtin.c	Mon Sep 21 18:28:35 1987
***************
*** 310,319 ****
  		 set_out(fd);
  		 if(a1 == 0)
  			{
! 			 if(type)
  				 prinscan(fd,0,troot,0);
! 			 else
  				 namscan(printflg,troot);
  			 break;
  			}
  		 if(com[1])
--- 310,321 ----
  		 set_out(fd);
  		 if(a1 == 0)
  			{
! 			 if(type) {
  				 prinscan(fd,0,troot,0);
! 			 } 
! 			 else {
  				 namscan(printflg,troot);
+ 			 }
  			 break;
  			}
  		 if(com[1])
***************
*** 415,422 ****
  					}
  				}
  			}
! 		 else
  			 prinscan(fd,flag&~F_FLAG,troot,aflag=='+');
  		 break;
  		}
  
--- 417,425 ----
  					}
  				}
  			}
! 		 else {
  			 prinscan(fd,flag&~F_FLAG,troot,aflag=='+');
+ 		 }
  		 break;
  		}
  
***************
*** 560,571 ****
  			{
  			 register int 	i;
  			 set_out(standout);
! 			 for(i=0; i<MAXTRAP; i++)
  				 if(trapcom[i])
  					{
  					 prn(i,':');
  					 pstr(trapcom[i],NL);
  					}
  			}
  		break;
  		
--- 563,593 ----
  			{
  			 register int 	i;
  			 set_out(standout);
! 			 for(i=0; i<MAXTRAP; i++) 
! 				{
! #ifdef notdef
! 				/* debug - print their \real/ status */
! 				 int s;
! 				 s = (int)signal(i,SIG_IGN);
! 				 prn(i,':');
! 				 if (s == SIG_IGN) {
! 					pstr("ign",NL);
! 				 }
! 				 else if ( s == SIG_DFL) {
! 					pstr("dfl",NL);
! 				 } 
! 				 else {
! 					pstr("caught", NL);
! 				 }
! 				 signal(i,s);
! #endif
! 
  				 if(trapcom[i])
  					{
  					 prn(i,':');
  					 pstr(trapcom[i],NL);
  					}
+ 				}
  			}
  		break;
  		

------- builtins.h -------
No differences encountered

------- cmd.c -------
*** /tmp/d02436	Thu Aug  4 14:12:15 1988
--- cmd.c	Mon Sep 21 18:28:33 1987
***************
*** 330,335 ****
--- 330,336 ----
  			}
  		 else
  			 ((PROCPTR)t)->procloc = -1;
+ 
  		 cmdptr = cmd(KTSYM,NLFLG);
  		 addblok(-1);
  		 blokptr = stakbsy;
***************
*** 622,631 ****
  				 flag |= EXP_MACRO;
  			 else if((c&QUOTE) || c=='"')
  				 flag |= EXP_TRIM;
! 			 else if(nquote==0 && (c=='*' || c=='?' || c == '['))
  				{
! 				 /* special case of '[' */
! 				 if(*sp || c!='[')
  					 flag |= EXP_FILE;
  				}
  			}
--- 623,635 ----
  				 flag |= EXP_MACRO;
  			 else if((c&QUOTE) || c=='"')
  				 flag |= EXP_TRIM;
! 			 else if(nquote==0 && (c=='*' || c=='?' || c == '[' || c == '{'))
  				{
! 				 /*
! 				  * special case of '[' and '{' 
! 				  * i.e. don't bother if its a '[' or a '{' alone.
! 				  */
! 				 if(*sp || (c!='[' && c!='{'))
  					 flag |= EXP_FILE;
  				}
  			}

------- ctype.c -------
*** /tmp/d02439	Thu Aug  4 14:12:17 1988
--- ctype.c	Sat Sep 19 17:13:47 1987
***************
*** 62,68 ****
  	0,	0,	0,	0,	0,	0,	0,	0,
  
  /*	x	y	z	{	|	}	~	del	*/
! 	0,	0,	0,	0,	_BAR,	0,	0,	0
  };
  
  
--- 62,68 ----
  	0,	0,	0,	0,	0,	0,	0,	0,
  
  /*	x	y	z	{	|	}	~	del	*/
! 	0,	0,	0,	T_EXP,	_BAR,	0,	0,	0
  };
  
  

------- defs.c -------
No differences encountered

------- defs.h -------
*** /tmp/d02445	Thu Aug  4 14:12:19 1988
--- defs.h	Sat Sep 19 17:13:47 1987
***************
*** 134,139 ****
--- 134,142 ----
  #define Noexec	22
  #define Notify	23
  #define Gmacs	24
+ #define Noeof_ever 25
+ #define Fgshort 26
+ #define Loginsh 27
  
  #define FIXFLG	(1<<Fixflg) /* used as state also */
  #define	ERRFLG	(1<<Errflg) /* used as state also */
***************
*** 158,165 ****
  #define	NOEXEC	(1L<<Noexec)
  #define	NOTIFY	(1L<<Notify)
  #define GMACS	(1L<<Gmacs)
  
- 
  /* states */
  /* low numbered states are same as flags */
  #define	PROMPT	INTFLG
--- 161,170 ----
  #define	NOEXEC	(1L<<Noexec)
  #define	NOTIFY	(1L<<Notify)
  #define GMACS	(1L<<Gmacs)
+ #define NOEOF_EVER (1L<<Noeof_ever)
+ #define FGSHORT (1L<<Fgshort)
+ #define LOGINSH (1L<<Loginsh)
  
  /* states */
  /* low numbered states are same as flags */
  #define	PROMPT	INTFLG
***************
*** 231,240 ****
--- 236,247 ----
  extern MSG	longint;
  extern MSG	lowercase;
  extern MSG	logout;
+ extern MSG	leaveshell;
  extern MSG	mailmsg;
  extern MSG	minus;
  extern MSG	noalias;
  extern MSG	nofork;
+ extern MSG	nomatchmsg;
  extern MSG	noquery;
  extern MSG	nosign;
  extern MSG	nospace;

------- edit.c -------
No differences encountered

------- edit.h -------
No differences encountered

------- emacs.c -------
No differences encountered

------- error.c -------
No differences encountered

------- execargs.h -------
No differences encountered

------- expand.c -------
*** /tmp/d02463	Thu Aug  4 14:12:24 1988
--- expand.c	Mon Sep 21 18:28:33 1987
***************
*** 8,13 ****
--- 8,14 ----
   *
   */
  
+ 
  #include	<stdio.h>
  #include	"defs.h"
  #include	<setjmp.h>
***************
*** 25,31 ****
  char *strrchr();
  
  
! /* globals (file name generation)
   *
   * "*" in params matches r.e ".*"
   * "?" in params matches r.e. "."
--- 26,32 ----
  char *strrchr();
  
  
! /* globals (file name generation) and alternation
   *
   * "*" in params matches r.e ".*"
   * "?" in params matches r.e. "."
***************
*** 32,44 ****
   * "[...]" in params matches character class
   * "[...a-z...]" in params matches a through z.
   *
   */
- 
  static VOID	addg();
  
! int expand(as,rflg)
  char *as;
  {
   int 	count;
  #ifdef BSD_4_1c
   DIR 	*dirf;
--- 33,188 ----
   * "[...]" in params matches character class
   * "[...a-z...]" in params matches a through z.
   *
+  * "...{a,b,c}" expands to "...a" "...b" "...c" (alternation).
+  *
   */
  static VOID	addg();
+ static int _count;
+ static int _hadbraces;
+ static int _braceerr;
  
! expand(as,nomatchflg)
  char *as;
  {
+ 	_count = 0;
+ 	_hadbraces = 0;
+ 	_braceerr = 0;
+ 	expand1(as,nomatchflg);
+ 	return(_count);
+ }
+ 
+ expand1(as,nomatchflg)
+ char *as;
+ {
+ 	int count;
+ 
+ 	/*
+ 	 * TODO: not count }'s inside []'s
+ 	 */
+ 	if (rindex(as,'{') && !_braceerr && !eq(as,"{}")) {
+ 		_hadbraces = 1;
+ 		execbrc(as);
+ 	}
+ 	else {
+ 		count = expand0(as,0,nomatchflg);
+ 		if (count == 0 && _hadbraces) {
+ 			/*
+ 			 * add it to gchain anyway,
+ 			 * we're doing alternation.
+ 			 */
+ 			addg("",as,0);
+ 			_count += 1;
+ 		}
+ 		else {
+ 			_count += count;
+ 		}
+ 	}
+ }
+ 
+ /*
+  * {a,b,c} alternation
+  */
+ execbrc(as)
+ char *as;
+ {
+ 	char *s = as;
+ 	char *rb;
+ 	char *restbuf = (char *)locstak();
+ 	char *endbrace;
+ 	char *startelem;
+ 	char *endelem;
+ 	int  brclev = 0;
+ 	char savec;
+ 
+ 
+ 	/*
+ 	 * Find max size of pattern (as) so we can reserve our
+ 	 * space and endstak() now.
+ 	 */
+ 	for (s = as; *s; s++)
+ 		;
+ 	endstak(restbuf + (s-as+1));
+ 
+ 	/*
+ 	 * copy everything up to the brace into restbuf.
+ 	 */
+ 	for (s = as, rb = restbuf; *s && *s != '{'; *rb++ = *s++)
+ 		;
+ 	/*
+ 	 * set endbrace to point at closing brace.
+ 	 */
+ 	for (endbrace = ++s; *endbrace; endbrace++)
+ 	switch (*endbrace) {
+ 	case '{':
+ 		brclev++;
+ 		continue;
+ 	case '}':
+ 		if (brclev == 0)
+ 			goto pend;
+ 		brclev--;
+ 		continue;
+ 	case '[': {	/* chars inside '[]'s don't count */
+ 		char *cp = endbrace;
+ 		for (cp++; *cp && *cp != ']'; cp++)
+ 			;
+ 		if (*cp)
+ 			endbrace = cp;
+ 		continue;
+ 	        }
+ 	}
+ pend:	
+ 	if (*endbrace == '\0') {
+ 		/* brace error - bail out */
+ 		_hadbraces = 0;
+ 		_braceerr = 1;
+ 		expand1(as);
+ 	}
+ 
+ 	brclev = 0;
+ 	/*
+ 	 * for each element in brace, strap it to
+ 	 * restbuf, append everything after endbrace,
+ 	 * and (recursively) call expand with restbuf.
+ 	 */
+ 	for (startelem = endelem = s; endelem <= endbrace; endelem++) 
+ 	switch (*endelem) {
+ 	case '{':
+ 		brclev++;
+ 		continue;
+ 	case '}':
+ 		if (brclev) {
+ 			brclev--; 
+ 			continue;
+ 		}
+ 		goto doit;	
+ 	case ',':
+ 		if (brclev)
+ 			continue;
+ doit:
+ 		savec = *endelem;
+ 		*endelem = '\0';
+ 		strcpy(rb,startelem);
+ 		strcat(rb,endbrace + 1);
+ 		*endelem = savec;
+ 		expand1(restbuf);
+ 		startelem = endelem + 1;
+ 		continue;
+ 	case '[': {
+ 		char *cp = endelem;
+ 		for (cp++; *cp && *cp != ']'; cp++)
+ 			;
+ 		if (*cp)
+ 			endelem = cp;
+ 	        }
+ 		continue;
+ 	}
+ }
+ 	
+ 
+ 
+ int expand0(as,rflg,nomatchflg)
+ char *as;
+ {
   int 	count;
  #ifdef BSD_4_1c
   DIR 	*dirf;
***************
*** 49,55 ****
   char *rescan = 0;
   register char *s, *cs;
   ARGPTR 	schain = gchain;
!  /* this union is forces enough space for the NULL byte */
   union Dirent
  	{
  	 struct direct	entry;
--- 193,199 ----
   char *rescan = 0;
   register char *s, *cs;
   ARGPTR 	schain = gchain;
!  /* this union forces enough space for the NULL byte */
   union Dirent
  	{
  	 struct direct	entry;
***************
*** 84,91 ****
  				{
  				 if (rflg && slash)
  					 break;
! 				 else
  					 return(0);
  				}
  
  			 case '/':
--- 228,236 ----
  				{
  				 if (rflg && slash)
  					 break;
! 				 else {
  					 return(0);
+ 				 }
  				}
  
  			 case '/':
***************
*** 193,199 ****
  			 count=0;
  			 while(rchain)
  				{
! 				 count += expand(rchain->argval,1);
  				 rchain=rchain->argchn;
  				}
  			}
--- 338,345 ----
  			 count=0;
  			 while(rchain)
  				{
! 				 /*don't complain about nomatch on a recursive expand*/
! 				 count += expand0(rchain->argval,1,0);
  				 rchain=rchain->argchn;
  				}
  			}
***************
*** 206,211 ****
--- 352,359 ----
  	  while(c = *s)
  		  *s++=(c&STRIP?c:'/');
  	}
+  if (count==0 && !rflg && nomatchflg && is_option(NOMATCH))
+ 	failed(as, nomatchmsg);
   return(count);
  }
  
***************
*** 299,303 ****
   if(suffix)
  	 cp =  movstr(suffix,cp);
   endstak(cp);
!  return(expand(dp,0));
  }
--- 447,465 ----
   if(suffix)
  	 cp =  movstr(suffix,cp);
   endstak(cp);
!  return(expand(dp,0,0));
  }
+ 
+ #ifdef notdef
+ int debug = 1;
+ #include "io.h"
+ dprint(fmt,a1,a2,a3,a4,a5,a6,a7)
+ char *fmt;
+ {
+ 	char temp[1024];
+ 	if (!debug)
+ 		return;
+ 	sprintf(temp,fmt,a1,a2,a3,a4,a5,a6,a7);
+ 	fputs(temp,output);
+ }
+ #endif

------- fault.c -------
*** /tmp/d02466	Thu Aug  4 14:12:26 1988
--- fault.c	Mon Sep 21 18:28:33 1987
***************
*** 28,71 ****
   * SIGCAUGHT signals trap to fault, others to done
   */
  static char trapflg[MAXTRAP]= {
! 					SIGIGNORE, /* 0 */
! 					0,	/* hangup - 1 */
! 					SIGCAUGHT,	/* interrupt */
! 					SIGNOSET|SIGCAUGHT,	/* quit */
! 					SIGNOSET,	/* illegal instr */
! 					SIGNOSET,	/* trace trap */
! 					0,	/* IOT */
! 					0,	/* EMT */
! 					0,	/* float pt. exp */
! 					SIGIGNORE,	/* kill */
! 					0, 	/* bus error */
! 					SIGNOSET,	/* memory faults */
! 					0,	/* bad sys call */
! 					0,	/* bad pipe call */
! 					SIGCAUGHT,	/* alarm */
! 					SIGCAUGHT, 	/* software termination */
! 					0,	/* unassigned */
  #ifdef BSD
! 					SIGNOSET,	/* sendable stop signal not from tty */
! 					SIGNOSET,	/* stop signal from tty */
! 					SIGNOSET,	/* continue a stopped process */
! 					SIGNOSET,	/* to parent on child stop or exit */
! 					SIGNOSET,	/* to readers pgrp upon background tty read */
! 					SIGNOSET,	/* like TTIN for output if (tp->t_local&LTOSTOP) */
! 					SIGNOSET,	/* to pgrp on every input character if LINTRUP */
! 					0,	/* exceeded CPU time limit */
! 					0,	/* exceeded file size limit */
  
  #else
! 					0,	/* unassigned */
! 					SIGNOSET,	/* death of child */
! 					SIGNOSET,	/* power fail */
  #endif
! 					SIGNOSET, /* vtarlm */
! 					SIGNOSET, /* profiling */
! 					SIGNOSET /* sigwinch */
  
! 					};
  
  /* ========	fault handling routines	   ======== */
  
--- 28,71 ----
   * SIGCAUGHT signals trap to fault, others to done
   */
  static char trapflg[MAXTRAP]= {
! 		SIGIGNORE, /* 0 */
! 		0,	/* hangup - 1 */
! 		SIGCAUGHT,	/* interrupt */
! 		SIGNOSET|SIGCAUGHT,	/* quit */
! 		SIGNOSET,	/* illegal instr */
! 		SIGNOSET,	/* trace trap */
! 		0,	/* IOT */
! 		0,	/* EMT */
! 		0,	/* float pt. exp */
! 		SIGIGNORE,	/* kill */
! 		0, 	/* bus error */
! 		SIGNOSET,	/* memory faults */
! 		0,	/* bad sys call */
! 		0,	/* bad pipe call */
! 		SIGCAUGHT,	/* alarm */
! 		SIGCAUGHT, 	/* software termination */
! 		0,	/* unassigned */
  #ifdef BSD
! 		SIGNOSET,	/* sendable stop signal not from tty */
! 		SIGNOSET,	/* stop signal from tty */
! 		SIGNOSET,	/* continue a stopped process */
! 		SIGNOSET,	/* to parent on child stop or exit */
! 		SIGNOSET,	/* to readers pgrp upon background tty read */
! 		SIGNOSET,	/* like TTIN for output if (tp->t_local&LTOSTOP) */
! 		SIGNOSET,	/* to pgrp on every input character if LINTRUP */
! 		0,	/* exceeded CPU time limit */
! 		0,	/* exceeded file size limit */
  
  #else
! 		0,	/* unassigned */
! 		SIGNOSET,	/* death of child */
! 		SIGNOSET,	/* power fail */
  #endif
! 		SIGNOSET, /* vtarlm */
! 		SIGNOSET, /* profiling */
! 		SIGNOSET /* sigwinch */
  
! 		};
  
  /* ========	fault handling routines	   ======== */
  
***************
*** 223,228 ****
--- 223,235 ----
  VOID setbrk(incr)
  {
   register BYTPTR a=(char *)(sbrk(incr));
+ #ifdef notdef
+ 	{ 
+ 	 char mess[128];
+ 	 sprintf(mess,"setbrk: incr: %d a: %x\n", incr, a);
+ 	 fputs(mess, output);
+ 	}
+ #endif notdef
   if((int)a == -1)
  	{
  	 error(nospace);
***************
*** 236,242 ****
   if(brkend > brkbegin + BRKMAX)
  	{
  #ifdef DBUG
! 	 int pid = fork();
  	 if(pid==0)
  		{
  		 chdir("/tmp");
--- 243,255 ----
   if(brkend > brkbegin + BRKMAX)
  	{
  #ifdef DBUG
! 	 char debugmsg[128];
! 	 int pid;
! 	 sprintf(debugmsg,"brkbegin: 0x%x brkend: 0x%x end-begin: %d incr: %d\n",
! 		brkbegin, brkend, brkend-brkbegin, incr);
! 	 fputs(debugmsg,output);
! #ifdef notdef
! 	 pid = fork();
  	 if(pid==0)
  		{
  		 chdir("/tmp");
***************
*** 244,251 ****
  		 signal(SIGIOT,0);
  		 abort();
  		}
! #endif
  	 error(nospace);
  	}
! #endif
  }
--- 257,265 ----
  		 signal(SIGIOT,0);
  		 abort();
  		}
! #endif notdef
! #endif DBUG
  	 error(nospace);
  	}
! #endif ! pdp11
  }

------- flags.h -------
No differences encountered

------- history.c -------
No differences encountered

------- io.c -------
No differences encountered

------- io.h -------
No differences encountered

------- jobs.c -------
*** /tmp/d02481	Thu Aug  4 14:12:30 1988
--- jobs.c	Sat Sep 19 17:13:51 1987
***************
*** 190,196 ****
  		 fputs(j_terminate,output);
  		 return(-1);
  		}
! 	 else if(login_sh)
  		{
  		 fputs(j_running,output);
  		 return(-1);
--- 190,196 ----
  		 fputs(j_terminate,output);
  		 return(-1);
  		}
! 	 else if(is_option(LOGINSH))
  		{
  		 fputs(j_running,output);
  		 return(-1);
***************
*** 240,246 ****
  {
   if((states&MONITOR)==0)
  	 return(0);
!  if(beenhere++ == 0 && pwlist && login_sh)
  	{
  	 fputs(j_running,output);
  	 return(-1);
--- 240,246 ----
  {
   if((states&MONITOR)==0)
  	 return(0);
!  if(beenhere++ == 0 && pwlist && is_option(LOGINSH))
  	{
  	 fputs(j_running,output);
  	 return(-1);
***************
*** 605,611 ****
  	 if(pid==0 && *rjob != '0')
  		 failed("kill",kill_usage);
  #ifdef BSD
! 	 if(sig==SIGSTOP && pid==jobstat.mypid && ppid==1)
  		{
  		/* can't stop login shell */
  		 errno = EPERM;
--- 605,611 ----
  	 if(pid==0 && *rjob != '0')
  		 failed("kill",kill_usage);
  #ifdef BSD
! 	 if(sig==SIGSTOP && pid==jobstat.mypid && is_option(LOGINSH))
  		{
  		/* can't stop login shell */
  		 errno = EPERM;

------- ksh -------
Binary files /tmp/d02484 and ksh differ

------- macro.c -------
No differences encountered

------- main.c -------
*** /tmp/d02490	Thu Aug  4 14:12:34 1988
--- main.c	Mon Sep 21 18:33:51 1987
***************
*** 120,131 ****
   if((beenhere++)==0)
  	 /* ? profile */
  	{
! 	 if(ppid==1)
  		 login_sh++;
! 	 if(*((sim=((char *) strrchr(cmdadr,'/'))?sim+1:cmdadr)) == '-')
  		{
  		 /* login shells are interactive */
! 		 flags |= INTFLG;
  		 login_sh +=2;
  #ifdef JOBS
  #ifdef BSD
--- 120,134 ----
   if((beenhere++)==0)
  	 /* ? profile */
  	{
! 	 if(ppid==1) {
  		 login_sh++;
! 		 flags |= LOGINSH;
! 	 }
! 	 if(*((sim=((char *) strrchr(cmdadr,'/'))?sim+1:cmdadr)) == '-'
! 	    || is_option(LOGINSH))
  		{
  		 /* login shells are interactive */
! 		 flags |= INTFLG | LOGINSH;
  		 login_sh +=2;
  #ifdef JOBS
  #ifdef BSD
***************
*** 175,180 ****
--- 178,196 ----
  			 fclose(input);
  			}
  		}
+ #ifdef DEFRC
+ 	 else if((sim=valup(HOMENOD)) && *sim)
+ 		{
+ 		 sim = mactrim(sim); 
+ 		 if((input = pathopen(sim,".kshrc")) != NULL)
+ 			{
+ 			 exfile(rflag);
+ 			 states &= ~TTYFLG;
+ 			 fclose(input);
+ 			}
+ 		}
+ #endif
+ 		 
  	 if(rsflag==0 || rflag==0)
  		 flags |= RSHFLG;
  		/* open input file if specified */
***************
*** 210,218 ****
   TREPTR t;
   register FILE *fp = input;
   register struct fixcmd *fixp;
-  int foo_bye_bye();
  
-  signal(SIGHUP, foo_bye_bye);
  	/* move input */
   if(fisopen(fp) && fileno(fp)!=F_STRING)
  	{
--- 226,232 ----
***************
*** 234,246 ****
   if(is_option(INTFLG) && prof==0 || (is_option(ONEFLG)==0 && isatty(fileno(stderr))
  	    && fp != NULL && isatty(fileno(fp))))
  	{
- /*debug*/ int dump_mjk();
  	 if(fileno(fp)==0)
  		 setbuf(fp,_sibuf);
  	 dfault(PS1NOD, (userid?stdprompt:supprompt));
  	 states |= TTYFLG|PROMPT;
  	 ignsig(SIGTERM);
- /*debug*/ signal(SIGSYS, dump_mjk);
  	 flags |= INTFLG;
  	 if(hist_open(userid)>=0)
  		 flags |= FIXFLG;
--- 248,258 ----
***************
*** 311,317 ****
--- 323,351 ----
  			}
  		 if(fixp)
  			 hist_eof();
+ 
+ 		 /***
+ 		 ** This was an amusing hack. Execute the prompt as the
+ 		 ** command "print -s PS1".  Thus your prompt is subject
+ 		 ** to macro and command substitution, and you can do
+ 		 ** some really oddball things like make the current
+ 		 ** date and time your prompt.  We removed it because we
+ 		 ** feel that this much power in the hands of an untrained
+ 		 ** person could be a dangerous thing for civilization
+ 		 ** and life as we know it.  While it seemed a bit excessive,
+ 		 ** the default case of printing a plain string is really
+ 		 ** not costly since its all builtin.  We fear people
+ 		 ** putting PS1='hostname`make vmunix`': would produce
+ 		 ** costly prompts...
+ 		 **
+ 		 ** { 
+ 		 **   char prompt[128];
+ 		 **  sprintf(prompt,"print -n \"%s\"", valup(PS1NOD));
+ 		 **  execexp(prompt,stderr);
+ 		 ** }
+ 		 ******/
  		 pr_prompt(valup(PS1NOD));
+ 
  		 /* sets timeout for command entry */
  #if TIMEOUT!=0
  		 if(timeout <= 0 || timeout > TIMEOUT)
***************
*** 327,335 ****
  		 if((states&PROMPT) && standin->fstak==0 && ferror(fp)==0) 
  			{
  			 clearerr(fp);
! 			 if(is_option(NOEOF) && login_sh && !ferror(output))
  				{
! 				 pstr(logout,NL);
  				 continue;
  				}
  #ifdef JOBS
--- 361,370 ----
  		 if((states&PROMPT) && standin->fstak==0 && ferror(fp)==0) 
  			{
  			 clearerr(fp);
! 			 if( ((is_option(NOEOF) && is_option(LOGINSH)) || is_option(NOEOF_EVER))
! 				&& !ferror(output))
  				{
! 				 pstr(is_option(LOGINSH)?logout:leaveshell,NL);
  				 continue;
  				}
  #ifdef JOBS
***************
*** 497,509 ****
  #else
   flush_out();
  #endif
- }
- /*debug start*/ dump_mjk() {
- 	chdir("/usr/staff1/koehler/src/ksh/sh");
- 	signal(SIGIOT, SIG_DFL);
- 	system ("sh -c echo ksh core dump at `pwd`|mail -s ksh koehler@decvax");
- 	abort();
- } /*debug end*/
- foo_bye_bye() {
- 	exit(0);
  }
--- 532,535 ----

------- makefile -------
*** /tmp/d02493	Thu Aug  4 14:12:35 1988
--- makefile	Fri Jan  8 23:49:55 1988
***************
*** 33,39 ****
  # JOBLIB = -ljobs
  # The following line is for Indian Hill
  # D = -DSHELL -DIH 
! D = -DSHELL
  CC = cc $D $(DVSH) $(DESH) $(DJOBS) $(DBSD) $(VIRAW) $(DEVFD) $(D4_1c) $(D4_2) 
  CC_CMD = $(CC) $(CFLAGS) -c
  OFILES = builtin.o \
--- 33,39 ----
  # JOBLIB = -ljobs
  # The following line is for Indian Hill
  # D = -DSHELL -DIH 
! D = -DSHELL -DDBUG -DACCT
  CC = cc $D $(DVSH) $(DESH) $(DJOBS) $(DBSD) $(VIRAW) $(DEVFD) $(D4_1c) $(D4_2) 
  CC_CMD = $(CC) $(CFLAGS) -c
  OFILES = builtin.o \
***************
*** 124,130 ****
  	  -chown bin /bin/$(sh)
  
  clean:
! 	  -rm -f *.o
  
  clobber:  clean
  	  -rm -f $(TESTDIR)/$(sh)
--- 124,130 ----
  	  -chown bin /bin/$(sh)
  
  clean:
! 	  -rm -f *.o sh
  
  clobber:  clean
  	  -rm -f $(TESTDIR)/$(sh)

------- makesh -------
*** /tmp/d02496	Thu Aug  4 14:12:36 1988
--- makesh	Fri Jan  8 23:44:25 1988
***************
*** 28,34 ****
  		shift
  		DBSD=-DBSD LFLAGS=-z DJOBS=-DJOBS JOBS=jobs.o
  		D4_1c=-DBSD_4_1c
! 		D4_2="-DBSD_4_2 -I/usr/include/sys";;
  	-*)
  		echo "USAGE: $0 [-m] [-r] [-4.2] [name]"
  		exit 1;;
--- 28,34 ----
  		shift
  		DBSD=-DBSD LFLAGS=-z DJOBS=-DJOBS JOBS=jobs.o
  		D4_1c=-DBSD_4_1c
! 		D4_2="-DBSD_4_2 -I/usr/include -I/usr/include/sys";;
  	-*)
  		echo "USAGE: $0 [-m] [-r] [-4.2] [name]"
  		exit 1;;
***************
*** 46,52 ****
  	then	D4_1c=-DBSD_4_1c JOBLIB="$JOBLIB libc.a"
  	fi
  	if	test -f /etc/gettytab #BSD 4.2
! 	then	D4_2="-DBSD_4_2 -I/usr/include/sys" JOBLIB=
  	fi
  	if	test -d /usr/suntool #sun workstations
  	then	FIXDATA=
--- 46,52 ----
  	then	D4_1c=-DBSD_4_1c JOBLIB="$JOBLIB libc.a"
  	fi
  	if	test -f /etc/gettytab #BSD 4.2
! 	then	D4_2="-DBSD_4_2 -I/usr/include -I/usr/include/sys" JOBLIB=
  	fi
  	if	test -d /usr/suntool #sun workstations
  	then	FIXDATA=

------- mode.h -------
No differences encountered

------- mods.sccs -------
*** /tmp/d02502	Thu Aug  4 14:12:37 1988
--- mods.sccs	Thu Aug  4 13:57:41 1988
***************
*** 0 ****
--- 1,206 ----
+ SCCS/s.jobs.c:
+ 
+ D 1.3	87/09/19 17:12:54	marc	3	2	00001/00001/01202
+ alternation
+ 
+ D 1.2	87/07/02 15:11:11	marcus	2	1	00002/00002/01201
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:52	marcus	1	0	01203/00000/00000
+ date and time created 87/06/30 17:54:52 by marcus
+ 
+ SCCS/s.defs.h:
+ 
+ D 1.2	87/07/02 15:11:06	marcus	2	1	00008/00001/00330
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:43	marcus	1	0	00331/00000/00000
+ date and time created 87/06/30 17:54:43 by marcus
+ 
+ SCCS/s.name.c:
+ 
+ D 1.4	87/09/21 18:28:23	marc	4	3	00000/00003/00824
+ remove some cruft
+ 
+ D 1.3	87/08/06 20:12:33	marc	3	2	00011/00002/00816
+ mods
+ 
+ D 1.2	87/07/02 15:11:20	marcus	2	1	00005/00002/00813
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:56	marcus	1	0	00815/00000/00000
+ date and time created 87/06/30 17:54:56 by marcus
+ 
+ SCCS/s.cmd.c:
+ 
+ D 1.4	87/09/21 18:28:20	marc	4	3	00001/00007/00700
+ remove some cruft
+ 
+ D 1.3	87/09/19 17:12:45	marc	3	2	00006/00003/00701
+ alternation
+ 
+ D 1.2	87/08/06 20:12:29	marc	2	1	00007/00000/00697
+ mods
+ 
+ D 1.1	87/06/30 17:54:41	marcus	1	0	00697/00000/00000
+ date and time created 87/06/30 17:54:41 by marcus
+ 
+ SCCS/s.edit.c:
+ 
+ D 1.1	87/06/30 17:54:44	marcus	1	0	00595/00000/00000
+ date and time created 87/06/30 17:54:44 by marcus
+ 
+ 
+ SCCS/s.fault.c:
+ 
+ D 1.4	87/09/21 18:28:19	marc	4	3	00002/00002/00263
+ remove some cruft
+ 
+ D 1.3	87/09/19 17:12:51	marc	3	2	00015/00001/00250
+ alternation
+ 
+ D 1.2	87/08/06 20:12:31	marc	2	1	00033/00033/00218
+ mods
+ 
+ D 1.1	87/06/30 17:54:48	marcus	1	0	00251/00000/00000
+ date and time created 87/06/30 17:54:48 by marcus
+ 
+ SCCS/s.flags.h:
+ 
+ D 1.1	87/06/30 17:54:49	marcus	1	0	00023/00000/00000
+ date and time created 87/06/30 17:54:49 by marcus
+ 
+ SCCS/s.msg.c:
+ 
+ D 1.2	87/07/02 15:11:18	marcus	2	1	00007/00001/00451
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:55	marcus	1	0	00452/00000/00000
+ date and time created 87/06/30 17:54:55 by marcus
+ 
+ SCCS/s.print.c:
+ 
+ D 1.2	87/07/02 15:11:23	marcus	2	1	00000/00000/00193
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:58	marcus	1	0	00193/00000/00000
+ date and time created 87/06/30 17:54:58 by marcus
+ 
+ SCCS/s.expand.c:
+ 
+ D 1.5	87/09/21 18:28:17	marc	5	4	00000/00000/00465
+ remove some cruft
+ 
+ D 1.4	87/09/21 17:56:56	marc	4	3	00008/00006/00457
+ checkpoint to make tar distribution
+ 
+ D 1.3	87/09/19 17:12:49	marc	3	2	00160/00004/00303
+ alternation
+ 
+ D 1.2	87/07/02 15:11:09	marcus	2	1	00008/00004/00299
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:47	marcus	1	0	00303/00000/00000
+ date and time created 87/06/30 17:54:47 by marcus
+ 
+ SCCS/s.args.c:
+ 
+ D 1.2	87/07/02 15:11:03	marcus	2	1	00002/00002/00277
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:38	marcus	1	0	00279/00000/00000
+ date and time created 87/06/30 17:54:38 by marcus
+ 
+ SCCS/s.builtin.c:
+ 
+ D 1.3	87/09/21 18:28:27	marc	3	2	00001/00000/01374
+ remove some cruft
+ 
+ D 1.2	87/08/06 20:12:25	marc	2	1	00025/00004/01349
+ mods
+ 
+ D 1.1	87/06/30 17:54:39	marcus	1	0	01353/00000/00000
+ date and time created 87/06/30 17:54:39 by marcus
+ 
+ SCCS/s.xec.c:
+ 
+ D 1.4	87/09/21 17:57:00	marc	4	3	00019/00017/00771
+ checkpoint to make tar distribution
+ 
+ D 1.3	87/08/06 20:15:08	marc	3	2	00011/00001/00777
+ mods
+ 
+ D 1.2	87/07/02 15:12:39	marcus	2	1	00020/00001/00758
+ added ignoreanyeof, loginsh, and nomatch options. allow ANY chars for an identifier.
+ 
+ D 1.1	87/06/30 17:55:07	marcus	1	0	00759/00000/00000
+ date and time created 87/06/30 17:55:07 by marcus
+ 
+ SCCS/s.ctype.c:
+ 
+ D 1.2	87/09/19 17:12:47	marc	2	1	00001/00001/00116
+ alternation
+ 
+ D 1.1	87/06/30 17:54:42	marcus	1	0	00117/00000/00000
+ date and time created 87/06/30 17:54:42 by marcus
+ 
+ SCCS/s.brkincr.h:
+ 
+ D 1.2	87/09/19 17:12:44	marc	2	1	00002/00001/00054
+ alternation
+ 
+ D 1.1	87/06/30 17:54:39	marcus	1	0	00055/00000/00000
+ date and time created 87/06/30 17:54:39 by marcus
+ 
+ SCCS/s.makesh:
+ 
+ D 1.2	87/09/19 17:12:42	marc	2	1	00002/00002/00079
+ alternation
+ 
+ D 1.1	87/06/30 17:54:36	marcus	1	0	00081/00000/00000
+ date and time created 87/06/30 17:54:36 by marcus
+ 
+ SCCS/s.makefile:
+ 
+ D 1.3	87/09/19 17:12:40	marc	3	2	00001/00001/00364
+ alternation
+ 
+ D 1.2	87/08/06 20:12:24	marc	2	1	00001/00001/00364
+ mods
+ 
+ D 1.1	87/06/30 17:54:35	marcus	1	0	00365/00000/00000
+ date and time created 87/06/30 17:54:35 by marcus
+ 
+ SCCS/s.main.c:
+ 
+ D 1.5	87/09/21 18:33:50	marc	5	4	00001/00000/00534
+ left out a brace when removing previous cruft
+ 
+ D 1.4	87/09/21 18:28:12	marc	4	3	00018/00040/00516
+ remove some cruft
+ 
+ D 1.3	87/08/06 20:15:06	marc	3	2	00035/00002/00521
+ mods
+ 
+ D 1.2	87/07/02 15:11:15	marcus	2	1	00021/00007/00502
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:54	marcus	1	0	00509/00000/00000
+ date and time created 87/06/30 17:54:54 by marcus
+ 
+ SCCS/s.service.c:
+ 
+ D 1.5	87/09/21 18:28:14	marc	5	4	00001/00004/00948
+ remove some cruft
+ 
+ D 1.4	87/09/21 17:56:58	marc	4	3	00005/00001/00947
+ checkpoint to make tar distribution
+ 
+ D 1.3	87/09/19 17:13:00	marc	3	2	00003/00000/00945
+ alternation
+ 
+ D 1.2	87/07/02 15:11:24	marcus	2	1	00008/00009/00937
+ Added nomatch, ignoreanyeof, and loginsh options.  Also, 
+ 
+ D 1.1	87/06/30 17:54:59	marcus	1	0	00946/00000/00000
+ date and time created 87/06/30 17:54:59 by marcus

------- msg.c -------
*** /tmp/d02505	Thu Aug  4 14:12:39 1988
--- msg.c	Sat Sep 19 17:13:53 1987
***************
*** 44,49 ****
--- 44,50 ----
  const MSG	noswap		= "cannot fork: no swap space";
  const MSG	piperr		= "cannot make pipe";
  const MSG	logout		= "Use 'exit' to logout";
+ const MSG	leaveshell	= "Use 'exit' to leave shell";
  const MSG	badopen		= "cannot open";
  const MSG	coredump	= " - core dumped";
  const MSG	ptrace		= "ptrace: ";
***************
*** 76,81 ****
--- 77,83 ----
  const MSG	subscript	= "subscript out of range";
  const MSG	argcount	= "bad argument count";
  const MSG	fn_hdr		= "\t{\n\t";
+ const MSG	nomatchmsg	= "no matching filename";
  #ifdef VSH
  const MSG	big_vi		= "fc -e \"${VISUAL:-${EDITOR:-vi}}\" ";
  #endif
***************
*** 359,365 ****
  	{"emacs",		Emacs},
  	{"gmacs",		Gmacs},
  #endif
! 	{"ignoreeof",		Noeof},
  	{"interactive",		Intflg},
  	{"keyword",		Keyflg},
  #ifdef JOBS
--- 361,369 ----
  	{"emacs",		Emacs},
  	{"gmacs",		Gmacs},
  #endif
! 	{"fgshorthand",		Fgshort}, /* recognize %jobname like csh does */
! 	{"ignoreeof",		Noeof},  /* don't exit login shell on ^D */
! 	{"ignoreanyeof",	Noeof_ever},  /* don't exit ANY shell on ^D */
  	{"interactive",		Intflg},
  	{"keyword",		Keyflg},
  #ifdef JOBS
***************
*** 367,372 ****
--- 371,377 ----
  #endif
  	{"noglob",		Noglob},
  	{"noexec",		Noexec},
+ 	{"nomatch",		Nomatch},
  	{"nounset",		Noset},
  	{"restricted",		Rshflg},
  	{"trackall",		Hashall},
***************
*** 376,381 ****
--- 381,387 ----
  	{"viraw",		Viraw},
  #endif
  	{"xtrace",		Execpr},
+ 	{"loginsh",		Loginsh},
  	{0,			0},
  };
  

------- name.c -------
*** /tmp/d02508	Thu Aug  4 14:12:40 1988
--- name.c	Mon Sep 21 18:28:35 1987
***************
*** 154,160 ****
  		{
  		 argscan++;
  		}
! 	 while(isalnum(*argscan));
   	/* check for subscript*/
  	 if(*argscan=='[')
  		{
--- 154,162 ----
  		{
  		 argscan++;
  		}
! 	 /* trying something potentially dangerous */
! 	 /*while(isalnum(*argscan));*/
! 	 while(*argscan && *argscan!='=');  /* mike says allow anything  - i agree */
   	/* check for subscript*/
  	 if(*argscan=='[')
  		{
***************
*** 161,168 ****
  		 while(*++argscan && *argscan!= ']');
  		 argscan++;
  		}
! 	 if((sep = *argscan) && sep!='=')
  		 failed(argi,notid);
  	 *argscan = 0;
  	 if(xp&N_FLAG)
  		{
--- 163,171 ----
  		 while(*++argscan && *argscan!= ']');
  		 argscan++;
  		}
! 	 if((sep = *argscan) && sep!='=') {
  		 failed(argi,notid);
+ 	 }
  	 *argscan = 0;
  	 if(xp&N_FLAG)
  		{
***************
*** 383,391 ****
   if(is_function(n))
  	{
  	 fputs(n->namid,fd);
  	 if(n->namsz>=0)
  		{
! 		 fputs(fn_hdr,fd);
  		 list_hist(n->namsz,EOF,"\n\t");
  		}
  	 else
--- 386,400 ----
   if(is_function(n))
  	{
  	 fputs(n->namid,fd);
+ 	 /*
+ 	  *  This prints the value of the function from the history list.
+ 	  *  - also - it is broken (at the time of this writing) for
+ 	  *  functions which don't get put on the history list.
+ 	  *  I.e.  "$ . rcfile".  
+ 	  */
  	 if(n->namsz>=0)
  		{
! 		 fputs(fn_hdr,fd);   /* prints "\t{\n\t */
  		 list_hist(n->namsz,EOF,"\n\t");
  		}
  	 else

------- name.h -------
No differences encountered

------- print.c -------
No differences encountered

------- proc.h -------
No differences encountered

------- service.c -------
*** /tmp/d02520	Thu Aug  4 14:12:44 1988
--- service.c	Sat Jan  9 00:54:14 1988
***************
*** 36,41 ****
--- 36,42 ----
  char	*mactrim();
  char	*strrchr();
  char	*movstr();
+ char	*simple();
  DOLPTR	newargs();
  STKPTR	endstak();
  STKPTR	cpystak();
***************
*** 632,637 ****
--- 633,641 ----
   return(t);
  }
  
+ /*
+  * sort the gchain.
+  */
  char **scan(argn)
  int 	argn;
  {
***************
*** 648,655 ****
  		 trim(*comargn);
  	 if((argp=argp->argchn)==0 || (argp->argflag.make))
  		{
! 		 if((n=comargm-comargn)>1)
  			 gsort(comargn,n);
  		 comargm = comargn;
  		}
  	}
--- 652,660 ----
  		 trim(*comargn);
  	 if((argp=argp->argchn)==0 || (argp->argflag.make))
  		{
! 		 if((n=comargm-comargn)>1) {
  			 gsort(comargn,n);
+ 		 }
  		 comargm = comargn;
  		}
  	}
***************
*** 729,735 ****
  				 ap = macro(ap);
  			 if(count==0 &&  eq(ap,bset))
  				 setflg++;
! 			 count += split(ap,argp->argflag.raw,setflg);
  			}
  		 else
  			{
--- 734,740 ----
  				 ap = macro(ap);
  			 if(count==0 &&  eq(ap,bset))
  				 setflg++;
! 			 count += split(ap,argp->argflag.raw,setflg,argp->argflag.exp);
  			}
  		 else
  			{
***************
*** 747,753 ****
   return(count);
  }
  
! static int split(s,eflag,setflg) /* blank interpretation routine */
  char *s;
  unsigned eflag;	/* if set then treat blanks tabs and newlines as quoted */
  {
--- 752,758 ----
   return(count);
  }
  
! static int split(s,eflag,setflg,expandflag) /* blank interpretation routine */
  char *s;
  unsigned eflag;	/* if set then treat blanks tabs and newlines as quoted */
  {
***************
*** 755,766 ****
   register int 	c;
   register ARGPTR ap;
   int 	count=0;
!  int expflag = (eflag==0 && is_option(NOGLOB)==0);
   char *seps = (setflg?valup(IFSNOD):NULL);
   if(seps==NULL)
  	 seps = sptbnl;
!  while(1)
! 	{
  	 if(trapnote&SIGSET)
  		 exitsh(SIGFAIL);
  	 ap = (ARGPTR)locstak();
--- 760,770 ----
   register int 	c;
   register ARGPTR ap;
   int 	count=0;
!  int expflag = (expandflag && is_option(NOGLOB)==0);
   char *seps = (setflg?valup(IFSNOD):NULL);
   if(seps==NULL)
  	 seps = sptbnl;
!  while(1) {
  	 if(trapnote&SIGSET)
  		 exitsh(SIGFAIL);
  	 ap = (ARGPTR)locstak();
***************
*** 786,799 ****
  	 ap->argflag.argsize = argp-ap->argval;
  	 ap->argflag.raw = 0;
  	 ap->argflag.make = 0;
! 	 if(expflag && (c=expand(ap->argval,0)))
  		 count += c;
! 	 else
! 		{
  		 count++;
  		 ap->argchn= gchain;
  		 gchain = ap;
! 		}
  	 gchain->argflag.make = 1;
  	}
  }
--- 790,803 ----
  	 ap->argflag.argsize = argp-ap->argval;
  	 ap->argflag.raw = 0;
  	 ap->argflag.make = 0;
! 	 if(expflag && (c=expand(ap->argval,0,1))) {
  		 count += c;
! 	 }
! 	 else {
  		 count++;
  		 ap->argchn= gchain;
  		 gchain = ap;
! 	 }
  	 gchain->argflag.make = 1;
  	}
  }
***************
*** 855,861 ****
  
  #ifdef ACCT
  #include	<sys/types.h>
! #include "/usr/src/cmd/acct/acctdef.h"
  #include <sys/acct.h>
  #include <sys/times.h>
  
--- 859,865 ----
  
  #ifdef ACCT
  #include	<sys/types.h>
! #include "acctdef.h"
  #include <sys/acct.h>
  #include <sys/times.h>
  
***************
*** 874,879 ****
--- 878,884 ----
  VOID initacct()
  {
  
+ 	printf("SETTING ACCTNOD\n");
  	SHACCT = valup(ACCTNOD);
  }
  /*
***************
*** 887,892 ****
--- 892,898 ----
  char	*cmdadr;
  {
   char * strncpy();
+  printf("IN PREACCT\n");
   if(SHACCT)
  	{
   	 sabuf.ac_btime = time((long *)0);
***************
*** 896,903 ****
--- 902,920 ----
  	 strncpy(sabuf.ac_comm, (char*)simple(cmdadr),
  	 	sizeof(sabuf.ac_comm));
  	 shaccton = 1;
+ 	 printf("SET SHACCTON to 1\n");
  	}
  }
+ 
+ char *
+ simple(s)
+ 	char *s;
+ {
+ 	char *cp = rindex(s);
+ 
+ 	return(cp == 0 ? s : cp + 1);
+ }
+ 
  #include <fcntl.h>
  VOID	doacct()
  {
***************
*** 904,909 ****
--- 921,927 ----
  int	fd;
  long	after;
  
+ printf("ABOUT >TO WRITE RECORD\n");
  if(shaccton)
  	{
  	 after = times(&buffer);
***************
*** 912,917 ****
--- 930,936 ----
  	 sabuf.ac_etime = compress( after - before);
  	 fd = open( SHACCT , O_WRONLY | O_APPEND | O_CREAT,0666);
  	 (void)write(fd, &sabuf, sizeof( sabuf ));
+ 	printf("WROTE RECORD\n");
  	 close( fd);
  	}
  }

------- shtype.h -------
No differences encountered

------- stak.c -------
No differences encountered

------- stak.h -------
No differences encountered

------- sym.h -------
No differences encountered

------- test -------
Binary files /tmp/d02535 and test differ

------- test.c -------
No differences encountered

------- test.h -------
No differences encountered

------- testbrk -------
Binary files /tmp/d02544 and testbrk differ

------- testbrk.c -------
*** /tmp/d02547	Thu Aug  4 14:12:51 1988
--- testbrk.c	Fri Sep 11 01:31:14 1987
***************
*** 0 ****
--- 1,38 ----
+ /*
+  *	testbrk.c - 
+  *
+  *	Created: Fri Sep 11 01:27:32 PDT 1987
+  */
+ 
+ #include <stdio.h>
+ 
+ #define USAGE "usage: %s\\n"
+ 
+ char *cmdname;
+ 
+ main(argc,argv)
+ char *argv[];
+ {
+ 	char *cp;
+ 	char *sbrk();
+ 	cmdname = argv[0];
+ 
+ 	/* main */
+ 	cp = sbrk(4096);
+ 	printf("sbrk(4096) -> %d\n", cp);
+ 	cp = sbrk(4096);
+ 	printf("sbrk(4096) -> %d\n", cp);
+ 	cp = sbrk(4096);
+ 	printf("sbrk(4096) -> %d\n", cp);
+ 	cp = sbrk(0);
+ 	printf("sbrk(0) -> %d\n", cp);
+ 	cp = sbrk(-4096);
+ 	printf("sbrk(-4096) -> %d\n", cp);
+ 	cp = sbrk(0);
+ 	printf("sbrk(0) -> %d\n", cp);
+ }
+ 
+ usage() {
+ 	fprintf(stderr, USAGE, cmdname);
+ 	exit(-1);
+ }

------- timeout.h -------
No differences encountered

------- vi.c -------
No differences encountered

------- word.c -------
No differences encountered

------- xec.c -------
*** /tmp/d02559	Thu Aug  4 14:12:56 1988
--- xec.c	Sat Jan  9 00:34:02 1988
***************
*** 99,106 ****
  			 else
  				{
  				 gchain=0;
! 				 argn = getarg((COMPTR)t,0);
! 				 com=scan(argn);
  				 trim(a1=com[0]);
  				}
  			 if(trapnote&SIGSET)
--- 99,134 ----
  			 else
  				{
  				 gchain=0;
! 				 if(internal==TYPESET) 
! 				       {
! 					ARGPTR arg;
! 					/* bug workaround -  typset command
! 					 * takes name=value pairs which 
! 					 * shouldn't be subject to file expansion.
! 					 * The subscript brakets "[]" 
! 					 * are also file expansion meta-characters.
! 					 * Bug is that typeset args with []'s were
! 					 * being subject to file expansion, but this
! 					 * generally goes unnoticed unless there is
! 					 * a multinumbered array index, which happens
! 					 * to match a file during globing.  Now with
! 					 * the noglob option, this bug is easily noticed
! 					 * because it is an error not to match a file.
! 					 * Workaround is to walk the arglist and turn off
! 					 * argflag.exp for the typeset command args. 
! 					 * A better fix will take some more thought
! 					 * and time i don't currently have.
! 					 */
! 					 arg=((COMPTR)t)->comarg;
! 					 while(arg)
! 						{
! 						 arg->argflag.exp = 0;
! 						 arg=arg->argnxt;
! 						}
! 				       }
! 				 /* generate argument list */
! 				 argn = getarg((COMPTR)t,0); 
! 				 com=scan(argn); /* scan also sorts */
  				 trim(a1=com[0]);
  				}
  			 if(trapnote&SIGSET)
***************
*** 671,676 ****
--- 699,710 ----
  
  		 case TTIME:
  			{
+ #ifdef notdef
+ 			get current time of day
+ 
+ 
+ 
+ #else
  			 /* time the command */
  			 struct tms before,after;
  			 long bt,at;
***************
*** 687,693 ****
  			 at +=  ((TIC_SEC*((long)(ta.millitm-tb.millitm)))/1000);
  #else
  			 at -= bt;
! #endif
  			 set_out(stderr);
  			 pstr(t_real,'\t');
  			 prt(at,NL);
--- 721,727 ----
  			 at +=  ((TIC_SEC*((long)(ta.millitm-tb.millitm)))/1000);
  #else
  			 at -= bt;
! #endif BSD
  			 set_out(stderr);
  			 pstr(t_real,'\t');
  			 prt(at,NL);
***************
*** 699,704 ****
--- 733,739 ----
  			 at = after.tms_stime - before.tms_stime;
  			 at += after.tms_cstime - before.tms_cstime;
  			 prt(at,NL);
+ #endif BSD
  			 break;
  			}
  
***************
*** 706,713 ****
  			{
  			 register NAMPTR np;
  			 char *fname = ((PROCPTR)t)->procnam;
! 			 if(!isalpha(*fname))
! 				 failed(fname,notid);
  #ifdef JOBS
  			 states |= NONSTOP;
  #endif
--- 741,750 ----
  			{
  			 register NAMPTR np;
  			 char *fname = ((PROCPTR)t)->procnam;
! 			 /* - allow anything - marc
! 			  * if(!isalpha(*fname))
! 			  *	 failed(fname,notid);
! 			  */
  #ifdef JOBS
  			 states |= NONSTOP;
  #endif
***************
*** 715,721 ****
  			 if(np->value.namval.ip)
  				 free(np->value.namval.cp);
  			 np->value.namval.ip = (int*)((PROCPTR)t)->proctre;
! 			 np->namsz = ((PROCPTR)t)->procloc;
  			 sattrib(np,L_FLAG|INT_GER);
  			 break;
  			}
--- 752,759 ----
  			 if(np->value.namval.ip)
  				 free(np->value.namval.cp);
  			 np->value.namval.ip = (int*)((PROCPTR)t)->proctre;
! 			 np->namsz = ((PROCPTR)t)->procloc; 
! 
  			 sattrib(np,L_FLAG|INT_GER);
  			 break;
  			}
