/*

 *      Copyright (c) 1984, 1985 AT&T
 *      All Rights Reserved

 *      THIS IS UNPUBLISHED PROPRIETARY SOURCE 
 *      CODE OF AT&T.
 *      The copyright notice above does not 
 *      evidence any actual or intended
 *      publication of such source code.

 */
/*
 * G. S. Fowler
 * AT&T Bell Laboratories
 */

/*
 * new->old makefile converter -- second pass
 * the first pass is "make -o"
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <ctype.h>
#include <stdio.h>
#include <generic.h>
#include <hash.h>

#if !lint
static char	stamp[] = "@(#)mkold2 (AT&T Bell Laboratories) 08/30/85a";
#endif

#define DELETE	(char*)0	/* delete path component in edit()	*/
#define KEEP	(char*)1	/* keep path component in edit()	*/

#define MAXBUF	4096		/* maximum work buffer size		*/
#define MAXLEV	256		/* maximum dependency nesting		*/
#define MAXNAME	1024		/* maximum file name component length	*/
#define MAXLINE	72		/* maximum dependency output line size	*/

#define allocate(x)	(x*)calloc(1,sizeof(x))
#define copy(x)		strcpy(malloc((unsigned)(strlen(x)+1)),x)
#define getrule(name)	(struct ruleinfo*)gethash(rultab,(name))
#define putrule(name,r)	puthash(rultab,(name),(GENERIC)(r))

struct ruleinfo				/* rule info			*/
{
	char		*name;		/* rule name			*/
	struct list	*dependencies;	/* dependency list		*/
	struct list	*lastdep;	/* last of dependencies		*/
	char		*commands;	/* update commands		*/
	char		*symdir;	/* symbolic directory name	*/
	char		*dirval;	/* directory symbol value	*/
	int		symdirz;	/* length of name if symdir	*/
	unsigned int	absolute:1;	/* name with absolute path	*/
	unsigned int	archive:1;	/* is an archive target		*/
	unsigned int	listdep:1;	/* listed as : dependency	*/
	unsigned int	listtarg:1;	/* listed as : target		*/
	unsigned int	source:1;	/* must exist before first make	*/
};

struct envinfo				/* environment directory name	*/
{
	char		*name;		/* symbol name			*/
	char		*value;		/* symbol value			*/
	int		length;		/* value length			*/
	unsigned int	used:1;		/* value used			*/
};

union info				/* generic list access		*/
{
	struct ruleinfo	*rule;
	struct envinfo	*envdir;
	char		*string;
	GENERIC		generic;
};

struct list				/* generic list			*/
{
	struct list	*next;		/* next in list			*/
	union info	item;		/* list item			*/
};

#define NIL	(struct list*)0

static int		debug;
static int		line;
static int		linetoken;
static int		ndirs;

static struct list	*dirs;
static struct list	*omitdirs;

static TABLE		rultab;

char			*edit();
char			*gettok();

int			strmatch();

long			settok();

struct list		*cons();

struct ruleinfo		*makerule();

extern int		strlen();
extern int		strncmp();

extern char		*calloc();
extern char		*gets();
extern char		*malloc();
extern char		*strcat();
extern char		*strcpy();

/*ARGSUSED*/
main(argc, argv)
int	argc;
char	**argv;
{
	register char			*s;
	register struct ruleinfo	*r;
	register struct list		*p;
	char				buf[MAXBUF];

	while (*++argv && **argv == '-')
	{
		while (*++*argv) switch(**argv)
		{
		case 'd':
			debug--;
			break;
		case 'x':
			if (!*(s = *argv + 1))
			{
				if (!*(argv + 1)) error(1, "-x option requires an argument");
				else s = *++argv;
			}
			if (*s)
			{
				(void)strcpy(buf, s);
				(void)strcat(buf, "*");
				omitdirs = cons((GENERIC)copy(buf), omitdirs);
			}
			*argv = "-";
			break;
		default:
			error(1, "unknown option `%c'", **argv);
			break;
		}
	}

	/*
	 * initialize
	 */

	omitdirs = cons((GENERIC)"/usr/include*", omitdirs);
	omitdirs = cons((GENERIC)"/", omitdirs);
	rultab = mkhash(511, HASH_ALLOCATE, (GENERIC)0, (GENERIC)0, (GENERIC)0, "rules");

	/*
	 * scan, collect and dump
	 */

	printf("# makefile generated by mkold\n");
	r = makerule("");
	scan(r);
	symdirs();
	for (p = r->dependencies; p; p = p->next)
		dump(p->item.rule);
	exit(0);
	/*NOTREACHED*/
}

/*
 * scan the intermediate data from the first pass
 */

scan(root)
struct ruleinfo	*root;
{
	register char			*s;
	register struct list		*p;
	int				level;
	char				buf[MAXBUF];
	struct ruleinfo			*rulstack[MAXLEV];

	level = line = 0;
	rulstack[0] = root;
	while (gets(buf))
	{
		line++;
		if (*buf == '#') continue;
		s = buf;
		collectdirs(buf);
		if (!strncmp(s, "setv ", 5)) printf("%s\n", s + 5);
		else if (!strncmp(s, "make ", 5))
		{
			p = allocate(struct list);
			if (rulstack[level]->lastdep) rulstack[level]->lastdep->next = p;
			else rulstack[level]->dependencies = p;
			rulstack[level]->lastdep = p;
			level++;
			p->item.rule = rulstack[level] = makerule(s + 5);
		}
		else if (!level) error(1, "missing make line");
		else if (!strncmp(s, "arch ", 5))
		{
			if (getrule(s + 5) != rulstack[level]) error(1, "invalid archive `%s'", rulstack[level]->name);
			else rulstack[level]->archive = 1;
		}
		else if (!strncmp(s, "file ", 5))
		{
			if (getrule(s + 5) != rulstack[level]) error(1, "invalid file `%s'", rulstack[level]->name);
			else rulstack[level]->source = 1;
		}
		else if (!strncmp(s, "exec ", 5))
		{
			rulstack[level]->commands = copy(s + 5);
		}
		else if (!strncmp(s, "done ", 5))
		{
			if (getrule(s + 5) != rulstack[level]) error(1, "invalid done `%s'", rulstack[level]->name);
			else level--;
		}
		else error(1, "%s: unknown input from pass1", s);
	}
	if (level) error(1, "not enough done lines");
	line = 0;
}

/*
 * generate symbol names for collected directories
 */

symdirs()
{
	register struct list	*p;
	char			buf[MAXBUF];

	if (dirs)
	{
		putchar('\n');
		commondirs();
		if (ndirs)
		{
			ndirs = 0;
			putchar('\n');
		}
		for (p = dirs; p; p = p->next)
		{
			sprintf(buf, "$(DIR.%02d)", ndirs);
			p->item.rule->symdir = copy(buf);
			p->item.rule->symdirz = strlen(p->item.rule->name);
			printf("DIR.%02d = %s\n", ndirs, p->item.rule->dirval ? p->item.rule->dirval : p->item.rule->name);
			ndirs++;
		}
	}
}

/*
 * dump the rules
 */

dump(r)
register struct ruleinfo	*r;
{
	register int		col;
	register struct list	*p;

	if (!r->listtarg && ((!r->source && r->dependencies) || r->commands))
	{
		clrdeps(r);
		r->listtarg = 1;
		r->listdep = 1;
		putchar('\n');
		col = dumpname(1, r->name);
		col = dumpstring(col, ":");
		for (p = r->dependencies; p; p = p->next)
			if (!p->item.rule->listdep)
			{
				clrdeps(p->item.rule);
				col = dumpdeps(col, p->item.rule);
			}
		putchar('\n');
		dumpcommand(r->commands);
		for (p = r->dependencies; p; p = p->next)
			if (p->item.rule != r)
				dump(p->item.rule);
	}
}

/*
 * dump the (source) dependencies for r
 */

dumpdeps(col, r)
register int			col;
register struct ruleinfo	*r;
{
	register struct list	*p;

	if (!r->listdep)
	{
		r->listdep = 1;
		for (p = omitdirs; p; p = p->next)
			if (strmatch(r->name, p->item.string))
				return(col);
		col = dumpname(col, r->name);
		if (r->source)
			for (p = r->dependencies; p; p = p->next)
				col = dumpdeps(col, p->item.rule);
	}
	return(col);
}

/*
 * dump a rule name, converting ".NAME" to "name"
 */

dumpname(col, s)
int		col;
register char	*s;
{
	register char		*t;
	register struct list	*p;
	char			*o;
	char			buf1[MAXNAME], buf2[MAXNAME];

	if (*s == '.' && isupper(*(s + 1)))
	{
		o = s;
		t = buf1;
		while (*++s)
		{
			if (isupper(*s)) *t++ = tolower(*s);
			else if (isdigit(*s)) *t++ = *s;
			else break;
		}
		if (*s) s = o;
		else
		{
			*t = '\0';
			s = buf1;
		}
	}
	if (*s == '/')
	{
		for (p = dirs; p; p = p->next)
			if (!strncmp(s, p->item.rule->name, p->item.rule->symdirz))
			{
				sprintf(buf2, "%s%s", p->item.rule->symdir, s + p->item.rule->symdirz);
				s = buf2;
				break;
			}
	}
	return(dumpstring(col, s));
}

/*
 * dump a string keeping track of the right margin
 */

dumpstring(col, s)
int	col;
char	*s;
{
	register int	n;

	n = strlen(s);
	if (col + n >= MAXLINE)
	{
		printf(" \\\n\t\t");
		col = 16;
	}
	else if (col <= 1) col = 1;
	else
	{
		putchar(' ');
		col++;
	}
	col += n;
	printf("%s", s);
	return(col);
}

/*
 * dump a command sequence
 */

dumpcommand(buf)
char	*buf;
{
	register char		*s, *t;
	register struct list	*p;
	long			state;

	if (buf)
	{
		state = settok((long)0);
		putchar('\t');
		while (s = gettok(buf))
		{
			putchar(' ');
			if (t = strchr(s, '/'))
			{
				*t = '\0';
				printf("%s", s);
				*t = '/';
				s = t;
				for (p = dirs; p; p = p->next)
					if (!strncmp(s, p->item.rule->name, p->item.rule->symdirz))
						break;
				if (p)
				{
					printf("%s", p->item.rule->symdir);
					s += p->item.rule->symdirz;
				}
				else
				{
					for (p = omitdirs; p; p = p->next)
						if (strmatch(s, p->item.string))
							break;
					if (p) error(1, "excluded path name %s appears in command", s);
				}
			}
			printf("%s", s);
			if (*s && s[strlen(s) - 1] == ';') printf(" \\\n\t");
		}
		putchar('\n');
		(void)settok(state);
	}
}

/*
 * clear listdep for all dependencies
 */

clrdeps(r)
register struct ruleinfo	*r;
{
	register struct list	*p;

	r->listdep = 0;
	for (p = r->dependencies; p; p = p->next)
		if (p->item.rule->listdep)
			clrdeps(p->item.rule);
}

/*
 * collect absolute directory paths
 */

collectdirs(buf)
char	*buf;
{
	register char			*s;
	register struct ruleinfo	*x;
	register struct list		*p;
	char				*t;
	int				c, e;
	long				state;
	char				tmp[MAXBUF];
	struct stat			st;

	(void)strcpy(tmp, buf);
	state = settok((long)0);
	while (s = gettok(tmp))
	{
		if (s = strchr(s, '/'))
		{
			t = s + strlen(s);
			c = *t;
			while (t > s && ((e = stat(s, &st)) || (st.st_mode & S_IFMT) !=  S_IFDIR))
			{
				*t = c;
				if (e) t--;
				else while (--t > s && *t != '/');
				c = *t;
				*t = '\0';
			}
			if (t > s)
			{
				for (p = omitdirs; p; p = p->next)
					if (strmatch(s, p->item.string))
						break;
				if (!p)
				{
					x = makerule(s);
					if (!x->absolute)
					{
						x->absolute = 1;
						dirs = cons((GENERIC)x, dirs);
					}
				}
			}
			*t = c;
		}
	}
	(void)settok(state);
}

/*
 * identify common directory prefix components
 */

commondirs()
{
	register struct list	*p, *q;
	register int		n;
	register struct envinfo	*e;
	register char		**ep;
	struct ruleinfo		*x;
	struct list		*m;
	char			*t;
	char			pfx[MAXNAME], buf[MAXNAME];
	struct list		*env;

	extern char		**environ;

	/*
	 * search the environment for directory names
	 */

	env = NIL;
	for (ep = environ; *ep; ep++)
	{
		if ((t = strchr(*ep, '=')) && *++t == '/')
		{
			e = allocate(struct envinfo);
			e->name = calloc(t - *ep, sizeof(char));
			(void)strncpy(e->name, *ep, t - *ep - 1);
			e->value = t;
			e->length = strlen(t);
			env = cons(e, env);
		}
	}

	/*
	 * sort the environment directories (dumb reverse-order sort)
	 */

	for (p = env; p; p = p->next)
	{
		m = p;
		for (q = p->next; q; q = q->next)
			if (strcmp(q->item.envdir->name, m->item.envdir->name) > 0)
				m = q;
		if (m != p)
		{
			e = p->item.envdir;
			p->item.envdir = m->item.envdir;
			m->item.envdir = e;
		}
	}

	/*
	 * sort the directories (dumb reverse-order sort)
	 */

	for (p = dirs; p; p = p->next)
	{
		m = p;
		for (q = p->next; q; q = q->next)
			if (strcmp(q->item.rule->name, m->item.rule->name) > 0)
				m = q;
		if (m != p)
		{
			x = p->item.rule;
			p->item.rule = m->item.rule;
			m->item.rule = x;
		}
	}

	/*
	 * now find the common prefices
	 */

	for (p = dirs; p; p = p->next)
	{
		(void)edit(pfx, p->item.rule->name, DELETE, KEEP, DELETE, DELETE, DELETE);
		if ((n = strlen(pfx)) > 1)
		{
			if ((x = getrule(pfx)) && !x->absolute) x = (struct ruleinfo*)0;
			for (q = dirs; q; q = q->next)
				if (q != p && !q->item.rule->dirval && !strncmp(q->item.rule->name, pfx, n))
				{
					if (!x)
					{
						x = makerule(pfx);
						x->absolute = 1;
						sprintf(buf, "$(COM.%02d)", ndirs);
						x->symdir = copy(buf);
						x->symdirz = n;
						printf("COM.%02d = ", ndirs);
						t = x->name;
						for (m = env; m; m = m->next)
							if (!strncmp(t, m->item.envdir->value, m->item.envdir->length))
							{
								printf("$(%s)", m->item.envdir->name);
								t += m->item.envdir->length;
								break;
							}
						printf("%s\n", t);
						if (m && !m->item.envdir->used)
						{
							m->item.envdir->used = 1;
							printf("# %s defined in the environment\n", m->item.envdir->name);
						}
						ndirs++;
					}
					sprintf(buf, "%s%s", x->symdir, q->item.rule->name + n);
					q->item.rule->dirval = copy(buf);
				}
		}
	}
}

/*
 * return old rule pointer if found
 * otherwise make a new rule
 */

struct ruleinfo*
makerule(name)
char	*name;
{
	struct ruleinfo	*r;

	if (!(r = getrule(name)))
	{
		r = allocate(struct ruleinfo);
		r->name = putrule((char*)0, r);
	}
	return(r);
}

/*
 * generic list constructor
 */

struct list*
cons(i, p)
GENERIC		i;
struct list	*p;
{
	register struct list	*q;

	q = allocate(struct list);
	q->next = p;
	q->item.generic = i;
	return(q);
}

#include <errno.h>

extern int	errno;
extern int	sys_nerr;

extern char	*sys_errlist[];

/*
 * error and message formatter
 * lev is the error level
 * lev >= 2 exits
 * lev < 0 is for debug tracing
 */

/*VARARGS2*/
error(lev, fmt, a1, a2, a3, a4, a5, a6, a7, a8)
int	lev;
char	*fmt;
{
	register FILE	*fd;
	int		sys;
	char		*cmd;

	if (lev < debug) return;
	fd = lev ? stderr : stdout;
	cmd = "mkold";
	sys = 0;
	switch (lev)
	{
	case 0:
		/* information */
		break;
	case 1:
		/* warning */
		fprintf(fd, "%s: (warning) ", cmd);
		break;
	case 2:
		/* error */
		fprintf(fd, "%s: ", cmd);
		sys = debug < 0;
		break;
	default:
		/* debug (<0) or internal error */
#if DEBUG
		if (lev > 128 || lev < -128)
		{
			fprintf(fd, "%s: (%s, line %d) ", cmd, (char*)lev, (int)fmt);
			fmt = (char*)a1;
			a1 = a2;
			a2 = a3;
			a3 = a4;
			a4 = a5;
			a5 = a6;
			a6 = a7;
			a7 = a8;
			sys = 1;
			lev = 3;
		}
		else
#endif
		if (lev >= 0)
		{
			fprintf(fd, "%s: (internal %d) ", cmd, lev);
			sys = 1;
		}
		else
		{
			if (debug < -1) fprintf(fd, "%s: (debug %d) ", cmd, -lev);
			else fprintf(fd, "%s: (debug) ", cmd);
		}
		break;
	}
	if (sys && errno > 0 && errno <= sys_nerr && errno != ENOENT && errno != EBADF)
		fprintf(fd, "[%s] ", sys_errlist[errno]);
	if (line) fprintf(fd, "line %d: ", line);
	if (fmt) fprintf(fd, fmt, a1, a2, a3, a4, a5, a6, a7, a8);
	fprintf(fd, "\n");
	fflush(fd);
	errno = 0;
	if (lev >= 2) exit(lev - 1);
}

static union
{
	long			state;
	struct
	{
		unsigned short	index;
		unsigned short	chr;
	} eos;
} token;

/*
 * generate isspace() separated tokens from a string
 * (char*)0 returned when no tokens remain
 *
 * the original string is restored after all tokens are generated
 * settok() allows simultaneous token generators
 */

char*
gettok(string)
char	*string;
{
	register char	*p, *r;
	register int	quote;

	/*
	 * restore string on each call
	 */

	p = string;
	if (token.state)
	{
		if (!token.eos.chr)
		{
			token.state = 0;
			return((char*)0);
		}
		p += token.eos.index;
		*p = token.eos.chr;
	}

	/*
	 * skip leading space
	 */

	while (isspace(*p) && (!linetoken || *p != '\n')) p++;
	if (!*p)
	{
		token.state = 0;
		return((char*)0);
	}

	/*
	 * find the end of this token
	 * "..." and '...' constants are detected inside tokens
	 */

	if (linetoken && *p == '\n') r = p + 1;
	else
	{
		quote = 0;
		for (r = p; *r; r++)
		{
			if (*r == '"' || *r == '\'')
			{
				if (quote == *r) quote = 0;
				else if (!quote) quote = *r;
			}
			else if (isspace(*r) && !quote) break;
		}
	}

	/*
	 * save state so we can restore string on the next call
	 */

	token.eos.index = r - string;
	token.eos.chr = *r;
	*r = '\0';
	return(p);
}

/*
 * save|restore previous gettok() state
 * settok(0) resets to init state
 */

long
settok(new)
long	new;
{
	long	old;

	old = token.state;
	token.state = new;
	return(old);
}

/*
 * edit a single (expanded) file name s into b
 * a pointer to the end of b (after editing) is returned
 *
 * each file component (described above) is modified as follows:
 *
 *	KEEP		component is kept unchanged
 *	DELETE		component is deleted
 *	<string>	component is changed to <string>
 */

char*
edit(b, s, mac, dir, pre, bas, suf)
register char	*b, *s;
char		*mac, *dir, *pre, *bas, *suf;
{
	register char	*p, *q;
	char		*ob;

	if (!*s)
	{
		*b = '\0';
		return(b);
	}
	ob = b;
	q = mac;
	if (q != DELETE && q != KEEP && (!*q || !strcmp(q, "!"))) q = DELETE;
	if (p = strrchr(s, '!'))
	{
		if (q == KEEP) while (s <= p) *b++ = *s++;
		else s = ++p;
	}
	if (q != DELETE && q != KEEP)
	{
		while (*q) *b++ = *q++;
		if (b > ob && *(b-1) != '!') *b++ = '!';
	}
	q = dir;
	if (q != DELETE && q != KEEP && (!*q || !strcmp(q, "."))) q = DELETE;
	if (p = strrchr(s, '/'))
	{
		if (q == KEEP) while (s <= p) *b++ = *s++;
		else s = ++p;
	}
	if (q != DELETE && q != KEEP)
	{
		while (*q) *b++ = *q++;
		if (b > ob && *(b-1) != '/') *b++ = '/';
	}
	q = pre;
	if ((p = strchr(s, '.')) && p < strrchr(s, '.'))
	{
		if (q == KEEP) while (s <= p) *b++ = *s++;
		else s = ++p;
	}
	if (q != DELETE && q != KEEP) while (*q) *b++ = *q++;
	q = bas;

#if DOT_BASE
	/*
	 * treat the name ".xxx" as a base component
	 */ 

	if ((*s == '.' && !(p = strrchr(s + 1, '.'))) || !(p = strrchr(s, '.')))
		p = s + strlen(s);
#else
	/*
	 * treat the name ".xxx" as a suffix component
	 * this is probably the more efficient interpretation
	 * because of the proliferation of .[A-Z]* rules
	 */ 

	if (!(p = strrchr(s, '.'))) p = s + strlen(s);
#endif

	if (q == KEEP) while (s < p) *b++ = *s++;
	else s = p;
	if (q != DELETE && q != KEEP) while (*q) *b++ = *q++;
	q = suf;
	if (*p && q == KEEP) while (*s) *b++ = *s++;
	else if (q != DELETE && q != KEEP) while (*q) *b++ = *q++;
	if (b > ob + 1 && *(b-1) == '/') b--;
	*b = '\0';
	return(b);
}
