


	     Tabs 2.0 Manual: Tools for	Creating Window	Based
			     Electronic	Forms

			    C. Douglas Blewett

			     Kenyon I. Hicks

			 AT&T Information Systems


       1.  IIIInnnnttttrrrroooodddduuuuccccttttiiiioooonnnn

       This paper is a brief introduction and a	user manual for	a
       package called Tabs.  This package can be used to produce
       window based user interfaces for	data processing	facilities.
       Tabs incorporates qualities from	both menu and block mode
       electronic forms	in one unified highly interactive system.
       The interface provided by this package has qualities that
       make it desirable for interfaces	for both novice	(i.e.
       casual) and expert (i.e.	frequent) users.  Currently Tabs is
       available on machines running the UNIX* operating system.

       The electronic forms produced using Tabs	may be conceptual-
       ized as a collection of controlled input	and output areas
       within CRT based	windows.  The input areas or fields may	be
       moved within and	between	windows	while the form is running.
       More than one window may	be used	at a time.  Like fields	the
       windows may also	be moved per the requirements of the appli-
       cation.

       The window based	interface is similar in	function to the
       display manager found in	Teitelman's Programmer's Assis-
       tant[1].	 CRT windows are constructed with a portable vir-
       tual terminal library.  The window based	virtual	terminal
       creates windows as three	dimensional rectangular	objects.
       Windows that are	``closer'' to the user occlude more distant
       windows.	 In this environment windows may be moved to arbi-
       trary spatial positions on the CRT screen and in	depth.	The
       low level virtual terminal is based on the UNIX version of
       EMACS[2]	and the	CURSES/TERMINFO	package[3].

       The following is	a list of concepts included within Tabs:

	  +o Tabs encourages the	use of complete	words for keywords
	    (e.g. -all rather than -a).	 Tabs' builtin abbreviation
	    capability encourages this.

	  +o Tabs allows	for easy recovery from user produced
	    errors.  Input may be edited and re-submitted.


       __________

	 * UNIX	is a Trademark of AT&T Bell Laboratories.




       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T






				  - 2 -



	  +o Help is given only when and	where it is needed.  Help
	    is provided	only when it is	requested by the user.
	    Error messages explain how to get help, but	do not
	    force the user into	troublesome help scenarios.

	  +o The	locus of control is with the end user.	Verifica-
	    tion of fields occurs at the user's	request.  This
	    prevents the display of help messages with every typo-
	    graphic error.

	  +o Users are encouraged to become more	proficient (i.e.,
	    expert users).  With experience, users move	naturally
	    from novice	to expert.  No special variables or flags
	    have to be set to access either novice or expert user
	    features.

	  +o Exception conditions (e.g. help messages) are handled
	    by using the dynamic aspects of Tabs.  Help	messages
	    are	displayed in a separate	``pop up'' window.  Simi-
	    larly, data	not frequently collected from users may	be
	    collected in a window that appears only when needed.

	  +o Forms produced using Tabs are for the most part more
	    dynamic than older ``boiler-plate''	style forms.  Tabs
	    also allows	the application	developer to do	operations
	    that are difficult or impossible to	do with	older mask
	    oriented forms.  For example, Tabs may look	for more
	    than one type of item per field (e.g. a file name or a
	    keyword).

	  +o The	details	of the implementation are kept from the
	    programmer by a fairly complete set	of function and
	    procedure calls.  Simple forms require very	little
	    knowledge to construct.  At	the same time more experi-
	    enced programmers can construct elaborate forms-based
	    applications which allow more detailed algorithmic
	    intervention.

	  +o Tabs takes a very high level approach to forms.  In
	    addition to	simple number and string fields, higher
	    level constructs (e.g. filenames or	environmental vari-
	    ables) are supported.  For example,	Tabs supports
	    scrollable regions and menus as field types.  A scroll-
	    able region	is a field that	may contain many different
	    types of fields in a scrolling window.

	  +o Forms are constructed by calling Tabs procedures or
	    primitives from some interpreted or	compiled language
	    (e.g. C).  Libraries of commonly used fields may be
	    constructed	and maintained using standard software
	    tools.



       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T






				  - 3 -



	  +o Tabs is extensible.	 New field types can be	added by
	    application	developers as they are needed.	Tabs also
	    allows the application developer to	use arbitrary C
	    functions for pre and post processing the fields and
	    for	providing help information.


       2.  TTTThhhheeee UUUUsssseeeerrrr IIIInnnntttteeeerrrrffffaaaacccceeee

       The user	interface can be thought of as having essentially
       two aspects, the	screen display and user	input.	The input
       side of the interface includes normal character input and
       characters that are commands to Tabs.  The screen display
       consists	of collections of field	and printed strings con-
       tained within windows.  The following section describes the
       screen displays and the next section describes user input
       features.

       2.1  _S_a_m_p_l_e__D_i_s_p_l_a_y_s  The interface is maintained via termi-
       nal virtualizing	software.  The environmental variable
       ``TERM''	is used	to determine what type of terminal is being
       used.  The following shell commands set the terminal to be a
       Concept 100 with	eight pages of memory.

	       TERM=c108-8p
	       export TERM

       The virtual terminal software currently supports	50 or more
       popular terminals.  Consult your	local installation for the
       list of supported terminals.

       Appendix	A contains a sample form as it might appear on an
       end user's terminal.  Tabs has all of the commonly used
       features	for input fields and output strings.  Output
       strings can be placed arbitrarily on the	screen and format-
       ted (e.g. centered).  Tabs also provides	facilities to han-
       dle calculated or constructed values as output strings (i.e.
       output only fields).

       Input fields may	include	labels (in four	directions), back-
       ground text, default values, and	special	formats.  Input
       fields may also have auto-tab attributes	(advance when
       full), enter only once, and a host of other form	attributes.
       Mouse and function keys are available for use with complex
       forms.  Section 2.2 has more information	on user	input.

       Appendix	B contains a partially completed form.	The user
       has requested help in the third field.  Help is provided	in
       a separate window.  Help	messages are always displayed in a
       separate	window.	 Simple	error or warning messages are
       displayed on the	last line of the current window	or a window



       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T






				  - 4 -



       chosen by the application developer.

       Help messages have two parts, a text message and	a qualify-
       ing list	or annotation.	The text part is the usual verbose
       type of message that is often used to explain what the input
       field is	about.	The qualifying list is extra information
       that Tabs constructs based on the field type.  For keywords
       the list	is the list of keywords.  For filenames	the list is
       the list	of matching files.  For	environmental variables	the
       list is the list	of variable names.  For	numeric	fields the
       list is the range.  Either or both of these help	message
       parts may be disabled by	the programmer per the requirements
       of the application.

       Tabs is designed	to produce dynamic forms.  The application
       may add,	move, and delete fields	and windows as needed.	A
       dynamic forms approach can greatly streamline end user
       interfaces.  Seldom used	fields don't always have to be
       displayed.  They	can be moved onto the form when	an excep-
       tion condition arises.  Exception conditions can	also be
       handled as separate forms running in a separate ``pop-up''
       window.	Appendix C is an example of this type of ``on-
       demand''	strategy.

       2.2  _C_h_a_r_a_c_t_e_r__D_i_r_e_c_t_i_v_e_s  The input side of the	interface
       includes	normal character input and characters that are com-
       mands to	Tabs.  Normal characters are read by Tabs and sub-
       sequently passed	onto the program as parsed items.  The com-
       mand style characters are termed	character directives.
       Character directives request specific actions from the Tabs
       system.	The action requested may be a request for some
       editing operation within	the field, movement to another
       field, a	request	to have	the current field completed and/or
       verified, or a request for help.	 Special characters used to
       invoke the directives have been chosen from the universe	of
       possible	character sequences.  An attempt has been made to
       make use	of current UNIX	standards (e.g.	ERASE and KILL).
       Some consideration has also been	given to selecting a port-
       able and	reasonable (e.g.  mnemonic) set	for commands not
       currently widely	used in	standard UNIX.	However, the com-
       mand set	can be changed to meet the needs of the	applica-
       tion.

       The following is	the current list of directives.

	  +o ? -	Help request

	    The	help request causes the	help window to be
	    displayed.	Application and	Tabs supplied help messages
	    are	printed	within it.  For	keywords the list of match-
	    ing	keywords is given.  For	filenames the list of



       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T






				  - 5 -



	    matching (i.e. wild	card matches) filenames	will be
	    printed.  For shell	variables the list of matching
	    shell variables is listed.	For numbers the	range and
	    number of digits behind the	decimal	are printed.


	  +o Control-I (TAB) - Validate the field and move to the
	    next field

	    TAB	is the field confirmation character.  This causes
	    the	current	field to be validated and program control
	    to move to the next	field.


	  +o ERASE - Erase the last character in	the field

	    This is the	user specified erase character.	 The last
	    character inserted in the field is deleted.	 The char-
	    acter may be recovered with	the control-O directive.


	  +o KILL - Kill	or Erase the entire field

	    This is the	user specified kill character.	The entire
	    field is erased. The field may be recovered	with the
	    control-O directive.


	  +o EOF	- End of file (usually Control-D)

	    This is the	user specified EOF character.  If EOF capa-
	    bilities for the field have	been enabled with the
	    Set_EOF() procedure, the current list of fields is
	    exited.  This directive is most commonly used to exit
	    from scrollable regions.


	  +o Control-P and the BACK TAB key - Move to the previous
	    field

	    This is the	BACK TAB directive.  If	BACK TAB capabili-
	    ties have been enabled for the field with the
	    Set_Tab_Movement() procedure, control will move to the
	    previous field.


	  +o Control-N -	Move to	the next field

	    This is the	FORWARD	directive.  If FORWARD movement
	    capabilities have been enabled for the field with the
	    Set_Tab_Movement() procedure, control will move to the



       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T






				  - 6 -



	    next field.	 This directive	differs	from the TAB key in
	    that verification may be disabled for FORWARD initiated
	    movement.


	  +o Cursor Pad Key and Mouse - move to a specific field

	    These are different	directives that	may be issued from
	    the	user's terminal.  Tabs currently supports the gen-
	    eric function key types listed below.  The control
	    characters that follow the function	key types are sup-
	    plied for terminals	that have no working function keys
	    and/or touch typists that prefer to	keep their hands on
	    the	main keyboard.

		      ___________________________________
		      |					 |
		      |	  Cursor Movement Directives	 |
		      _|_____________________________________________________________________|
		      |					 |
		      |Function	Key   Control Equivalent |
		      |					 |
		      _|__________________________________|
		      |		    |			 |
		      |HOME	    | Control-A		 |
		      |BOTTOM	    | Control-Z		 |
		      |LEFT ARROW   | Control-T		 |
		      |RIGHT ARROW  | Control-Y		 |
		      |UP ARROW	    | Control-^		 |
		      |DOWN ARROW   | Control-G		 |
		      _||______________||____________________||


	    The	keys control-^,	control-T, control-Y, and control-G
	    are	good for arrow key substitutes.	 They match the
	    compass points on most keyboards.  The other arrow key
	    or cursor pad substitutes are control-A for	HOME and
	    control-Z for BOTTOM.  control-A is	above control-Z	on
	    the	keyboard.

	    Cursor pad and mouse directives have to be enabled with
	    the	Set_Tab_Movement() procedure.  Get_List() performs
	    the	correct	inter-field movement.


	  +o Control-C -	Clear away error messages and the help win-
	    dow

	    Control-C causes the help window and error messages	to


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 7 -



	    be removed from the	display.  This allows the user to
	    have an unobstructed view of the form.


	  +o Control-V -	Verify the screen by refreshing	the display

	    Control-V refreshes	the screen.  This is useful to help
	    the	end user recover from wall and write messages.


	  +o Control-O -	Overlay	erased characters

	    Control-O recovers characters that have been erased
	    from the end of the	field with KILL, ERASE,	and/or
	    control-W.	This implements	a very simple form of over-
	    lay	editing.


	  +o Control-W -	Delete the last	word entered

	    Control-W deletes the last word entered in the field.
	    This is essentially	a character delete for words.


	  +o Control-B -	Beginning of the field

	    Control-B moves the	cursor in the field to the begin-
	    ning of the	field. This allows the end user	to insert
	    characters at the beginning	of the field.  Characters
	    to the right of the	cursor are pushed to the right as
	    new	characters are entered.


	  +o Control-E -	End of the field

	    Control-E moves the	cursor to the end of the field.
	    This allows	the user to resume adding characters to	the
	    end	of the field after some	other editing operation.


	  +o Control-L -	Left in	the field

	    Control-L moves the	cursor left one	character in the
	    field.  This allows	the user to add	characters at any
	    point within the field.  Characters	to the right of	the
	    cursor are pushed to the right as new characters are
	    entered.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 8 -



	  +o Control-R -	Right in the field

	    Control-R moves the	cursor right one character in the
	    field.  This allows	the user to add	characters at any
	    point within the field.  Characters	to the right of	the
	    cursor are pushed to the right as new characters are
	    entered.


	  +o Control-[ (ESCAPE) - Completion request

	    ESCAPE is the completion request key.  This	causes file
	    names, decimal numbers, shell variables, and keywords
	    to be expanded.  In	fields where auto advance has been
	    set	(see Set_Auto_Advance()	) program control moves	to
	    the	next field.


       3.  TTTThhhheeee CCCC IIIInnnntttteeeerrrrffffaaaacccceeee

       3.1  _A__S_i_m_p_l_e__F_o_r_m  Appendix D contains a simple	C based
       form.  In this form we create two fields.  On lines 17 and
       18 field	zero is	created	as a numeric field with	a range	of
       -123.55 to 123.00.  Field zero is set to	be right justified
       on line 20.  Field one, on line 29, is a	confirmation field.
       Since the user can only exit a confirmation field with a
       carriage	return it is a good choice for the last	field in a
       form.  This use of confirmation fields prevents the user
       from accidentally moving	off the	end of the form	with one of
       the normal field	movement keys.

       Notice that the form contained in Appendix D begins with	a
       call to the procedure Start_Form() and ends with	a call to
       the procedure End_Form().  All forms must begin and end with
       these calls.

       The bulk	of the processing in the form in Appendix D is con-
       tained in the two procedure calls, Show_List() and
       Get_List().  Show_List(), on line 41, displays the fields
       and Get_List(), on line 43, collects the	input from the
       user.  The values returned for each field can be	examined
       with calls to the procedure Field_Value().

       3.2  _A__M_o_r_e__C_o_m_p_l_e_x__F_o_r_m	 Appendix E contains a more complex
       C based form.  This form	contains six fields of various
       types.  The call	to Def_Interrupt(), line 16, sets the form
       to catch	interrupt signals by running the beep()	routine.
       Help messages are set to	use efficient, MIT style scrolling
       on line 18.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 9 -



       This form appears to the	end user to behave in a	much dif-
       ferent manner than the form from	Appendix D.  The call to
       Set_Auto_Advance(), line	93, sets the fields to auto-tab	to
       the next	field.	This means that	when a field is	full or
       when the	completion request (i.e. ESCAPE) has been given,
       control will move automatically to the next field.  This	one
       feature can greatly enhance the input process for the end
       user.

       This form also allows the user to move from field to field
       using either terminal supplied function keys and/or a mouse.
       This is enabled with the	call to	the procedure
       Set_Tab_Movement() on line 92.

       Many of the following sections are a list of Tabs functions
       and procedures.	Most users will	only need a few	of these to
       create forms.  It is probably a good idea to read through
       this list to see	what options are available and refer to	the
       list as the application and your	memory require.


       4.  SSSSeeeettttuuuupppp

       This section contains routines for setting up and ending	a
       Tabs program.

       4.1  _S_t_a_r_t___F_o_r_m

       Start_Form (h_char, v_char)
       char h_char;
       char v_char;

       This procedure performs all of the initial setup	steps for
       running a form.	The global variables ``stdwindow'' and
       ``errwindow'' are initialized by	this procedure.
       Start_Form() must be called prior to all	field related
       activity.  This procedure also sets the terminal	to raw
       mode.

       The variable ``h_char'' is used as the horizontal character
       for boxing the standard window.	``v_char'' is used as the
       vertical	boxing character.  If ``h_char'' is zero the window
       will be displayed unboxed.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 10 -



       4.2  _D_e_f___I_n_t_e_r_r_u_p_t

       Def_Interrupt (function)
       int (*function) ();

       This procedure sets the specified function to catch SIGINT
       and SIGQUIT.  If	0 is specified the default actions will	be
       taken.



       4.3  _E_n_d___F_o_r_m

       End_Form	()

       This procedure sets the terminal	back to	cooked mode and
       resets the signals SIGQUIT and SIGINT.


       5.  SSSSiiiimmmmpppplllleeee IIIInnnnppppuuuutttt	FFFFiiiieeeelllldddd MMMMaaaannnnaaaaggggeeeemmmmeeeennnntttt

       This section contains simple field creation, deletion, move-
       ment and	modification routines.	Other sections also contain
       field management	functions (e.g., the menu and scrollable
       region sections).  Any routine in any section that starts
       with ``Set_'' modifies a	previously created field.

       5.1  _N_e_w___F_i_e_l_d

       struct field_item      *
       New_Field (row, column, type, fill_char,	help, keywords)
       int     row;
       int     column;
       int     type;
       char   *fill_char;
       char   *help;
       char   *keywords;

       This function creates a new field with the specified attri-
       butes.  This procedure does not update the screen.  The
       arguments are used as follows:

	  +o row

	    This is the	row or line position of	the field.  This
	    function assumes that the field will be placed (see
	    Show_Field() and Show_Default_Field()) in the standard
	    window (i.e. struct	window *stdwindow).  The rows run
	    from the top of the	screen to the bottom of	the screen.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 11 -



	    All	coordinates are	zero origin based.

	  +o column

	    This is the	column position	of the field.  The columns
	    run	from left to right on the screen.  All coordinates
	    are	zero origin based.

	  +o type

	    This is the	type of	field to be created.  The following
	    types of fields are	currently supported:

	       - CMKEY and CMKEY_LIST -	keywords

	       - CMCFM - confirmation -	carriage return	or line
		 feed only

	       - CMSTR - string	- any combination of letters and
		 numbers

	       - CMNUM - numeric only -	this includes both integer
		 and decimal numbers

	       - CMFILE	- file names - this includes file wild
		 carding

	       - CMENV - environmental variables - (sorts environ
		 array as a side effect)

	       - CMREGN	- a scrollable region (see New_Region()
		 below).

	  +o fill_char

	    This is a string containing	the background text for	the
	    field.  The	background text	is the string of characters
	    that are over written with the end user supplied input.
	    The	length of the field is determined from the length
	    of this string.

	  +o help

	    This is the	help message that will be printed when the
	    end	user enters a ``?''.  If this argument is zero the
	    default help message for this type of field	will be
	    printed when help is requested.  More detailed control
	    of help displays may be obtained with the Set_Help()



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 12 -



	    procedure.

	  +o keywords

	    The	keyword	field is used with CMKEY, CMFILE, and CMNUM
	    type fields. For CMKEY, keyword fields, ``keywords'' is
	    a string containing	the list of allowable keywords.
	    Keywords are separated by spaces, for example
	    "one two three".  Keywords are displayed in	sorted
	    order.  The	number of keywords must	be less	than or
	    equal to the defined constant MAX_KEYS, which is
	    currently set to 128.

	    For	CMKEY_LIST, keyword list fields, ``keywords'' is a
	    zero terminated array of struct keys.  The keys struc-
	    ture contains a pointer to a keyword string	(kstr) and
	    a keyword value (kval).  Keywords constructed using
	    this technique may contain any character including
	    spaces.  The associated key	value for the selected item
	    is placed in ``field_ptr->fndfv''.	Keywords are
	    displayed in sorted	order. Keywords	lists of more than
	    defined constant MAX_KEYS, which is	currently set to
	    128, will not be sorted.

	    For	CMFILE,	filename fields, ``keywords'' contains the
	    number of files.  If the number is one, one	filename
	    may	be given.  If the number is greater than one, files
	    may	be specified using wild	card notation (e.g.
	    *.[hc]).  This number is passed as an ASCII	string,	for
	    example "2".

	    For	CMNUM, numeric fields, ``keywords'' contains the
	    number of digits behind the	decimal	point and the range
	    for	the number.  These numbers are passed as an ASCII
	    string of the form,	``DIGITS,LOW,HIGH''.  For example,
	    "2,0.0,9.9", would be used for fields wishing one digit
	    behind the decimal point and a number in the range 0.0
	    to 9.9.  The number	of digits behind the decimal point
	    is in plus one notation.  Zero specifies integer
	    numbers.  One specifies only a decimal point, etc.



       5.2  _D_e_l___F_i_e_l_d

       Del_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure deletes the specified field.  This only


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 13 -



       removes the field from the display.  If the field has
       labels, the labels are also deleted.  It	does not free any
       memory.	The field may be display again with any	of the
       ``Show''	routines.



       5.3  _F_r_e_e___F_i_e_l_d

       Free_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure frees the	space associated with the specified
       field.  If the field has	labels,	the labels are also freed.
       This routine does not delete the	fields or labels from the
       window display.



       5.4  _M_o_v_e___F_i_e_l_d

       Move_Field (field_ptr, row, column, window)
       struct field_item      *field_ptr;
       int     row;
       int     column;
       struct window *window;

       This procedure moves the	specified field	to the (row,column)
       position	in the specified window.  The old position is
       deleted.	 If no window is specified (i.e. window	is equal to
       zero), the old window is	assumed.



       5.5  _D_u_p___F_i_e_l_d

       struct field_item *
       Dup_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure duplicates the specified field.  The value
       returned	is a pointer to	the new	field.	A zero return means
       that the	field was not successfully duplicated.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 14 -



       5.6  _S_e_t___L_a_b_e_l

       Set_Label (field_ptr, where, label, attribute)
       struct field_item *field_ptr;
       char   *where;
       char   *label;
       int     attribute;

       This procedure adds a label to the specified field.  Labels
       may be placed in	four directions	around the field.
       ``where'' should	be either "left", "right", "above", or
       "below".	 This procedure	modifies the data structures asso-
       ciated with a particular	field but it does not update the
       screen.	The attribute argument specifies the visual attri-
       bute that is to be applied to the string.  See the
       Set_Attribute() procedure for a list of available visual
       attributes.



       5.7  _D_e_l___L_a_b_e_l

       Del_Label (field_ptr, label_ptr)
       struct field_item      *field_ptr;
       struct label_item      *label_ptr;

       This procedure deletes the specified label.  This only
       removes the label from the display.  It does not	free any
       memory.



       5.8  _F_r_e_e___L_a_b_e_l

       Free_Label (label_ptr)
       struct label_item *label_ptr;

       This procedure frees the	space associated with the specified
       label.  This routine does not delete the	fields or labels
       from the	window display.











	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 15 -



       5.9  _S_e_t___A_t_t_r_i_b_u_t_e_s

       Set_Attributes (field_ptr, flags)
       struct field_item *field_ptr;
       int     flags;

       This procedure sets the attribute flags associated with the
       specified field.	 The following is a list of the	supported
       attributes.

	       ____________________________________________
	       |					   |
	       |		Attributes		   |
	       _|_______________________________________________________________________________________|
	       |					   |
	       |  Keyword	       Attribute	   |
	       |					   |
	       _|___________________________________________|
	       |	    |				   |
	       |FANORMAL    | No Attributes		   |
	       _|_____________|______________________________|
	       |	    |				   |
	       |FAREVV	    | Reverse Video		   |
	       |FAHALF	    | Half Intensity		   |
	       |FAUNDER	    | Underline			   |
	       |FABLINK	    | Blink			   |
	       |FABOLD	    | Bold			   |
	       |FAINVISIBLE | Invisible			   |
	       |	    |				   |
	       _|_____________|______________________________|
	       |	    |				   |
	       |FARIGHT*    | Right Justify		   |
	       |FACENTER*   | Center			   |
	       |FALEFT*	    | Left Justify		   |
	       |FACASE*	    | Ignore the case for keywords |
	       |FAPROTECT*  | Protected	field		   |
	       _||_____________||______________________________||

       Invisible fields	behave like the	assigned field type except
       that characters in the field are	displayed as blank spaces
       on the screen.



       __________

	 * These attributes are	for input fields only.	They do	not
	   apply to ``printing.''



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 16 -



       Set_Attribute() calls are NOT cumulative.  Each call will
       completely reset	all of the attributes to the new flags.
       The following line is a typical use of the procedure.

	       Set_Attribute (f[index],	FACENTER | FAREVV | FAUNDER);




       5.10  _S_e_t___A_n___A_t_t_r_i_b_u_t_e

       Set_An_Attribute	(field_ptr, flags)
       struct field_item *field_ptr;
       int     flags;

       This procedure sets the attribute flags associated with the
       specified field.	 Attributes include left, right, and center
       for formatting, and the visual attributes. The attributes
       can be set one at a time	or in one call.	 Set_An_Attribute()
       calls ARE cumulative.  See Set_Attributes() for a list of
       the supported attributes.



       5.11  _U_n___S_e_t___A_n___A_t_t_r_i_b_u_t_e

       Un_Set_An_Attribute (field_ptr, flags)
       struct field_item *field_ptr;
       int     flags;

       This procedure removes the specified attribute.	See
       Set_Attributes()	for a list of the supported attributes.



       5.12  _S_e_t___A_u_t_o___A_d_v_a_n_c_e

       Set_Auto_Advance	(field_ptr, state)
       struct field_item      *field_ptr;
       boole  state;

       This procedure sets the auto advance (advance when complete)
       flag for	the specified field.  If the auto advance flag is
       set, the	field is exited	when it	is full	or when	a comple-
       tion request is made (e.g. ESCAPE key is	pressed).






	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 17 -



       5.13  _S_e_t___C_M_P___D_e_f_a_u_l_t

       Set_CMP_Default (field_ptr, string)
       struct field_item *field_ptr;
       char   *string;

       This procedure sets the ``completion default'' for the
       specified field.	 If the	user enters a completion request
       (ESCAPE)	in an empty field, the completion default is
       printed (i.e. completed).  It is	an invisible default value.
       The procedure Show_Default_Field() is used to set visible
       default values.



       5.14  _S_e_t___E_O_F

       Set_EOF (field_ptr, eof_state, eof_verify)
       struct field_item      *field_ptr;
       boole  eof_state;
       boole  eof_verify;

       This procedure sets the state flag for enabling EOF exit
       from the	specified field.  If ``eof_state'' is TRUE, the
       field can be exited by entering the end of file character,
       usually control-D.  If ``eof_verify'' is	TRUE, then the
       field is	verified before	exiting.  The default action for
       the EOF character is to cause Get_List()	to return or stop
       processing the current list of fields.



       5.15  _S_e_t___W_i_n_d_o_w

       Set_Window (field_ptr, window1, window2,	window3)
       struct field_item *field_ptr;
       struct window *window1;
       struct window *window2;
       struct window *window3;

       This procedure sets the data collection window, help window,
       and error message window	(see Print_Message()) for the
       specified field.	 ``window1'' is	the data collection window.
       ``window2'' is the help window.	``window3'' is the error
       message window.	A window pointer of zero may be	used to
       specify no change.

       Most fields use two standard windows.  ``stdwindow'' is
       defined to be the main default window for both data


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 18 -



       collection and error messages (see Start_Form()).  ``errwin-
       dow'' is	the default help window. Forms running in very nar-
       row windows may wish to have the	error messages sent to
       ``stdwindow''.

       This command should be used prior to displaying the field
       (see Show_Field() and Show_Default_Field()).  To	change the
       data collection window after the	field has been displayed
       use the procedure Move_Field().



       5.16  _L_i_n_k___F_i_e_l_d_s

       Link_Fields (field1_ptr,	field2_ptr)
       struct field_item *field1_ptr;
       struct field_item *field2_ptr;

       This procedure links field2 to field1.  When getting input
       to field1, field2 will be used as an alternate.	This pro-
       vides a mechanism for reading two or more types from the
       same field.  The	field used as field2_ptr may be	used in
       links with other	fields.	 All string space is maintained	by
       the first item of the link.

       BE WARE!!! Some field types behave differently when they	are
       used as linked fields.  The confirmation	field will allow
       both TAB	and a confirmation key (i.e. carriage return or	new
       line) when it is	used as	a secondary linked field.  Numeric
       fields use the default reader (i.e. getachar()) rather than
       the number filtering reader read_num().



       5.17  _U_n_l_i_n_k___F_i_e_l_d_s

       Unlink_Fields (field1_ptr, field2_ptr)
       struct field_item *field1_ptr;
       struct field_item *field2_ptr;

       This procedure unlinks two previously linked fields.


       6.  FFFFiiiieeeelllldddd DDDDiiiissssppppllllaaaayyyy aaaannnndddd CCCCoooolllllllleeeeccccttttiiiioooonnnn

       These routines display previously created fields	on the
       screen, write field contents to an output file pointer, col-
       lect the	response from the user and provide access to the
       response.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 19 -



       6.1  _S_h_o_w___F_i_e_l_d

       Show_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure initializes the specified	field.	This
       includes	displaying the field in	its window (see
       Set_Window()).  In most cases Show_List() is the	preferred
       method.



       6.2  _S_h_o_w___D_e_f_a_u_l_t___F_i_e_l_d

       Show_Default_Field (field_ptr, string)
       struct field_item      *field_ptr;
       char   *string;

       This procedure sets the default value of	the specified field
       to the value in ``string''.  This procedure will	cause the
       field to	be displayed (like Show_Field()	).  No type check-
       ing is done on the default value.



       6.3  _S_h_o_w___L_a_b_e_l

       Show_Label (field_ptr, label_ptr)
       struct field_item      *field_ptr;
       struct label_item      *label_ptr;

       This procedure prints the specified label item with the
       specified field.	 Labels	may appear in 4	directions around
       the field.  This	procedure is called by Show_Field() and
       Show_Default_Field().



       6.4  _G_e_t___F_i_e_l_d

       Get_Field (field_ptr)
       struct field_item      *field_ptr;

       This function performs all of the processing required to
       collect the user's input	for the	specified field.  If the
       field has not been displayed it will be.	 The user's input
       may be examined by using	the function Field_Value ().

       The value returned by the function is the method	by which


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 20 -



       the user	exited the field.

		__________________________________________
		|					  |
		|	 Get_Field() Return Codes	  |
		_|___________________________________________________________________________________|
		|					  |
		|Return	Code	     Interpretation	  |
		|					  |
		_|_________________________________________|
		|	     |				  |
		|CMNORM	     | tab key or carriage return |
		|CMFTAB	     | forward tab key		  |
		|CMBTAB	     | backward	tab key		  |
		|CMHOME	     | home key			  |
		|CMBOTTOM    | bottom key		  |
		|CMUP	     | up key			  |
		|CMDOWN	     | down key			  |
		|CMLEFT	     | left key			  |
		|CMRIGHT     | right key		  |
		|CMMOUSE     | mouse tracks		  |
		|CMEOF	     | EOF character		  |
		_||_____________||____________________________||

       All returns, other than tab, must be enabled for	the field
       with the	Set_Tab_Movement() or Set_EOF () procedures.  See
       Get_List() for the details of handling all of these returns.

       No formatting is	provided in this procedure.  Get_List()
       performs	the standard (attribute	specified) formatting.	In
       most cases Get_List() is	the preferred field collection
       function.  Get_List() calls Get_Field().



       6.5  _F_i_e_l_d___V_a_l_u_e

       Field_Value (field_ptr, string)
       struct field_item *field_ptr;
       char   string[];

       This procedure places the current value of the specified
       field in	``string''.  This is hardly necessary from a C
       based form.  A C	based form can access the field	structure
       directly.  The procedure	is required for	forms produced in
       an interpreted language.





	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 21 -



       ReShow_Field (field_ptr)
       struct field_item       *field_ptr;

       This procedure displays a single	field and leaves its con-
       tents untouched.	 If the	field was previously centered or
       right justified it displays it the same way.



       6.6  _R_i_g_h_t___F_i_e_l_d

       Right_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure right justifies the current value	of the
       specified field.



       6.7  _L_e_f_t___F_i_e_l_d

       Left_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure left justifies the current value of the
       specified field.



       6.8  _C_e_n_t_e_r___F_i_e_l_d

       Center_Field (field_ptr)
       struct field_item      *field_ptr;

       This procedure centers the current value	of the specified
       field.



       6.9  _D_u_m_p___F_i_e_l_d

       Dump_Field (field_ptr, where)
       struct field_item      *field_ptr;
       FILE * where;

       This procedure prints the current value of the specified
       field on	the specified stream created with a call to
       fopen(3)	or popen(3).  This is hardly necessary from C, but
       it is required for interpreted versions.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 22 -



       7.  FFFFoooorrrrmmmm	DDDDiiiissssppppllllaaaayyyy	aaaannnndddd CCCCoooolllllllleeeeccccttttiiiioooonnnn

       The previous section included routines that applied to a
       single field.  The routines in this section deal	with lists
       of fields.  A routine is	also included to collect a position
       on the screen from the end_user,	Get_Position().

       7.1  _S_h_o_w___L_i_s_t

       Show_List (field_array, count)
       struct field_item *field_array[];
       int     count;

       The procedure performs a	Show_Field() for an array of
       fields.	The array is ``count'' items long.  The	array of
       fields may include scrollable regions (i.e. a CMREGN
       fields).



       7.2  _G_e_t___L_i_s_t

       Get_List	(field_array, count, ok_to_back, ok_to_forward)
       struct field_item *field_array[];
       int     count;
       boole   ok_to_back;
       boole   ok_to_forward;

       This procedure collects input for an array of fields.  The
       array of	fields may include scrollable regions (i.e. a
       CMREGN field). The array	is ``count'' items long.  This pro-
       cedure also handles formatting and inter-field movement.
       Get_List() also executes	all application	specified pre and
       post action routines (see Set_Actions()).

       If ``ok_to_back'' is TRUE, Get_List() allows the	user to
       back off	(e.g. using BACK TAB) the front	of the list.  If
       ``ok_to_forward'' is TRUE, Get_List() allows the	user to
       move forward off	(e.g. using the	FORWARD	directive) the end
       of the list.  These two flags are also used internally by
       Tabs for	handling embedded regions.










	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 23 -



       7.3  _G_e_t___S_I___L_i_s_t

       Get_SI_List (field_array, count,	start_index,
	       ok_to_back, ok_to_forward)

       struct field_item *field_array[];
       int     count;
       int     start_index;
       boole   ok_to_back;
       boole   ok_to_forward;

       Get_SI_List() has the same parameters as	Get_List() with	the
       except of start_index.  start_index is the index	of the
       field where the cursor is to be placed for input.  This
       allows the application to start the input process at a field
       other than field	zero.  This is very useful for forms that
       have default values for the first few fields.



       7.4  _G_e_t___P_o_s_i_t_i_o_n

       Get_Position (window, row, column, help_string)
       struct window *window;
       int    *row;
       int    *column;
       char   *help_string;

       This procedure collects a (row,column) address from the
       user.  The values are returned in row and column.  Most of
       the common methods for moving in	a window are accepted
       including mouse and function keys.



       7.5  _R_e_S_h_o_w___A_l_l___L_i_s_t_s

       ReShow_All_Lists	(clear_flag)
       int     clear_flag;

       This procedure displays all fields in all active	lists
       (lists that are within the Get_List procedure).	When
       ``clear_flag'' is TRUE all field	values are cleared.  When
       it is FALSE field values	are left untouched.







	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 24 -



       7.6  _R_e_S_h_o_w___L_i_s_t

       ReShow_List (field_list,	count, clear_flag)
       struct field_item       *field_list[];
       int     count;
       int     clear_flag;

       This procedure displays ``count'' items in the list of
       fields, ``field_list''.	If ``clear_flag'' is TRUE all field
       values are cleared.  If it is FALSE field values	are left
       untouched.



       7.7  _C_l_e_a_r___F_o_r_m

       Clear_Form (window)
       struct window *window;

       This procedure clears the specified window.  The	cursor is
       placed at position (0,0)	in the window.	The name
       Clear_Form() comes from the notion that a form is a collec-
       tion of controlled I/O areas contained within a window.



       7.8  _D_u_m_p___F_o_r_m

       Dump_Form (window, where)
       struct window *window;
       FILE *where;

       This procedure prints the specified window.  ``where'' is a
       stream pointer obtained from a call to a	standard I/O
       library function	such as	fopen or popen.	 Windows may be
       printed even though they	are not	currently visible.



       7.9  _S_C_R_N___D_u_m_p

       SCRN_Dump (where)
       FILE *where;

       This procedure prints the current contents of the screen.
       "where" is a stream pointer obtained from a call	to a stan-
       dard I/O	library	function such as fopen or popen.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 25 -



       8.  IIIInnnntttteeeerrrr----ffffiiiieeeelllldddd CCCCoooonnnnttttrrrroooollll aaaannnndddd MMMMoooovvvveeeemmmmeeeennnntttt

       This section includes routines to change	inter-field move-
       ment characteristics and	a routine to set pre and post
       actions on fields, Set_Actions().  This last routine makes
       the list-collection routines described above highly extensi-
       bility.	Another	document, ``Tabs:  A Window Based, Extensi-
       ble, Highly Typed, Electronic Forms Package'' [4], provides
       necessary background information	for efficient use of the
       routines	described here.

       8.1  _S_e_t___T_a_b___M_o_v_e_m_e_n_t

       Set_Tab_Movement	(field_ptr, bt_state, bt_verify,
			       cp_state, cp_verify, onepass)
       struct field_item      *field_ptr;
       boole   bt_state;
       boole   bt_verify;
       boole   cp_state;
       boole   cp_verify;

       This procedure sets the state flags for controlling movement
       out of the specified field.

	  +o bt_state - specifies whether or not	BACK TAB is
	    allowed.  Control-P	is also	controlled by this flag.

	  +o bt_verify -	specifies whether or not the field should
	    be verified	when BACK TAB is used.

	  +o cp_state - specifies whether or not	cursor pad and
	    mouse style	movement are allowed.  Control-N is also
	    controlled by this flag.

	  +o cp_verify -	specifies whether or not the field should
	    be verified	when cursor or mouse movement are used.

	  +o onepass - specifies	whether	or not the field is to be
	    used only once.  A field is	marked as having been used
	    when it contains characters	and the	user moves to
	    another field.

       Applications often allow	BACK TAB from any field	without
       verification. This allows the end user to go back and edit
       previous	fields.	 With only BACK	TAB available the applica-
       tion can	guarantee that the form	is complete and	valid up to
       the current field.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 26 -



       8.2  _S_e_t___B_T___M_o_v_e_m_e_n_t

       Set_BT_Movement (field_ptr, bt_state, bt_verify)
       struct field_item      *field_ptr;
       boole bt_state;
       boole bt_verify;

       This procedure sets the BACK TAB	states only.
       Set_Tab_Movement() uses this function.



       8.3  _S_e_t___C_P___M_o_v_e_m_e_n_t

       Set_CP_Movement (field_ptr, cp_state, cp_verify)
       struct field_item      *field_ptr;
       boole cp_state;
       boole cp_verify;

       This procedure sets the cursor pad and mouse states only.
       Set_Tab_Movement() uses this function.



       8.4  _S_e_t___O_n_e___P_a_s_s

       Set_One_Pass (field_ptr,	onepass_state)
       struct field_item      *field_ptr;
       boole onepass_state;

       This procedure specifies	whether	or not the field is to be
       used only once.	Set_Tab_Movement() uses	this function.



       8.5  _S_e_t___A_c_t_i_o_n_s

       Set_Actions (field_ptr, pre, post)
       register	struct field_item *field_ptr;
       int (*pre) ();
       int (*post) ();

       This procedure sets the pre and post action routines to
       ``pre'' and ``post'' respectively.  The pre-action is exe-
       cuted just prior	to reading the field each time the field is
       entered.	 The post action routine is executed each time the
       field is	exited.	 These routines	give the application
       developer a great deal of freedom and control while using
       all of the power	of Get_List().


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 27 -



       The following is	a code fragment	for defining a typical pre
       or post action routine.

       int
       pre_or_post (f, count, index, rc)
       struct field_item **f;
       int     count;
       int     index;
       int     rc;
       {
	       /* Body */
       ~
	       return (new index);
       }

       The arguments passed to the pre and post	action routines	are
       as follows.

	  +o struct field_item **f;

	    This is the	list of	fields from the	call to	Get_List().

	  +o int	count;

	    This is the	number of fields from the call to
	    Get_List().

	  +o int	index;

	    This is the	index of the current field (e.g	f[index]).

	  +o int	rc;

	    This is the	return code from the last call to
	    Get_Field().

       The return value	from the pre and post action routines must
       be an int. This is used as the next index for Get_List().
       Returning ``count'' always causes Get_List() to return.
       Returning ``index'' allows Get_List() to	proceed	as usual.
       A minus one (i.e. -1) return value causes the current field
       to be collected again.

       The pre and post	action routines	may be used with the rede-
       finable character features (see the description of the
       Def_Char_Action() procedure) to implement control character
       directives that have some inter-field action.  To avoid hav-
       ing to set the pre and post actions of every field there
       exist global pre	and post action	routines that may be set by


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 28 -



       the application.	 The following is a code fragment for set-
       ting the	global pre and post action routines.

       main ()
       {
	       extern int my_post ();
	       extern int my_pre ();
	       ~
	       Glbl_post_action	= my_post;
	       Glbl_pre_action = my_pre;
	       ~
       }

       If both field specified and global pre and/or post actions
       are supplied both will be executed.  The	global routines	are
       executed	first and the return from the global actions take
       precedence over the field specified actions.


       9.  EEEEddddiiiitttt	SSSSttttyyyylllleeee aaaannnndddd CCCCuuuurrrrssssoooorrrr PPPPllllaaaacccceeeemmmmeeeennnntttt

       With the	exception of Def_Editing_Type(), the functions
       described here are concerned with how the cursor	is posi-
       tioned when a field is entered.


       9.1  _D_e_f___E_d_i_t_i_n_g___T_y_p_e

       Def_Editing_Type	(type)
       int type;

       This procedure defines the editing type that will be used
       with all	subsequent input fields.  OVERLAY and INSERT are
       the only	available types.  All other types will be ignored.
       Calling this procedure will immediately invoke the the edit-
       ing type	that is	requested.

       INSERT is the default mode.  In this mode, when a valid
       character is entered from the keyboard the characters from
       the cursor to the end of	the field are moved one	character
       position	to the right and the new character is put where	the
       cursor is.  The cursor is then moved one	character position
       to the right.

       In OVERLAY mode the new character replaces the character
       under the cursor	and then the cursor is moved one character
       position	to the right.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 29 -



       9.2  _D_e_f___E_n_t_r_y___T_y_p_e

       Def_Entry_Type (type)
       int type;

       This procedure defines the entry	type that will be used with
       all subsequent input fields.  The entry type specifies where
       the cursor should be placed when	the user moves into an
       input field that	contains data.	FAR_RIGHT and FAR_LEFT are
       the only	available types.  All other types will be ignored.
       FAR_RIGHT is the	default.  Calling this procedure will
       immediately invoke the entry type that is requested.




       9.3  _D_e_f___A_u_t_o___P_o_s

       Def_Auto_Pos (flag)
       boole   flag;

       If _f_l_a_g is FALSE	cursor positioning upon	field entry will
       behave as defined by the	last call to Def_Entry_Type(), the
       default situation.  When	_f_l_a_g is	TRUE cursor positioning
       upon field entry	is turned off such that	when a user
       reenters	a field	the cursor will	be in the same position	as
       when the	user left the field unless some	BREAK character	or
       pre/post	action routine moves the cursor.  For example,
       positioning with	the mouse or other pointing device is pos-
       sible when _f_l_a_g is TRUE.

       The following is	a detailed explanation of how cursor posi-
       tioning works so	that application developers can	take full
       advantage of the	possibilities available	when cursor posi-
       tioning is turned off.  Def_Entry_Type()	forces the cursor
       to be positioned	either at the beginning	or end of the field
       each time a field is entered.  Not having to worry about
       cursor position is convenient for application developers.
       However,	more flexibility, as provided by Def_Auto_Pos()	and
       Def_Keep_Pos() is sometimes required.  An understanding of
       the details of cursor positioning is necessary to utilize
       these routines effectively.

       The position of the cursor in the field is determined by	the
       text cursor, _t_x_c_u_r_s_o_r (a	pointer	in the field structure -
       see ``the field structure'' section of this manual).  The
       cursor on the screen points to the same character that the
       text cursor points to in	the text buffer	(pointed to by
       _t_x_b_u_f), the buffer that holds the value of the field.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 30 -



       Notice that the position	of the cursor is not determined	by
       a row and column	position but simply by the position of the
       text cursor in the text buffer.

       Consider	the default situation in Tabs.	When a field is
       entered the visible cursor is moved to the position just
       beyond the last character in the	field.	To do this Tabs
       just repositions	the text cursor	for that field so that it
       points to a location in the text	buffer that is one position
       beyond the last character in the	field (equal to	the text
       pointer,	_t_x_p_t_r in the field structure).	This is	done in
       Get_Field().  Lower level routines then automatically move
       the cursor on the screen	to correspond to the position of
       the text	cursor in the text buffer.

       Several types of	routines can effect the	cursor position.
       We are only concerned here with positioning the cursor as
       the field is being entered.  The	effect of Def_Auto_Pos()
       and Def_Keep_Position() is to turn off cursor positioning,
       as defined by Def_Entry_Type(), when entering a field.
       CORRECT character routines (see Def_Char_Action()) and rou-
       tines that display the field manipulate the text	cursor but
       are not effected	by these functions.  For example,
       Show_Default_Field() always moves the text cursor to the
       beginning or end	of the field depending on the last call	to
       Def_Entry_Type().

       The following example global pre-action routine (see
       Set_Actions()) shows one	way to search for a string in a
       list of fields.	Char_String and	String_Len are globals.
       The cursor will be positioned at	the start of the string	if
       the string is in	the field and the search is ended by set-
       ting the	global pre-action routine to 0.	 Otherwise the
       index to	the next field will be returned	and the	search will
       continue.  The search is	started	elsewhere by:

	  +o assigning the Glbl_pre_action() to myglobal_pre()

	  +o assigning the search string	to Char_String

	  +o assigning the length of the	search string to
	    String_Len.

	  +o calling Get_List()

       If the search string is not found Get_List() will return.





	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 31 -



       myglobal_pre (f,	count, index, rc)
       register	struct field_item     **f;
       int     count;
       register	int index;
       int     rc;
       {
	       register	char	    *char_ptr;

	       char_ptr	= field_ptr -> txbuf;
	       while (*char_ptr)
	       {
		       if (strncmp (Char_String, char_ptr, String_Len) == 0)
		       {
			       /* found	it - set cursor	position */
			       field_ptr -> txcursor = char_ptr;
			       Def_Keep_Position (TRUE);
			       Glbl_pre_action = 0;
			       return (index);
		       }
		       char_ptr++;
	       }
	       return (++index);
       }




       9.4  _D_e_f___K_e_e_p___P_o_s_i_t_i_o_n

       Def_Keep_Position (flag)
       int	  flag;

       If _f_l_a_g is FALSE	cursor positioning upon	field entry will
       behave as defined by the	last call to Def_Entry_Type(), the
       default situation.  When	_f_l_a_g is	TRUE cursor positioning
       upon field entry	is turned off for the entry into oooonnnneeee field.
       The normal result is that when a	user re-enters a field the
       cursor will be in the same position as when the user left
       the field.  However, the	position of the	cursor may been
       changed by a BREAK character or pre/post	action routine.
       See Def_Auto_Pos() for a	detailed explanation of	how cursor
       positioning works.  If Def_Keep_Position() is called from a
       pre-action routine you can be sure that the normal field-
       entry cursor positioning	will be	turned off for the correct
       field.  Def_Auto_Pos() changes field entry positioning for
       all entries into	all fields.  This routine does not distin-
       guish between fields.  It only applies for one time to the
       next field that is entered.



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 32 -



       10.  CCCCrrrreeeeaaaattttiiiinnnngggg CCCChhhhaaaarrrraaaacccctttteeeerrrr DDDDiiiirrrreeeeccccttttiiiivvvveeeessss ---- DDDDeeeeffff____CCCChhhhaaaarrrr____AAAAccccttttiiiioooonnnn

       Def_Char_Action (c, type, function, break_type)
       char c;
       int type;
       int (*function) ();
       int break_type;

       This procedure is used to redefine the meaning of characters
       to Tabs.	 The arguments to the procedure	are as follows:

	  +o c -	the character whose definition is to be	altered.
	    This includes the control keys (i.e. 0 to 037), all
	    printable characters and numbers (i.e. 038 to 0177)	and
	    the	following special keys.




































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 33 -



		   _________________________________________
		   |					    |
		   |	      Special Characters	    |
		   _|_________________________________________________________________________________|
		   |					    |
		   |Defined Constant	       Key	    |
		   |					    |
		   _|________________________________________|
		   |		     |			    |
		   |K_HOME	     | HOME or TOP	    |
		   |K_BOTTOM	     | BOTTOM		    |
		   |K_LEFT	     | Left Arrow	    |
		   |K_RIGHT	     | Right Arrow	    |
		   |K_UP	     | Up Arrow		    |
		   |K_DOWN	     | Down Arrow	    |
		   |K_TAB	     | TAB		    |
		   |K_FTAB	     | Forward Tab	    |
		   |K_BTAB	     | Back Tab		    |
		   |K_ESC	     | Escape		    |
		   |K_HELP	     | Help		    |
		   |K_EOL	     | End-of-line	    |
		   |K_EOF	     | End-of-file	    |
		   |K_NULL	     | Invalid Key Entered  |
		   |K_MOUSE	     | Mouse Button Press   |
		   |K_MOUSE2	     | Mouse Button Release |
		   |K_F0	     | f0		    |
		   |K_F1	     | f1		    |
		   |K_F2	     | f2		    |
		   |K_F3	     | f3		    |
		   |K_F4	     | f4		    |
		   |K_F5	     | f5		    |
		   |K_F6	     | f6		    |
		   |K_F7	     | f7		    |
		   |K_F8	     | f8		    |
		   |K_F9	     | f9		    |
		   |K_FA	     | f10		    |
		   _||__________________||______________________||

	  +o type - this	is the type of character that ``c'' is to
	    become.  There are four character types.

	       - BREAK - this class of characters specifies that
		 Tabs is to perform some inter-field action or
		 verification.	Common BREAK characters	include	the
		 cursor	pad keys and TAB and carriage return.

	       - CORRECT - this	class of characters is used to per-
		 form editing operations within	a given	field.
		 Common	CORRECT	characters are the user's ERASE	and


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 34 -



		 KILL characters.

	       - PUNC -	this class of characters is used to
		 separate and define words and tokens read by Tabs.
		 The space character (octal 40)	is the only prede-
		 fined PUNC character.

	       - NORMAL	- this class of	characters includes all	of
		 the characters	that are displayed within a field.
		 This is the standard character	set.

	  +o function - this is the function that will be used to
	    process the	character.  Standard processing	functions
	    include, regchar() for NORMAL and PUNC characters,
	    brkchar() for BREAK	characters, and	corchar() for
	    CORRECT characters.	 These functions all have the fol-
	    lowing format.

	    function (field_ptr, rc)
	    struct field_item *field_ptr;
	    char    rc;
	    {
		    /* Body */

		    return (TRUE or FALSE);
	    }

	    ``field_ptr'' points to the	current	field.	``rc'' is
	    the	character that was associated with this	function.
	    ``rc'' is included so that one function may	be used	to
	    handle many	different characters.

	  +o break_type - this is meaningful only if the	character
	    being specified is to be a BREAK character.	 There are
	    six	types of BREAK characters. These different types
	    refer to internally	maintained lists of BREAK charac-
	    ters that are arranged by function.

	       - CM_LIST - this	is used	to specify the cursor move-
		 ment list of BREAK characters.	 All of	the cursor
		 pad keys are included in this list.

	       - BTAB_LIST - this is the BACK TAB list.	 The BACK
		 TAB key and control-P are included in this list.
		 Some people also add control-N	to this	list.

	       - TAB_LIST - this is the	TAB list.  The TAB key is
		 included in this list.	 If you	define a key other
		 than control-I	as the TAB key,	TAB_LIST should	be


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 35 -



		 used as the ``break_type'' for	the new	character.

	       - CFM_LIST - this is the	list of	characters that	are
		 allowed as confirmation characters.  The default
		 list includes carriage	return and line	feed.

	       - EOF_LIST - this is the	list of	characters that	may
		 be used as end	of file	characters (see	Set_EOF()).
		 The default list includes the user's specified	EOF
		 character, usually control-D.

	       - UTIL_LIST - this list is intended for BREAK char-
		 acters	that have some intra-field specific action.
		 ESCAPE	and ``?'' are included in this list.

       The following code fragment could be used to change the EOF
       character from control-D	to control-X.

       main ()
       {
	       extern int mybrkchar ();
	       ~
	       Def_Char_Action (CTRL(D), NORMAL, regchar, 0);
	       Def_Char_Action (CTRL(X), BREAK,	mybrkchar, EOF_LIST);
	       ~
       }

       mybrkchar (field_ptr, rc)
       struct field_item *field_ptr;
       char    rc;
       {
	       brkchar (field_ptr, K_EOF);
	       return (TRUE);
       }

       ``mybrkchar()'' uses the	standard BREAK character handler to
       set all flags, etc.  ``brkchar()'' is given one of the gen-
       eric BREAK characters.  The complete list of generic BREAK
       characters may be found in the Tabs header file,
       ``fields.h.''

       Notice that the application suppled BREAK routine,
       ``mybrkchar()'' returns TRUE.  All BREAK	handling routines
       must return TRUE	if the BREAK action, return to Get_Field(),
       is to be	performed.  A TRUE return from any of the character
       handling	routines will cause control to return to
       Get_Field().




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 36 -



       11.  HHHHeeeellllpppp

       These routines control the display of help information on
       the screen.

       11.1  _S_e_t___H_e_l_p

       Set_Help	(field_ptr, string, print_col, suppress, help_routine)
       struct field_item *field_ptr;
       char   *string;
       boole   print_col;
       boole   suppress;
       int   (*help_routine) ();

       This procedure is used to change	the help attributes of the
       specified field.

	  +o ``string'' is the new help string.	If string is 0 or
	    "\0", then the standard system help	line will be used.

	  +o ``print_col'' is a flag that should	be TRUE	if the help
	    messages are to be printed as one column (the default)
	    and	FALSE if the output is to be printed as	a tight
	    row.  Row style output is harder to	read, but allows
	    more information to	be displayed at	one time.

	  +o ``suppress'' is a flag that	specifies if the list part
	    of the help	information is not to be presented.  The
	    list part of the help information includes keywords,
	    wild carded	filenames, environmental variable names,
	    and	the range information for numeric fields.  If
	    suppress is	FALSE (the default), the standard list part
	    of the help	messages is provided.

	  +o ``help_routine'' is	a pointer to a help function.  This
	    help function is invoked whenever the end user requests
	    help.  The function	may be used to supply changing or
	    dynamic aspects of some help information. The help pro-
	    cedure should have one argument, a pointer to the
	    current field.  The	following code fragments could be
	    used to add	the date to a help message.










	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 37 -



	    main ()
	    {
	    ~
	    extern int hlp ();
	    ~
	    Set_Help (f[0], "Enter a date.", FALSE, TRUE, hlp);
	    ~
	    }

	    hlp	(field_ptr)
	    struct field_item *field_ptr;
	    {
		    long    Time_loc;
		    char   *C_time;
		    char sbuf[80];

		    Time_loc = (long) time (0);
		    C_time = (char *) ctime (&Time_loc);
		    C_time[strlen(C_time) - 1] = ' ';

		    sprintf (sbuf, "Today's date is: %s", C_time);
		    prhlp (field_ptr, sbuf, FALSE, FALSE);
	    }


       If ``suppress'' is TRUE and ``string'' and ``help_routine''
       are 0, no help of any kind will given.



       11.2  _D_e_f___H_e_l_p___H_e_l_p

       Def_Help_Help (string)
       char    *string;

       This procedure defines the string of characters that tells
       how to get help.	 The default is	"- Type	 ? for help".  This
       string is printed with most error messages.













	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 38 -



       11.3  _P_r_i_n_t___H_e_l_p___W_i_n_d_o_w

       Print_Help_Window (field_ptr, attribute,	sp, ap1, ap2, ap3, ap4,
					       ap5, ap6, ap7)
       Struct field_item      *field_ptr;
       int     attribute;
       char   *sp;
       char   *ap1;
       char   *ap2;
       char   *ap3;
       char   *ap4;
       char   *ap5;
       char   *ap6;
       char   *ap7;

       This procedure prints to	the help window	of the specified
       field.  If the help window is not at level 0 it is moved
       into place.  Argument ``sp'' is the format string like the
       one used	in sprintf().  The attribute argument specifies	the
       visual attribute	that is	to be applied to the string.  See
       the Set_Attribute() procedure for a list	of available visual
       attributes.




       12.  EEEErrrrrrrroooorrrr MMMMeeeessssssssaaaaggggeeeessss

       These routines control the display of error information on
       the screen.

       12.1  _P_r_i_n_t___M_e_s_s_a_g_e

       Print_Message (window, attribute, sp, ap1, ap2, ap3, ap4,
				       ap5, ap6, ap7)
       struct window  *window;
       int     attribute;
       char   *sp;
       char   *ap1;
       char   *ap2;
       char   *ap3;
       char   *ap4;
       char   *ap5;
       char   *ap6;
       char   *ap7;

       This procedure prints a formatted error or warning message
       on the last line	of the specified window.  Argument ``sp''
       is the format string like the one used in sprintf().  The


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 39 -



       attribute argument specifies the	visual attribute that is to
       be applied to the string.  See the Set_Attribute() procedure
       for a list of available visual attributes.



       12.2  _S_e_t___E_r_r_o_r

       Set_Error (field_ptr, message);
       struct field_item *field_ptr;
       char   *message;

       This procedure sets the error message for the specified
       field.  All errors that occur in	the specified field will be
       ``announced'' with the new message.



       12.3  _D_e_f___E_r_r_o_r___A_t_t_r

       Def_Error_Attr (flags)
       int     flags;

       This procedure defines the attributes flags to be used when
       error messages are displayed.  ``flags''	is just	like the
       flags argument to Set_Attributes().


       13.  FFFFoooorrrrmmmmaaaatttttttteeeedddd PPPPrrrriiiinnnnttttiiiinnnngggg ooooffff SSSSttttrrrriiiinnnnggggssss

       These routines print strings on the screen according to a
       specified format.

       13.1  _P_r_i_n_t___F_o_r_m

       Print_Form (window, row,	column,	attribute, string)
       struct window  *window;
       int     row;
       int     column;
       int     attribute;
       char   *string;

       This procedure prints the specified string in the specified
       window at location (row,	column)	in the window.	The attri-
       bute argument specifies the visual attribute that is to be
       applied to the string.  See the Set_Attribute() procedure
       for a list of available visual attributes.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 40 -



       13.2  _D_e_l___P___F_o_r_m

       Del_P_Form (window, row,	column,	string)
       struct window  *window;
       int     row;
       int     column;
       char   *string;

       This procedure deletes the specified string in the specified
       window at location (row,	column)	in the window.	A string of
       blanks is used to ``cover'' the old string.  No check is
       made as to whether the string is	actually present in the
       window prior to performing the delete operation.



       13.3  _P_r_i_n_t___C_e_n_t_e_r

       Print_Center (window, row, attribute, string)
       struct window  *window;
       int     row;
       int     attribute;
       char   *string;

       This procedure prints the specified string centered on line
       ``row'' in the specified	window.	 The attribute argument
       specifies the visual attribute that is to be applied to the
       string.	See the	Set_Attribute()	procedure for a	list of
       available visual	attributes.



       13.4  _D_e_l___P___C_e_n_t_e_r

       Del_P_Center (window, row, string)
       struct window  *window;
       int     row;
       char   *string;

       This procedure deletes the specified string centered on line
       ``row'' in the specified	window.	 A string of blanks is used
       to ``cover'' the	old string.  No	check is made as to whether
       the string is actually present in the window prior to per-
       forming the delete operation.







	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 41 -



       13.5  _L_e_f_t_S_t_r_i_n_g

       LeftString (window, row,	column,	fill_char, value, attribute)
       struct window *window;
       int     row;
       int     column;
       char   *fill_char;
       char   *value;
       int     attribute;

       This procedure left justifies the specified value at posi-
       tion (row, column) in the specified window.  ``fill_char''
       is used as background text.  The	attribute argument speci-
       fies the	visual attribute that is to be applied to the
       string.	See the	Set_Attribute()	procedure for a	list of
       available visual	attributes.



       13.6  _C_e_n_t_e_r_S_t_r_i_n_g

       CenterString (window, row, column, fill_char, value, attribute)
       struct window *window;
       int     row;
       int     column;
       char   *fill_char;
       char   *value;
       int     attribute;

       This procedure centers the specified value at position (row,
       column) in the specified	window.	 ``fill_char'' is used as
       background text.	 The attribute argument	specifies the
       visual attribute	that is	to be applied to the string.  See
       the Set_Attribute() procedure for a list	of available visual
       attributes.



       13.7  _R_i_g_h_t_S_t_r_i_n_g

       RightString (window, row, column, fill_char, value, attribute)
       struct window *window;
       int     row;
       int     column;
       char   *fill_char;
       char   *value;
       int     attribute;

       This procedure right justifies the specified value at


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 42 -



       position	(row,column) in	the specified window.
       ``fill_char'' is	used as	background text.  The attribute
       argument	specifies the visual attribute that is to be
       applied to the string.  See the Set_Attribute() procedure
       for a list of available visual attributes.


       14.  SSSSccccrrrroooollllllllaaaabbbblllleeee RRRReeeeggggiiiioooonnnnssss

       These routines create and free scrollable regions.
       New_Scroll_Region does more work	than New_Region.  It will
       create the window and the region	field in addition to the
       list of fields.

       14.1  _N_e_w___R_e_g_i_o_n__-__C_r_e_a_t_e__a__s_c_r_o_l_l_a_b_l_e__r_e_g_i_o_n

       New_Region (window, field_list, count, rows, field_region, skip)
       struct window  *window;
       struct field_item     **field_list;
       int     count;
       int     rows;
       struct field_item     **field_region;
       int     skip;

       This procedure creates a	list of	fields for a scrollable
       region. Scrollable regions allow	the programmer to collect
       ROWS lines of fields in an N line area, where ROWS may be
       greater than N.	A scrollable region may	be used	much like a
       regular field.  The arguments to	New_Region() are as fol-
       lows.

	  +o window

	    This is a pointer to a window structure obtained from a
	    call to the	function New_Window().	Scrolling is con-
	    fined to the specified window.

	  +o field_list

	    This is an array of	fields created with the	New_Field()
	    function.  This is the list	of fields that will be
	    repeated on	each line of the scrollable region.  This
	    list may contain one or more fields.  Fields may be	on
	    more than one row.	Row positions should start at 0.

	  +o count

	    This is the	number of fields in the	``field_list''
	    array.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 43 -



	  +o rows

	    This is the	number of lines	to be included in the
	    scrolling region.

	  +o field_region

	    This is the	array of fields	that will be used in the
	    scrollable region. This is a one dimensional array of
	    field pointers.  Care should be taken to guarantee that
	    field_region contains at least ``count'' time ``rows''
	    field pointers.

	  +o skip

	    This is the	number of lines	to skip	between	rows in	the
	    region.

       Once the	scrollable region has been constructed it may be
       attached	to another list	of fields.  A scrollable region
       used in this fashion can	be treated essentially like one
       field by	the programmer.	 Show_List() and Get_List() can	be
       used to perform the appropriate actions.

       The following two lines of code is a sample set up for a
       scrollable region.  A CMREGN field is a field that points to
       an array	of fields created with the New_Region()	procedure.

	       New_Region (reg_window, fline, 4, 20, fregion, 1);

	       f[2] = New_Field	(9, 12,	CMREGN,	(char *) fregion,
		       (char *)	(4 * 20), 0);

       The arguments to	New_Field() for	CMREGN are somewhat dif-
       ferent than those used to create	the other field	types.	The
       (row,column) position should be the top left hand corner	of
       the window (this	will be	used for mouse and cursor movement
       selection).  The	``fill_char'' argument is a pointer to the
       array of	fields.	 The ``help'' argument is the number of
       fields in the array.

       Appendix	F contains a sample C based form that uses a
       scrollable region.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 44 -



       14.2  _N_e_w___S_c_r_o_l_l___R_e_g_i_o_n

       struct field_item       *
       New_Scroll_Region (row, column, height, width, sample_list, count,
       repetitions, skip, region_list, parent_window)
       int     row;
       int     column;
       int     height;
       int     width;
       struct field_item       *sample_list[];
       int     count;
       int     repetitions;
       int     skip;
       struct field_item       *region_list[];
       struct window   *parent_window;

       This procedure creates a	new scrollable region and returns a
       pointer to a field of type CMREGN.  It creates a	new window
       and places the list in that window.  The	arguments are used
       as follows:

	  +o row

	    This is the	row or line position of	the upper left
	    corner of the window containing the	region.	 Row and
	    column are based relative to parent_window or to the
	    upper left corner of the screen if parent_window is	0.

	  +o column

	    This is the	column position	of the new window.

	  +o height

	    This is the	height of the new window in rows.

	  +o width

	    This is the	width of the new window	in columns.

	  +o sample_list

	    This is a list of fields that represents one repetition
	    of the fields in the new region.

	  +o count

	    This is the	number of fields in the	sample_list list of
	    fields.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 45 -



	  +o repetitions

	    This is the	number of times	the sample_list	list of
	    fields will	be repeated in the region.

	  +o skip

	    This is the	number of rows to skip between repetitions
	    of the sample_list list of fields.

	  +o region_list

	    This is the	array of field pointers	that will be used
	    in the new region.	This must contain (count * repeti-
	    tions) number of fields.

	  +o parent_window

	    The	new region window will be placed relative to the
	    parent_window.  See	New_Rel_Window() for an	explanation
	    of related windows.	 If parent_window is 0,	the new
	    window will	be positioned with absolute coordinates	and
	    can	only be	moved (row, column and depth) independently
	    of other windows.



       14.3  _F_r_e_e___R_e_g_i_o_n

       Free_Region (field_ptr)
       struct field_item       *field_ptr;

       This procedure frees the	space associated with a	field of
       type CMREGN created with	New_Field() and	either New_Region()
       or New_Scroll_Region().	It also	deletes	the region from	the
       display.	 If the	field is not a CMREGN field, the field will
       be freed	and deleted from the display.


       15.  MMMMeeeennnnuuuussss

       These routines create, free and control the display of menus
       on the screen.  There are two basic types of menus, best-
       match menus and menus of	fields.	 New_Menu and Free_Menu
       treat menus as a	region of fields.  Other routines treat
       menus as	a simple list of items.	 End-user interaction is
       different for the two menu types.  See [5] for a	more com-
       plete description of match style	menus.



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 46 -



       15.1  _N_e_w___M_e_n_u__-__C_r_e_a_t_e__a__M_e_n_u__a_s__a__S_c_r_o_l_l_a_b_l_e__R_e_g_i_o_n

       New_Menu	(field_ptr, xorigin, yorigin, height, width,
		       orient, fregion,	field_count)
       struct field_item  *field_ptr;
       int     xorigin;
       int     yorigin;
       int     height;
       int     width;
       char   *orient;
       struct field_item ***fregion;
       int    *field_count;

       This procedure creates menus from CMKEY or CMKEY_LIST
       fields. The item	that is	selected from the menu is placed in
       the keyword field.  This	procedure creates an array of
       fields, one per keyword and a window for	displaying the new
       menu.  Menus created using this routine scroll to display
       long lists of keywords.	Keywords may also be displayed
       vertically or horizontally in columns.  The following is	a
       description of the arguments to the procedure.

	  +o field_ptr

	    This is a pointer to a field structure created with	a
	    call to New_Field().  The field must be a CMKEY or
	    CMKEY_LIST type.

	  +o xorigin

	    This is the	row origin for the menu	window.

	  +o yorigin

	    This is the	column origin for the menu window.

	  +o height

	    This is the	height for the menu window.

	  +o width

	    This is the	width for the menu window.

	  +o orient

	    This is the	orientation for	the menu window.  The first
	    character of the string should be an ``h'' for horizon-
	    tal	or a ``v'' for vertical.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 47 -



	  +o fregion

	    This is a pointer to an array of field pointers.  The
	    newly created fields will be created using these
	    pointers.  Be careful to allocate enough pointers.

	  +o field_count

	    This is a pointer to an integer in which the number	of
	    fields (count) will	be returned.

       The return from New_Menu() is a boole that specifies if the
       menu was	created.  malloc() is used to create the new menu.

       The following is	a code fragment	for using New_Menu() to
       create static menus.

	       fkeys = New_Field (6, 33, CMKEY,	"____________",
			       0, "a few key words");

	       Set_Label (fkeys, "left", "Selection: ",	FANORMAL);

	       if (New_Menu (fkeys, 19,	20, 8, 40, "hvertizontal",
			       &fregion, &count))
	       {
		       f[new] =	New_Field (fregion[0] -> window	-> _x_pos,
				       fregion[0] -> window -> _y_pos,
				       CMREGN,
				       (char *)	fregion, (char *) count, 0);

		       Pop_Window (fregion[0] -> window,
				       f[index]	-> window -> _depth - 1);
	       }

	       Show_List (f, count);

	       Get_List	(f, count, FALSE, FALSE);

       For pop-up style	menus use something like the following.
       N_M_pre_pop_up is included in the Tabs library.	It pops	up
       the region window to make it visible, calls Get_List() for
       the region, pushes the region window to make it disappear
       and then	returns	the index to the next field.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 48 -



	       extern int N_M_pre_pop_up ();

	       f[new] =	New_Field (6, 33, CMKEY, "____________",
			       0, "a few key words");

	       Set_Label (f[new], "left", "Selection: ", FANORMAL);

	       if (New_Menu (f[new], 19, 20, 8,	40, "hvertizontal",
			       &fregion, &count))
	       {
		       f[new] -> user_pointer =	(char *) fregion;
		       f[new] -> user_mask = count;
		       Set_Actions (f[new], N_M_pre_pop_up, 0);
	       }

	       Show_List (f, count);

	       Get_List	(f, count, FALSE, FALSE);




       15.2  _F_r_e_e___M_e_n_u

       Free_Menu (fregion, count)
       struct field_item **fregion;
       int count;

       This procedure frees the	space associated with the specified
       list of fields.	The fields must	have been created with the
       New_Menu() procedure.  This routine does	not delete the
       fields or labels	from the window	display.



       15.3  _N_e_w___M_a_t_c_h___M_e_n_u

       New_Match_Menu (field_ptr, xorigin, yorigin, max_height,	max_width,
			  orient, type)

       struct field_item *field_ptr;
       int     xorigin;
       int     yorigin;
       int     max_height;
       int     max_width;
       char   *orient;
       char   *type;




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 49 -



       This function creates menus from	keywords defined in exist-
       ing CMKEY or CMKEY_LIST fields.	Menus are displayed in a
       separate	window created by New_Match_Menu().  The CMKEY or
       CMKEY_LIST field	serves as a response field for the menu.
       As characters are typed into the	response field,	the
       response	is matched against the items in	the menu.  The
       closest	match as determined by the crosscor() function.
       The item	most closely matching the user's input is
       highlighted and	pointed	at with	">".  This is repeated for
       each character entered by the user until	the user moves to
       the next	field.

       The number of selections	for the	menu can be set	with the
       function	Set_M_Selections() described below.  The default is
       one selection.  The user	enters the multiple selection char-
       acter to	begin a	new  match area	in the response	field.	The
       field is	divided	into sections separated	by the multiple
       selection character (the	default	is "|",	see Def_M_Char()
       below).	For each match area a separate best match is deter-
       mined.  The item	in the menu that matches is marked with	a
       ">".  The other matched items are marked	with a "+".  When
       the user	tries to select	too many items the left	most  match
       area in the response field is deleted.  With a single char-
       acter field the effect is the same as hitting the line kill
       key (i.e. it erases the field).

       The display of the menu window can be delayed (see
       Set_M_Delay()).	Delaying the menu allows users to move
       quickly within a	form, avoiding popup menus.  The delay also
       allows experienced to avoid menus.  Providing user-
       selectable delays for menus is one way to allow users to
       adapt the system	to their own level of expertise.

       There are two types of menus; popup and static.	Popup menus
       only appear when	the cursor is in the response field.
       Static menus are	always at one depth less than the response
       field.	Menus can either be vertical or	horizontal.  Items
       in vertical menus are left justified and	are listed top to
       bottom.	Additional columns are added as	needed up to the
       maximum allowed by the width of the menu	window.	 Items in
       horizontal menus	are centered and listed	left to	right.
       Additional rows are added as needed up to the maximum height
       of the menu window.

       The size	of a menu window is adjusted to	fit the	number of
       items.  For vertical menus, the window is collapsed right to
       left, then bottom to top.  For horizontal menus,	the window
       is collapsed bottom to top, then	right to left.	If the
       items don't fit in the window, the menu is not displayed.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 50 -



       The help	message	will show what items can be selected, and
       the user	can find out what item(s) matches the contents of
       the response area with the completion key or by going to
       another field.  The contents of the response area are always
       expanded	when the user leaves the field.

       If the xorigin or yorigin is less than zero the size and
       location	of the window are set by the menu function.  The
       menu window is centered above the response field	if the
       field is	in the bottom half of the screen and below the
       response	field if the field is in the top half of the
       screen.	If you choose to let the menu function determine
       the location of the window you will not have to re-calculate
       where the menu window should go each time you move the
       response	field.

       The user_pointer	in the field_items structure for the
       response	field is used to point to the menu structure (see
       below).	The item selected is in	the usual place,
       field_ptr->txbuf, and can be retrieved using Field_Value().
       The index to the	first item in the response field is in
       field_ptr->fndfv	and is 0 based.	 See Set_M_Selections()	for
       what happens when there is more than one	selection.

       Menus created with New_Match_Menu() need	a post_action rou-
       tine, Post_Match_Menu() (see below).  It	is assigned as the
       post_action routine in the call to New_Match_Menu().  If	you
       write a post_action routine, call Post_Match_Menu from your
       routine.	 Be sure to assign your	post_action routine after
       the call	to New_Match_Menu().

       New_Popup_Menu(), New_Static_Menu() and New_Fixed_Menu()
       provide a higher-level interface	for creating menus.

       The arguments to	New_Match_Menu() are used as follows:

	  +o field_ptr

	    This is a pointer to a field structure created with	a
	    call to New_Field().  The field must be a CMKEY or
	    CMKEY_LIST type.

	  +o xorigin

	    This is the	row origin (upper left corner) for the menu
	    window.  If	``xorigin'' is less than 0, the	location
	    and	size of	the menu window	are determined automati-
	    cally by New_Match_Menu().



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 51 -



	  +o yorigin

	    This is the	column origin for the menu window.  If
	    ``yorigin''	is less	than 0,	the location and size of
	    the	menu window are	determined automatically by
	    New_Match_Menu().

	  +o max_height

	    This is the	maximum	possible height	for the	menu window
	    and	the maximum possible number of rows of items.
	    ``max_height'' is ignored if ``xorigin'' or	``yorigin''
	    is less than 0.

	  +o max_width

	    This is the	maximum	possible width for the menu window.
	    This is used to determine the maximum possible number
	    of columns.	 The number of columns is determined with
	    the	following calculation:	``max_width'' /	(length	of
	    longest item + 3 ).	 ``max_width'' is ignored if
	    ``xorigin''	or ``yorigin'' is less than 0.

	  +o orient

	    This is the	orientation for	the menu window.  The first
	    character of the string should be an "h" for horizontal
	    and	a "v" for vertical.  See above for a description of
	    what vertical and horizontal mean.

	  +o type

	    Type is either popup or static.  The first letter must
	    be a "p" for popup and an "s" for static.

       The following is	a code fragment	for using New_Match_Menu()
       to create a popup menu.














	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 52 -



	       f[index]	= New_Field (6,	33, CMKEY, "__________", 0,
					"a few items");

	       Set_Label (f[index], "left", "Choice: ",	FANORMAL);

	       if (New_Match_Menu (f[index], 8,	33, 10,	45,
					     "vertical", "popup")
			       == FALSE)
	       {
		       Print_Message (stdwindow, FANORMAL,
			       "Cannot create match menu");
	       }

	       index++;

	       Show_List (f, index);

	       Get_List	(f, index);




       15.4  _F_r_e_e___M_a_t_c_h___M_e_n_u

       Free_Match_Menu (field_ptr)
       struct field_item      *field_ptr;

       This procedure frees any	space created by the call to
       New_Match_Menu()	associated with	the specified field.  The
       field itself is not freed.



       15.5  _N_e_w___P_o_p_u_p___M_e_n_u

       New_Popup_Menu (field_ptr, delay, location)
       struct field_item       *field_ptr;
       int     delay;
       char    *location;

       This procedure creates a	popup menu from	a CMKEY	or
       CMKEY_LIST field.  It is	a higher-level interface for creat-
       ing New_Match_Menu() style popup	menus.	Popup menus created
       with New_Popup_Menu are always layed out	vertically and are
       not confined to the window the response field is	in the way
       static menus are.  ``delay'' is the delay in seconds between
       characters before the menu appears (see Set_M_Delay()).
       ``location'' is the same	as for New_Static_Menu().
       Post_Match_Menu() and New_Match_Menu() describe how to use


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 53 -



       post action routines for	popup mens.  See also
       Set_M_Selections(), Def_M_Char(), Set_M_Delay() and
       Free_Match_Menu().



       15.6  _N_e_w___F_i_x_e_d___M_e_n_u

       New_Fixed_Menu (field_ptr, window, orient)
       struct field_item       *field_ptr;
       struct window   *window;
       char    *orient;

       This routine displays the menu items in the ``window''
       passed to it or,	if ``window'' is 0, it creates a borderless
       window across the top of	the screen and displays	the items
       in that window.	This routine does not touch the	window
       except to display items in the window.  That is,	it does	not
       move the	window in depth	when the user enters the field nor
       does it clear the window	or push	it when	the user leaves	the
       field.  ``orient'' is the same as it is for
       New_Match_Menu().  If you use a post-action routine with	a
       New_Fixed_Menu()	field be sure to call Post_Match_Menu()
       from within the post-action routine as described	in
       New_Match_Menu().



       15.7  _N_e_w___S_t_a_t_i_c___M_e_n_u

       New_Static_Menu (field_ptr, max_height, location)
       struct field_item       *field_ptr;
       int     max_height;
       char    *location;

       This procedure creates a	static menu from a CMKEY or
       CMKEY_LIST field.  It is	a higher-level interface for creat-
       ing New_Match_Menu() style static menus.	 Static	menus
       created with New_Static_Menu() are always layed out horizon-
       tally within the	window the response field is in.
       ``max_height'' is the maximum possible height in	rows the
       menu window can be.  ``location'' is where the menu window
       will be located as follows:

	  +o left - left	of the field.  The window will start at	the
	    same row as	the field and extend to	the left and down.

	  +o right - right of the field.	 The window will start at
	    the	same row as the	field and extend to the	right and


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 54 -



	    down.

	  +o above or over - above the field.  The window will be
	    centered above the field and extend	left, right and	up.

	  +o under - below the field.  The window will be centered
	    below the field and	extend left, right and down.

	  +o top	- across the top of the	window the field is in,
	    extending down.

	  +o bottom - across the	bottom of the window the field is
	    in,	extending up.

       Before static menus will	appear,	Show_Static_Menu() must	be
       called.	The end-user interaction is the	same as	for
       New_Match_Menu().  See also Set_M_Selections(),
       Def_M_Char(), Free_Match_Menu(),	New_Fixed_Menu() and
       New_Popup_Menu().



       15.8  _S_h_o_w___S_t_a_t_i_c___M_e_n_u

       Show_Static_Menu	(field_ptr)
       struct field_item       *field_ptr;

       This procedure displays a menu created by New_Static_Menu().



       15.9  _D_e_f___M___C_h_a_r

       Def_M_Char (mult_char)
       char    mult_char;

       The menu	response field is divided into sections	separated
       by the multiple selection character, ``mult_char''.  For
       each response section a separate	best match is determined.
       The user	may type the ``mult_char'' key to end one selection
       area and	begin another.	The default key	is `|'.	 See also
       Set_M_Selections();









	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 55 -



       15.10  _S_e_t___M___S_e_l_e_c_t_i_o_n_s

       Set_M_Selections	(field_ptr, max_selections, match_index)
       struct field_item       *field_ptr;
       int     max_selections;
       int     match_index[];

       This procedure sets the maximum number of selections for	a
       menu created with New_Match_Menu(), New_Static_Menu(),
       New_Fixed_Menu()	or New_Popup_Menu().  The default number of
       selections is one.  Match areas in the response field are
       separated by the	multiple selection character (default '|',
       see Def_M_Char()).  For each match area a separate best
       match is	determined.  When the user tries to make more than
       ``max_selections'' number of selections,	the leftmost match
       area in the response field is removed.  For a single selec-
       tion menu, the multiple selection character has the same
       effect as the field erase character.

       ``match_index'' is an array of integers that upon return
       will contain the	indexes	to the matched items.  It must be
       declared	as having ``max_selections'' plus 1 number of ele-
       ments.  Upon return the first element in	the array contains
       the number of selections	the user made.	Subsequent elements
       contain the indexes to the first, second, etc selections.
       Since the contents of the field may not be expanded if the
       field is	not long enough, the ``match_index'' array should
       be used to identify the responses rather	than the contents
       of the field.

       When using the mouse, items are added by	clicking the left-
       most button when	the pointer is over the	item in	the menu.
       Clicking	the same button	over a previously selected item
       will end	selection.



       15.11  _S_e_t___M___D_e_l_a_y

       Set_M_Delay (field_ptr, delay)
       struct field_item       *field_ptr;
       int     delay;

       This procedure sets the delay for popup menus created with
       New_Match_Menu()	and New_Popup_Menu().  ``delay'' is the
       number of seconds the user must wait between keystrokes
       before a	popup menu will	appear.	 The menu window will not
       appear as long as the user hits a key every ``delay'' or
       fewer seconds.  It is useful to delay the presentation of a


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 56 -



       menu at least one second	in case	the user is just passing
       through the field in route to another field.  Otherwise,	the
       menu pops up and	disappears every time the user enters and
       leaves the field.  A longer delay means experienced users do
       not have	to look	at the menus except when there is a need
       to.



       15.12  _D_e_f___M_a_t_c_h___T_y_p_e

       Def_Match_Type (match_routine)
       int     (*match_routine)();

       This routine lets you assign a different	match routine for
       menus created with New_Match_Menu(), New_Static_Menu,
       New_Popup_Menu and New_Fixed_Menu().  The default best match
       selection routine is included here as an	example.  The new
       ``match_routine'' will be called	with the same arguments	as
       the crosscor() routine.	It is called once for each item	in
       the menu	for every character typed by the user.	The calling
       routine expects a score to be returned for each item and	it
       will make the item with the highest score the matched item.

       /*
	*
	*    cross correlation routine for determining best matches
	*
	*    crosscor (response, item, type)
	*
	*    response -	the user's response
	*    item - the	word the response will be scored against - list	item
	*    type - 0 for menu match, 1	for spelling corrector
	*
	*    This procedure produces correlation scores	between	two words
	*    (user's response and list item).  It is important that the
	*    user's response is	the first argument and the list	item is
	*    the second.
	*/

       #define POINTS	 5000

       crosscor	(response, item, type)
       char    *response;  /* user's response */
       char    *item;	   /* the word the response will be scored  against */
       char    type;	   /* type = 0 for menu	match, 1 for spelling corrector	*/
       {
	   register char    *presp;
	   register char    *pitem;


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 57 -



	   char	   *pprev_match;
	   int	   lens;
	   int	   lent;
	   register int	   match_pos;
	   register int	    score = 0;
	   char	   item_buf[256];
	   register char    *pitem_buf;

	   if ((lens = strlen (response)) == 0)
	       return (-1);
	   if ((lent = strlen (item)) == 0)
	       return (-1);

	   strcpy (item_buf, item);

	   /* if first item matches give it additional weight */
	   if (*item_buf == *response)
	       score +=	(2 * POINTS);

	   presp = response;
	   pprev_match = item +	lent;
	   while (*presp)
	   {
	       pitem = item;
	       pitem_buf = item_buf;
	       while (*pitem)
	       {
		   if (*presp == *pitem_buf)
		   {
		       /* make character 0 - can't be matched again */
		       *pitem_buf = ' ';

		       /* get position of match	in item	string */
		       match_pos = (pitem - item)*100;

		       /* increase score */
		       score +=	(POINTS	- (match_pos));

		       /* increase score if previous character also matches */
		       if (pitem != item && presp != response)
			   if (*(presp - 1) == *(pitem - 1))
			       score +=	(POINTS	- match_pos);

		       /* increase score if next character also	matches	*/
		       if ((*(presp + 1) == *(pitem + 1)) && *(presp + 1))
			   score += (POINTS - match_pos);

		       /* increase score if this match and prev	were
			* in left to right order in the	item string


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 58 -



			*/
		       if (pitem >= pprev_match)
			   score += (POINTS - match_pos);

		       pprev_match = pitem;
		       break;
		   }
		   pitem++;
		   pitem_buf++;
	       }
	       presp++;

	       /* reduce score if no match for current response	character */
	       if (*pitem == ' ')
		   score -= (2 * POINTS);
	   }
	   if (type == 1)
	       /* spelling match - heavier penalty for missing characters */
	       score +=	(lens -	lent) *	POINTS;
	   else
	       score +=	lens - lent; /*	can remove if items are	sorted */
	   if (score)
	       return (score);
	   else
	       return (-1);
       }

       Note the	comment	on the sixth line from the bottom.  This
       line can	be removed if the menu items are sorted.  Normally,
       the best	match routine gives a small penalty for	extra char-
       acters in the item so that the list of items does not have
       to be sorted.  The shortest of otherwise	equal matching
       items will have the highest score.  This	is appropriate if
       the list	is sorted.  If this line is removed and	there is
       more than one item with the same	highest	score, the first
       item with that score will be picked.  Removing this line
       will result in a	better selection technique provided that
       items are sorted.



       15.13  _P_o_s_t___M_a_t_c_h___M_e_n_u

       Post_Match_Menu (field_ptr, count, index, rc)
       struct field_item       *field_ptr;
       int     count;
       int     index;
       int     rc;



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 59 -



       This is the post_action routine required	by menus created
       with New_Match_Menu().  It is assigned as the post_action
       routine in the call to New_Match_Menu().	 If you	write a
       post_action routine, call Post_Match_Menu() from	that rou-
       tine and	assign the post_action routine after the call to
       New_Match_Menu().  Post_Match_Menu() resets global menu
       variables and copies the	index to the first selection from
       the response field into field_ptr -> fndfv.  It requires	the
       standard	arguments for a	post_action routine and	always
       returns the index to the	current	field.


       16.  FFFFiiiieeeelllldddd OOOOvvvveeeerrrrfffflllloooowwww aaaannnndddd EEEExxxxtttteeeennnnssssiiiioooonnnn

       These routines control what happens when	the user reaches
       the end of a field.  An user-defined function can be
       assigned	to be called when the field overflows.	Sample
       field-extension routines	are included.




       16.1  _S_e_t___O_v_e_r_f_l_o_w

       Set_Overflow (field_ptr,	flag)
       struct field_item       *field_ptr;
       int     flag;

       This procedure enables or disables the overflow action (see
       Def_Overflow_Action) for	a particular field.  Whatever func-
       tion is defined in Def_Overflow_Action()	will be	applied	to
       the field when the user reaches the end of the field.



       16.2  _S_e_t___E_x_t_e_n_d

       Set_Extend (field_ptr, fill_char)
       struct field_item       *field_ptr;
       char    *fill_char;

       This procedure marks a field as extendable if ``fill_char''
       is longer than the current fill_char string in the field
       structure (see below) or	unextendible if	it is shorter.
       This routine calls Set_Overflow() with the appropriate
       values and sets up the field for	use with an extension rou-
       tine as defined by a call to Def_Overflow_Action().  For
       examples	of extension routines see Extend(), Ext_Field()	and
       Ext_Long_Field().


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 60 -



       16.3  _D_e_f___O_v_e_r_f_l_o_w___A_c_t_i_o_n

       Def_Overflow_Action (function)
       int     (*function)();

       This procedure defines the function that	will be	called when
       the user	reaches	the end	of a field.  The function will be
       called if the overflow action has been enabled for that
       field by	Set_Overflow() or Set_Extend().	 A 0 for ``func-
       tion'' will turn	off the	overflow action	and the	default	is
       no action.  See Extend(), Ext_Field() and Ext_Long_Field()
       for examples of overflow	functions.  If writing your own
       extension routines, you should also look	at the way
       Set_Extend() sets up elements in	the field structure for	use
       by Extend, etc.	``ext_fill_char'' in the field structure
       was included for	use with extension/field overflow func-
       tions.  For example, it is treated as the background text
       for the largest possible	field by Set_Extend() and the asso-
       ciated functions.



       16.4  _E_x_t_e_n_d

       Extend (field_ptr)
       struct field_item       *field_ptr;

       This procedure will extend a field one character	if this
       function	has been setup as the overflow function	(see
       Def_Overflow_Action()).	Action will be taken if	the field
       is not as long as the fill character string passed to
       Set_Extend() and	the user has reached the end of	the field.
       Extend()	does not check to see if it will write over another
       field.  Ext_Field() and Ext_Long_Field()	check the position
       of other	fields and move	them, then call	Extend() to expand
       the field.  This	is the simplest	of the extend routines.















	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 61 -



       16.5  _E_x_t___F_i_e_l_d

       Ext_Field (field_ptr)
       struct field_item       *field_ptr;

       This procedure will extend a field one character	if this
       function	has been setup as the overflow function	(see
       Def_Overflow_Action()).	Action will be taken if	the field
       is not as long as the fill character string passed to
       Set_Extend() and	the user has reached the end of	the field.
       The position of other fields is checked so that they are	not
       overwritten.  Other fields are moved to the right if there
       is room on the line.  The field will not	be extended if
       fields to the right can not be moved or there is	no room	to
       extend the field	on the line.  Fields to	the right will not
       be moved	if they	have labels above or below the field.


       16.6  _E_x_t___L_o_n_g___F_i_e_l_d

       Ext_Long_Field (field_ptr)
       struct field_item       *field_ptr;

       This procedure is like Ext_Field() except that it will move
       fields down a row if there is no	room to	the right.  If
       necessary (and if there is room), fields	will be	moved to
       make room for the field to be moved to the next line.  If
       there is	no room	to move	other fields the field will not	be
       extended.  Instead of extendable	fields that go across lines
       it is usually better to use a scrollable	region created with
       New_Scroll_Region() or New_Region().  The
       New_Scroll_Region() procedure makes it easy to write an
       overflow	action that would replace a field with a scrollable
       region when the user overflowed the field.


       17.  SSSSccccrrrraaaattttcccchhhhppppaaaadddd aaaannnndddd MMMMaaaarrrrkkkkeeeedddd AAAArrrreeeeaaaassss

       These routines create and manipulate marked areas.
       Scratchpad operations are available for use with	marked
       areas.  Turning on marked areas enables character directives
       for sweeping out	areas with a mouse.









	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 62 -



       17.1  _N_e_w___M_a_r_k_e_d___A_r_e_a

       New_Marked_Area (area_index, top_row, top_col, bot_row, bot_col)
       int     area_index;
       int     top_row;
       int     top_col;
       int     bot_row;
       int     bot_col;

       This procedure creates a	marked area.  The area is not
       displayed on the	screen until ReShow_All_Lists()	is called
       so that more than one area can be created at a time.  There
       are a maximum of	three areas that can be	marked.	 Therefore,
       ``area_index'' can have a value of 1, 2 or 3.  The upper
       left corner of the area is defined by ``top_row'' and
       ``top_col''.  The lower right corner of the area	is defined
       by ``bot_row'' and ``bot_col''.	Def_Marked_Areas() enables
       or disables marked areas	and Set_Area_Attributes() deter-
       mines the attributes with which the marked area will be
       displayed.  Clear_Marked_Areas()	resets all marked areas.



       17.2  _D_e_f___M_a_r_k_e_d___A_r_e_a_s

       Def_Marked_Areas	(flag)
       int     flag;

       This procedure enables (when flag is TRUE) or disables (when
       flag is FALSE) the display of marked areas.  Mouse functions
       are enabled so that sweeping with a mouse will mark an area.
       New_Marked_Area() creates a marked area and
       Clear_Marked_Areas() resets marked areas.  The default is
       FALSE.  When flag is TRUE mouse character directives are
       enabled so that sweeping	with a mouse will mark an area.



       17.3  _C_l_e_a_r___M_a_r_k_e_d___A_r_e_a_s

       Clear_Marked_Areas ()

       This procedure resets marked areas by turning off the areas
       and reshowing all lists on the screen.







	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 63 -



       Def_Area_Attributes (flags)
       int     flags;

       This procedure defines the attributes flags to be used when
       marked areas are	displayed.  ``flags'' is just like the
       flags argument to Set_Attributes().



       17.4  _D_e_f___S_c_r_a_t_c_h_p_a_d

       Def_Scratchpad (flag)
       boole   flag;

       This procedure enables (when flag is TRUE) or disables (when
       flag is FALSE) scratchpad operations for	marked areas.  The
       default is FALSE.  The scratchpad operations and	keystrokes
       necessary to invoke the operations are as follows:

	  +o CTRL(X)x - (cut) - cut the contents	of the marked area
	    to the scratchpad.

	  +o CTRL(X)c - (copy) -	copy the contents of the marked
	    area to the	scratchpad.

	  +o CTRL(X)a - (append)	- append the contents of the marked
	    area to the	scratchpad.

	  +o CTRL(X)p - (paste) - paste the contents of the
	    scratchpad.

	  +o CTRL(X)d - (delete)	- delete the contents of the marked
	    area.

       Def_Scratchpad()	calls Def_Marked_Areas() with flag equal to
       TRUE, calls New_Marked_Area() to	create marked areas and
       calls Clear_Marked_Areas() to remove them.  See also
       Def_Area_Attributes().


       18.  WWWWiiiinnnnddddoooowwwwssss

       18.1  _A_n__I_n_t_r_o_d_u_c_t_i_o_n  The windowing provided with Tabs is
       produced	via a set of functions and procedures.	These rou-
       tines are used to manipulate a window data structure.  Win-
       dows produced by	this window package act	essentially like
       independent CRT screens with tab	stops, scrolling, and cur-
       sor movement.  Those who	wish to	know more of the internal
       structure of the	windows	should consult the windows.h header


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 64 -



       file.

       Two types of scrolling are available.  With normal scrolling
       the entire window will move up one line when a newline is
       printed on the bottom line of window or (when the bottom
       line of the window extends to the right hand edge of the
       window).	 MIT scrolling is a much more efficient	method of
       scrolling, especially when used on terminals that have no
       line insert and delete capabilities.  In	this case overflow
       from the	bottom line of the window goes to the top line of
       the window.  This method	of scrolling is	used on	some old
       systems at MIT, hence the term.

       The following line sets the scrolling in	the help window	to
       the MIT variety.

	       errwindow -> _type_scroll = FALSE;

       18.2  _W_i_n_d_o_w__F_u_n_c_t_i_o_n_s__a_n_d__P_r_o_c_e_d_u_r_e_s  The following is a
       list of the most	commonly used functions	and procedures for
       manipulating windows.



       18.2.1  _N_e_w___W_i_n_d_o_w__-__C_r_e_a_t_e__a__n_e_w__w_i_n_d_o_w

       struct window  *
       New_Window (newwindow)
       struct SWindow  newwindow;

       This function creates a new window with the specified
       characteristics.	 The function allocates	space for the
       specified window.  New_Window also guarantees legal place-
       ment of the new window.	No screen updating is performed	to
       allow the user to create	more than one window with only one
       screen update (see Ref_All_Windows()).

       The following is	the current contents of	the window specifi-













	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 65 -



       cation structure.

       struct SWindow
       {
	       int top_x;
	       int top_y;
	       int lines;
	       int cols;
	       int depth;
	       char box_h;
	       char box_v;
	       char type_scroll;
	       int  box_attribute;
       };

	  +o top_x - The	row number for the upper left hand corner
	    of the window

	  +o top_y - The	column number for the upper left hand
	    corner of the window

	  +o lines - The	number of lines	to be included in the win-
	    dow

	  +o cols - The number of columns to be included	in the win-
	    dow

	  +o depth - The	artificial depth at which the window is	to
	    be displayed (0 to INVISIBLE - currently 200)

	  +o box_h - The	horizontal boxing character - If ``box_h''
	    is zero no box will	be drawn.

	  +o box_v - The	vertical boxing	character

	  +o box_attribute - The	visual attributes to be	used for
	    boxing the window.

	  +o type_scroll	- The type of scrolling	to be used in the
	    window - Specify FALSE for MIT style scrolling.

       The value returned is a pointer to the new window.  If a	new
       window cannot be	allocated, -1 is returned.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 66 -



       18.2.2  _F_r_e_e___W_i_n_d_o_w

       int
       Free_Window (window)
       struct window  *window;

       This function deletes the specified window.  The	storage
       associated with the window is freed.  The map of	the screen
       is also updated.	 No screen updating is performed.  This
       allows more than	one window to be deleted with one screen
       update (see Ref_All_Windows()).

       The value returned is the new total number of active win-
       dows.  If the window is not one of the list of windows -1 is
       returned.



       18.2.3  _P_o_p___W_i_n_d_o_w

       Pop_Window (window, depth)
       struct window  *window;
       int depth;

       This procedure moves the	specified window to the	specified
       depth. Depths run from zero, furthest forward, to INVISIBLE
       (currently set at 200).



       18.2.4  _P_u_s_h___W_i_n_d_o_w

       Push_Window (window)
       struct window  *window;

       This procedure moves the	specified window to level INVISIBLE
       (currently set at 200).	This makes the window seem to
       disappear.













	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 67 -



       18.2.5  _M_o_v_e___W_i_n_d_o_w

       void
       Move_Window (window, toprow, topcolumn, depth)
       struct window *window;
       int     toprow;
       int     topcolumn;
       int     depth;

       This procedure moves the	specified window to the	indicated
       (row,column) and	simulated depth.  Move_Window guarantees
       legal placement of the window.  No screen updating is per-
       formed to allow the user	to move	more than one window with
       only one	screen update (see Ref_All_Windows()).



       18.2.6  _D_u_p___W_i_n_d_o_w

       Dup_Window (window)
       struct window   *window;

       This procedure duplicates a window created with New_Window()
       and returns a pointer to	the new	window.	 The new window
       will be at the same row and column as the original but will
       have a depth one	position nearer	to the top.



       18.2.7  _W_r_e_f_r_e_s_h

       void
       Wrefresh	(window)
       struct window *window;

       This procedure updates the specified window.  This procedure
       assumes that windows at depths greater than the defined con-
       stant INVISIBLE are not visible.	 INVISIBLE is currently	set
       at 200.



       18.2.8  _R_e_f___A_l_l___W_i_n_d_o_w_s

       void
       Ref_All_Windows ()

       This procedure updates all of the windows.  This	procedure
       assumes that windows at depths greater than the defined


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 68 -



       constant	INVISIBLE are not visible.  INVISIBLE is currently
       set at 200. The update includes boxing the windows.



       18.2.9  _R_e_f_r_e_s_h

       void
       Refresh ()

       This procedure clears the screen	and then updates all of	the
       windows.	 This is useful	for recovering from things such	as
       ``wall''	messages.



       18.2.10	_N_e_w___R_e_l___W_i_n_d_o_w

       struct window   *
       New_Rel_window (SWindow,	parent_window)
       struct SWindow  SWindow;
       struct window   *parent_window;

       This procedure creates a	new window and positions it in a
       tree of window related windows.	It is placed beneath
       ``parent_window'' in the	tree.  When ``parent_window'' is
       moved with Move_Rel_window(), the new window and	all other
       windows beneath ``parent_window'' in the	tree are moved the
       same relative amount if possible.  Likewise, when
       ``parent_window'' is freed with Free_Rel_Window(), ``win-
       dow'' is	freed along with any other window beneath
       ``parent_window'' in the	tree.  See also	Pop_Rel_Window(),
       Push_Rel_Window(), Dup_Rel_Window(), and	Change_Parent().
       The elements in the SWindow structure are relative to the
       location	of ``parent_window'' instead of	absolute locations
       like they are with New_Window().	 This means, for example,
       that ``depth'' must be less than	0 if it	is to appear in
       front of	``parent_window.''  See	[6] for	more information on
       related windows.



       18.2.11	_F_r_e_e___R_e_l___W_i_n_d_o_w

       Free_Rel_Window (window)
       struct window   *window;

       This procedure calls Free_Window() for windows created with
       either New_Rel_Window() or New_Window().	 If ``window'' has


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 69 -



       dependent windows, they are also	freed.



       18.2.12	_P_o_p___R_e_l___W_i_n_d_o_w

       Pop_Rel_Window (window, depth)
       struct window   *window;
       int     depth;

       This procedure moves windows created with New_Rel_Window()
       or New_Window() in depth.  ``depth'' is the absolute new
       depth of	the window.  Popping the window	to a depth of
       INVISIBLE (currently set	at 200)	makes the window invisible.
       If ``window'' has dependent windows, they also get moved	the
       same relative amount as ``window''.



       18.2.13	_P_u_s_h___R_e_l___W_i_n_d_o_w

       Push_Rel_Window (window)
       struct window   *window;

       This procedure makes a window created with New_Rel_Window()
       or New_Window() invisible.  If ``window'' has dependent win-
       dows they are also made invisible.



       18.2.14	_M_o_v_e___R_e_l___W_i_n_d_o_w

       Move_Rel_Window (window,	top_row, top_column, depth)
       struct window   *window;
       int     top_row;
       int     top_column;
       int     depth;

       This procedure moves a window created either with
       New_Rel_Window or New_Window to a new row, column and depth
       location.  ``top_row'' is the new row for the upper left
       corner of the window.  ``top_column'' is	the new	column for
       the upper left corner of	the window.  ``top_row'' and
       ``top_column'' are absolute coordinates (relative to the
       upper left corner of the	screen).  If ``window''	has depen-
       dent windows they are moved the same relative amount so that
       the relative position and depth of the dependent	windows	to
       ``window'' are maintained.



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 70 -



       18.2.15	_D_u_p___R_e_l___W_i_n_d_o_w

       Dup_Rel_Window (window, type)
       struct window   *window;
       char    *type;

       This procedure duplicates a window created with
       New_Rel_Window()	or New_Window().  If the ``type'' is
       ``all'' and the windows has dependents, they will also be
       duplicated.  Otherwise, just ``window'' will be duplicated.
       Each new	window will be at the same row and column as the
       original	but will have a	depth one position nearer to the
       top.  It	is often necessary to reposition windows in the
       hierarchy or on the screen immediately after they are
       copied.	See Pop_Rel_Window(), Change_Parent() and
       Move_Rel_Window().



       18.2.16	_C_h_a_n_g_e___P_a_r_e_n_t

       Change_Parent (window, new_parent)
       struct window   *window;
       struct window   *new_parent;

       This procedure repositions a window in the hierarchical tree
       of windows.  All	windows	beneath	``window'' in the hierarchy
       remain beneath it.  See also New_Rel_Window(),
       Dup_Rel_Window(() and Move_Rel_Window().



       18.2.17	_w___m_g_o

       void
       w_mgo (window, row, column)
       struct window *window;
       int    row;
       int    column;

       This procedure moves the	(real and virtual) cursor to the
       (row,column) position in	the specified window.









	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 71 -



       18.2.18	_w___s_g_o

       void
       w_sgo (window, row, column)
       struct window *window;
       int     row;
       int     column;

       This procedure moves the	real cursor to the (row,column)
       position	in the specified window.



       18.2.19	_w___x_g_o

       void
       w_xgo (window, row, column)
       struct window *window;

       This procedure moves the	virtual	cursor to the (row,column)
       position	in the specified window.



       18.2.20	_w_c_l_r_l

       void
       wclrl (window)
       struct window *window;

       This procedure clears the rest of the current line in the
       specified window.



       18.2.21	_w_a_x_p_r_i_n_t_f__a_n_d__w_x_p_r_i_n_t_f















	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 72 -



       void
       waxprintf (window, attribute, sp, ap1, ap2, ap3,	ap4, ap5, ap6, ap7)
       int    attribute;

       and

       void
       wxprintf	(window, sp, ap1, ap2, ap3, ap4, ap5, ap6, ap7)
       struct window *window;
       char   *sp;
       char   *ap1;
       char   *ap2;
       char   *ap3;
       char   *ap4;
       char   *ap5;
       char   *ap6;
       char   *ap7;

       These procedure are window based	printfs.  ``sp'' is the
       format string.


       19.  CCCCoooommmmppppiiiilllliiiinnnngggg CCCC	BBBBaaaasssseeeedddd FFFFoooorrrrmmmmssss

       Compiling C programs using the Tab libraries is a fairly
       straightforward process.	 The sample programs in	appendices
       D, E, and F are a good place to start.  Notice that all of
       the programs include the	same five header files.

       #include	<stdio.h>
       #include	<setjmp.h>
       #include	"vt.h"
       #include	"windows.h"
       #include	"fields.h"

       The header files	must be	included in the	order listed above.

       The following is	a sample makefile that can be used to com-













	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 73 -



       pile the	first sample program, ``x1.c''.

       #
       # FORMS must point to the forms.d directory for the inclusion
       #       of the libraries	and the	header files
       #

       FORMS=/u1/blewett/forms.d
       TAB=${FORMS}/Tab.d/libform.a
       WIN=${FORMS}/windows.d/libwindows.a
       VT=${FORMS}/vt.d/libvt.a


       F_LIBS=${TAB} ${WIN} ${VT}

       CFLAGS=-O -I${FORMS}/Tab.d -I${FORMS}/vt.d -I${FORMS}/windows.d

       x1:     x1.o ${F_LIBS}
	       cc -o x1	x1.o ${F_LIBS} -lcurses


       The library files should	be included in the order listed
       above.

       This example assumes that the library and header	files are
       being maintained	privately by the user.	Installing the
       files in	``/usr/include'' and in	``/usr/lib'' will of course
       simplify	the makefile.


       20.  TTTTiiiippppssss oooonnnn UUUUssssiiiinnnngggg TTTTaaaabbbbssss

       20.1  _A_l_w_a_y_s__U_s_e__G_e_t___L_i_s_t_(_)  Tabs provides essentially end-
       less flexibility.  There	are at least three ways	to do most
       everything.  This can be	a benefit or a detriment.  Most
       forms follow the	simple example given in	Appendix D.  A com-
       mon problem is to use Get_Field() when in fact you want to
       collect a list of fields.  In most cases	the
       Get_List()/Show_List() combination will be the easiest way
       to construct a new form.	 It is also a very good	idea to
       start out by selecting one of the demonstration programs	as
       the basis for creating your own program.

       20.2  _M_e_t_h_o_d_s__f_o_r__C_r_e_a_t_i_n_g__N_u_l_l__F_i_e_l_d_s  Application
       designers commonly want to look for more	than one data type
       per field.  The most common combination is to look for any
       field type and a	null response.	Again there are	at least
       three ways to do	this with Tabs.	 The recommended way to	do
       this is to link two fields together with	the Link_Fields()


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 74 -



       procedure.  You can link	a confirmation field in	with every
       field that you want to behave in	this manner. Confirmation
       fields when they	appear as secondary linked fields will
       accept both confirmation	characters (i.e. carriage return
       and new line) and the TAB character as valid responses.	The
       field description for the end user is then a field of a par-
       ticular type or an empty	field.	The help and error messages
       will all	reflect	the right stuff.  Linked fields	require	no
       memory for storage so you can link the same confirmation
       field in	each time that you need	it with	out any	ill
       effects.

       The second way that you can do this sort	of thing is to
       redefine	the confirmation keys to be whatever type of vali-
       dation you require.  This is quite a bit	more difficult to
       do than the link	technique, but it is not really	all that
       tough.  You can do this with the	Def_Char_Action() pro-
       cedure.

       The third way is	to create your own field type.	This is
       probably	easier than changing the definition of all of your
       confirmation keys, but harder by	quite a	bit than the link
       technique.  A good place	to start with this is the x7.c pro-
       gram in the doc.d directory of your Tabs	source.

       Most of the current Tabs	users use the link technique.
       There are examples of it	in most	of the sample programs,	for
       example x3.c.

       20.3  _D_e_f_i_n_i_n_g _C_h_a_r_a_c_t_e_r	_D_i_r_e_c_t_i_v_e_s _f_o_r _I_n_t_e_r-_F_i_e_l_d _E_d_i_t_i_n_g
       _a_n_d _C_o_n_t_r_o_l  This section describes how to create characters
       actions that result in inter-field interaction or movement.
       Page-up and page-down characters	for scrollable regions are
       examples	of this	type of	character.  The	following example
       contains	character-action and post-action routines that
       define CTRL(U) and CTRL(D) to do	page-up	and page_down.	The
       scrollable region field,	_r_e_g__f_i_e_l_d, can be created the same
       way f[2]	is created in Appendix F.  Only	the relevant por-
       tions of	the main routine are shown here.












	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 75 -



       main()
       {
	       ...
	       Def_Char_Action (CTRL(D), BREAK,	mybrkchar, CM_LIST);   /* Page Down */
	       Def_Char_Action (CTRL(U), BREAK,	mybrkchar, CM_LIST);   /* Page Up */
	       ...
	       /* create scrollable region field, reg_field */
	       ...
	       Set_Actions (reg_field, 0, reg_post); /*	set pre/post action routines */
	       ...
	       /* display field(s) and collect user's response(s) */
	       ...
       }
       /*
	*      This is a sample	BREAK character	action routine.
	*      It uses the standard Tabs brkchar() routine to set the appropriate
	*      flags, etc.  All	BREAK routines should return TRUE.
	*/

       mybrkchar (field_ptr, rc)
       struct field_item *field_ptr;
       char    rc;
       {
	       switch (rc)
	       {
	       case CTRL(U):   /* Page Up */
		       brkchar (field_ptr, K_HOME);
		       field_ptr -> user_mask =	CTRL(U);
		       break;
	       case CTRL(D):   /* Page Down */
		       brkchar (field_ptr, K_HOME);
		       field_ptr -> user_mask =	CTRL(D);
		       break;
	       default:
		       brkchar (field_ptr, rc);
	       }

	       return (TRUE);
       }
       /*
	*      This is a sample	post action routine.  The return value (int) is
	*      the index of the	next field to be read.	An index of -1 indicates
	*      that the	current	field should be	re-read.
	*/
       #define REPEAT -1    /* repeat a	character */
       #define NUM_LINES 4  /* number of lines to scroll the region */

       reg_post	(f, count, index, rc)
       struct field_item     **f;


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 76 -



       int     count;
       int index;
       int     rc;
       {
	       int new_index;

	       switch (f[index]	-> user_mask)  /* Oh those side	effects!!! */
	       {
	       case CTRL(U):   /* Page Up */
		       new_index = index - NUM_LINES;
		       break;
	       case CTRL(D):   /* Page Down */
		       new_index = index + NUM_LINES;
		       break;
	       default:
		       return (index);
	       }
	       f[index]	-> user_mask = 0;
	       if (new_index < 0)	       /* above	top? */
		       new_index = 0;
	       if (new_index >=	count)	       /* below	bottom?	*/
		       new_index = count - 1;
	       if (new_index ==	index)	       /* same field? */
		       new_index = REPEAT;
	       return (new_index);
       }

       Both character-action and post-action routines are necesary
       because the BREAK character entered by the user is normally
       not known in a post-action routine.  ``mybrkchar'' sets
       _u_s_e_r__m_a_s_k in the	_f_i_e_l_d structure	to the appropriate BREAK
       character.  The post-action routine then	uses this value	to
       determine whether to page up or down.  This use of _u_s_e_r__m_a_s_k
       is quite	straightforward.  The call to brkchar()	with K_HOME
       is more interesting.

       The way we recommend to write a BREAK character action rou-
       tine is to model	the new	BREAK character	after another BREAK
       character.  K_HOME is similar enough to what we want to do.
       But in what sense?  To answer this question we have to
       understand why the above	example	works.	The following
       reduces the flow	of control, function calls and arguments in
       Tabs to only what is needed to understand this example.








	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 77 -



       Get_List	(field_list)   /* controls inter-field movement	and editing */
       {
	       next = 0;
	       while (next < count)
	       {
		       index = next;
		       ret_code	= Get_Field (field_list[index]);
		       if (post-action)	/* e.g.,  reg_post */
			       next = post-action (ret_code,index);
		       if (next	== index)
			       /* determine ``next'' from ret_code and field_flags*/
	       }
       }

       Get_Field (field)   /* controls intra-field movement and	editing	*/.
       {
	       while (TRUE)
	       {
		       ch = read_a_char();
		       flag = character_action(); /* e.g. mybrkchar */
		       if (flag	== TRUE)
		       {
			       switch (some_variable)
			       {
			       ...
			       case K_HOME:
				       /* set field_flags and ret_code */
				       return (ret_code);
			       ...
			       }
		       }
	       }
       }

       Look first at Get_Field().  When	CTRL(D)	is typed by the
       user to page down, the character	action routine (mybrkchar()
       in this case) calls brkchar with	K_HOME.	 As a result,
       Get_Field sets the field-dependent flags	and return code	to
       the appropriate conditions for K_HOME.  However,	mybrkchar()
       also sets _u_s_e_r__m_a_s_k to CTRL(D) so that it will be remembered
       for later use in	the post-action	routine.

       Now look	at Get_List().	If the post-action routine
       (reg_post() in this case) returns the index passed to it
       then the	flags and return code set for K_HOME will have an
       effect.	But the	_u_s_e_r__f_l_a_g is set to CTRL(D) so the return
       from reg_post() will not	be the same as the index passed	to
       it.  The	post-action routine has	a higher priority than
       flags and return	codes set in Get_Field().


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 78 -



       K_HOME was used as the model because it caused control to be
       moved to	another	field within the same list of fields.
       K_DOWN, K_UP, etc. would	have been just as good a model.
       See the description of Def_Char_Action()	for the	complete
       list of standard	BREAK characters and break character types.

       The type	of interactions	between	routines shown here can	be
       used between character-action routines and any type of pre-
       action or post-action routine.  This extensibility provides
       a powerful mechanism for	creating a wide	variety	of special
       character directives.


       21.  CCCCoooonnnnssssttttrrrruuuuccccttttiiiinnnngggg AAAApppppppplllliiiiccccaaaattttiiiioooonnnn DDDDeeeeffffiiiinnnneeeedddd FFFFiiiieeeelllldddd TTTTyyyyppppeeeessss

       New field types may be created by the application program-
       mer.  If	the application	requires a novel data type that	is
       not included in the Tabs	library, the application may con-
       struct its own field type.  A typical application supplied
       field type can be created with less than	20 lines of C
       source code.  Application created field types are especially
       important for handling data base	applications that cannot
       know until run time what	the data will look like.

       Each field type procedure has two operations that must be
       performed.  First the procedure must verify the end user's
       input.  The second operation included with every	field type
       is to supply help.  In the example in Appendix G	the verifi-
       cation part of the field	is handled in the lines	between	115
       and 128.	 This code is very general.  The test at lines 115
       and 116 can be replaced with another string comparison to
       produce whatever	type is	required.  The rest of the code
       between 117 and 128 would remain	the same.

       The help	part of	the example lies between 98 and	113.  The
       two error arguments to cm_start() are the error messages	to
       be displayed if the field is empty and the user has entered
       a confirmation character	or a completion	character.  The
       procedure call to prhlp() on line 109 sends the string argu-
       ment to the pop-up help window.	The strings on lines 98	and
       109 are obviously field type specific, but the rest of the
       code could be used for most other arbitrary field types.









	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 79 -



       22.  TTTThhhheeee	FFFFiiiieeeelllldddd SSSSttttrrrruuuuccccttttuuuurrrreeee

       This section describes the main data structure used by Tab.
       This section is provided	mainly for insight.  Most applica-
       tion developers do not need to know these specifics.  The
       access procedures should	be used	whenever possible.

       The following is	the current field definition.











































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 80 -



       struct field_item
       {
	       int     x_pos;
	       int     y_pos;
	       int     (*type) ();
	       int     (*type_used) ();
	       int     length;
	       char   *fill_char;
	       char   *ext_fill_char;
	       char   *keywords;

	       struct  window  *window;
	       struct  window  *errwin;
	       struct  window  *meswin;

	       int     attribute;
	       int     user_mask;
	       char   *user_pointer;

	       int     (*read_routine) ();
	       int     (*pre_action) ();
	       int     (*post_action) ();
	       int     (*help_routine) ();

	       int     txflg;
	       char   *txbuf;
	       char   *txend;
	       char   *txptr;
	       char   *txcursor;

	       int     fnflg;
	       char   *fnhlp;
	       char   *fnerr;
	       char   *fndfs;
	       int     fndfv;
	       struct  field_item  *fnalt;

	       int     cmflg;

	       struct  label_item  *label;
       };

       The entries in the structure are	used as	follows:

	  +o int	x_pos

	    This is the	row position of	the field in the window.




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 81 -



	  +o int	y_pos

	    This is the	column position	of the field in	the window.

	  +o int	(*type)	()

	    This is the	type of	the field.  Tab	currently supports
	    the	following generic types.

	       - CMKEY - keywords

	       - CMKEY_LIST - keyword list (from struct	keys)

	       - CMCFM - confirm a command (new	line)

	       - CMSTR - string

	       - CMNUM - number

	       - CMFILE	- UNIX file

	       - CMENV - environmental variable

	       - CMREGN	- scrollable region

	    Applications may also specify their	own field types
	    (see the section on	constructing application defined
	    field types).

	  +o int	(*type_used) ()

	    This is the	type of	the field that was entered.  This
	    is the verified field type.	 This acts as a	return
	    value for the field	type.  This is useful for input
	    fields that	have alternate field links (see
	    Link_Field()).

	  +o int	length

	    This is the	length of the field in characters.

	  +o char *fill_char

	    This is the	background text.

	  +o char *ext_fill_char

	    This is the	background text	for extendable fields.
	    This string	is the background for the fully	extended


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 82 -



	    field.

	  +o char *keywords

	    This is the	list of	keywords for keyword fields.

	  +o struct window *window

	    This is the	pointer	to the window from which the field
	    is to be read.

	  +o struct window *errwin

	    This is the	pointer	to the help window.  Help messages
	    are	printed	in this	window.

	  +o struct window *meswin

	    This is the	pointer	to the message window.
	    Print_Message() style error	messages are printed on	the
	    last line of this window.  ``meswin'' and ``window''
	    are	usually	the same window.

	  +o int	attribute

	    This is the	attribute flag.	 The following attributes
	    are	supported.

	       - FARIGHT - right justify the field

	       - FACENTER - center the field

	       - FALEFT	- left justify the field

	       - FAREVV	- reverse video

	       - FAHALF	- half intensity

	       - FAUNDER - underline

	       - FABLINK - blink

	       - FABOLD	- bold

	       - FACASE	- ignore the case of keyword matches

	       - FAPROTECT - protect the field so the user can not
		 change	its content



	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 83 -



	       - FAINVISIBLE - invisible - field content is
		 displayed as spaces

	  +o int	user_mask

	    This is an extra integer for use by	the application
	    only.

	  +o char *user_pointer

	    This is an extra pointer for use by	the application
	    only.

	  +o int	(*read_routine)	()

	    This is a pointer to the routine that will be used to
	    read the users input.  This	is used	for creating fields
	    that have some minimal constraint on the range of input
	    characters.

	  +o int	(*pre_action) ()

	    This is a pointer to the application supplied pre-
	    action routine.

	  +o int	(*post_action) ()

	    This is a pointer to the application supplied post-
	    action routine.

	  +o int	(*help_routine)	()

	    This is a pointer to the application supplied help rou-
	    tine.

	  +o int	txflg

	    This is a flag used	internally by Tab.  The	value of
	    the	flag reflects the current state	of input for the
	    field.

	  +o char *txbuf

	    The	string pointed to with txbuf contains the current
	    contents of	the field.

	  +o char *txend

	    This is a pointer used internally by Tab.  It marks	the


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 84 -



	    end	of the string pointed to by txbuf.

	  +o char *txptr

	    This is a pointer used internally by Tab for specifying
	    the	end of the user's input	string.

	  +o char *txcursor

	    This is a pointer used internally by Tab for specifying
	    the	location of the	cursor in the user's input string.

	  +o int	fnflg

	    This is a flag used	to control help	functions within
	    Tab.

	  +o char *fnhlp

	    This is a pointer to the application supplied help
	    string.

	  +o char *fnerr

	    This is a pointer to the application supplied error
	    message.

	  +o char *fndfs

	    This is a pointer to the completion	default	for the
	    field.

	  +o int	fndfv

	    This is an integer that is used as a modifier for cer-
	    tain field types (e.g CMFILE and CMNUM).

	  +o struct field_item *fnalt

	    This is the	pointer	to an alternate	field.	This is
	    used for reading more than one type	from a given field.

	  +o int	cmflg

	    This flag contains the status of the field.

	  +o struct label_item *label

	    This is the	pointer	to the first label for the field.


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 85 -



       23.  RRRReeeeffffeeeerrrreeeennnncccceeeessss

	[1]  Teitelman,	Warren,	``A Display Oriented Programmer's
	     Assistant'', CSL 77-3, Xerox Palo Alto Research
	     Center, March 8, 1977.

	[2]  Montgomery, Warren, ``An Interactive Screen Editor'',
	     BTL Technical Memorandum 80-5343.2, April 14, 1980.

	[3]  Horton, Mark R., ``The New	Curses and Terminfo Pack-
	     age'', Bell Laboratories internal publication TM 82-
	     59473-8, August 2,	1982.

	[4]  Blewett, Douglas ``Tabs:  A Window	Based, Extensible,
	     Highly Typed, Electronic Forms Package'', AT&T Bell
	     Laboratories internal publication TM 83-45411-10,
	     December 7, 1983.

	[5]  Hicks, K.I. ``A Menu Toolkit'', AT&T Bell Laboratories
	     internal publication TM 11386-850322-01, March 22,
	     1985.

	[6]  Hicks, K.I. ``Managing Related Windows and	Forms'',
	     AT&T Bell Laboratories internal publication TM 11386-
	     850409-01,	April 9, 1985.


























	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 86 -



       _A_p_p_e_n_d_i_x__A__-__A__S_a_m_p_l_e__F_o_r_m



	.
       _______________________________________________________________________________


			     Media Industries Inventory	Systems

				   New Arrivals	Entry Form


		 Item	      Quantity	   Origin	Amount
	     ____________	__10	   _______	___0.29	  =	     2.90

	     ____________	____	   _______	_______	  =		0


								      ===========

									     2.90
				      Confirm:*




       _______________________________________________________________________________























	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 87 -



       _A_p_p_e_n_d_i_x__B__-__F_o_r_m__w_i_t_h__a__H_e_l_p__W_i_n_d_o_w



	.
       _______________________________________________________________________________


			     Media Industries Inventory	Systems

				   New Arrivals	Entry Form


		 Item	      Quantity	   Origin	Amount
	     blits for me	__10	   B?_____	3400.00	  =	 34000.00

	     3bX's_____----------------------------------------	  =	500000.00
		       |  Options:			      |
		       |   Boston			      |
		       |Enter the city of origin.  This	is    |	      ===========
		       |the shipment origin.  Do NOT use the  |
		       |city of	manufacture.		      |		534000.00
		       |				      |
		       |				      |
		       ----------------------------------------


       _______________________________________________________________________________























	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 88 -



       _A_p_p_e_n_d_i_x__C__-__F_o_r_m_s__D_e_m_o_n_s_t_r_a_t_i_n_g__M_u_l_t_i_p_l_e__W_i_n_d_o_w_s



	.
       _______________________________________________________________________________


	       --------------------------------------------------------------
	       |			  Field9			    |
	       |							    |
	       |	 Field Type: confirm				    |
	       |	   Keywords: ___________________________________    |
	       |     Decimal Digits: _					    |
	     bl|       Lowest Value: ___________________________________    |0.00
	       |      Highest Value: ___________________________________    |
	     3b|    Background Text: *__________________________________    |0.00
	 ---------------------------------------------------------	    |
	 |		New Field Help Information		 |	    |
	 |							 |_______   |====
	 | More: yes  Value: Press the return key when you are__ |n: yes    |
	 | More: no_  Value: ___________________________________ | _	    |0.00
	 | More: ___  Value: ___________________________________ |	    |
	 | More: ___  Value: ___________________________________ |-----------
	 |							 |
	 ---------------------------------------------------------

       _______________________________________________________________________________























	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 89 -



       _A_p_p_e_n_d_i_x__D__-__C__B_a_s_e_d__F_o_r_m


















































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 90 -



	.
	   1   #include	<stdio.h>
	   2   #include	<setjmp.h>
	   3   #include	"vt.h"
	   4   #include	"windows.h"
	   5   #include	"fields.h"
	   6
	   7   main ()
	   8   {
	   9	       struct field_item *f[2];
	  10
	  11	       Start_Form (0, 0);
	  12
	  13   /*
	  14	*      Define Field 0
	  15	*
	  16	*/
	  17	       f[0] = New_Field(10, 40,	CMNUM, "_______",
	  18			       0, "3,-123.55,123.00");
	  19
	  20	       Set_Attributes (f[0], FARIGHT);
	  21
	  22	       Set_Label (f[0],	"l", "A	Number:", FANORMAL);
	  23
	  24
	  25   /*
	  26	*      Define Field 1
	  27	*
	  28	*/
	  29	       f[1] = New_Field(12, 40,	CMCFM, "_",
	  30		   "Please Press Return	when you are ready to proceed.",
	  31		   0);
	  32
	  33	       Set_Label (f[1],	"l", "Confirm:", FANORMAL);
	  34
	  35   /*
	  36	*      Process the fields
	  37	*
	  38	*/
	  39	       Print_Center (stdwindow,	1, FAREVV, "A Sample Form");
	  40
	  41	       Show_List (f, 2);
	  42
	  43	       Get_List	(f, 2, FALSE, FALSE);
	  44
	  45	       End_Form	();
	  46   }




	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 91 -



       _A_p_p_e_n_d_i_x__E__-__M_o_r_e__C_o_m_p_l_e_x__C__B_a_s_e_d__F_o_r_m

	.
	   1   #include	<stdio.h>
	   2   #include	<setjmp.h>
	   3   #include	"vt.h"
	   4   #include	"windows.h"
	   5   #include	"fields.h"
	   6
	   7   main ()
	   8   {
	   9	       extern int beep ();
	  10
	  11	       int i;
	  12	       struct field_item *f[6];
	  13
	  14	       Start_Form (0, 0);
	  15
	  16	       Def_Interrupt (beep);			   /* Catch Interrupt */
	  17
	  18	       errwindow -> _type_scroll = FALSE;  /* MIT scroll Help */
	  19
	  20	       Print_Center (stdwindow,	1, FAREVV, "A Sample Form");
	  21
	  22   /*
	  23	*      Field 0 - a keyword
	  24	*
	  25	*/
	  26	       f[0] = New_Field(6, 33, CMKEY, "__________________",
	  27			       "Enter a	sample keyword.",
	  28			       "a few key words	to choose from");
	  29
	  30	       Set_Label (f[0],	"l", "Keyword: ", FANORMAL);
	  31
	  32   /*
	  33	*      Field 1 - a centered string
	  34	*
	  35	*/
	  36	       f[1] = New_Field(8, 33, CMSTR, "__________________",
	  37			       "Enter a	line of	characters.", 0);
	  38
	  39	       Set_Label (f[1],	"l", "String: ", FANORMAL);
	  40
	  41	       Set_Attributes (f[1], FACENTER);
	  42
	  43   /*
	  44	*      Field 2 - a file	name
	  45	*
	  46	*/


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 92 -



	  47	       f[2] = New_Field(10, 33,	CMFILE,	"__________________",
	  48			       "Enter a	sample filename.",
	  49			       "1");
	  50
	  51	       Set_Label (f[2],	"l", "Filename:	", FANORMAL);
	  52
	  53   /*
	  54	*      Field 3 - an environmental variable
	  55	*
	  56	*/
	  57	       f[3] = New_Field(12, 33,	CMENV, "__________________",
	  58			       0, 0);
	  59
	  60	       Set_Label (f[3],	"l", "Environ: ", FANORMAL);
	  61
	  62   /*
	  63	*      Field 4 - a right justified decimal number
	  64	*
	  65	*/
	  66	       f[4] = New_Field(14, 33,	CMNUM, "__________________",
	  67			       0, "3,-123.55,123.00");
	  68
	  69	       Set_Label (f[4],	"l", "Number: ", FANORMAL);
	  70
	  71	       Set_Attributes (f[4], FARIGHT);
	  72
	  73   /*
	  74	*      Field 5 - a carriage return
	  75	*
	  76	*/
	  77	       f[5] = New_Field(16, 33,	CMCFM, "_",
	  78		   "Please press return	when you are ready to proceed.",
	  79		   0);
	  80
	  81	       Set_Label (f[5],	"l", "Confirm: ", FANORMAL);
	  82
	  83
	  84   /*
	  85	*      Set the fields so that ^B and ^F	(cursor	pad and	mouse)
	  86	*	       work no verify and no "onetime"
	  87	*
	  88	*      Set the fields to auto advance -	tab when full
	  89	*/
	  90	       for (i =	0; i < 6; i++)
	  91	       {
	  92		       Set_Tab_Movement	(f[i], TRUE, FALSE, TRUE, FALSE, FALSE);
	  93		       Set_Auto_Advance	(f[i], TRUE);
	  94	       }
	  95


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 93 -



	  96	       Show_List (f, 6);
	  97
	  98	       Get_List	(f, 6, FALSE, FALSE);
	  99
	 100	       Print_Message (stdwindow, FANORMAL, "Bye!");
	 101
	 102	       End_Form	();
	 103   }











































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 94 -



       _A_p_p_e_n_d_i_x__F__-__C__B_a_s_e_d__F_o_r_m__U_s_i_n_g__a__S_c_r_o_l_l_a_b_l_e__R_e_g_i_o_n

	.
	   1   #include	<stdio.h>
	   2   #include	<setjmp.h>
	   3   #include	"vt.h"
	   4   #include	"windows.h"
	   5   #include	"fields.h"
	   6
	   7   main ()
	   8   {
	   9	       struct field_item      *f[4];
	  10	       struct field_item      *fline;
	  11	       struct field_item      *fcfcfm;
	  12	       struct field_item      *fregion[20];
	  13	       struct SWindow  setup_window;
	  14	       struct window  *reg_window;
	  15
	  16	       Start_Form (0, 0);
	  17
	  18	       Print_Center (stdwindow,	1, FANORMAL,
	  19			       "Media Industries Electronic Mail");
	  20
	  21   /*
	  22	*      Create the To: line field
	  23	*
	  24	*/
	  25	       f[0] = New_Field	(4, 29,	CMSTR, "____________________",
	  26			       "Enter the list of people ... ",
	  27			       0);
	  28	       Set_Label (f[0],	"l", "To: ", FANORMAL);
	  29	       Set_Tab_Movement	(f[0], TRUE, TRUE, TRUE, TRUE, FALSE);
	  30	       Set_Auto_Advance	(f[0], TRUE);
	  31
	  32   /*
	  33	*      Create the Subject: line	field
	  34	*
	  35	*/
	  36	       f[1] = New_Field	(5, 29,	CMSTR, "____________________",
	  37			       "Enter the subject of the message. ...",
	  38			       0);
	  39	       Set_Label (f[1],	"l", "Subject: ", FANORMAL);
	  40	       Set_Tab_Movement	(f[1], TRUE, TRUE, TRUE, TRUE, FALSE);
	  41	       Set_Auto_Advance	(f[1], TRUE);
	  42
	  43   /*
	  44	*      Create the scrollable region for	creating mail the message
	  45	*
	  46	*      REGION: Create the window first


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 95 -



	  47	*
	  48	*/
	  49	       setup_window.top_x = 9;
	  50	       setup_window.top_y = 12;
	  51	       setup_window.lines = 6;
	  52	       setup_window.cols = 50;
	  53	       setup_window.box_h = '-';
	  54	       setup_window.box_v = '|';
	  55	       setup_window.type_scroll	= TRUE;
	  56	       setup_window.depth = 6;
	  57	       setup_window.box_attribute = 0;
	  58	       reg_window = New_Window (setup_window);
	  59
	  60   /*
	  61	*      REGION: Create the one line field for the message
	  62	*
	  63	*/
	  64	       fline = New_Field (0, 0,	CMSTR,
	  65		       "_________________________________________________",
	  66		       "Enter a	line of	text for the message.",
	  67		       0);
	  68	       Set_Tab_Movement	(fline,	TRUE, FALSE, TRUE, FALSE, FALSE);
	  69	       Set_Auto_Advance	(fline,	TRUE);
	  70
	  71   /*
	  72	*      REGION: Link the	one line field to allow	blank lines
	  73	*	       The user	may enter a line of text or
	  74	*	       hit the tab or return keys.
	  75	*
	  76	*/
	  77	       fcfcfm =	New_Field (0, 0, CMCFM,
	  78		       "_________________________________________________",
	  79		       0, 0);
	  80	       Link_Fields (fline, fcfcfm);
	  81
	  82	       Set_EOF (fline, TRUE, TRUE);    /* Allow	exit by	EOF */
	  83
	  84   /*
	  85	*      REGION: Create the scrollable region and	add it to the list
	  86	*	       of fields.
	  87	*
	  88	*/
	  89	       New_Region (reg_window, &fline, 1, 20, fregion, 1);
	  90
	  91	       f[2] = New_Field	(9, 12,	CMREGN,
	  92			       (char *)	fregion, (char *) 20, 0);
	  93
	  94   /*
	  95	*      Create a	confirmation field that	will be	collected


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 96 -



	  96	*	       after the scrollable region
	  97	*
	  98	*/
	  99	       f[3] = New_Field	(17, 29, CMCFM,	"_", 0,	0);
	 100	       Set_Label (f[3],	"l", "Confirm: ", FANORMAL);
	 101	       Set_Tab_Movement	(f[3], TRUE, TRUE, TRUE, TRUE, FALSE);
	 102
	 103   /*
	 104	*      Process the form
	 105	*
	 106	*/
	 107	       Show_List (f, 4);
	 108
	 109	       Get_List	(f, 4, FALSE, FALSE);
	 110
	 111	       End_Form	();
	 112   }


































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 97 -



       _A_p_p_e_n_d_i_x__G__-__A__F_o_r_m__w_i_t_h__a_n__A_p_p_l_i_c_a_t_i_o_n__S_u_p_p_l_i_e_d__F_i_e_l_d__T_y_p_e


	.
	   1   #include	<stdio.h>
	   2   #include	<setjmp.h>
	   3   #include	"vt.h"
	   4   #include	"windows.h"
	   5   #include	"fields.h"
	   6
	   7   /*
	   8	* This program demonstrates the	use of application defined
	   9	* field	types.	The field created with this example is a
	  10	* regular expression field.
	  11	*/
	  12
	  13   main ()
	  14   {
	  15	       struct field_item *f[3];
	  16	       extern int cmregex ();
	  17	       extern int change_help ();
	  18
	  19	       Start_Form (0, 0);
	  20
	  21	       Print_Center (stdwindow,	1, FANORMAL,
	  22		       "Regular	Expression Matching Example");
	  23
	  24   /*
	  25	*      Create the string field to collect the regular expression
	  26	*
	  27	*/
	  28	       f[0] = New_Field	(5, 38,	CMSTR, "____________________",
	  29			"Enter the regular expression ... ",
	  30			       0);
	  31	       Set_Label (f[0],	"left",	"Expression: ",	FANORMAL);
	  32	       Set_Tab_Movement	(f[0], TRUE, TRUE, TRUE, TRUE, FALSE);
	  33	       Set_Auto_Advance	(f[0], TRUE);
	  34
	  35   /*
	  36	*      The application defined regular expression field
	  37	*
	  38	*/
	  39	       f[1] = New_Field	(7, 38,	CMSTR, "____________________",
	  40			       0,
	  41			       0);
	  42	       Set_Label (f[1],	"left",	"Matching Pattern: ", FANORMAL);
	  43	       Set_Tab_Movement	(f[1], TRUE, FALSE, TRUE, FALSE, FALSE);
	  44	       Set_Auto_Advance	(f[1], TRUE);
	  45	       Set_Actions (f[1], change_help, 0);


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 98 -



	  46
	  47   /*
	  48	*      Change the type to the application supplied routine
	  49	*
	  50	*/
	  51	       f[1] -> type = cmregex;
	  52   /*
	  53	*      Set the keyword list used by cmregex to the compiled regular
	  54	*      expression.  The	pre_action routine will	in this	program
	  55	*      re-compile the expression with each pass.  The following
	  56	*      line (or	one with a different expression) would be used
	  57	*      in an example where the regular expression did not change.
	  58	*
	  59	*/
	  60	       f[1] -> keywords	= (char	*) regcmp ("^[a-c][0-9]{1,3}$",	0);
	  61
	  62   /*
	  63	*      Create a	confirmation field that	will be	collected last
	  64	*
	  65	*/
	  66	       f[2] = New_Field	(9, 38,	CMCFM, "_", 0, 0);
	  67	       Set_Label (f[2],	"left",	"Confirm: ", FANORMAL);
	  68	       Set_Tab_Movement	(f[2], TRUE, TRUE, TRUE, TRUE, FALSE);
	  69
	  70   /*
	  71	*      Process the form
	  72	*
	  73	*/
	  74	       Show_List (f, 3);
	  75
	  76	       Show_Default_Field (f[0], "^[a-c][0-9]{1,3}$");
	  77
	  78	       Get_List	(f, 3, FALSE, FALSE);
	  79
	  80	       End_Form	();
	  81   }
	  82
	  83   /*
	  84	*      cmregex (field_ptr)
	  85	*
	  86	*      This function matches an	arbitrary string with
	  87	*      a regular expression.
	  88	*/
	  89
	  90   cmregex (field_ptr)
	  91   register	struct field_item     *field_ptr;
	  92   {
	  93	       extern char *__loc1;
	  94	       extern char *regex ();


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				  - 99 -



	  95	       char *rc;
	  96	       char *error;
	  97
	  98	       error = "Cannot match or	complete the expression";
	  99
	 100	       if (!cm_start (field_ptr, error,	error))	return;
	 101
	 102	       if (field_ptr ->	cmflg &	CMHLP)
	 103	       {
	 104		       field_ptr -> cmflg |= CMNOP;
	 105
	 106		       if (field_ptr ->	fnflg &	FNHLP)
	 107			       return;
	 108
	 109		       prhlp (field_ptr, "Enter	pattern	to be matched.",
	 110			       FALSE, FALSE);
	 111
	 112		       return;
	 113	       }
	 114
	 115	       rc = regex (field_ptr ->	keywords, field_ptr -> txbuf);
	 116	       if ((rc != NULL)	&& (__loc1 == field_ptr	-> txbuf))
	 117	       {
	 118		       if (field_ptr ->	cmflg &	CMCMP)
	 119		       {
	 120			       complete	(field_ptr, field_ptr -> txbuf);
	 121			       field_ptr -> cmflg |= CMREP;
	 122		       }
	 123		       return;
	 124	       }
	 125
	 126	       error_fields = error;
	 127	       field_ptr -> cmflg |= CMNOP;
	 128	       return;
	 129   }
	 130
	 131   /*
	 132	* Pre-action routine for the regular expression	routine.  This is
	 133	* added	fluff that could be handled more directly in cmregex (), but
	 134	* gives	us a little experience with Set_Help ()	and action routines.
	 135	*
	 136	*/
	 137   change_help (f, count, index, rc)
	 138   struct field_item     **f;
	 139   int     count;
	 140   int     index;
	 141   int     rc;
	 142   {
	 143	       static char help_buf[128];


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T







				 - 100 -



	 144	       char *ptr;
	 145
	 146	       ptr = (char *) regcmp (f[0] -> txbuf, 0);
	 147
	 148	       if (ptr == NULL)
	 149	       {
	 150		       beep ();
	 151		       Print_Message (f[1] -> meswin, FANORMAL,
	 152			       "The regular expression does not	compile.");
	 153		       return (count); /* Exit from the	list */
	 154	       }
	 155
	 156	       if (f[1]	-> keywords)
	 157		       free (f[1] -> keywords);
	 158
	 159	       f[1] -> keywords	= ptr;
	 160
	 161	       sprintf (help_buf,
	 162		       "Enter a	string that will match the pattern
	 163		       f[0] -> txbuf);
	 164
	 165	       Set_Help	(f[1], help_buf, FALSE,	FALSE, 0);
	 166
	 167	       return (index);
	 168   }


























	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

       Copyright (c) 1984, 1985, 1986, 1987AT&T	All Rights Reserved
				D R A F	T











				 CONTENTS


	1.  Introduction.......................................	  1

	2.  The	User Interface.................................	  3
	    2.1	   Sample Displays.............................	  3
	    2.2	   Character Directives........................	  4

	3.  The	C Interface....................................	  8
	    3.1	   A Simple Form...............................	  8
	    3.2	   A More Complex Form.........................	  8

	4.  Setup..............................................	  9
	    4.1	   Start_Form..................................	  9
	    4.2	   Def_Interrupt...............................	 10
	    4.3	   End_Form....................................	 10

	5.  Simple Input Field Management......................	 10
	    5.1	   New_Field...................................	 10
	    5.2	   Del_Field...................................	 12
	    5.3	   Free_Field..................................	 13
	    5.4	   Move_Field..................................	 13
	    5.5	   Dup_Field...................................	 13
	    5.6	   Set_Label...................................	 14
	    5.7	   Del_Label...................................	 14
	    5.8	   Free_Label..................................	 14
	    5.9	   Set_Attributes..............................	 15
	    5.10   Set_An_Attribute............................	 16
	    5.11   Un_Set_An_Attribute.........................	 16
	    5.12   Set_Auto_Advance............................	 16
	    5.13   Set_CMP_Default.............................	 17
	    5.14   Set_EOF.....................................	 17
	    5.15   Set_Window..................................	 17
	    5.16   Link_Fields.................................	 18
	    5.17   Unlink_Fields...............................	 18

	6.  Field Display and Collection.......................	 18
	    6.1	   Show_Field..................................	 19
	    6.2	   Show_Default_Field..........................	 19
	    6.3	   Show_Label..................................	 19
	    6.4	   Get_Field...................................	 19
	    6.5	   Field_Value.................................	 20
	    6.6	   Right_Field.................................	 21
	    6.7	   Left_Field..................................	 21
	    6.8	   Center_Field................................	 21
	    6.9	   Dump_Field..................................	 21

	7.  Form Display and Collection........................	 22


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

				  - i -
				D R A F	T











	    7.1	   Show_List...................................	 22
	    7.2	   Get_List....................................	 22
	    7.3	   Get_SI_List.................................	 23
	    7.4	   Get_Position................................	 23
	    7.5	   ReShow_All_Lists............................	 23
	    7.6	   ReShow_List.................................	 24
	    7.7	   Clear_Form..................................	 24
	    7.8	   Dump_Form...................................	 24
	    7.9	   SCRN_Dump...................................	 24

	8.  Inter-field	Control	and Movement...................	 25
	    8.1	   Set_Tab_Movement............................	 25
	    8.2	   Set_BT_Movement.............................	 26
	    8.3	   Set_CP_Movement.............................	 26
	    8.4	   Set_One_Pass................................	 26
	    8.5	   Set_Actions.................................	 26

	9.  Edit Style and Cursor Placement....................	 28
	    9.1	   Def_Editing_Type............................	 28
	    9.2	   Def_Entry_Type..............................	 29
	    9.3	   Def_Auto_Pos................................	 29
	    9.4	   Def_Keep_Position...........................	 31

       10.  Creating Character Directives -
	    Def_Char_Action....................................	 32

       11.  Help...............................................	 36
	    11.1   Set_Help....................................	 36
	    11.2   Def_Help_Help...............................	 37
	    11.3   Print_Help_Window...........................	 38

       12.  Error Messages.....................................	 38
	    12.1   Print_Message...............................	 38
	    12.2   Set_Error...................................	 39
	    12.3   Def_Error_Attr..............................	 39

       13.  Formatted Printing of Strings......................	 39
	    13.1   Print_Form..................................	 39
	    13.2   Del_P_Form..................................	 40
	    13.3   Print_Center................................	 40
	    13.4   Del_P_Center................................	 40
	    13.5   LeftString..................................	 41
	    13.6   CenterString................................	 41
	    13.7   RightString.................................	 41

       14.  Scrollable Regions.................................	 42
	    14.1   New_Region -	Create a scrollable region.....	 42
	    14.2   New_Scroll_Region...........................	 44
	    14.3   Free_Region.................................	 45


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

				  - ii -
				D R A F	T











       15.  Menus..............................................	 45
	    15.1   New_Menu - Create a Menu as a Scrollable
		   Region......................................	 46
	    15.2   Free_Menu...................................	 48
	    15.3   New_Match_Menu..............................	 48
	    15.4   Free_Match_Menu.............................	 52
	    15.5   New_Popup_Menu..............................	 52
	    15.6   New_Fixed_Menu..............................	 53
	    15.7   New_Static_Menu.............................	 53
	    15.8   Show_Static_Menu............................	 54
	    15.9   Def_M_Char..................................	 54
	    15.10  Set_M_Selections............................	 55
	    15.11  Set_M_Delay.................................	 55
	    15.12  Def_Match_Type..............................	 56
	    15.13  Post_Match_Menu.............................	 58

       16.  Field Overflow and Extension.......................	 59
	    16.1   Set_Overflow................................	 59
	    16.2   Set_Extend..................................	 59
	    16.3   Def_Overflow_Action.........................	 60
	    16.4   Extend......................................	 60
	    16.5   Ext_Field...................................	 61
	    16.6   Ext_Long_Field..............................	 61

       17.  Scratchpad and Marked Areas........................	 61
	    17.1   New_Marked_Area.............................	 62
	    17.2   Def_Marked_Areas............................	 62
	    17.3   Clear_Marked_Areas..........................	 62
	    17.4   Def_Scratchpad..............................	 63

       18.  Windows............................................	 63
	    18.1   An Introduction.............................	 63
	    18.2   Window Functions and	Procedures.............	 64
		   18.2.1   New_Window - Create	a new win-
			    dow................................	 64
		   18.2.2   Free_Window........................	 66
		   18.2.3   Pop_Window.........................	 66
		   18.2.4   Push_Window........................	 66
		   18.2.5   Move_Window........................	 67
		   18.2.6   Dup_Window.........................	 67
		   18.2.7   Wrefresh...........................	 67
		   18.2.8   Ref_All_Windows....................	 67
		   18.2.9   Refresh............................	 68
		   18.2.10  New_Rel_Window.....................	 68
		   18.2.11  Free_Rel_Window....................	 68
		   18.2.12  Pop_Rel_Window.....................	 69
		   18.2.13  Push_Rel_Window....................	 69
		   18.2.14  Move_Rel_Window....................	 69
		   18.2.15  Dup_Rel_Window.....................	 70


	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

				 - iii -
				D R A F	T











		   18.2.16  Change_Parent......................	 70
		   18.2.17  w_mgo..............................	 70
		   18.2.18  w_sgo..............................	 71
		   18.2.19  w_xgo..............................	 71
		   18.2.20  wclrl..............................	 71
		   18.2.21  waxprintf and wxprintf.............	 71

       19.  Compiling C	Based Forms............................	 72

       20.  Tips on Using Tabs.................................	 73
	    20.1   Always Use Get_List().......................	 73
	    20.2   Methods for Creating	Null Fields............	 73
	    20.3   Defining Character Directives for Inter-
		   Field Editing and Control...................	 74

       21.  Constructing Application Defined Field Types.......	 78

       22.  The	Field Structure................................	 79

       23.  References.........................................	 85
	    Appendix A - A Sample Form.........................	 86
	    Appendix B - Form with a Help Window...............	 87
	    Appendix C - Forms Demonstrating Multiple Win-
	    dows...............................................	 88
	    Appendix D - C Based Form..........................	 89
	    Appendix E - More Complex C	Based Form.............	 91
	    Appendix F - C Based Form Using a Scrollable
	    Region.............................................	 94
	    Appendix G - A Form	with an	Application Supplied
	    Field Type.........................................	 97





















	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved

				  - iv -
				D R A F	T









	     Tabs 2.0 Manual: Tools for	Creating Window	Based
			     Electronic	Forms


			    C. Douglas Blewett

			     Kenyon I. Hicks
			 AT&T Information Systems


				 _A_B_S_T_R_A_C_T



       This paper is a brief introduction and a	user manual for	a
       package called Tabs.  Tabs can be used to produce window-
       based user interfaces.  Tabs incorporates qualities from
       both menu and block mode	electronic forms in one	unified
       interactive system.  The	interface provided by this package
       has qualities that make it desirable for	interfaces for both
       novice (i.e. casual) and	expert (i.e.  frequent)	users.

       The electronic forms produced using Tabs	are a collection of
       controlled input	and output areas within	windows	on a CRT.
       The input areas or fields may be	moved within and between
       windows while the form is running.  More	than one window	may
       be used at a time.  Like	fields,	windows	can be moved per
       the requirements	of the application.

       CRT windows are constructed with	a portable virtual terminal
       library.	 The window-based virtual terminal creates windows
       as three	dimensional rectangular	objects.  Windows that are
       ``closer'' to the user occlude more distant windows.  In
       this environment	windows	may be moved to	arbitrary spatial
       positions on the	CRT screen and in depth.

       Forms are constructed by	calling	Tabs procedures	or primi-
       tives from some interpreted or compiled language	(e.g. C).
       Libraries of commonly used fields may be	constructed and
       maintained using	standard software tools.  These	algorithmi-
       cally defined forms are more dynamic than the old boiler-
       plate forms of the past.















































































	      Copyright	(c) 1984, 1985,	1986, 1987AT&T All Rights Reserved


				D R A F	T


