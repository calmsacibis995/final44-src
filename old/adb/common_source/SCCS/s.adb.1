h39322
s 00001/00001/00842
d D 5.13 94/04/18 20:39:33 bostic 14 13
c misspelling
e
s 00015/00012/00828
d D 5.12 93/06/29 16:06:28 mckusick 13 12
c typesetting nits
e
s 00192/00368/00648
d D 5.11 91/08/07 18:15:41 cael 12 11
c mdoc version three
e
s 00005/00004/01011
d D 5.10 91/04/04 18:01:49 bostic 11 10
c new copyright; att/bsd/shared
e
s 00027/00024/00988
d D 5.9 90/07/24 22:40:16 cael 10 9
c .Xr botch fix
e
s 00002/00003/01010
d D 5.8 90/06/26 00:58:26 cael 9 8
c converted man page
e
s 00697/00486/00316
d D 5.7 90/06/11 05:29:55 cael 8 7
c converted man page
e
s 00004/00002/00798
d D 5.6 89/10/26 22:04:45 torek 7 6
c explain breakpointsbetter
e
s 00001/00001/00799
d D 5.5 89/04/09 21:29:41 bostic 6 5
c $s is now 1024
e
s 00001/00001/00799
d D 5.4 89/03/08 16:22:17 jak 5 4
c typos
e
s 00164/00230/00636
d D 5.3 89/01/16 21:13:02 bostic 4 3
c new version from Chris Torek
e
s 00001/00001/00865
d D 5.2 85/04/29 14:15:58 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00124/00203/00742
d D 5.1 85/04/29 14:15:25 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00945/00000/00000
d D 4.1 85/04/29 14:15:09 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 8
.\" Copyright (c) 1980 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 8
I 8
D 11
.\" Copyright (c) 1980, 1990 The Regents of the University of California.
D 9
.\" All rights reserved.
E 8
.\"
D 8
.\"	%W% (Berkeley) %G%
E 8
I 8
.\" %sccs.include.redist.man%
E 9
I 9
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 11
I 11
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
E 11
E 9
E 8
.\"
D 2
.TH ADB 1 4/1/81
E 2
I 2
D 3
.TH ADB 1 "18 July 1983"
E 3
I 3
D 8
.TH ADB 1 "%Q%"
E 3
E 2
.UC 4
.SH NAME
adb \- debugger
.SH SYNOPSIS
.B adb
D 2
[\fB\-w\fR] [ objfil [ corfil ] ]
E 2
I 2
D 4
[\fB\-w\fR] [ \fB\-k\fR ] [ \fB-I\fRdir ] [ objfil [ corfil ] ]
E 4
I 4
[ \fB\-w\fR ] [ \fB\-k\fR ] [ \fB-I\fRdir ] [ objfil [ corfil ] ]
E 4
E 2
.ds TW \v'.25m'\s+2~\s-2\v'-.25m'
D 2
.ds ST \v'.25m'*\v'-.25m'
E 2
I 2
.ds ST *
E 2
.ds IM \v'.1m'=\v'-.1m'\s-2\h'-.1m'>\h'.1m'\s+2
.ds LE \(<=
.ds LT \s-2<\s+2
.ds GT \s-2>\s+2
.SH DESCRIPTION
.I Adb
E 8
I 8
D 11
.\"     %W% (Berkeley) %G%
E 11
I 11
D 12
.\" %sccs.include.proprietary.man%
E 12
I 12
.\" %sccs.include.proprietary.roff%
E 12
.\"
.\"	%W% (Berkeley) %G%
E 11
.\"
.Dd %Q%
.Dt ADB 1
.Os BSD 4
.Sh NAME
.Nm adb
.Nd debugger
.Sh SYNOPSIS
.Nm adb
.Op Fl w
.Op Fl k
D 12
.Oo
.Op Fl I Ar dir
.Oo
E 12
I 12
.Op Fl I Ns Ar dir
E 12
.Op Ar objfil Op Ar corfil
.Sh DESCRIPTION
.Nm Adb
E 8
is a general purpose debugging program.
It may be used to examine files and to provide
D 2
a controlled environment for the execution
of UNIX programs.
E 2
I 2
a controlled environment for the execution of UNIX programs.
E 2
D 8
.PP
.I Objfil
E 8
I 8
.Pp
.Ar Objfil
E 8
is normally an executable program file, preferably
D 2
containing a symbol table;
if not then the
symbolic features of
E 2
I 2
containing a symbol table; if not then the symbolic features of
E 2
D 4
.I  adb
E 4
I 4
D 8
.I adb
E 8
I 8
.Nm adb
E 8
E 4
D 2
cannot be used although the file can still
be examined.
E 2
I 2
cannot be used although the file can still be examined.
E 2
The default for
D 8
.I objfil
E 8
I 8
.Ar objfil
E 8
is
D 4
.B  a.out.
E 4
I 4
D 8
.B a.out.
E 4
.I Corfil
E 8
I 8
.Pa a.out .
.Ar Corfil
E 8
D 2
is assumed to be a core image file produced after
executing
E 2
I 2
is assumed to be a core image file produced after executing
E 2
D 8
.IR objfil ;
E 8
I 8
.Ar objfil ;
E 8
the default for
D 8
.I corfil
E 8
I 8
.Ar corfil
E 8
is
D 4
.B  core.
E 4
I 4
D 8
.B core.
E 4
.PP
E 8
I 8
.Pa core
.Pp
E 8
Requests to
D 4
.I  adb
E 4
I 4
D 8
.I adb
E 8
I 8
.Nm adb
E 8
E 4
D 2
are read from the standard input and
responses are to the standard output.
E 2
I 2
are read from the standard input and responses are to the standard output.
E 2
If the
D 4
.B  \-w
E 4
I 4
D 8
.B \-w
E 8
I 8
.Fl w
E 8
E 4
flag is present then both
D 4
.I  objfil
E 4
I 4
D 8
.I objfil
E 8
I 8
.Ar objfil
E 8
E 4
and
D 8
.I corfil
E 8
I 8
.Ar corfil
E 8
D 2
are
created if necessary and
opened for reading and writing
E 2
I 2
are created if necessary and opened for reading and writing
E 2
so that files can be modified using
D 8
.IR adb .
I 2
.PP
The \fB\-k\fP option makes \fIadb\fP do UNIX kernel memory
mapping; it should be used when \fIcore\fP is a UNIX crash dump
or \fI/dev/mem\fP.
.PP
The \fB\-I\fP option specifies a directory where files to be read
with $< or $<< (see below) will be sought; the default is
.IR /usr/lib/adb .
.PP
E 2
.I Adb
D 2
ignores QUIT; INTERRUPT
causes return to the next
E 2
I 2
ignores QUIT; INTERRUPT causes return to the next
E 2
.I adb
E 8
I 8
.Nm adb .
.Pp
The
.Fl k
option makes
.Nm adb
D 12
do UNIX kernel memory
E 12
I 12
do
.Ux
kernel memory
E 12
mapping; it should be used when
.Pa core
D 12
is a UNIX crash dump
E 12
I 12
is a
.Ux
crash dump
E 12
or
.Pa /dev/mem .
.Pp
The
.Fl I
option specifies a directory where files to be read
with
D 10
.Li $<
E 10
I 10
.Ic $<
E 10
or
D 10
.Li $<<
E 10
I 10
.Ic $<<
E 10
(see below) will be sought; the default is
.Pa /usr/lib/adb .
.Pp
.Nm Adb
ignores
.Li QUIT ;
.Li INTERRUPT
causes return to the next
.Nm adb
E 8
command.
D 8
.PP
E 8
I 8
.Pp
E 8
In general requests to
D 4
.I  adb
E 4
I 4
D 8
.I adb
E 8
I 8
.Nm adb
E 8
E 4
are of the form
D 8
.PP
.if n .ti 16
.if t .ti 1.6i
[\|\fIaddress\fR\|]  [\|,
.IR count \|]
[\|\fIcommand\fR\|] [\|;\|]
.PP
E 8
I 8
D 12
.Pp
.ti +\n(Dsu
E 12
I 12
.Bd -filled -offset indent
E 12
.Op Ad address
.Op \&, Va count
.Op Ic command
.Op \&;
I 12
.Ed
E 12
.Pp
E 8
If
D 8
.I address
E 8
I 8
.Ad address
E 8
is present then
D 4
.I  dot
E 4
I 4
D 8
.I dot
E 8
I 8
.Ad dot
E 8
E 4
is set to
D 8
.IR address .
E 8
I 8
.Ad address .
E 8
Initially
D 8
.I dot
E 8
I 8
.Ad dot
E 8
D 2
is set to 0.
For most commands
E 2
I 2
is set to 0.  For most commands
E 2
D 8
.I count
E 8
I 8
.Va count
E 8
D 2
specifies how many times
the command will be executed.
The default
E 2
I 2
specifies how many times the command will be executed.  The default
E 2
D 8
.I count
E 8
I 8
.Va count
E 8
is 1.
D 8
.I Address
E 8
I 8
.Ad Address
E 8
and
D 8
.I count
E 8
I 8
.Va count
E 8
are expressions.
D 8
.PP
E 8
I 8
.Pp
E 8
D 2
The interpretation of an address depends
on the context it is used in.
If a subprocess is being debugged then
addresses are interpreted
E 2
I 2
The interpretation of an address depends on the context it is used in.
If a subprocess is being debugged then addresses are interpreted
E 2
in the usual way in the address space of the subprocess.
D 13
If the operating system is being debugged either post-mortem or using
E 13
I 13
If the operating system is being debugged, either post-mortem or using
E 13
the special file
D 2
.B /dev/kmem
E 2
I 2
D 8
.I /dev/mem
E 8
I 8
.Pa /dev/mem
E 8
E 2
D 5
to interactive examine and/or modify memory the maps are set to map
E 5
I 5
to interactively examine and/or modify memory, the maps are set to map
E 5
D 2
the kernel virtual addresses which start at 0x80000000.
For further details of address mapping see
E 2
I 2
D 4
the kernel virtual addresses which start at 0x80000000 (on the VAX).
E 4
I 4
D 8
the kernel virtual addresses which start at 0x80000000 (on the VAX); see
E 4
E 2
.SM ADDRESSES.
.SH EXPRESSIONS
.TP 7.2n
.B .
E 8
I 8
the kernel virtual addresses which start at
.Li \&0x80000000
(on the VAX); see ADDRESSES below.
.Sh EXPRESSIONS
D 12
.Tw Li
.Tp Sy \&\.
E 12
I 12
.Bl -tag -width integer
.It Sy \&\.
E 12
E 8
The value of
D 8
.IR dot .
.TP 7.2n
+
E 8
I 8
.Ad dot .
D 12
.Tp  Sy \&\+
E 12
I 12
.It  Sy \&\+
E 12
E 8
The value of
D 8
.I dot
E 8
I 8
.Ad dot
E 8
incremented by the current increment.
D 8
.TP 7.2n
^
E 8
I 8
D 12
.Tp Sy \&^
E 12
I 12
.It Sy \&^
E 12
E 8
The value of
D 8
.I dot
E 8
I 8
.Ad dot
E 8
decremented by the current increment.
D 8
.TP 7.2n
"
E 8
I 8
D 12
.Tp Sy \&"
E 12
I 12
.It Sy \&"
E 12
E 8
The last
D 8
.I address
E 8
I 8
.Ad address
E 8
typed.
D 8
.TP 7.2n
.I integer
A number.  The prefixes 0o and 0O (\*(lqzero oh\*(rq) force interpretation
in octal radix; the prefixes 0t and 0T force interpretation in
decimal radix; the prefixes 0x and 0X force interpretation in
hexadecimal radix.  Thus 0o20 = 0t16 = 0x10 = sixteen.
E 8
I 8
D 12
.Tp Va integer
E 12
I 12
.It Va integer
E 12
A number.  The prefixes
.Li \&0o
and
.Li \&0O
(\*(lqzero oh\*(rq)
force interpretation
in octal radix; the prefixes
.Li 0t
and
.Li 0T
force interpretation in
decimal radix; the prefixes
.Li 0x
and
.Li 0X
force interpretation in
hexadecimal radix.  Thus
.Li 0o20
=
.Li 0t16
=
.Li 0x10
= sixteen.
E 8
If no prefix appears, then the
D 8
.I default\ radix
is used; see the $d command.  The default radix is initially hexadecimal.
The hexadecimal digits are 0123456789abcdefABCDEF with the obvious
E 8
I 8
.Em default radix
is used; see the
D 10
.Li $d
E 10
I 10
.Ic $d
E 10
command.  The default radix is initially hexadecimal.
The hexadecimal digits are
.Li 0123456789abcdefABCDEF
with the obvious
E 8
values.  Note that a hexadecimal number whose most significant
D 8
digit would otherwise be an alphabetic character must have a 0x
(or 0X) prefix (or a leading zero if the default radix is hexadecimal).
.TP 7.2n
.IB integer . fraction
E 8
I 8
digit would otherwise be an alphabetic character must have a
.Li 0x
(or
.Li 0X )
prefix (or a leading zero if the default radix is hexadecimal).
D 12
.Tp Va integer.fraction
E 12
I 12
.It Va integer.fraction
E 12
E 8
A 32 bit floating point number.
D 8
.TP 7.2n
.I \'cccc\|\'
E 8
I 8
D 12
.Tp Li \'cccc\'
E 12
I 12
.It Li \'cccc\'
E 12
E 8
The ASCII value of up to 4 characters.
D 2
\\ may be used to escape a \'.
E 2
I 2
D 8
\e may be used to escape a \'.
E 2
.TP 7.2n
.I \*(LT name
E 8
I 8
.Li \e
may be used to escape a
.Li \' .
D 12
.Tp Va < name
E 12
I 12
.It Va < name
E 12
E 8
The value of
D 8
.IR name ,
E 8
I 8
.Va name ,
E 8
which is either a variable name or a register name.
D 8
.I Adb
E 8
I 8
.Nm Adb
E 8
D 2
maintains a number of variables
(see
E 2
I 2
maintains a number of variables (see
E 2
D 8
.SM VARIABLES\*S)
E 8
I 8
D 12
VARIABLES below)
E 12
I 12
.Sx VARIABLES
below)
E 12
E 8
named by single letters or digits.
If
D 8
.I name
E 8
I 8
.Va name
E 8
D 2
is a register name then
the value of the register is obtained from
E 2
I 2
is a register name then the value of the register is obtained from
E 2
the system header in
D 8
.IR corfil .
D 2
The register names are
those printed by the $r command.
E 2
I 2
The register names are those printed by the $r command.
E 2
.TP 7.2n
.I symbol
E 8
I 8
.Ar corfil .
The register names are those printed by the
D 10
.Li $r
E 10
I 10
.Ic $r
E 10
command.
D 12
.Tp Va symbol
E 12
I 12
.It Va symbol
E 12
E 8
A
D 8
.I symbol
E 8
I 8
.Va symbol
E 8
D 2
is a sequence
of upper or lower case letters, underscores or
digits, not starting with a digit.
.BR \\ " may be used to escape other characters."
The value of the
E 2
I 2
is a sequence of upper or lower case letters, underscores or
digits, not starting with a digit.  The backslash character
D 8
.B \e 
E 8
I 8
.Li \e
E 8
may be used to escape other characters.  The value of the
E 2
D 8
.I symbol
E 8
I 8
.Va symbol
E 8
D 2
is taken from the symbol table
in
E 2
I 2
is taken from the symbol table in
E 2
D 8
.IR objfil .
D 2
An initial \_ or \*(TW will be prepended to
E 2
I 2
An initial \_ will be prepended to
E 2
.I symbol
E 8
I 8
.Ar objfil .
An initial
.Li \_
will be prepended to
.Va symbol
E 8
if needed.
D 8
.TP
.I _ symbol
In C, the `true name' of an external symbol begins with _.
E 8
I 8
D 12
.Tp Va _symbol
E 12
I 12
.It Va _symbol
E 12
In C, the `true name' of an external symbol begins with
.Li \_ .
E 8
D 2
It may be necessary to utter this name to disinguish it
E 2
I 2
It may be necessary to utter this name to distinguish it
E 2
from internal or hidden variables of a program.
D 8
.TP 7.2n
.IB routine . name
E 8
I 8
D 12
.Tp Va routine.name
E 12
I 12
.It Va routine.name
E 12
E 8
The address of the variable
D 8
.I name
E 8
I 8
.Va name
E 8
D 2
in the specified
C routine.
Both
E 2
I 2
in the specified C routine.  Both
E 2
D 8
.I routine
E 8
I 8
.Va routine
E 8
and
D 8
.I name
E 8
I 8
.Va name
E 8
are
D 8
.IR symbols .
E 8
I 8
.Va symbols .
E 8
If
D 4
.I name
D 2
is omitted the value is the address of the
most recently activated C stack frame
E 2
I 2
is omitted the value is the address of the most recently activated C stack frame
E 2
corresponding to
.IR routine .
(This form is currently broken on the VAX; local variables can be examined
E 4
I 4
D 8
.I routine
E 8
I 8
.Va routine
E 8
is omitted, the currently active frame is used.
(This form is currently broken; local variables can be examined
E 4
only with
D 2
.IR sdb (1).)
E 2
I 2
D 8
.IR dbx (1).)
E 8
I 8
.Xr dbx 1 ) .
E 8
I 4
If
D 8
.I name
E 8
I 8
.Va name
E 8
is omitted the value is the address
of the most recently activated C stack frame
corresponding to
D 8
.I routine
E 8
I 8
.Va routine
E 8
(this much works).
E 4
E 2
D 8
.TP 7.2n
.RI ( exp \|)
E 8
I 8
D 12
.Tp (exp)
.\" .Tp Cx \&(\&
.\" .Va exp
.\" .Cx \&)\&
E 12
I 12
.It Pq Va exp
E 12
E 8
The value of the expression
D 8
.IR exp .
.LP
.SM
D 4
.B  "Monadic\ operators"
E 4
I 4
.B "Monadic\ operators"
E 4
.TP 7.2n
.RI \*(ST exp
E 8
I 8
D 12
.Va exp .
.Tp
.Pp
E 12
I 12
.Ar exp .
.El
E 12
.Ss Monadic Operators
D 12
.Pp
.Dp Cx Li \&*
.Va exp
.Cx
E 12
I 12
.Bl -tag -width flag -compact
.It Li \&* Ns Va exp 
E 12
E 8
D 2
The contents of the location addressed
by
E 2
I 2
The contents of the location addressed by
E 2
D 8
.I exp
E 8
I 8
.Va exp
E 8
in
D 8
.IR corfil .
.TP 7.2n
.RI @ exp
E 8
I 8
.Ar corfil .
D 12
.Dp Cx Li \&@
.Va exp
.Cx
E 12
I 12
.It Li \&@ Ns Va exp 
E 12
E 8
The contents of the location addressed by
D 8
.I exp
E 8
I 8
.Va exp
E 8
in
D 8
.IR objfil .
.TP 7.2n
.RI \- exp
E 8
I 8
.Ar objfil .
D 12
.Dp Cx Li \&\-
.Va exp
.Cx
E 12
I 12
.It Li \&\- Ns Va exp 
E 12
E 8
Integer negation.
D 8
.TP 7.2n
.RI \*(TW exp
E 8
I 8
D 12
.Dp Cx Li \&~
.Va exp
.Cx
E 12
I 12
.It Li \&~ Ns Va exp 
E 12
E 8
Bitwise complement.
D 8
.TP 7.2n
.RI # exp
E 8
I 8
D 12
.Dp Cx Li \&#
.Va exp
.Cx
E 12
I 12
.It Li \&# Ns Va exp 
E 12
E 8
Logical negation.
D 8
.LP
I 2
.tr ''
E 2
D 4
.B  "Dyadic\ operators"
E 4
I 4
.B "Dyadic\ operators"
E 8
I 8
D 12
.Dp
E 12
I 12
.El
E 12
.Ss Dyadic operators
E 8
E 4
D 2
are left associative
and are less binding than monadic operators.
E 2
I 2
D 12
are left associative and are less binding than monadic operators.
E 2
D 8
.TP 7.2n
.IR e1 + e2
E 8
I 8
.Dp Cx Va e1
.Li \&\+
.Va e2
.Cx
E 12
I 12
Are left associative and are less binding than monadic operators.
.Pp
.Bl -tag -width xxXxx -compact
.It Va e1 Ns Li \&\+ Ns Va e2 
E 12
E 8
Integer addition.
D 8
.TP 7.2n
.IR e1 \- e2
E 8
I 8
D 12
.Dp Cx Va e1
.Li \&\-
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li \&\- Ns Va e2 
E 12
E 8
Integer subtraction.
D 8
.TP 7.2n
.IR e1 \*(ST e2
E 8
I 8
D 12
.Dp Cx Va e1
.Li \&*
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li \&* Ns Va e2 
E 12
E 8
Integer multiplication.
D 8
.TP 7.2n
.IR e1 % e2
E 8
I 8
D 12
.Dp Cx Va e1
.Li \&%
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li \&% Ns Va e2 
E 12
E 8
Integer division.
D 8
.TP 7.2n
.IR e1 & e2
E 8
I 8
D 12
.Dp Cx Va e1
.Li &
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li & Ns Va e2 
E 12
E 8
Bitwise conjunction.
D 8
.TP 7.2n
.IR e1 \(bv e2
E 8
I 8
D 12
.Dp Cx Va e1
.Li \&|
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li \&| Ns Va e2 
E 12
E 8
Bitwise disjunction.
D 8
.TP 7.2n
.IR e1 # e2
.I E1
E 8
I 8
D 12
.Dp Cx Va e1
.Li #
.Va e2
.Cx
E 12
I 12
.It Va e1 Ns Li # Ns Va e2 
E 12
D 13
.Va E1
E 13
I 13
.Va e1
E 13
E 8
rounded up to the next multiple of
D 8
.IR e2 .
.DT
.SH COMMANDS
E 8
I 8
.Va e2 .
D 12
.Dp
E 12
I 12
.El
E 12
.Sh COMMANDS
E 8
D 2
Most commands consist of a verb followed by a modifier or list
of modifiers.
E 2
I 2
Most commands consist of a verb followed by a modifier or list of modifiers.
E 2
The following verbs are available.
D 2
(The commands `?' and `/' may be followed by `\*(ST';
see
E 2
I 2
D 8
(The commands `?' and `/' may be followed by `\*(ST'; see
E 2
.SM ADDRESSES
E 8
I 8
(The commands
.Ic ?
and
.Li /
may be followed by
.Li * ;
see the
D 12
ADDRESSES section
E 12
I 12
.Sx ADDRESSES
section
E 12
E 8
for further details.)
D 8
.TP .5i
.RI ? f
E 8
I 8
D 12
.Tw XXX
.Tp Cx Ic ?
.Va f
.Cx
E 12
I 12
.Bl -tag -width flag
.It Ic ? Ns Va f 
E 12
E 8
Locations starting at
D 8
.I address
E 8
I 8
.Ad address
E 8
in
D 4
.I  objfil
E 4
I 4
D 8
.I objfil
E 8
I 8
.Ar objfil
E 8
E 4
are printed according to the format
D 8
.IR f .
.I dot
E 8
I 8
.Va f .
.Ad dot
E 8
is incremented by the sum of the increments for each format letter (q.v.).
D 8
.TP
.RI / f
E 8
I 8
D 12
.Tp Cx Ic /
.Va f
.Cx
E 12
I 12
.It Ic / Ns Va f 
E 12
E 8
Locations starting at
D 8
.I address
E 8
I 8
.Ad address
E 8
in
D 4
.I  corfil
E 4
I 4
D 8
.I corfil
E 8
I 8
.Ar corfil
E 8
E 4
are printed according to the format
D 8
.I f
E 8
I 8
.Va f
E 8
and
D 8
.I dot
is incremented as for `?'.
.TP
D 4
.RI  = f
E 4
I 4
.RI = f
E 8
I 8
.Ad dot
is incremented as for
.Ic ? .
D 12
.Tp Cx Ic =
.Va f
.Cx
E 12
I 12
.It Ic = Ns Va f 
E 12
E 8
E 4
The value of
D 8
.I address
E 8
I 8
.Ad address
E 8
D 2
itself is printed in the
styles indicated by the format
E 2
I 2
itself is printed in the styles indicated by the format
E 2
D 8
.IR f .
E 8
I 8
.Va f .
E 8
(For
D 8
.B i 
E 8
I 8
.Va i
E 8
D 4
format `?' is printed for the parts of the instruction that reference
E 4
I 4
D 13
format zero values are assumed
E 13
I 13
format, zero values are assumed
E 13
for the parts of the instruction that reference
E 4
subsequent words.)
D 8
.PP
E 8
I 8
D 12
.Tp
E 12
I 12
.El
E 12
.Pp
E 8
A
D 8
.I format
E 8
I 8
.Va format
E 8
D 2
consists of one or more characters that specify a style
of printing.
E 2
I 2
consists of one or more characters that specify a style of printing.
E 2
Each format character may be preceded by a decimal integer
that is a repeat count for the format character.
D 13
While stepping through a format
E 13
I 13
While stepping through a format,
E 13
D 8
.I dot
E 8
I 8
.Ad dot
E 8
D 2
is incremented
by the amount given for each format letter.
E 2
I 2
is incremented by the amount given for each format letter.
E 2
If no format is given then the last format is used.
D 4
The format letters available are as follows.
.ta 2.5n .5i
.RS
E 4
I 4
The format characters available are as follows.
D 8
Note that a backslash (\e) must be used
E 8
I 8
Note that a backslash
D 12
.Cx (
.Li \e
.Cx )
.Cx
E 12
I 12
.Pq Li \e
E 12
must be used
E 8
to quote the three numeric formats.
D 8
.de f1
E 4
.TP
D 4
.BR o "	2"
D 2
Print 2 bytes in octal.
All octal numbers output by
E 2
I 2
Print 2 bytes in octal.  All octal numbers output by
E 2
.I adb
are preceded by 0.
E 4
I 4
.BR "\\$1" "	\\$2"
..
.de fR
E 4
.br
.ns
.TP
D 4
.BR O "	4"
Print 4 bytes in octal.
E 4
I 4
.BR "\\$1" "	\\$2"
..
.de fI
E 4
.br
.ns
.TP
D 4
.BR q "	2"
Print in signed octal.
E 4
I 4
.BI "\\$1" "	\\$2"
..
.de f
E 4
.br
.ns
.TP
D 4
.BR Q "	4"
Print long signed octal.
.br
.ns
.TP
.BR d "	2"
Print in decimal.
.br
.ns
.TP
.BR D "	4"
Print long decimal.
.br
.ns
.TP
.BR x "	2"
Print 2 bytes in hexadecimal.
.br
.ns
.TP
.BR X "	4"
Print 4 bytes in hexadecimal.
.br
.ns
.TP
.BR u "	2"
Print as an unsigned decimal number.
.br
.ns
.TP
.BR U "	4"
Print long unsigned decimal.
.br
.ns
.TP
.BR f "	4"
D 2
Print the 32 bit value
as a floating point number.
E 2
I 2
Print the 32 bit value as a floating point number.
E 2
.br
.ns
.TP
.BR F "	8"
Print double floating point.
.br
.ns
.TP
.BR b "	1"
Print the addressed byte in octal.
.br
.ns
.TP
.BR c "	1"
Print the addressed character.
.br
.ns
.TP
.BR C "	1"
Print the addressed character using
E 4
I 4
\\$1
..
.ta 2.5n .5i
.RS
.f1 1 1
E 8
I 8
D 12
.Dw \&M_____\&M
.Dp Cx Ic 1
.Cx \&\ \ \&
.Va 1
.Cx
E 12
I 12
.Pp
.Bl -tag -width \&M_____\&M -compact
.It Ic 1 Va 1 
E 12
E 8
Print 1 byte in the current radix
D 8
(which may be either signed or unsigned; see the $d command).
.fR 2 2
E 8
I 8
(which may be either signed or unsigned; see the
D 10
.Li $d
E 10
I 10
.Ic $d
E 10
command).
D 12
.Dp Cx Ic 2
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic 2 Va 2 
E 12
E 8
Print 2 bytes in the current radix.
D 8
.fR 4 4
E 8
I 8
D 12
.Dp Cx Ic 4
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic 4 Va 4 
E 12
E 8
Print 4 bytes in the current radix.
D 8
.fR v 2
E 8
I 8
D 12
.Dp Cx Ic v
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic v Va 2 
E 12
E 8
Print 2 bytes in the signed variant of the current radix.
D 8
.fR V 4
E 8
I 8
D 12
.Dp Cx Ic V
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic V Va 4 
E 12
E 8
Print 4 bytes in the signed variant of the current radix.
D 8
.fR o 2
E 8
I 8
D 12
.Dp Cx Ic o
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic o Va 2 
E 12
E 8
Print 2 bytes in unsigned octal.  All octal numbers output by
D 8
.I adb
E 8
I 8
.Nm adb
E 8
are preceded by 0.
D 8
.fR O 4
E 8
I 8
D 12
.Dp Cx Ic O
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic O Va 4 
E 12
E 8
Print 4 bytes in unsigned octal.
D 8
.fR q 2
E 8
I 8
D 12
.Dp Cx Ic q
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic q Va 2 
E 12
E 8
Print 2 bytes in signed octal.
D 8
.fR Q 4
E 8
I 8
D 12
.Dp Cx Ic Q
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic Q Va 4 
E 12
E 8
Print 4 bytes in signed octal.
D 8
.fR u 2
E 8
I 8
D 12
.Dp Cx Ic u
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic u Va 2 
E 12
E 8
Print 2 bytes in unsigned decimal.
D 8
.fR U 4
E 8
I 8
D 12
.Dp Cx Ic U
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic U Va 4 
E 12
E 8
Print 4 bytes in long unsigned decimal.
D 8
.fR d 2
E 8
I 8
D 12
.Dp Cx Ic d
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic d Va 2 
E 12
E 8
Print 2 bytes in signed decimal.
D 8
.fR D 4
E 8
I 8
D 12
.Dp Cx Ic D
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic D Va 4 
E 12
E 8
Print 4 bytes in long signed decimal.
D 8
.fR x 2
E 8
I 8
D 12
.Dp Cx Ic x
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic x Va 2 
E 12
E 8
Print 2 bytes in unsigned hexadecimal.
D 8
.fR X 4
E 8
I 8
D 12
.Dp Cx Ic X
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic X Va 4 
E 12
E 8
Print 4 bytes in unsigned hexadecimal.
D 8
.fR z 2
E 8
I 8
D 12
.Dp Cx Ic z
.Cx \&\ \ \&
.Va 2
.Cx
E 12
I 12
.It Ic z Va 2 
E 12
E 8
Print 2 bytes in signed hexadecimal.
D 8
.fR Z 4
E 8
I 8
D 12
.Dp Cx Ic Z
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic Z Va 4 
E 12
E 8
Print 4 bytes in signed hexadecimal.
D 8
.fR f 4
E 8
I 8
D 12
.Dp Cx Ic f
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic f Va 4 
E 12
E 8
Print 4 bytes as a floating point number.
D 8
.fR F 8
E 8
I 8
D 12
.Dp Cx Ic F
.Cx \&\ \ \&
.Va 8
.Cx
E 12
I 12
.It Ic F Va 8 
E 12
E 8
D 13
Print 8 bytes as a double floating point number.
E 13
I 13
Print 8 bytes as a double precision floating point number.
E 13
D 8
.fR b 1
E 8
I 8
D 12
.Dp Cx Ic b
.Cx \&\ \ \&
.Va 1
.Cx
E 12
I 12
.It Ic b Va 1 
E 12
E 8
Print 1 byte in unsigned octal.
D 8
.fR c 1
E 8
I 8
D 12
.Dp Cx Ic c
.Cx \&\ \ \&
.Va 1
.Cx
E 12
I 12
.It Ic c Va 1 
E 12
E 8
Print 1 byte as a character.
D 8
.fR C 1
E 8
I 8
D 12
.Dp Cx Ic C
.Cx \&\ \ \&
.Va 1
.Cx
E 12
I 12
.It Ic C Va 1 
E 12
E 8
Print 1 byte as a character, using
E 4
the standard escape convention where control characters
D 10
are printed as ^X and the delete character is printed as ^?.
E 10
I 10
are printed as
D 12
.Cx \&^ Ar X
.Cx
and the delete character is printed as ^?.
E 10
D 4
.br
.ns
.TP
.BI s "	n"
E 4
I 4
D 8
.fI s n
E 8
I 8
.Dp Cx Ic s
.Cx \&\ \ \&
.Va n
.Cx
E 12
I 12
.Ql \&^X
and the delete character is printed as
.Ql ^? .
.It Ic s Va n 
E 12
E 8
E 4
D 2
Print the addressed characters until a zero character
is reached.
E 2
I 2
Print the addressed characters until a zero character is reached.
I 13
.Ar n
is the length of the string including its zero terminator.
E 13
E 2
D 4
.br
.ns
.TP
.BI S "	n"
E 4
I 4
D 8
.fI S n
E 4
D 2
Print a string using 
the ^\fIX\fR escape convention (see \fBC\fR above).
E 2
I 2
Print a string using the ^\fIX\fR escape convention (see \fBC\fR above).
E 2
.I n
E 8
I 8
D 12
.Dp Cx Ic S
.Cx \&\ \ \&
.Va n
.Cx
E 12
I 12
.It Ic S Va n 
E 12
D 10
Print a string using the ^
.Ar X
E 10
I 10
Print a string using the
D 12
.Cx \&^ Ar X
.Cx
E 12
I 12
.Ql ^X
E 12
E 10
escape convention (see
.Ar C
above).
.Ar n
E 8
is the length of the string including its zero terminator.
D 4
.br
.ns
.TP
.BR Y "	4"
E 4
I 4
D 8
.fR Y 4
E 8
I 8
D 12
.Dp Cx Ic Y
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.It Ic Y Va 4 
E 12
E 8
E 4
Print 4 bytes in date format (see
D 8
.IR ctime (3)).
D 4
.br
.ns
.TP
.BR i "	n"
E 4
I 4
.fR i n
E 8
I 8
.Xr ctime 3 ) .
D 12
.Dp Cx Ic i
.Cx \&\ \ \&
.Va n
.Cx
E 12
I 12
.It Ic i Va n 
E 12
E 8
E 4
D 2
Print as VAX instructions.
E 2
I 2
Print as machine instructions.
E 2
D 8
.I n
E 8
I 8
.Ar n
E 8
is the number of bytes occupied by the instruction.
D 4
This style of printing causes variables 1 and 2 to be set
to the offset parts of the source and destination respectively.
.br
.ns
.TP
.BR a "	0"
E 4
I 4
This style of printing causes the numeric variables 1, 2, ... to be set
according to the offset parts of the arguments, if any, of the instruction
D 12
(up to 6 on the VAX).
D 8
.fR a 0
E 8
I 8
.Dp Cx Ic a
.Cx \&\ \ \&
.Va 0
.Cx
E 12
I 12
(up to 6 on the
.Tn VAX ) .
.It Ic a Va 0 
E 12
E 8
E 4
Print the value of
D 8
.I dot
E 8
I 8
.Ad dot
E 8
in symbolic form.
Symbols are checked to ensure that they have an appropriate
type as indicated below.
D 8
.LP
	/	local or global data symbol
.br
	?	local or global text symbol
.br
	=	local or global absolute symbol
D 4
.TP
.BR p "	4"
E 4
I 4
.f1 p 4
E 8
I 8
D 12
.Dw AAAA
.Dp Va /
E 12
I 12
.Bl -tag -width flag -compact
.It Va /
E 12
local or global data symbol
D 12
.Dp Va \&?
.Cx
E 12
I 12
.It Va \&?
E 12
local or global text symbol
D 12
.Dp Va \&=
.Cx
E 12
I 12
.It Va \&=
E 12
local or global absolute symbol
D 12
.Dp
.Dp Cx Ic p
.Cx \&\ \ \&
.Va 4
.Cx
E 12
I 12
.El
.It Ic p Va 4 
E 12
E 8
E 4
Print the addressed value in symbolic form using
the same rules for symbol lookup as
D 8
.BR a .
D 4
.br
I 2
.tr ''
E 2
.ns
.TP
.BR t "	0"
E 4
I 4
.fR t 0
E 8
I 8
.Ic a .
D 12
.Dp Cx Ic t
.Cx \&\ \ \&
.Va 0
.Cx
E 12
I 12
.It Ic t Va 0 
E 12
E 8
E 4
D 2
When preceded by an integer tabs to the next
appropriate tab stop.
E 2
I 2
D 13
When preceded by an integer tabs to the next appropriate tab stop.
E 13
I 13
When preceded by an integer, tabs to the next appropriate tab stop.
E 13
E 2
For example,
D 8
.B 8t 
E 8
I 8
.Li 8t
E 8
moves to the next 8-space tab stop.
D 4
.br
.ns
.TP
.BR r "	0"
E 4
I 4
D 8
.fR r 0
E 8
I 8
D 12
.Dp Cx Ic r
.Cx \&\ \ \&
.Va 0
.Cx
E 12
I 12
.It Ic r Va 0 
E 12
E 8
E 4
Print a space.
D 4
.br
.ns
.TP
.BR n "	0"
E 4
I 4
D 8
.fR n 0
E 8
I 8
D 12
.Dp Cx Ic n
.Cx \&\ \ \&
.Va 0
.Cx
E 12
I 12
.It Ic n Va 0 
E 12
E 8
E 4
Print a newline.
I 13
.ne 2v
E 13
D 4
.br
.ns
E 4
D 8
.tr '"
D 4
.TP
.BR '...' " 0"
E 4
I 4
.fR '...' 0
E 8
I 8
D 10
.Dp Ic \*(Rq...\*(Lq
E 10
I 10
D 12
.Dp Ic \*(Lq...\*(Rq
E 10
.Va 0
D 10
\&\ \ \&
E 10
I 10
.br
E 12
I 12
.It Ic \*(Lq...\*(Rq Va 0
E 12
E 10
E 8
E 4
Print the enclosed string.
D 4
.br
E 4
D 8
.tr ''
D 4
.br
.ns
.TP
.B ^
E 4
I 4
.f ^
E 4
.I Dot
E 8
I 8
D 10
.Dp ^
E 10
I 10
D 12
.Dp Ic \&^
E 12
I 12
.It Ic \&^
E 12
E 10
.Ad Dot
E 8
D 2
is decremented by the current increment.
Nothing is printed.
E 2
I 2
is decremented by the current increment.  Nothing is printed.
E 2
D 4
.br
.ns
.TP
+
E 4
I 4
D 8
.f +
E 4
.I Dot
E 8
I 8
D 10
.Dp +
E 10
I 10
D 12
.Dp Ic \&+
E 12
I 12
.It Ic \&+
E 12
E 10
.Ad Dot
E 8
D 2
is incremented by 1.
Nothing is printed.
E 2
I 2
is incremented by 1.  Nothing is printed.
E 2
D 4
.br
.ns
.TP
\-
E 4
I 4
D 8
.f \-
E 4
.I Dot
E 8
I 8
D 10
.Dp \-
E 10
I 10
D 12
.Dp Ic \&\-
E 12
I 12
.It Ic \&\-
E 12
E 10
.Ad Dot
E 8
D 2
is decremented by 1.
Nothing is printed.
E 2
I 2
is decremented by 1.  Nothing is printed.
E 2
D 8
.RE
.TP
newline
E 8
I 8
D 12
.Dp newline
E 12
I 12
.It newline
E 12
E 8
Repeat the previous command with a
D 8
.I count
E 8
I 8
.Va count
E 8
of 1.
I 4
D 8
.rm f
.rm fI
.rm fB
.rm f1
E 4
.TP
.RB [ ?/ ] l "\fI value mask\fR"
E 8
I 8
D 12
.Dp
E 12
I 12
.El
E 12
.Pp
D 12
.Tw $modifier
.Tp Cx Op Ic ?/
.Ic l\ \&
.Va value mask
.Cx
E 12
I 12
.Bl -tag -width $modifier
.It Xo
.Oo Ic ?/ Oc Ns Ic l
.Va "value mask"
.Xc
E 12
E 8
Words starting at
D 4
.I  dot
E 4
I 4
D 8
.I dot
E 8
I 8
.Ad dot
E 8
E 4
are masked with
D 8
.I mask
and compared with
.I value
E 8
I 8
.Va mask
and
compared with
.Va value
E 8
D 2
until
a match is found.
E 2
I 2
until a match is found.
E 2
If
D 8
.B L
E 8
I 8
.Cm L
E 8
is used then the match is for 4 bytes at a time instead of 2.
If no match is found then
D 8
.I dot
E 8
I 8
.Ad dot
E 8
is unchanged; otherwise
D 8
.I dot
E 8
I 8
.Ad dot
E 8
is set to the matched location.
If
D 8
.I mask
E 8
I 8
.Va mask
E 8
D 4
is omitted then \-1 is used.
E 4
I 4
is omitted then all bits are compared.
E 4
D 8
.TP
.RB [ ?/ ] w "\fI value ...\fR"
E 8
I 8
D 12
.Tp Cx Op Ic ?/
.Ic w\ \&
.Va value ...
.Cx
E 12
I 12
.It Xo
.Oo Ic ?/ Oc Ns Ic w
.Va "value ..."
.Xc
E 12
E 8
Write the 2-byte
D 8
.I value
E 8
I 8
.Va value
E 8
D 2
into the addressed
location.
If the command is
E 2
I 2
into the addressed location.  If the command is
E 2
D 8
.BR W ,
E 8
I 8
.Ic W ,
E 8
write 4 bytes.
D 2
Odd addresses are not allowed when writing to the subprocess
address space.
E 2
I 2
D 4
Odd addresses are not allowed when writing to the subprocess address space.
E 4
I 4
D 8
Odd addresses \fIare\fP allowed
E 8
I 8
Odd addresses
.Em are
allowed
E 8
when writing to the subprocess address space.
E 4
E 2
D 8
.TP
[\fB?/\fR]\fBm\fI b1 e1 f1\fR[\fB?/\fR]
.br
E 8
I 8
D 12
.Tp Cx Op Ic ?/
.Ic m\ \&
.Ad b1 e1 f1
.Op Ic ?/
.Cx
E 12
I 12
.It Xo
.Oo Ic ?/ Oc Ns Ic m
.Ad b1 e1 f1 Ns Op Ic ?/ 
.Xc
E 12
E 8
New values for
D 8
.RI ( b1,\ e1,\ f1 )
E 8
I 8
D 10
.Ad  ( b1 , e1 , f1 )
E 10
I 10
D 12
.Pf \&( Ad b1 , e1 , f1 )
E 12
I 12
.Pq Ad b1 , e1 , f1
E 12
E 10
E 8
D 2
are recorded.
If less than three expressions are given then
E 2
I 2
are recorded.  If less than three expressions are given then
E 2
the remaining map parameters are left unchanged.
D 8
If the `?' or `/' is followed by `\*(ST' then
the second segment (\fIb2\fR\|,\|\fIe2\fR\|,\|\fIf2\fR)
E 8
I 8
If the
.Ic ?
or
.Ic /
is followed by
.Li *
then
D 10
the second segment (
.Ad  ( b2 , e2 , f2 )
E 10
I 10
the second segment
D 12
.Pf \&( Ad b2 , e2 , f2 )
E 12
I 12
.Pq Ad b2 , e2 , f2
E 12
E 10
E 8
of the mapping is changed.
D 2
If the list is terminated by `?' or `/' then the file
(\fIobjfil\fR or
E 2
I 2
D 8
If the list is terminated by `?' or `/' then the file (\fIobjfil\fR or
E 2
.I corfil
E 8
I 8
If the list is terminated by
.Ic ?
or
.Ic /
then the file
D 10
.Ar ( objfil
E 10
I 10
D 12
.Pf \&( Ar objfil
E 12
I 12
.Pf ( Ar objfil
E 12
E 10
or
.Ar corfil
E 8
D 2
respectively) is used
for subsequent requests.
E 2
I 2
respectively) is used for subsequent requests.
E 2
D 4
(So that, for example, `/m?' will cause `/' to refer to
.IR objfil .)
E 4
I 4
D 8
For example, `/m?' will cause `/' to refer to
.IR objfil .
E 4
.TP
.BI \*(GT name
.I Dot
E 8
I 8
For example,
D 10
.Li /m?
E 10
I 10
.Sq Li /m?
E 10
will cause
.Ic /
to refer to
.Ar objfil .
D 12
.Tp Cx Ic >
.Va name
.Cx
E 12
I 12
.It Ic > Ns Va name 
E 12
.Ad Dot
E 8
is assigned to the variable or register named.
D 8
.TP
.B !
D 2
A shell is called to read the
rest of the line following `!'.
E 2
I 2
A shell (/bin/sh) is called to read the rest of the line following `!'.
E 2
.TP
.RI $ modifier
D 2
Miscellaneous commands.
The available 
E 2
I 2
Miscellaneous commands.  The available 
E 2
.I modifiers 
E 8
I 8
D 12
.Tp Ic \&!
E 12
I 12
.It Ic \&!
E 12
A shell
D 10
.Cx \&(
.Pa /bin/sh )
.Cx
E 10
I 10
D 12
.Pf \&( Pa /bin/sh )
E 12
I 12
.Pq Pa /bin/sh
E 12
E 10
is called to read the rest of the line following
.Ic \&! .
D 12
.Tp Cx Cm $
.Va modifier
.Cx
E 12
I 12
.It Cm $ Ns Va modifier 
E 12
Miscellaneous commands.  The available
.Va modifiers
E 8
are:
I 4
D 8
.de f
.br
.ns
.TP
..
E 4
.RS
.TP
.BI < f
Read commands from the file
.IR f .
E 8
I 8
D 12
.Tw fil
.Tp Cx Cm <
.Va file
.Cx
E 12
I 12
.Bl -tag -width filexx
.It Cm < Ns Va file 
E 12
Read commands from
D 13
.Va file
E 13
I 13
.Va file .
E 13
E 8
If this command is executed in a file, further commands
in the file are not seen.
If
D 8
.I f
E 8
I 8
.Va file
E 8
D 2
is omitted, the current input stream is terminated.
If a
E 2
I 2
is omitted, the current input stream is terminated.  If a
E 2
D 8
.I count
E 8
I 8
.Va count
E 8
is given, and is zero, the command will be ignored.
The value of the count will be placed in variable
D 8
.I 9
E 8
I 8
.Va 9
E 8
before the first command in
D 8
.I f
E 8
I 8
.Va file
E 8
is executed.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.BI << f
E 8
I 8
D 12
.Tp Cx Cm <<
.Va file
.Cx
E 12
I 12
.It Cm << Ns Va file 
E 12
E 8
Similar to
D 8
.B <
E 8
I 8
.Cm <
E 8
except it can be used in a file of commands without
D 2
causing the file to be closed.
Variable
E 2
I 2
causing the file to be closed.  Variable
E 2
D 8
.I 9
E 8
I 8
.Va 9
E 8
D 2
is saved during the execution of this command, and restored
when it completes.
E 2
I 2
is saved during the execution of this command, and restored when it completes.
E 2
There is a (small) finite limit to the number of
D 8
.B <<
E 8
I 8
.Cm <<
E 8
files that can be open at once.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.BI > f
E 8
I 8
D 12
.Tp Cx Cm >
.Va file
.Cx
E 12
I 12
.It Cm > Ns Va file 
E 12
E 8
Append output to the file
D 8
.IR f ,
E 8
I 8
.Va file ,
E 8
D 2
which is created if it does not exist.
If
E 2
I 2
which is created if it does not exist.  If
E 2
D 8
.I f
E 8
I 8
.Va file
E 8
is omitted, output is returned to the terminal.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B ?
E 8
I 8
D 12
.Tp Cx Cm ?
.Va file
.Cx
E 12
I 12
.It Cm ? Ns Va file 
E 12
E 8
Print process id, the signal which caused stoppage or termination,
D 8
as well as the registers as \fB$r\fR.  This is the default if
\fImodifier\fR is omitted.
D 4
.br
.ns
.TP
E 4
I 4
.f
E 4
.B r
E 8
I 8
as well as the registers as
.Ic $r .
This is the default if
.Va modifier
is omitted.
D 12
.Tp Cm r
E 12
I 12
.It Cm r
E 12
E 8
D 2
Print the general registers and
the instruction addressed by
E 2
I 2
Print the general registers and the instruction addressed by
E 2
D 8
.BR pc .
.I Dot
is set to \fBpc\fR.
D 4
.br
.ns
.TP
E 4
I 4
.f
E 4
.B b
E 8
I 8
.Nm pc .
.Ad Dot
is set to
.Nm pc .
D 12
.Tp Cm b
E 12
I 12
.It Cm b
E 12
E 8
D 2
Print all breakpoints
and their associated counts and commands.
E 2
I 2
Print all breakpoints and their associated counts and commands.
E 2
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B c
E 8
I 8
D 12
.Tp Cm c
E 12
I 12
.It Cm c
E 12
E 8
D 2
C stack backtrace.
If
E 2
I 2
C stack backtrace.  If
E 2
D 8
.I address
D 2
is given then it is taken as the
address of the current frame (instead of
.BR r5 ).
If
E 2
I 2
is given then it is taken as the address of the current frame 
E 8
I 8
.Ad address
is given then it is taken as the address of the current frame
E 8
instead of the contents of the frame\-pointer register.  If
E 2
D 8
.B C 
E 8
I 8
.Cm C
E 8
D 2
is used then the names and (16 bit) values of all automatic
and static variables are printed for each active function.
If
E 2
I 2
is used then the names and (32 bit) values of all automatic
D 4
and static variables are printed for each active function. (broken
on the VAX).  If
E 4
I 4
and static variables are printed for each active function
(this is partially broken; the names are not now available).  If
E 4
E 2
D 8
.I count
E 8
I 8
.Va count
E 8
is given then only the first
D 8
.I count
E 8
I 8
.Va count
E 8
frames are printed.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B d
E 8
I 8
D 12
.Tp Cm d
E 12
I 12
.It Cm d
E 12
E 8
Set the default radix to
D 8
.I address
E 8
I 8
.Ad address
E 8
D 2
and report the new value.
Note that
E 2
I 2
D 4
and report the new value.  Note that
E 4
I 4
and report the new value.  If no
E 4
E 2
D 8
.I address
E 8
I 8
.Ad address
E 8
D 4
is interpreted in the (old) current radix.
Thus \*(lq10$d\*(rq never changes the default radix.
To make decimal the default radix, use \*(lq0t10$d\*(rq.
.br
.ns
.TP
E 4
I 4
is given, the default radix is not changed.
The new radix must be between -16 (decimal) and 16 (decimal)
and must not be 0, 1, or -1.
A negative radix implies that numbers printed in that radix
will be treated as signed; otherwise they are treated as unsigned.
Note that
D 8
.I address
E 8
I 8
.Ad address
E 8
is interpreted in the (old) current radix.
D 12
Thus \*(lq10$d\*(rq simply changes the default radix to unsigned.
To make signed decimal the default radix, use \*(lq-0t10$d\*(rq.
D 8
.f
E 4
.B e
E 8
I 8
.Tp Cm e
E 12
I 12
Thus
.Dq "10$d"
simply changes the default radix to unsigned.
To make signed decimal the default radix, use
.Dq "-0t10$d"
.It Cm e
E 12
E 8
D 2
The names and values of
external variables are printed.
E 2
I 2
The names and values of external variables are printed.
E 2
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B w
E 8
I 8
D 12
.Tp Cm w
E 12
I 12
.It Cm w
E 12
E 8
Set the page width for output to
D 8
.I address
E 8
I 8
.Ad address
E 8
(default 80).
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B s
E 8
I 8
D 12
.Tp Cm s
E 12
I 12
.It Cm s
E 12
E 8
Set the limit for symbol matches to
D 8
.I address
E 8
I 8
.Ad address
E 8
D 6
(default 255).
E 6
I 6
(default 1024).
E 6
D 4
.br
.ns
.TP
.B o
All integers input are regarded as octal.
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
D 2
.B d
Reset integer input as described in
.SM EXPRESSIONS.
.br
.ns
.TP
E 2
.B q
E 8
I 8
D 12
.Tp Cm q
E 12
I 12
.It Cm q
E 12
E 8
Exit from
D 8
.IR adb .
D 4
.br
.ns
.TP
E 4
I 4
.f
E 4
.B v
E 8
I 8
.Nm adb .
D 12
.Tp Cm v
E 12
I 12
.It Cm v
E 12
E 8
Print all non zero variables in octal.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B m
E 8
I 8
D 12
.Tp Cm m
E 12
I 12
.It Cm m
E 12
E 8
Print the address map.
I 2
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
.B p
.RI ( "Kernel debugging" )
Change the current kernel memory mapping to map the designated 
.B "user structure"
E 8
I 8
D 12
.Tp Cm p
D 10
.Em ( Kernel debugging )
E 10
I 10
.Pf \&( Em Kernel debugging )
E 12
I 12
.It Cm p
.Pq Em Kernel debugging
E 12
E 10
Change the current kernel memory mapping to map the designated
.Sy user structure
E 8
to the address given by the symbol
D 8
.I "_u."
E 8
I 8
.Sy _u .
E 8
The
D 8
.I address
E 8
I 8
.Ad address
E 8
D 4
argument is the address of the user's user page table entries (on
the VAX).
E 4
I 4
argument is the address of the user's user page table entries.
E 4
E 2
D 8
.RE
.TP
.BI : modifier
E 8
I 8
D 12
.Tp
.Tp Cx Cm :
.Va modifier
.Cx
E 12
I 12
.El
.It Cm : Ns Va modifier 
E 12
E 8
D 2
Manage a subprocess.
Available modifiers are:
E 2
I 2
Manage a subprocess.  Available modifiers are:
E 2
D 8
.RS
.TP
.BI b c
E 8
I 8
D 12
.Tw Ds
.Tp Cx Cm b
.Va c
.Cx
E 12
I 12
.Bl -tag -width Ds
.It Cm b Ns Va c 
E 12
E 8
Set breakpoint at
D 8
.IR address .
E 8
I 8
.Ad address .
E 8
The breakpoint is executed
D 8
.IR count \-1
E 8
I 8
.Va count\-1
E 8
D 2
times before
causing a stop.
Each time the breakpoint is encountered
the command
E 2
I 2
D 7
times before causing a stop.
E 7
I 7
times before causing a stop,
after which it stops unconditionally.
E 7
Each time the breakpoint is encountered the command
E 2
D 8
.I c
E 8
I 8
.Va c
E 8
D 2
is executed.
If this command is omitted or sets
E 2
I 2
is executed.  If this command is omitted or sets
E 2
D 8
.I dot
E 8
I 8
.Ad dot
E 8
D 2
to zero
then the breakpoint causes a stop.
E 2
I 2
D 7
to zero then the breakpoint causes a stop.
E 7
I 7
to zero, the breakpoint causes a stop immediately,
regardless of any remaining count.
E 7
E 2
D 8
.TP
.B d
E 8
I 8
D 12
.Tp Cm d
E 12
I 12
.It Cm d
E 12
E 8
Delete breakpoint at
D 8
.IR address .
.TP
I 4
.B D
E 8
I 8
.Ad address .
D 12
.Tp Cm D
E 12
I 12
.It Cm D
E 12
E 8
Delete all breakpoints.
D 8
.TP
E 4
.B r
E 8
I 8
D 12
.Tp Cm r
E 12
I 12
.It Cm r
E 12
E 8
Run
D 8
.I objfil
E 8
I 8
.Ar objfil
E 8
D 2
as a subprocess.
If
E 2
I 2
as a subprocess.  If
E 2
D 8
.I address
E 8
I 8
.Ad address
E 8
D 2
is given explicitly then the
program is entered at this point; otherwise
E 2
I 2
is given explicitly then the program is entered at this point; otherwise
E 2
the program is entered at its standard entry point.
D 8
.I count
E 8
I 8
.Va count
E 8
D 2
specifies how many breakpoints are to be
ignored before stopping.
Arguments to the subprocess may be supplied on the
same line as the command.
E 2
I 2
specifies how many breakpoints are to be ignored before stopping.
Arguments to the subprocess may be supplied on the same line as the command.
E 2
An argument starting with < or > causes the standard
input or output to be established for the command.
D 2
All signals are turned on on entry to the subprocess.
E 2
D 8
.TP
.BI c s
E 8
I 8
D 12
.Tp Cx Cm c
.Va s
.Cx
E 12
I 12
.It Cm c Ns Va s 
E 12
E 8
D 2
The subprocess is continued
with signal
.I s
c
E 2
I 2
The subprocess is continued with signal
E 2
D 8
.I s,
E 8
I 8
D 13
.Va s
E 13
I 13
.Va s ;
E 13
E 8
see
D 2
.IR signal (2).
E 2
I 2
D 8
.IR sigvec (2).
E 8
I 8
.Xr sigvec 2 .
E 8
E 2
If
D 8
.I address
E 8
I 8
.Ad address
E 8
D 2
is given then the subprocess
is continued at this address.
E 2
I 2
is given then the subprocess is continued at this address.
E 2
If no signal is specified then the signal
that caused the subprocess to stop is sent.
D 2
Breakpoint skipping is the same
as for
E 2
I 2
Breakpoint skipping is the same as for
E 2
D 8
.BR r .
.TP
.BI s s
E 8
I 8
.Cm r .
D 12
.Tp Cx Cm s
.Va s
.Cx
E 12
I 12
.It Cm s Ns Va s 
E 12
E 8
As for
D 8
.B c 
E 8
I 8
.Cm c
E 8
D 2
except that
the subprocess is single stepped
E 2
I 2
except that the subprocess is single stepped
E 2
D 8
.I count
E 8
I 8
.Va count
E 8
D 2
times.
If there is no current subprocess then
E 2
I 2
times.  If there is no current subprocess then
E 2
D 8
.I objfil
E 8
I 8
.Ar objfil
E 8
D 2
is run
as a subprocess as for
E 2
I 2
is run as a subprocess as for
E 2
D 8
.BR r .
E 8
I 8
.Cm r .
E 8
In this case no signal can be sent; the remainder of the line
is treated as arguments to the subprocess.
D 8
.TP
.B k
E 8
I 8
D 12
.Tp Cm k
E 12
I 12
.It Cm k
E 12
E 8
The current subprocess, if any, is terminated.
D 8
.RE
.SH VARIABLES
.I Adb
E 8
I 8
D 12
.Tp
.Tp
E 12
I 12
.El
.El
E 12
.Sh VARIABLES
.Nm Adb
E 8
provides a number of variables.
Named variables are set initially by
D 4
.I  adb
E 4
I 4
D 8
.I adb
E 8
I 8
.Nm adb
E 8
E 4
but are not used subsequently.
D 2
Numbered variables are reserved for communication
as follows.
E 2
I 2
Numbered variables are reserved for communication as follows.
E 2
D 8
.TP
0
E 8
I 8
D 12
.Dw Ds
.Di L
.Dp \&0
E 12
I 12
.Pp
.Bl -tag -width Ds -compact
.It \&0
E 12
E 8
The last value printed.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
1
E 8
I 8
D 12
.Dp \&1
E 12
I 12
.It \&1
E 12
E 8
The last offset part of an instruction source.
D 4
.br
.ns
.TP
2
The previous value of variable 1.
.br
.ns
.TP
E 4
I 4
D 12
This continues up through at most 6 on the VAX.
E 12
I 12
This continues up through at most 6 on the
.Tn VAX .
E 12
For a three-operand instruction, variable 2 is the second source offset
and variable 3 the destination offset part.
D 8
.f
E 4
9
E 8
I 8
D 12
.Dp \&9
E 12
I 12
.It \&9
E 12
E 8
The count on the last $< or $<< command.
D 8
.PP
E 8
I 8
D 12
.Dp
E 12
I 12
.El
.Pp
E 12
E 8
D 2
On entry the following are set
from the system header in the
E 2
I 2
On entry the following are set from the system header in the
E 2
D 8
.IR corfil .
E 8
I 8
.Ar corfil .
E 8
If
D 8
.I corfil
E 8
I 8
.Ar corfil
E 8
does not appear to be a
D 8
.B core 
E 8
I 8
.Pa core
E 8
D 2
file then
these values are set from
E 2
I 2
file then these values are set from
E 2
D 8
.IR objfil .
.TP
b
E 8
I 8
.Ar objfil .
D 12
.Dw Ds
.Di L
.Dp b
E 12
I 12
.Pp
.Bl -tag -width Ds -compact
.It b
E 12
E 8
The base address of the data segment.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
d
E 8
I 8
D 12
.Dp d
E 12
I 12
.It d
E 12
E 8
The data segment size.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
e
E 8
I 8
D 12
.Dp e
E 12
I 12
.It e
E 12
E 8
The entry point.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
m
E 8
I 8
D 12
.Dp m
E 12
I 12
.It m
E 12
E 8
The `magic' number (0407, 0410 or 0413).
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
s
E 8
I 8
D 12
.Dp s
E 12
I 12
.It s
E 12
E 8
The stack segment size.
D 4
.br
.ns
.TP
E 4
I 4
D 8
.f
E 4
t
E 8
I 8
D 12
.Dp t
E 12
I 12
.It t
E 12
E 8
The text segment size.
D 8
.SH ADDRESSES
E 8
I 8
.Sh ADDRESSES
E 8
The address in a file associated with
D 2
a written address is determined by a mapping
associated with that file.
E 2
I 2
a written address is determined by a mapping associated with that file.
E 2
Each mapping is represented by two triples
D 8
.RI ( "b1, e1, f1" )
E 8
I 8
D 10
.Ad ( b1 , e1 , f1 )
E 10
I 10
D 12
.Pf \&( Ad b1 , e1 , f1 )
E 12
I 12
.Pq Ad b1 , e1 , f1
E 12
E 10
E 8
and
D 8
.RI ( "b2, e2, f2" )
E 8
I 8
D 10
.Ad ( b2 , e2 , f2 )
E 10
I 10
D 12
.Pf \&( Ad b2 , e2 , f2 )
E 12
I 12
.Pq Ad b2 , e2 , f2
E 12
E 10
E 8
and the
D 8
.I file address
E 8
I 8
.Ad file
.Ad address
E 8
corresponding to a written
D 8
.I address
E 8
I 8
.Ad address
E 8
is calculated as follows.
I 12
.Bd -filled -offset indent
D 13
\*(aDb1\*(sY\*(<=\*(aRaddress \*(sY\(->
\*(aRfile address\*(dF=\*(aRaddress\*(sY+\*(aDf1\*(sY-\*(aDf1,
E 13
I 13
\*(aDb1\*(sY\*(<=\*(aRaddress\*(<=\*(aDe1 \*(sY\(->
\*(aRfile address\*(dF=\*(aRaddress\*(sY+\*(aDf1\*(sY-\*(aDb1,
E 13
otherwise
.Ed
E 12
D 8
.PP
.if t .ti 1.5i
.if n .ti 8
.IR b1 \*(LE address < e1
\*(IM
.IR "file address" = address + f1\-b1,
otherwise,
.PP
.if t .ti 1.5i
.if n .ti 8
.IR b2 \*(LE address < e2
\*(IM
.IR "file address" = address + f2\-b2,
.PP
E 8
I 8
.Pp
D 12
.Ds I
.Cx Ad b1
.Sy \&\*(<=
.Ad address
.Sy <
.Ad e1
.Sy \ \&\(->\ \&
.Ad file address
.Sy =
.Ad address
.Sy +
.Ad f1
.Sy \-
.Ad b1 ,
.Cx \ \&
.Cx otherwise,
.Cx
.De
E 12
I 12
.Bd -filled -offset indent
D 13
\*(aDb1\*(sY\*(<=\*(aRaddress \*(sY\(->
\*(aRfile address\*(dF=\*(aRaddress\*(sY+\*(aDf2\*(sY-\*(aDf2\*(dF
E 13
I 13
\*(aDb2\*(sY\*(<=\*(aRaddress\*(<=\*(aDe2 \*(sY\(->
\*(aRfile address\*(dF=\*(aRaddress\*(sY+\*(aDf2\*(sY-\*(aDb2\*(dF
E 13
.Ed
E 12
.Pp
D 12
.Ds I
.Cx Ad b2
.Sy \&\*(<=
.Ad address
.Sy <
.Ad e2
.Sy \ \&\(->\ \&
.Ad file address
.Sy =
.Ad address
.Sy +
.Ad f2
.Sy \-
.Ad b2 ,
.Cx
.De
.Pp
E 12
E 8
otherwise, the requested
D 8
.I address
E 8
I 8
.Ar address
E 8
D 2
is not legal.
In some cases (e.g. for programs with separated I and D
space) the two segments for a file may overlap.
If a
E 2
I 2
is not legal.  In some cases (e.g. for programs with separated I and D
space) the two segments for a file may overlap.  If a
E 2
D 8
.B ? 
E 8
I 8
.Ic ?
E 8
or
D 8
.B / 
E 8
I 8
.Ic /
E 8
is followed by an
D 8
.B \*(ST 
E 8
I 8
.Ic *
E 8
D 2
then only the second
triple is used.
E 2
I 2
then only the second triple is used.
E 2
D 8
.PP
E 8
I 8
.Pp
E 8
D 2
The initial setting of both mappings is suitable for
normal
E 2
I 2
The initial setting of both mappings is suitable for normal
E 2
D 8
.B a.out 
E 8
I 8
.Pa a.out
E 8
and
D 8
.B core 
E 8
I 8
.Pa core
E 8
D 2
files.
If either file is not of the kind expected then, for that file,
E 2
I 2
files.  If either file is not of the kind expected then, for that file,
E 2
D 8
.I b1
is set to 0,
.I e1
E 8
I 8
.Ad b1
is set to
.Li 0 ,
.Ad e1
E 8
D 2
is set to
the maximum file size
and
E 2
I 2
is set to the maximum file size and
E 2
D 8
.I f1
E 8
I 8
.Ad f1
E 8
is set to 0; in this way the whole
file can be examined with no address translation.
D 8
.PP
D 2
So that
.I adb
may be used on large files
all appropriate values are kept as signed 32 bit integers.
E 2
.SH FILES
a.out
.br
core
.SH SEE\ ALSO
D 2
sdb(1),
E 2
I 2
cc(1),
dbx(1),
E 2
ptrace(2),
a.out(5),
core(5)
.SH DIAGNOSTICS
`Adb' when there is no current command or format.
E 8
I 8
D 12
.Pp
E 12
.Sh FILES
D 12
.Dw a.out
I 10
.Di L
E 10
.Dp Pa a.out
.Dp Pa core
.Dp
E 12
I 12
.Bl -tag -width a.out -compact
.It Pa a.out
.It Pa core
.El
E 12
.Sh SEE ALSO
.Xr cc 1 ,
.Xr dbx 1 ,
.Xr ptrace 2 ,
.Xr a.out 5 ,
.Xr core 5
.Sh HISTORY
.Nm Adb
D 12
was first released with Version 7 AT&T UNIX.  The version
E 12
I 12
was first released with
.At v7 .
The version
E 12
of
.Nm adb
this man page describes
D 14
is descended from the orignial.
E 14
I 14
is descended from the original.
E 14
.Sh DIAGNOSTICS
.Li `adb'
when there is no current command or format.
E 8
Comments about inaccessible files, syntax errors,
abnormal termination of commands, etc.
D 2
Exit status is 0, unless last command failed or
returned nonzero status.
E 2
I 2
Exit status is 0, unless last command failed or returned nonzero status.
E 2
D 8
.SH BUGS
E 8
I 8
.Sh BUGS
E 8
D 2
Local variable addresses and names are recorded in the
.I a.out
file in a format known only to
.IR sdb (1).
.PP
Use of # for the unary logical negation operator is
peculiar.
.PP
There doesn't seem to be any way to clear all breakpoints.
E 2
I 2
Since no shell is invoked to interpret the arguments of the
D 8
.B :r
E 8
I 8
.Ic :r
E 8
command, the customary wild-card and variable expansions cannot occur.
E 2
E 1
