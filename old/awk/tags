ALLOC	parse.c	/^node *ALLOC(n)$/
Mmain	main.c	/^main(argc, argv) int argc; char *argv[]; {$/
PUTS	lib.c	/^PUTS(s) char *s; {$/
RETURN	awk.lx.c	/^#define	RETURN(x)	{if (ldbg) ptoken(x); return(x);/
TOLOWER	main.c	/^#define TOLOWER(c)	(isupper(c) ? tolower(c) : c) /
YY_FATAL_ERROR	awk.lx.c	/^#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )$/
YY_INPUT	awk.lx.c	/^#define YY_INPUT(buf,result,max_size)				\\$/
YY_PROTO	awk.lx.c	/^#define YY_PROTO(proto) proto$/
YY_SC_TO_UI	awk.lx.c	/^#define YY_SC_TO_UI(c) ((unsigned int) (unsigned c/
YY_STATE_EOF	awk.lx.c	/^#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + st/
add	b.c	/^int *add(n) {		\/* remember setvec *\/$/
aprintf	run.c	/^obj aprintf(a,n) node **a;$/
arith	run.c	/^obj arith(a,n) node **a;$/
array	run.c	/^obj array(a,n) node **a;$/
arrayel	run.c	/^obj arrayel(a,b) node *a; obj b;$/
asprintf	run.c	/^obj asprintf(a,n) node **a;$/
assign	run.c	/^obj assign(a,n) node **a;$/
boolop	run.c	/^obj boolop(a,n) node **a;$/
cat	run.c	/^obj cat(a,q) node **a;$/
cclenter	b.c	/^char *cclenter(p)$/
cfoll	b.c	/^cfoll(v)		\/* enter follow set of each leaf of ver/
cgotofn	b.c	/^struct fa *cgotofn()$/
checkval	tran.c	/^checkval(vp)$/
dopa2	run.c	/^obj dopa2(a,n) node **a;$/
error	lib.c	/^error(isfatal, fmt, va_alist)$/
execute	run.c	/^obj execute(u) node *u;$/
exptostat	parse.c	/^node *exptostat(a) node *a;$/
fieldadr	lib.c	/^cell *fieldadr(n)$/
first	b.c	/^first(p)			\/* collects initially active leaves of/
fldbld	lib.c	/^fldbld()$/
fncn	run.c	/^obj fncn(a,n) node **a;$/
foll_free	b.c	/^foll_free(i)$/
follow	b.c	/^follow(v)$/
format	run.c	/^char *format(s,a) char *s; node *a;$/
forstat	run.c	/^obj forstat(a,n) node **a;$/
freesymtab	tran.c	/^freesymtab(ap)	\/* free symbol table *\/$/
freetr	b.c	/^freetr(p)	\/* free parse tree and follow sets *\/$/
freeze	freeze.c	/^freeze(s) char *s;$/
genprint	parse.c	/^node *genprint()$/
getfval	tran.c	/^awkfloat getfval(vp)$/
getline	run.c	/^obj getline()$/
getrec	lib.c	/^getrec()$/
getsval	tran.c	/^char *getsval(vp)$/
gettemp	run.c	/^obj gettemp()$/
hash	tran.c	/^hash(s)	\/* form hash value for string s *\/$/
ifstat	run.c	/^obj ifstat(a,n) node **a;$/
incrdecr	run.c	/^obj incrdecr(a, n) node **a;$/
indirect	run.c	/^obj indirect(a,n) node **a;$/
instat	run.c	/^obj instat(a, n) node **a;$/
isanumber	lib.c	/^isanumber(s)$/
jump	run.c	/^obj jump(a,n) node **a;$/
left	b.c	/^#define left(v)	v->narg[0]$/
linkum	parse.c	/^node *linkum(a,b) node *a, *b;$/
lookup	tran.c	/^cell *lookup(s, tab, flag)	\/* look for s in tab, /
makedfa	b.c	/^struct fa *makedfa(p)	\/* returns dfa for tree poi/
makesymtab	tran.c	/^cell **makesymtab()$/
match	b.c	/^match(pfa, p)$/
matchop	run.c	/^obj matchop(a,n) node **a;$/
member	b.c	/^member(c, s)	\/* is c in s? *\/$/
node0	parse.c	/^node *node0(a)$/
node1	parse.c	/^node *node1(a,b) node *b;$/
node2	parse.c	/^node *node2(a,b,c) node *b, *c;$/
node3	parse.c	/^node *node3(a,b,c,d) node *b, *c, *d;$/
node4	parse.c	/^node *node4(a,b,c,d,e) node *b, *c, *d, *e;$/
nodetoobj	run.c	/^obj nodetoobj(a) node *a;$/
notin	b.c	/^notin(array, n, prev)		\/* is setvec in array[0] t/
nullproc	run.c	/^obj nullproc() {}$/
op1	parse.c	/^node *op1(a,b) node *b;$/
op2	parse.c	/^node *op2(a,b,c) node *b, *c;$/
op3	parse.c	/^node *op3(a,b,c,d) node *b, *c, *d;$/
overflo	b.c	/^overflo()$/
pa2stat	parse.c	/^node *pa2stat(a,b,c) node *a, *b, *c;$/
parent	b.c	/^#define parent(v)	v->nnext$/
pastat	run.c	/^obj pastat(a,n) node **a;$/
penter	b.c	/^penter(p)	\/* set up parent pointers and leaf indi/
print	run.c	/^obj print(a,n) node **a;$/
program	run.c	/^obj program(a, n) node **a;$/
ptoken	awk.lx.c	/^ptoken(n)$/
recbld	lib.c	/^recbld()$/
redirprint	run.c	/^redirprint(s, a, b) char *s; node *b;$/
relop	run.c	/^obj relop(a,n) node **a;$/
right	b.c	/^#define right(v)	v->narg[1]$/
run	run.c	/^run()$/
setclvar	lib.c	/^setclvar(s)	\/* set var=value from s *\/$/
setfval	tran.c	/^awkfloat setfval(vp, f)$/
setsval	tran.c	/^char *setsval(vp, s)$/
setsymtab	tran.c	/^cell *setsymtab(n, s, f, t, tab)$/
sindex	run.c	/^obj sindex(a, nnn) node **a;$/
split	run.c	/^obj split(a,nnn) node **a;$/
startreg	awk.lx.c	/^startreg()$/
stat1	parse.c	/^node *stat1(a,b) node *b;$/
stat2	parse.c	/^node *stat2(a,b,c) node *b, *c;$/
stat3	parse.c	/^node *stat3(a,b,c,d) node *b, *c, *d;$/
stat4	parse.c	/^node *stat4(a,b,c,d,e) node *b, *c, *d, *e;$/
substr	run.c	/^obj substr(a, nnn) node **a;$/
syminit	tran.c	/^syminit()$/
tempfree	run.c	/^tempfree(a) obj a;$/
thaw	freeze.c	/^thaw(s) char *s;$/
tostring	tran.c	/^char *tostring(s)$/
type	b.c	/^#define type(v)	v->nobj$/
unput	awk.lx.c	/^#define unput(c) yyunput( c, yytext_ptr )$/
valtonode	parse.c	/^node *valtonode(a, b) cell *a;$/
whilestat	run.c	/^obj whilestat(a,n) node **a;$/
yfree	tran.c	/^yfree(a) char *a;$/
ymalloc	tran.c	/^char *ymalloc(u) unsigned u;$/
yy_create_buffer	awk.lx.c	/^YY_BUFFER_STATE yy_create_buffer( file, size )$/
yy_delete_buffer	awk.lx.c	/^void yy_delete_buffer( b )$/
yy_fatal_error	awk.lx.c	/^static void yy_fatal_error( msg )$/
yy_flex_alloc	awk.lx.c	/^static void *yy_flex_alloc( size )$/
yy_flex_free	awk.lx.c	/^static void yy_flex_free( ptr )$/
yy_flex_realloc	awk.lx.c	/^static void *yy_flex_realloc( ptr, size )$/
yy_flex_strcpy	awk.lx.c	/^static void yy_flex_strcpy( s1, s2 )$/
yy_get_next_buffer	awk.lx.c	/^static int yy_get_next_buffer()$/
yy_get_previous_state	awk.lx.c	/^static yy_state_type yy_get_previous_state()$/
yy_init_buffer	awk.lx.c	/^void yy_init_buffer( b, file )$/
yy_pop_state	awk.lx.c	/^static void yy_pop_state()$/
yy_push_state	awk.lx.c	/^static void yy_push_state( new_state )$/
yy_switch_to_buffer	awk.lx.c	/^void yy_switch_to_buffer( new_buffer )$/
yy_top_state	awk.lx.c	/^static int yy_top_state()$/
yy_try_NUL_trans	awk.lx.c	/^static yy_state_type yy_try_NUL_trans( yy_current_/
yyerror	lib.c	/^yyerror(s) char *s; {$/
yyless	awk.lx.c	/^#define yyless(n) \\$/
yymore	awk.lx.c	/^#define yymore() yymore_used_but_not_detected$/
yyrestart	awk.lx.c	/^void yyrestart( input_file )$/
yyterminate	awk.lx.c	/^#define yyterminate() return YY_NULL$/
yyunput	awk.lx.c	/^static void yyunput( c, yy_bp )$/
yywrap	main.c	/^yywrap()$/
