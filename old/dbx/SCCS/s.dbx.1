h37673
s 00267/00377/00469
d D 6.6 91/08/09 20:27:07 cael 7 6
c mdoc version three
e
s 00021/00017/00825
d D 6.5 90/07/24 22:43:32 cael 6 5
c .Xr botch fix
e
s 00636/00376/00206
d D 6.4 90/06/11 05:55:42 cael 5 4
c converted man page
e
s 00014/00003/00568
d D 6.3 89/05/23 10:20:29 bostic 4 3
c add Berkeley specific copyright notice
e
s 00027/00000/00544
d D 6.2 86/01/12 22:04:38 donn 3 2
c Add a description of $unsafecall and $unsafeassign; relate a few of the
c known bugs with Fortran support.
e
s 00207/00218/00337
d D 6.1 85/04/29 21:10:33 mckusick 2 1
c 4.3BSD beta release manual page
e
s 00555/00000/00000
d D 5.1 85/04/29 21:09:40 mckusick 1 0
c manual page first distributed with 4.2BSD
e
u
U
t
T
I 1
D 4
.\" Copyright (c) 1983 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 4
I 4
D 5
.\" Copyright (c) 1983 The Regents of the University of California.
E 5
I 5
.\" Copyright (c) 1983, 1990 The Regents of the University of California.
E 5
.\" All rights reserved.
.\"
D 5
.\" Redistribution and use in source and binary forms are permitted
.\" provided that the above copyright notice and this paragraph are
.\" duplicated in all such forms and that any documentation,
.\" advertising materials, and other materials related to such
.\" distribution and use acknowledge that the software was developed
.\" by the University of California, Berkeley.  The name of the
.\" University may not be used to endorse or promote products derived
.\" from this software without specific prior written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 5
I 5
D 7
.\" %sccs.include.redist.man%
E 7
I 7
.\" %sccs.include.redist.roff%
E 7
E 5
E 4
.\"
D 5
.\"	%W% (Berkeley) %G%
E 5
I 5
.\"     %W% (Berkeley) %G%
E 5
.\"
D 2
.TH DBX 1 "18 July 1983"
E 2
I 2
D 5
.TH DBX 1 "%Q%"
E 2
.UC 5
.ds dB dbx
.ds DB Dbx
.SH NAME
dbx \- debugger
.SH SYNOPSIS
.B dbx
[
.B \-r
] [
.B \-i
] [
I 2
.B \-k
] [
E 2
.B \-I
.I dir
] [
I 2
.B \-c
.I file
] [
E 2
.I objfile
[
.I coredump
]]
.SH DESCRIPTION
\fI\*(DB\fP is a tool for source level debugging and execution of
E 5
I 5
.Dd %Q%
.Dt DBX 1
.Os BSD 4.2
.Sh NAME
.Nm dbx
.Nd debugger
.Sh SYNOPSIS
.Nm Dbx
.Op Fl r
.Op Fl i
.Op Fl k
.Op Fl I Ar dir
.Op Fl c Ar file
.Op Ar objfile Op Ar coredump
.Sh DESCRIPTION
D 6
.Nm dbx
E 6
I 6
.Nm Dbx
E 6
is a tool for source level debugging and execution of
E 5
D 7
programs under UNIX.
E 7
I 7
programs under
.Ux .
E 7
D 5
The \fIobjfile\fP is an object file produced by a compiler
with the appropriate flag (usually ``\-g'')
E 5
I 5
The
.Ar objfile
is an object file produced by a compiler
with the appropriate flag (usually
.Fl g )
E 5
specified to produce symbol information in the object file.
D 2
Currently, \fIcc\fP(1) and \fIf77\fP(1) produce the appropriate source 
information
and it is expected that in the future the Pascal compiler
will also be able to generate source level information.
E 2
I 2
D 5
Currently, \fIcc\fP(1), \fIf77\fP(1), \fIpc\fP(1), and the DEC Western
Research Laboratory Modula-2 compiler, \fImod\fP(l),
E 5
I 5
Currently,
.Xr cc 1 ,
.Xr f77 1 ,
.Xr pc 1 ,
D 7
and the DEC Western
E 7
I 7
and the
.Tn DEC
Western
E 7
Research Laboratory Modula-2 compiler,
.Xr mod l ,
E 5
produce the appropriate source information.
E 2
D 5
The machine level facilities of \fI\*(dB\fP
E 5
I 5
The machine level facilities of
.Nm dbx
E 5
can be used on any program.
D 5
.PP
E 5
I 5
.Pp
E 5
D 2
If no \fIobjfile\fP is specified, \fI\*(dB\fP looks
for a file named ``a.out'' in the current directory.
The object file contains a symbol table which includes the name of the
E 2
I 2
D 6
The object file contains a symbol table that includes the name of the
E 6
I 6
The object file contains a symbol table that includes the names of
E 6
E 2
all the source files translated by the compiler to create it.
These files are available for perusal while using the debugger.
D 5
.PP
If a file named ``core'' exists in the current directory
or a \fIcoredump\fP file is specified, \fI\*(dB\fP can be used
E 5
I 5
.Pp
D 6
If a file named ``core''
E 6
I 6
If a file named
.Pa core
E 6
exists in the current directory
or a
.Ar coredump
file is specified,
.Nm dbx
can be used
E 5
to examine the state of the program when it faulted.
D 5
.PP
If the file ``.\*(dBinit'' exists in the current directory then the
E 5
I 5
.Pp
D 6
If the file ``.dbxinit'' exists in the current directory then the
E 6
I 6
If the file
.Pa .dbxinit
exists in the current directory then the
E 6
E 5
debugger commands in it are executed.
D 5
\fI\*(DB\fP also checks for a ``.\*(dBinit'' in the user's home directory
E 5
I 5
.Nm Dbx
D 6
also checks for a ``.dbxinit'' in the user's home directory
E 6
I 6
also checks for a
.Pa .dbxinit
in the user's home directory
E 6
E 5
if there isn't one in the current directory.
D 5
.PP
E 5
I 5
.Pp
E 5
The command line options and their meanings are:
D 2
.nr In 7
E 2
I 2
D 5
.nr In 8
E 2
.in +\n(Inn
.ta \n(Inn
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.ti -\n(Inn
\&\fB\-r\fP	\c
Execute \fIobjfile\fP immediately.
If it terminates successfully \fI\*(dB\fP exits.
E 5
I 5
D 7
.Tw Fl
.Tp Fl r
E 7
I 7
.Bl -tag -width indent
.It Fl r
E 7
Execute
.Ar objfile
immediately.
If it terminates successfully
.Nm dbx
exits.
E 5
Otherwise the reason for termination will be reported
and the user offered the option of entering the debugger
or letting the program fault.
D 5
\fI\*(DB\fP will read from ``/dev/tty'' when \fB\-r\fP is specified
E 5
I 5
.Nm Dbx
D 6
will read from ``/dev/tty'' when
E 6
I 6
will read from
.Pa /dev/tty
when
E 6
.Fl r
is specified
E 5
and standard input is not a terminal.
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
D 5
.sp 1
E 2
.ti -\n(Inn
\&\fB\-i\fP	\c
Force \fI\*(dB\fP to act as though standard input is a terminal.
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.ti -\n(Inn
I 2
\&\fB\-k\fP	\c
E 5
I 5
D 7
.Tp Fl i
E 7
I 7
.It Fl i
E 7
Force
.Nm dbx
to act as though standard input is a terminal.
D 7
.Tp Fl k
E 7
I 7
.It Fl k
E 7
E 5
Map memory addresses, useful for kernel debugging.
D 5
.sp 1
.ti -\n(Inn
E 2
\&\fB\-I\fP \fIdir\fP	\c
Add \fIdir\fP to the list of directories
E 5
I 5
D 7
.Tp Cx Fl I
.Cx \&\ \&
.Ar dir
.Cx
E 7
I 7
.It Fl I Ar dir 
E 7
Add
.Ar dir
to the list of directories
E 5
that are searched when looking for a source file.
D 5
Normally \fI\*(dB\fP looks for source files in the current directory
and in the directory where \fIobjfile\fP is located.
The directory search path can also be set with the \fBuse\fP command.
I 2
.sp 1
.ti -\n(Inn
\&\fB\-c\fP \fIfile\fP	\c
Execute the \fI\*(dB\fP commands in the \fIfile\fP before
E 5
I 5
Normally
.Nm dbx
looks for source files in the current directory
and in the directory where
.Ar objfile
is located.
The directory search path can also be set with the
D 6
.Ar use
E 6
I 6
.Ic use
E 6
command.
D 7
.Tp Cx Fl c
.Cx \&\ \&
.Ar file
.Cx
E 7
I 7
.It Fl c Ar file 
E 7
Execute the
.Nm dbx
commands in the
.Ar file
before
E 5
reading from standard input.
E 2
D 5
.in -\n(Inn
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.PP
Unless \fB\-r\fP is specified, \fI\*(dB\fP just prompts and waits for a command.
.sp 1
.ne 8
.B Execution and Tracing Commands
.sp 1
.TP
\fBrun\fP [\fIargs\fP] [\fB<\fP \fIfilename\fP] [\fB>\fP \fIfilename\fP]
I 2
.ns
.TP
\fBrerun\fP [\fIargs\fP] [\fB<\fP \fIfilename\fP] [\fB>\fP \fIfilename\fP]
E 2
Start executing \fIobjfile\fP, passing \fIargs\fP as command line arguments;
\fB<\fP or \fB>\fP can be used to redirect input or output in the usual manner.
I 2
When \fBrerun\fP is used without any arguments the previous
E 5
I 5
D 7
.Tp
E 7
I 7
.El
E 7
.Pp
Unless
.Fl r
is specified,
.Nm dbx
just prompts and waits for a command.
.Ss Execution and Tracing Commands
D 7
.Dw Fl
.Di L
.Dp Cx Ic run
.Cx \&\ \&
.Op Ar args
.Cx \&\ \&
E 7
I 7
.Pp
.Bl -tag -width indent -compact
.It Xo
.Ic run Op Ar args
E 7
.Op Sy < Ar filename
D 7
.Cx \&\ \&
.Op Sy > Ar filename
.Cx
.Dp Cx Ic rerun
.Cx \&\ \&
E 7
I 7
.Op Sy > Ar filename 
.Xc
.It Xo
.Ic rerun
E 7
.Op Ar args
D 7
.Cx \&\ \&
E 7
.Op Sy < Ar filename
D 7
.Cx \&\ \&
.Op Sy > Ar filename
.Cx
E 7
I 7
.Op Sy > Ar filename 
.Xc
E 7
Start executing
.Ar objfile  ,
passing
.Ar args
as command line arguments;
.Sy <
or
.Sy >
can be used to redirect input or output in the usual manner.
When
.Ic rerun
is used without any arguments the previous
E 5
argument list is passed to the program;
D 5
otherwise it is identical to \fBrun\fP.
E 2
If \fIobjfile\fP has been written since the last time the symbolic information
was read in, \fI\*(dB\fP will read in the new information.
.TP
\fBtrace\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIprocedure/function\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIexpression\fP \fBat\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIvariable\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
E 5
I 5
otherwise it is identical to
.Ic run .
If
.Ar objfile
has been written since the last time the symbolic information
was read in,
.Nm dbx
will read in the new information.
D 7
.Dp Cx Ic trace
.Cx \&\ \&
.Op Ic in Ar procedure/function
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
.Ar procedure/function
.Cx \&\ \&
.Op Ic in Ar procedure/function
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
.Ar expression
.Cx \&\ \&
.Ic at
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
.Ar variable
.Cx \&\ \&
.Op Ic in Ar procedure/function
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
E 7
I 7
.Pp
.It Xo
.Ic trace
.Op Ic \&in Ar procedure/function
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic trace Ar source-line-number
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic trace Ar procedure/function
.Op Ic \&in Ar procedure/function
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic trace Ar expression
.Ic \&at Ar source-line-number
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic trace Ar variable
.Op Ic \&in Ar procedure/function
.Op Ic \&if Ar condition 
.Xc
E 7
E 5
Have tracing information printed when the program is executed.
A number is associated with the command that is used
D 5
to turn the tracing off (see the \fBdelete\fP command).
.sp 1
E 5
I 5
to turn the tracing off (see the
.Ic delete
command).
.Pp
E 5
The first argument describes what is to be traced.
D 5
If it is a \fIsource-line-number\fP, then the line is printed
E 5
I 5
If it is a
.Ar source-line-number ,
then the line is printed
E 5
immediately prior to being executed.
Source line numbers in a file other than the current one
must be preceded by the name of the file in quotes and a colon, e.g.
"mumble.p":17.
D 5
.sp 1
E 5
I 5
.Pp
E 5
If the argument is a procedure or function name then
every time it is called, information is printed telling
what routine called it, from what source line it was called,
and what parameters were passed to it.
In addition, its return is noted, and if it's a function
then the value it is returning is also printed.
D 5
.sp 1
If the argument is an \fIexpression\fP with an \fBat\fP clause
E 5
I 5
.Pp
If the argument is an
.Ar expression
with an
.Ic at
clause
E 5
then the value of the expression is printed whenever the
identified source line is reached.
D 5
.sp 1
E 5
I 5
.Pp
E 5
If the argument is a variable then the name and value of the variable
is printed whenever it changes.
Execution is substantially slower during this form of tracing.
D 5
.sp 1
E 5
I 5
.Pp
E 5
If no argument is specified then all source lines are printed
before they are executed.
Execution is substantially slower during this form of tracing.
D 5
.sp 1
The clause ``\fBin\fP \fIprocedure/function\fP'' restricts tracing information
E 5
I 5
.Pp
The clause
.Ic in
.Ar procedure/function
restricts tracing information
E 5
to be printed only while executing inside the given procedure
or function.
D 5
.sp 1
\fICondition\fP is a boolean expression and is
E 5
I 5
.Pp
.Ar Condition
is a boolean expression and is
E 5
evaluated prior to printing the tracing information;
if it is false then the information is not printed.
D 5
.br
.ne 10
.IP "\fBstop\fP \fBif\fP \fIcondition\fP"
.ns
.IP "\fBstop\fP \fBat\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]"
.ns
.IP "\fBstop\fP \fBin\fP \fIprocedure/function\fP [\fBif\fP \fIcondition\fP]"
.ns
.IP "\fBstop\fP \fIvariable\fP [\fBif\fP \fIcondition\fP]"
E 5
I 5
D 7
.Dp Cx Ic stop if
.Cx \&\ \&
.Ar condition
.Cx
.Dp Cx Ic stop at
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic stop in
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic stop
.Cx \&\ \&
.Ar variable
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
E 7
I 7
.Pp
.It Ic "stop if" Ar condition 
.It Xo
.Ic "stop at" Ar source-line-number
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic "stop in" Ar source-line-number
.Op Ic \&if Ar condition 
.Xc
.It Xo
.Ic stop Ar variable
.Op Ic \&if Ar condition 
.Xc
E 7
E 5
Stop execution when the given line is reached, procedure or function
called, variable changed, or condition true.
D 5
.IP "\fBstatus\fP [\fB>\fP \fIfilename\fP]"
Print out the currently active \fBtrace\fP and \fBstop\fP commands.
D 2
.IP "\fBdelete\fP \fIcommand-number\fP"
The trace or stop corresponding to the given number is removed.
E 2
I 2
.IP "\fBdelete\fP \fIcommand-number\fP ..."
E 5
I 5
D 7
.Dp Cx Ic status
.Cx \&\ \&
.Op Ic \&> Ar filename
.Cx
E 7
I 7
.Pp
.It Ic status Op Ic \&> Ar filename 
E 7
Print out the currently active
.Ic trace
and
.Ic stop
commands.
D 7
.Dp Cx Ic delete
.Cx \&\ \&
.Ar command-number ...
.Cx
E 7
I 7
.Pp
.It Ic delete Ar command-number ... 
E 7
E 5
The traces or stops corresponding to the given numbers are removed.
E 2
The numbers associated with traces and stops are printed by
D 5
the \fBstatus\fP command.
.IP "\fBcatch\fP \fInumber\fP"
.ns
I 2
.IP "\fBcatch\fP \fIsignal-name\fP"
.ns
E 2
.IP "\fBignore\fP \fInumber\fP"
D 2
Start or stop trapping signal \fInumber\fP before it is sent
E 2
I 2
.ns
.IP "\fBignore\fP \fIsignal-name\fP"
E 5
I 5
the
.Ic status
command.
D 7
.Dp Cx Ic catch
.Cx \&\ \&
.Ar number
.Cx
.Dp Cx Ic catch
.Cx \&\ \&
.Ar signal-name
.Cx
.Dp Cx Ic ignore
.Cx \&\ \&
.Ar number
.Cx
.Dp Cx Ic ignore
.Cx \&\ \&
.Ar signal-name
.Cx
E 7
I 7
.Pp
.It Ic catch Ar number 
.It Ic catch Ar signal-name 
.It Ic ignore Ar number 
.It Ic ignore Ar signal-name 
E 7
E 5
Start or stop trapping a signal before it is sent
E 2
to the program.
This is useful when a program being debugged
handles signals such as interrupts.
D 2
Initially all signals are trapped except SIGCONT, SIGCHILD,
E 2
I 2
A signal may be specified by number or by a name
D 7
(e.g., SIGINT).
Signal names are case insensitive and the ``SIG'' prefix is optional.
By default all signals are trapped except SIGCONT, SIGCHILD,
E 2
SIGALRM and SIGKILL.
D 2
.IP \fBcont\fP
E 2
I 2
D 5
.IP "\fBcont\fP \fIinteger\fP"
.ns
.IP "\fBcont\fP \fIsignal-name\fP"
E 5
I 5
.Dp Cx Ic cont
.Cx \&\ \&
.Ar integer
.Cx
.Dp Cx Ic cont
.Cx \&\ \&
.Ar signal-name
.Cx
E 7
I 7
(e.g.,
.Dv SIGINT ) .
Signal names are case insensitive and the
.Dq Dv SIG
prefix is optional.
By default all signals are trapped except
.Dv SIGCONT ,
.Dv SIGCHILD ,
.Dv SIGALRM
and
.Dv SIGKILL .
.Pp
.It Ic cont Ar integer 
.It Ic cont Ar signal-name 
E 7
E 5
E 2
Continue execution from where it stopped.
I 2
If a signal is specified, the process continues as though
it received the signal.
Otherwise, the process is continued as though it had not been stopped.
D 5
.PP
E 5
I 5
.Pp
E 5
E 2
Execution cannot be continued if the process has ``finished'',
that is, called the standard procedure ``exit''.
D 5
\fI\*(DB\fP does not allow the process to exit, thereby
E 5
I 5
.Nm Dbx
does not allow the process to exit, thereby
E 5
letting the user to examine the program state.
D 5
.IP \fBstep\fP
E 5
I 5
D 7
.Dp Ic step
E 7
I 7
.Pp
.It Ic step
E 7
E 5
Execute one source line.
D 5
.IP \fBnext\fP
E 5
I 5
D 7
.Dp Ic next
E 7
I 7
.Pp
.It Ic next
E 7
E 5
Execute up to the next source line.
D 5
The difference between this and \fBstep\fP is that
E 5
I 5
The difference between this and
.Ic step
is that
E 5
if the line contains a call to a procedure or function
D 5
the \fBstep\fP command will stop at the beginning of that
block, while the \fBnext\fP command will not.
I 2
.IP "\fBreturn\fP [\fIprocedure\fP]"
Continue until a return to \fIprocedure\fP is executed, or
E 5
I 5
the
.Ic step
command will stop at the beginning of that
block, while the
.Ic next
command will not.
D 7
.Dp Cx Ic return
.Cx \&\ \&
.Op Ar procedure
.Cx
E 7
I 7
.Pp
.It Ic return Op Ar procedure 
E 7
Continue until a return to
.Ar procedure
is executed, or
E 5
until the current procedure returns if none is specified.
D 5
.IP "\fBcall\fP \fIprocedure(parameters)\fP"
E 5
I 5
D 7
.Dp Cx Ic call
.Cx \&\ \&
.Ar procedure (parameters )
.Cx
E 7
I 7
.Pp
.It Ic call Ar procedure(parameters ) 
E 7
E 5
Execute the object code associated with the named procedure or function.
E 2
D 5
.sp 1
.br
.ne 8v
.PP
D 2
.B Displaying and Naming Data
E 2
I 2
.B Printing Variables and Expressions
E 2
.sp 1
D 2
.IP "\fBprint\fP \fIexpression\fP [\fB,\fP \fIexpression\fP ...]"
Print out the values of the expressions.
Array expressions are always subscripted by brackets (``[ ]'').
Variables having the same identifier as one in the current block may be
referenced as ``\fIblock-name\fP\ \fB.\fP\ \fIvariable\fP''.
E 2
I 2
.PP
E 5
I 5
D 7
.Dp
E 7
I 7
.El
E 7
.Ss Printing Variables and Expressions
E 5
Names are resolved first using the static scope of the current function,
then using the dynamic scope if the name is not defined
in the static scope.
If static and dynamic searches do not yield a result,
an arbitrary symbol is chosen and
D 5
the message ``[using\ \fIqualified\ name\fP]'' is printed.
E 5
I 5
the message
D 6
.Cx ``
.Op using Ar qualified name
.Cx \'\'
.Cx
E 6
I 6
D 7
.Dq Li [using Ar qualified name]
E 7
I 7
.Dq Bq Li using Ar qualified name
E 7
E 6
is printed.
E 5
The name resolution procedure may be overridden by qualifying an identifier
D 5
with a block name, e.g., ``\fImodule\fP.\fIvariable\fP''.
E 5
I 5
with a block name, e.g.,
D 6
.Cx ``
Ar module.variable
.Cx \'\'.
.Cx
E 6
I 6
.Dq Li module.variable
E 6
E 5
For C, source files are treated as modules named
by the file name without ``.c''.
D 5
.PP
E 5
I 5
.Pp
E 5
Expressions are specified with an approximately
common subset of C and Pascal (or equivalently Modula-2) syntax.
Indirection can be denoted using either a prefix ``*'' or
a postfix ``^'' and
D 5
array expressions are subscripted by brackets (``[ ]'').
E 5
I 5
array expressions are subscripted by brackets
D 7
.Cx (``
.Op
.Cx \'\').
.Cx
E 7
I 7
.Pq Dq Bq
E 7
E 5
E 2
The field reference operator (``.'') can be used with pointers
D 5
as well as records, making the C operator ``->'' unnecessary
E 5
I 5
as well as records, making the C operator ``\->'' unnecessary
E 5
(although it is supported).
D 2
The construct \fItypename\fP(\fIexpression\fP) can be used to print
the \fIexpression\fP out in the format of the named \fItype\fP.
E 2
I 2
D 5
.PP
E 5
I 5
.Pp
E 5
Types of expressions are checked;
the type of an expression may be overridden
D 5
by using ``\fItype-name\fP(\fIexpression\fP)''.
E 5
I 5
by using
D 7
.Cx ``
.Ar type-name (expression)
.Cx \'\'.
.Cx
E 7
I 7
.Dq Ar type-name Ns Pq Ar expression .
E 7
E 5
When there is no corresponding named type
D 5
the special constructs ``&\fItype-name\fP'' and ``$$\fItag-name\fP''
E 5
I 5
the special constructs
D 7
.Cx ``&
.Ar type-name
.Cx \'\'
.Cx
E 7
I 7
.Dq Ar &type-name
E 7
and
D 7
.Cx ``$$
.Ar tag-name
.Cx \'\'
.Cx
E 7
I 7
.Dq Ar $$tag-name
E 7
E 5
can be used to represent a pointer to a named type or C structure tag.
D 5
.sp 1
.IP "\fBassign\fP \fIvariable\fP \fB=\fP \fIexpression\fP"
E 5
I 5
D 7
.Dw Fl
.Di L
.Dp Cx Ic assign
.Cx \&\ \&
.Ar variable
.Ic =
.Ar expression
.Cx
E 7
I 7
.Pp
.Bl -tag -width indent -compact
.It Ic assign Ar variable Ic = Ar expression 
E 7
E 5
Assign the value of the expression to the variable.
D 5
.IP "\fBdump\fP [\fIprocedure\fR] [\fB>\fP \fIfilename\fP]"
E 5
I 5
D 7
.Dp Cx Ic dump
.Cx \&\ \&
E 7
I 7
.Pp
.It Xo
.Ic dump
E 7
.Op Ar procedure
D 7
.Cx \&\ \&
.Op Ic > Ar filename
.Cx
E 7
I 7
.Op Ic > Ar filename 
.Xc
E 7
E 5
Print the names and values of variables in the given procedure,
or the current one if none is specified.
If the procedure given is ``.'', then the all active variables
are dumped.
D 5
.IP "\fBprint\fP \fIexpression\fP [\fB,\fP \fIexpression\fP ...]"
E 5
I 5
D 7
.Dp Cx Ic print
.Cx \&\ \&
.Ar expression
.Cx \&\ \&
.Op Ic \&, Ar expression ...
.Cx
E 7
I 7
.Pp
.It Xo
.Ic print Ar expression
.Op Ic \&, Ar expression ... 
.Xc
E 7
E 5
Print out the values of the expressions.
E 2
D 5
.IP "\fBwhatis\fP \fIname\fP"
E 5
I 5
D 7
.Dp Cx Ic whatis
.Cx \&\ \&
.Ar name
.Cx
E 7
I 7
.Pp
.It Ic whatis Ar name 
E 7
E 5
Print the declaration of the given name, which may be qualified
with block names as above.
D 5
.IP "\fBwhich\fP \fIidentifier\fP"
E 5
I 5
D 7
.Dp Cx Ic which
.Cx \&\ \&
.Ar identifier
.Cx
E 7
I 7
.Pp
.It Ic which Ar identifier 
E 7
E 5
Print the full qualification of the given identifer, i.e.
the outer blocks that the identifier is associated with.
I 2
D 5
.IP "\fBup\fP [\fIcount\fP]"
.ns
.IP "\fBdown\fP [\fIcount\fP]"
E 5
I 5
D 7
.Dp Cx Ic up
.Cx \&\ \&
.Op Ar count
.Cx
.Dp Cx Ic down
.Cx \&\ \&
.Op Ar count
.Cx
E 7
I 7
.Pp
.It Ic up Op Ar count 
.It Ic down Op Ar count 
E 7
E 5
Move the current function, which is used for resolving names,
D 5
up or down the stack \fIcount\fP levels.
The default \fIcount\fP is 1.
.IP \fBwhere\fP
E 5
I 5
up or down the stack
.Ar count
levels.
The default
.Ar count
is 1.
D 7
.Dp Ic where
E 7
I 7
.Pp
.It Ic where
E 7
E 5
Print out a list of the active procedures and function.
E 2
D 5
.IP "\fBwhereis\fP \fIidentifier\fP"
E 5
I 5
D 7
.Dp Cx Ic whereis
.Cx \&\ \&
.Ar identifier
.Cx
E 7
I 7
.Pp
.It Ic whereis Ar identifier 
E 7
E 5
Print the full qualification of all the symbols whose
name matches the given identifier.
The order in which the symbols are printed is not meaningful.
I 6
D 7
.Dp
E 7
I 7
.El
E 7
E 6
D 2
.IP "\fBassign\fP \fIvariable\fP \fB=\fP \fIexpression\fP"
.ns
.IP "\fBset\fP \fIvariable\fP \fB=\fP \fIexpression\fP"
Assign the value of the expression to the variable.
.IP "\fBcall\fP \fIprocedure(parameters)\fP"
Execute the object code associated with the named procedure or function.
Currently, calls to a procedure with a variable number of arguments
are not possible.
Also, string parameters are not passed properly for C.
.IP \fBwhere\fP
Print out a list of the active procedures and function.
.IP "\fBdump\fP [\fB>\fP \fIfilename\fP]"
Print the names and values of all active variables.
E 2
D 5
.sp 1
.br
.ne 8v
.PP
.B Accessing Source Files
.sp 1
I 2
.IP "/\fIregular\ expression\fP[/]"
.ns
.IP "?\fIregular\ expression\fP[?]"
E 5
I 5
.Ss Accessing Source Files
.Pp
I 6
D 7
.Di L
E 6
.Dp Cx Ar /regular expression
.Op /
.Cx
.Dp Cx Ar ?regular expression
.Op ?
.Cx
E 7
I 7
.Bl -tag -width indent -compact
.It Ns / Ar "regular expression" Ns Op / 
.It Ns ? Ar "regular expression" Ns Op ? 
E 7
E 5
Search forward or backward in the current source file
for the given pattern.
E 2
D 5
.IP "\fBedit\fP [\fIfilename\fP]"
.ns
.IP "\fBedit\fP \fIprocedure/function-name\fP"
Invoke an editor on \fIfilename\fP or the current source file if none
E 5
I 5
D 7
.Dp Cx Ic edit
.Cx \&\ \&
.Op Ar filename
.Cx
.Dp Cx Ic edit
.Cx \&\ \&
.Ar procedure/function-name
.Cx
E 7
I 7
.Pp
.It Ic edit Op Ar filename 
.It Ic edit Ar procedure/function-name 
E 7
Invoke an editor on
.Ar filename
or the current source file if none
E 5
is specified.
D 5
If a \fIprocedure\fP or \fIfunction\fP name is specified,
E 5
I 5
If a
.Ar procedure
or
.Ar function
name is specified,
E 5
the editor is invoked on the file that contains it.
Which editor is invoked by default depends on the installation.
The default can be overridden by setting the environment variable
D 5
EDITOR to the name of the desired editor.
.IP "\fBfile\fP [\fIfilename\fP]"
Change the current source file name to \fIfilename\fP.
E 5
I 5
.Ev EDITOR
to the name of the desired editor.
D 7
.Dp Cx Ic file
.Cx \&\ \&
.Op Ar filename
.Cx
E 7
I 7
.Pp
.It Ic file Op Ar filename 
E 7
Change the current source file name to
.Ar filename  .
E 5
If none is specified then the current source file name is printed.
D 5
.IP "\fBfunc\fP [\fIprocedure/function\fP]"
E 5
I 5
D 7
.Dp Cx Ic func
.Cx \&\ \&
.Op Ar procedure/function
.Cx
E 7
I 7
.Pp
.It Ic func Op Ar procedure/function 
E 7
E 5
Change the current function.
If none is specified then print the current function.
Changing the current function implicitly changes the current source file
to the one that contains the function; it also changes the current scope
used for name resolution.
D 5
.IP "\fBlist\fP [\fIsource-line-number\fP [\fB,\fP \fIsource-line-number\fP]]"
.ns
.IP "\fBlist\fP \fIprocedure/function\fP"
E 5
I 5
D 7
.Dp Cx Ic list
.Cx \&\ \&
.Op Ar source-line-number Op Ic \&, Ar source-line-number
.Cx
.Dp Cx Ic list
.Cx \&\ \&
.Ar procedure/function
.Cx
E 7
I 7
.Pp
.It Xo
.Ic list
.Oo Ar source-line-number
.Op Ic \&, Ar source-line-number Oc
.Xc
.It Ic list Ar procedure/function 
E 7
E 5
List the lines in the current source file from the first line number to
the second inclusive.
If no lines are specified, the next 10 lines are listed.
If the name of a procedure or function is given
D 5
lines \fIn-k\fP to \fIn+k\fP are listed where \fIn\fP is the first statement
in the procedure or function and \fIk\fP is small.
.IP "\fBuse\fP \fIdirectory-list\fP"
E 5
I 5
lines
.Ar n-k
to
D 6
.Ar n +k
E 6
I 6
.Ar n+k
E 6
are listed where
.Ar n
is the first statement
in the procedure or function and
.Ar k
is small.
D 7
.Dp Cx Ic use
.Cx \&\ \&
.Ar directory-list
.Cx
E 7
I 7
.Pp
.It Ic use Ar directory-list 
E 7
E 5
Set the list of directories to be searched
when looking for source files.
D 5
.sp 1
.br
.ne 8v
.PP
I 2
.B Command Aliases and Variables
.sp 1
.TP
\fBalias\fP \fIname\fP \fIname\fP
.ns
.TP
\fBalias\fP \fIname\fP ``\fIstring\fP''
.ns
.TP
\fBalias\fP \fIname\fP (\fIparameters\fP) ``\fIstring\fP''
E 5
I 5
D 7
.Dp
E 7
I 7
.El
E 7
.Ss Command Aliases and Variables
D 7
.Dw Fl
.Di L
.Dp Cx Ic alias
.Cx \&\ \&
.Ar name
.Cx \&\ \&
.Ar name
.Cx
.Dp Cx Ic alias
.Cx \&\ \&
.Ar name
.Cx \&\ \&
.Ar string
.Cx
.Dp Cx Ic alias
.Cx \&\ \&
.Ar name (parameters)
.Cx \&\ \&
.Cx ``
.Ar string
.Cx \'\'
.Cx
E 7
I 7
.Pp
.Bl -tag -width indent -compact
.It Ic alias Ar name Ar name 
.It Ic alias Ar name Ar string 
.It Xo
.Ic alias
.Ar name Pq Ar parameters
.Dq Ar string
.Xc
E 7
E 5
When commands are processed,
D 5
\*(dB first checks to see if the word
E 5
I 5
dbx first checks to see if the word
E 5
is an alias for either a command or a string.
D 5
If it is an alias, then \*(dB treats the input as though
E 5
I 5
If it is an alias, then dbx treats the input as though
E 5
the corresponding string (with values substituted for any parameters)
had been entered.
For example,
to define an alias ``rr'' for the command ``rerun'',
one can say
D 5
.sp 1
.in +8n
alias rr rerun
.in -8n
.sp 1
E 5
I 5
.Pp
D 7
.Dl alias rr rerun
E 7
I 7
.Dl alias \&rr rerun
E 7
.Pp
E 5
To define an alias called ``b'' that sets a stop at a particular line
one can say
D 5
.sp 1
.in +8n
alias b(x) ``stop at x''
.in -8n
.sp 1
E 5
I 5
.Pp
.Dl alias b(x) ``stop at x''
.Pp
E 5
Subsequently, the command ``b(12)'' will expand to ``stop at 12''.
D 5
.need 5
.TP
\fBset\fP \fIname\fP [= \fIexpression\fP]
The \fBset\fP command defines values for debugger variables.
E 5
I 5
.Pp
D 7
.Dp Cx Ic set
I 6
.Ws
E 6
.Ar name
.Op \&= Ar expression
.Cx
E 7
I 7
.It Xo
.Ic set Ar name
.Op No \&= Ar expression 
.Xc
E 7
The
.Ic set
command defines values for debugger variables.
E 5
The names of these variables cannot conflict with names in the program
being debugged, and are expanded to the corresponding expression
within other commands.
The following variables have a special meaning:
D 5
.sp 1
.in +8n
.ti -5n
$frame
.br
Setting this variable to an address causes \*(dB to use the stack frame
E 5
I 5
D 7
.Dw Ds
.Di L
.Dp Li $frame
E 7
I 7
.Pp
.Bl -tag -width flag -compact
.It Li $frame
E 7
Setting this variable to an address causes dbx to use the stack frame
E 5
pointed to by the address for
doing stack traces and accessing local variables.
This facility is of particular use for kernel debugging.
D 5
.sp 1
.ti -5n
$hexchars
.ti -5n
$hexints
.ti -5n
$hexoffsets
.ti -5n
$hexstrings
.br
When set, \*(dB prints out
E 5
I 5
D 7
.Dp Li $hexchars
.Dp Li $hexints
.Dp Li $hexoffsets
.Dp Li $hexstrings
E 7
I 7
.Pp
.It Li $hexchars
.It Li $hexints
.It Li $hexoffsets
.It Li $hexstrings
E 7
When set, dbx prints out
E 5
out characters, integers, offsets from registers, or character pointers
respectively in hexadecimal.
D 5
.sp 1
.ti -5n
$listwindow
.br
E 5
I 5
D 7
.Dp Li $listwindow
E 7
I 7
.Pp
.It Li $listwindow
E 7
E 5
The value of this variable specifies the number
D 5
of lines to list around a function or when the \fBlist\fP command
E 5
I 5
of lines to list around a function or when the
.Ic list
command
E 5
is given without any parameters.
Its default value is 10.
D 5
.sp 1
.ti -5n
$mapaddrs
.br
Setting (unsetting) this variable causes \*(dB to start (stop)
E 5
I 5
D 7
.Dp Li $mapaddrs
E 7
I 7
.Pp
.It Li $mapaddrs
E 7
Setting (unsetting) this variable causes dbx to start (stop)
E 5
mapping addresses.
As with ``$frame'', this is useful for kernel debugging.
I 3
D 5
.sp 1
.ti -5n
$unsafecall
.ti -5n
$unsafeassign
.br
E 5
I 5
D 7
.Dp Li $unsafecall
.Dp Li $unsafeassign
E 7
I 7
.Pp
.It Li $unsafecall
.It Li $unsafeassign
E 7
E 5
When ``$unsafecall'' is set,
strict type checking is turned off for arguments to
D 5
subroutine or function calls (\fIe.g.\fP in the \fBcall\fP statement).
E 5
I 5
subroutine or function calls (
.Ar e .g .
in the
.Ic call
statement).
E 5
When ``$unsafeassign'' is set,
strict type checking between the two sides
D 5
of an \fBassign\fP statement is turned off.
E 5
I 5
of an
.Ic assign
statement is turned off.
E 5
These variables should be used only with great care,
D 5
because they severely limit \*(dB's usefulness
E 5
I 5
because they severely limit dbx's usefulness
E 5
for detecting errors.
E 3
D 5
.in -8n
.TP
\fBunalias\fP \fIname\fP
E 5
I 5
D 7
.Dp
.Dp Cx Ic unalias
.Cx \&\ \&
.Ar name
.Cx
E 7
I 7
.El
.Pp
.It Ic unalias Ar name 
E 7
E 5
Remove the alias with the given name.
D 5
.TP
\fBunset\fP \fIname\fP
Delete the debugger variable associated with \fIname\fP.
.sp 1
.br
.ne 8v
.PP
E 2
.B Machine Level Commands
.sp 1
.TP
\fBtracei\fP [\fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBtracei\fP [\fIvariable\fP] [\fBat\fP \fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBstopi\fP [\fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBstopi\fP [\fBat\fP] [\fIaddress\fP] [\fBif\fP \fIcond\fP]
E 5
I 5
D 7
.Dp Cx Ic unset
.Cx \&\ \&
.Ar name
.Cx
E 7
I 7
.Pp
.It Ic unset Ar name 
E 7
Delete the debugger variable associated with
.Ar name  .
D 7
.Dp
E 7
I 7
.El
E 7
.Ss Machine Level Commands
D 7
.Dw Fl
.Di L
.Dp Cx Ic tracei
.Cx \&\ \&
E 7
I 7
.Pp
.Bl -tag -width Fl -compact
.It Xo
.Ic tracei
E 7
.Op Ar address
D 7
.Cx \&\ \&
.Op .Ic if Ar cond
.Cx
.Dp Cx Ic tracei
.Cx \&\ \&
E 7
I 7
.Op Ic \&if Ar cond 
.Xc
.It Xo
.Ic tracei
E 7
.Op Ar variable
D 7
.Cx \&\ \&
.Op Ic at Ar address
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
.Dp Cx Ic stopi
.Cx \&\ \&
E 7
I 7
.Op Ic \&at Ar address
.Op Ic \&if Ar cond 
.Xc
.It Xo
.Ic stopi
E 7
.Op Ar address
D 7
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
.Dp Cx Ic stopi
.Cx \&\ \&
.Op Ic at
.Cx \&\ \&
E 7
I 7
.Op Ic \&if Ar cond 
.Xc
.It Xo
.Ic stopi
.Op Ic \&at
E 7
.Op Ar address
D 7
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
E 7
I 7
.Op Ic \&if Ar cond 
.Xc
E 7
E 5
Turn on tracing or set a stop using a machine instruction address.
D 5
.TP
\fBstepi\fP
.ns
.TP
\fBnexti\fP
Single step as in \fBstep\fP or \fBnext\fP, but do a single instruction
E 5
I 5
D 7
.Dp Ic stepi
.Dp Ic nexti
E 7
I 7
.Pp
.It Ic stepi
.It Ic nexti
E 7
Single step as in
.Ic step
or
.Ic next  ,
but do a single instruction
E 5
rather than source line.
D 5
.TP
\fIaddress\fP \fB,\fP\fIaddress\fP\fB/\fP [\fImode\fP]
.ns
.TP
D 2
[\fIaddress\fP] \fB/\fP [\fIcount\fP] [\fImode\fP]
E 2
I 2
\fIaddress\fP \fB/\fP [\fIcount\fP] [\fImode\fP]
E 2
Print the contents of memory starting at the first \fIaddress\fP
and continuing up to the second \fIaddress\fP or until \fIcount\fP items are printed.
E 5
I 5
D 7
.Dp Cx Ar address
.Cx \&,
.Ar address
.Cx \&/
.Op Ar mode
.Cx
.Dp Cx Ar address
.Cx \&/
.Op Ar count
.Op Ar mode
.Cx
E 7
I 7
.Pp
.Sm off
.It Xo
.Ar address , Ar address / Op Ar mode 
.Xc
.It Xo
.Ar address / Op Ar count
.Sm on
.Op Ar mode 
.Xc
E 7
Print the contents of memory starting at the first
.Ar address
and continuing up to the second
.Ar address
or until
.Ar count
items are printed.
E 5
D 2
If no address is specified, the address following the one
E 2
I 2
If the address is ``.'', the address following the one
E 2
printed most recently is used.
D 5
The \fImode\fP specifies how memory is to be printed;
E 5
I 5
The
.Ar mode
specifies how memory is to be printed;
E 5
if it is omitted the previous mode specified is used.
The initial mode is ``X''.
The following modes are supported:
D 5
.nr In 5
.in +\n(Inn
.ta \n(Inn
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.ti -\n(Inn
\&\fBi\fP	\c
E 5
I 5
D 7
.Dw Cm
.Dp Cm i
E 5
print the machine instruction
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBd\fP	\c
E 5
I 5
.Dp Cm d
E 5
print a short word in decimal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBD\fP	\c
E 5
I 5
.Dp Cm D
E 5
print a long word in decimal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBo\fP	\c
E 5
I 5
.Dp Cm o
E 5
print a short word in octal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBO\fP	\c
E 5
I 5
.Dp Cm O
E 5
print a long word in octal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBx\fP	\c
E 5
I 5
.Dp Cm x
E 5
print a short word in hexadecimal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBX\fP	\c
E 5
I 5
.Dp Cm X
E 5
print a long word in hexadecimal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBb\fP	\c
E 5
I 5
.Dp Cm b
E 5
print a byte in octal
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBc\fP	\c
E 5
I 5
.Dp Cm c
E 5
print a byte as a character
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBs\fP	\c
E 5
I 5
.Dp Cm s
E 5
print a string of characters terminated by a null byte
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBf\fP	\c
E 5
I 5
.Dp Cm f
E 5
print a single precision real number
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\fBg\fP	\c
E 5
I 5
.Dp Cm g
E 5
print a double precision real number
D 5
.in -\n(Inn
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.PP
E 5
I 5
.Dp
E 7
.Pp
I 7
.Bl -tag -width flag -compact
.It Cm i
Print the machine instruction.
.It Cm d
Print a short word in decimal.
.It Cm D
Print a long word in decimal.
.It Cm o
Print a short word in octal.
.It Cm O
Print a long word in octal.
.It Cm x
Print a short word in hexadecimal.
.It Cm X
Print a long word in hexadecimal.
.It Cm b
Print a byte in octal.
.It Cm c
Print a byte as a character.
.It Cm s
Print a string of characters terminated by a null byte.
.It Cm f
Print a single precision real number.
.It Cm g
Print a double precision real number.
.El
.El
.Pp
E 7
E 5
Symbolic addresses are specified by preceding the name with an ``&''.
Registers are denoted by ``$rN'' where N is the number of the register.
Addresses may be expressions made up of other addresses and
the operators ``+'', ``-'', and indirection (unary ``*'').
D 5
.sp 1
.br
.ne 8v
.PP
.B Miscellaneous Commands
.sp 1
I 2
.IP \fBgripe\fP
Invoke a mail program to send a message to the person in charge of \fI\*(dB\fP.
.IP \fBhelp\fP
Print out a synopsis of \fI\*(dB\fP commands.
.IP "\fBquit\fP"
Exit \fI\*(dB\fP.
E 2
.IP "\fBsh\fP \fIcommand-line\fP"
E 5
I 5
D 7
.Dp
E 7
.Ss Miscellaneous Commands
D 7
.Tw Ic
.Tp Ic gripe
E 7
I 7
.Bl -tag -width indent
.It Ic gripe
E 7
Invoke a mail program to send a message to the person in charge of
.Nm dbx  .
D 7
.Tp Ic help
E 7
I 7
.It Ic help
E 7
Print out a synopsis of
.Nm dbx
commands.
D 7
.Tp Ic quit
E 7
I 7
.It Ic quit
E 7
Exit
.Nm dbx  .
D 7
.Tp Cx Ic sh
.Cx \&\ \&
.Ar command-line
.Cx
E 7
I 7
.It Ic sh Ar command-line 
E 7
E 5
Pass the command line to the shell for execution.
D 7
The SHELL environment variable determines which shell is used.
D 2
.IP "\fBalias\fP \fInew-command-name\fP \fIold-command-name\fP"
Respond to \fInew-command-name\fP
as though it were \fIold-command-name\fP.
.IP \fBhelp\fP
Print out a synopsis of \fI\*(dB\fP commands.
.IP \fBgripe\fP
Invoke a mail program to send a message to the person in charge of \fI\*(dB\fP.
E 2
D 5
.TP
\fBsource\fP \fIfilename\fP
Read \fI\*(dB\fP commands from the given \fIfilename\fP.
D 2
Especially useful when the \fIfilename\fP has been created by redirecting
a \fBstatus\fP command from an earlier debugging session.
.IP "\fBquit\fP"
Exit \fI\*(dB\fP.
E 2
.SH FILES
.nr In 20
.in +\n(Inn
.ta \n(Inn
D 2
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
I 2
.sp 1
E 2
.ti -\n(Inn
\&a.out	\c
E 5
I 5
.Tp Cx Ic source
.Cx \&\ \&
.Ar filename
.Cx
E 7
I 7
The
.Ev SHELL
environment variable determines which shell is used.
.It Ic source Ar filename 
E 7
Read
.Nm dbx
commands from the given
.Ar filename  .
D 7
.Tp
E 7
I 7
.El
E 7
.Sh ENVIRONMENT
.Nm Dbx
D 6
checks these environment variables:
E 6
I 6
D 7
utilizes the following environment variables:
E 6
.Ds I
EDITOR
HOME
PATH
SHELL
.De
E 7
I 7
examines the following environment variables:
.Bl -tag -width indent -compact -offset indent
.It Ev EDITOR
.It Ev HOME
.It Ev PATH
.It Ev SHELL
.El
E 7
.Sh FILES
D 7
.Dw .dbxinit
.Di L
.Dp Pa a.out
E 5
object file
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.ti -\n(Inn
\&\&.\*(dBinit	\c
E 5
I 5
.Dp Pa .dbxinit
E 5
initial commands
D 2
.br
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
E 2
D 5
.SH SEE ALSO
D 2
cc(1), f77(1), pc(1)
E 2
I 2
cc(1), f77(1), pc(1), mod(l)
E 2
.SH COMMENTS
D 2
Non-local gotos can cause some trace/stops to be missed.
Most of the command names are too long.
The alias facility helps, but is really quite weak.
A \fIcsh\fP-like history capability would improve the situation.
But then, who wants to duplicate the c-shell in a debugger?
.PP
\fI\*(DB\fP suffers from the same ``multiple include'' malady as does sdb.
E 2
I 2
\fI\*(DB\fP suffers from the same ``multiple include'' malady as did \fIsdb\fP.
E 5
I 5
.Dp
E 7
I 7
.Bl -tag -width .dbxinit -compact
.It Pa a.out
Object file.
.It Pa .dbxinit
Initial commands.
.El
E 7
.Sh SEE ALSO
.Xr cc 1 ,
.Xr mod l ,
.Xr f77 1 ,
.Xr pc 1
.Sh HISTORY
D 7
.Nm Dbx
appeared in 4.2 BSD.
E 7
I 7
The
.Nm dbx
command appeared in
.Bx 4.2 .
E 7
.Sh BUGS
.Nm Dbx
suffers from the same ``multiple include'' malady as did
.Nm sdb  .
E 5
E 2
If you have a program consisting of a number of object files
and each is built from source files that include header files,
the symbolic information for the header files is replicated in
each object file.
Since about one debugger start-up is done for each link,
D 5
having the linker (ld) re-organize the symbol information
E 5
I 5
having the linker
.Xr ld 1
re-organize the symbol information
E 5
D 2
won't save much time, though it would reduce some of the
E 2
I 2
would not save much time, though it would reduce some of the
E 2
disk space used.
D 2
The problem is an artifact of the unrestricted semantics
E 2
I 2
D 5
.PP
E 5
I 5
.Pp
E 5
This problem is an artifact of the unrestricted semantics
E 2
of #include's in C; for example an include file can contain
static declarations that are separate entities for each file
in which they are included.
I 2
However, even with Modula-2 there is a substantial amount of duplication
of symbol information necessary for inter-module type checking.
I 3
D 5
.PP
E 5
I 5
.Pp
E 5
Some problems remain with the support for individual languages.
Fortran problems include:
inability to assign to logical, logical*2, complex
and double complex variables;
inability to represent parameter constants
which are not type integer or real;
peculiar representation for the values of dummy procedures
(the value shown for a dummy procedure is actually
the first few bytes of the procedure text;
to find the location of the procedure,
use ``&'' to take the address of the variable).
E 3
E 2
E 1
