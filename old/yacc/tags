My1	y1.c	/^main(argc,argv) int argc; char *argv[]; {$/
aoutput	y4.c	/^aoutput(){ \/* this version is for C *\/$/
apack	y3.c	/^apack(p, n ) int *p;{ \/* pack state i from temp1 /
arout	y4.c	/^arout( s, v, n ) char *s; int *v, n; {$/
aryfil	y1.c	/^aryfil( v, n, c ) int *v,n,c; { \/* set elements 0/
callopt	y4.c	/^callopt(){$/
cempty	y1.c	/^cempty(){ \/* mark nonterminals which derive the e/
chcopy	y1.c	/^char *chcopy( p, q )  char *p, *q; {$/
chfind	y2.c	/^chfind( t, s ) register char *s; {$/
closure	y1.c	/^closure(i){ \/* generate the closure of state i */
cpfir	y1.c	/^cpfir() {$/
cpres	y1.c	/^cpres(){ \/* compute an array with the beginnings /
cpyact	y2.c	/^cpyact(offset){ \/* copy C action to the next ; or/
cpycode	y2.c	/^cpycode(){ \/* copies code between \\{ and \\} *\//
cpyunion	y2.c	/^cpyunion(){$/
cstash	y2.c	/^cstash( s ) register char *s; {$/
defin	y2.c	/^defin( t, s ) register char  *s; {$/
defout	y2.c	/^defout(){ \/* write out the defines (at the end of/
error	y1.c	/^error(s,a1) char *s; { \/* write out error comment/
fdtype	y2.c	/^fdtype( t ){ \/* determine the type of a symbol */
finact	y2.c	/^finact(){$/
flset	y1.c	/^struct looksets *flset( p )   struct looksets *p; /
gettok	y2.c	/^gettok() {$/
gin	y4.c	/^gin(i){$/
go2gen	y3.c	/^go2gen(c){ \/* output the gotos for nonterminal c /
go2out	y3.c	/^go2out(){ \/* output the gotos for the nontermnina/
gtnm	y4.c	/^gtnm(){$/
hideprod	y3.c	/^hideprod(){$/
nxti	y4.c	/^nxti(){ \/* finds the next i *\/$/
osummary	y4.c	/^osummary(){$/
others	y1.c	/^others(){ \/* put out other arrays, copy the parse/
output	y3.c	/^output(){ \/* print the output for the states *\/$/
precftn	y3.c	/^precftn(r,t,s){ \/* decide a shift\/reduce conflic/
prlook	y1.c	/^prlook( p ) struct looksets *p;{$/
putitem	y1.c	/^putitem( ptr, lptr )  int *ptr;  struct looksets */
setunion	y1.c	/^setunion( a, b ) register *a, *b; {$/
setup	y2.c	/^setup(argc,argv) int argc; char *argv[];$/
skipcom	y2.c	/^skipcom(){ \/* skip over comments *\/$/
stagen	y1.c	/^stagen(){ \/* generate the states *\/$/
state	y1.c	/^state(c){ \/* sorts last state,and sees if it equa/
stin	y4.c	/^stin(i){$/
summary	y1.c	/^summary(){ \/* output the summary on the tty *\/$/
symnam	y1.c	/^char *symnam(i){ \/* return a pointer to the name /
warray	y3.c	/^warray( s, v, n ) char *s; int *v, n; {$/
wdef	y3.c	/^wdef( s, n ) char *s; { \/* output a definition of/
wract	y3.c	/^wract(i){ \/* output state i *\/$/
writem	y1.c	/^char *writem(pp) int *pp; { \/* creates output str/
wrstate	y3.c	/^wrstate(i){ \/* writes state i *\/$/
