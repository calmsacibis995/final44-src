h08882
s 00002/00003/01632
d D 8.3 94/06/13 19:23:57 mckusick 47 45
c update SPARC information
e
s 00001/00001/01634
d R 8.3 94/06/06 22:46:05 mckusick 46 45
c transposition
e
s 00003/00000/01632
d D 8.2 94/06/01 19:44:13 ah 45 44
c page breaks for 4.4BSD manuals
e
s 00000/00000/01632
d D 8.1 93/07/27 18:59:02 mckusick 44 43
c 4.4BSD snapshot (revision 8.1)
e
s 00008/00009/01624
d D 6.32 93/07/27 18:41:02 mckusick 43 41
c assume /tmp is memory-based, so /var is the other filesystem to consider;
c specify -uw when making root read-write
e
s 00002/00002/01631
d R 6.32 93/07/27 18:30:01 mckusick 42 41
c assume /tmp is memory-based, so /var is the other filesystem to consider
e
s 00029/00058/01604
d D 6.31 93/07/27 18:00:07 mckusick 41 40
c convert from .NH to .Sh to get table of contents
e
s 00013/00013/01649
d D 6.30 93/07/26 17:03:21 mckusick 40 39
c parameterize block counts
e
s 00010/00000/01652
d D 6.29 93/07/26 16:17:10 mckusick 39 38
c describe the amount of space needed by /var
e
s 00007/00002/01645
d D 6.28 93/07/26 16:03:05 mckusick 38 36
c refine the SPARC description
e
s 00006/00002/01645
d R 6.28 93/07/26 15:47:37 mckusick 37 36
c more SPARC nits
e
s 00009/00008/01638
d D 6.27 93/07/26 11:45:06 mckusick 36 35
c update of instructions based on feedback from Don Coleman
e
s 00003/00000/01643
d D 6.26 93/07/23 14:25:19 bostic 35 34
c note that you have to set the password for "toor", not just "root"
e
s 00009/00001/01634
d D 6.25 93/07/22 09:01:35 hibler 34 33
c minor nits, clarify "mt fsf" for 9-tracks
e
s 00024/00008/01611
d D 6.24 93/07/22 00:48:23 mckusick 33 32
c update for expected layout on the tape
e
s 00170/00107/01449
d D 6.23 93/07/21 18:30:28 mckusick 32 31
c describe layout for one or two disks; cleanup source extraction directions
e
s 00002/00001/01554
d D 6.22 93/07/16 09:30:39 hibler 31 30
c "assisted boot" should be "attended boot"
e
s 00001/00001/01554
d D 6.21 93/07/16 08:18:08 hibler 30 29
c add missing \fP
e
s 00014/00006/01541
d D 6.20 93/07/15 16:58:28 hibler 29 28
c minor corrections to /usr installation
e
s 00030/00030/01517
d D 6.19 93/07/15 16:37:40 mckusick 28 27
c spelling and diction
e
s 00102/00073/01445
d D 6.18 93/07/15 09:11:45 hibler 27 26
c cleanups, add filesystem comments about 64k block size and 
c frag size < sector size
e
s 00005/00000/01513
d D 6.17 93/07/14 21:34:14 torek 26 25
c we discovered serial console is busted
e
s 00030/00015/01483
d D 6.16 93/07/14 11:12:00 hibler 25 24
c minimal instructions for installing from remote tape,
c change "mt" commmands from '-t' to documented '-f' flag
e
s 00113/00026/01385
d D 6.15 93/07/14 10:38:54 hibler 24 23
c more HP300 changes + some Sparc changes from Chris
e
s 00350/00008/01061
d D 6.14 93/07/13 16:41:36 mckusick 23 22
c section 4.2 moves to 2.5 as disk layout needs to be dealt with earlier
e
s 00016/00013/01053
d D 6.13 93/07/13 13:39:40 hibler 22 21
c downplay the tape bootstrap option for HPs (only works for cartridge)
e
s 00026/00017/01040
d D 6.12 93/07/12 22:42:48 mckusick 21 20
c nits discovered from reading
e
s 00005/00002/01052
d D 6.11 93/07/12 21:37:07 mckusick 20 19
c add reference to starting the network
e
s 00074/00040/00980
d D 6.10 93/07/12 20:09:51 mckusick 19 18
c comments from Bostic
e
s 00011/00004/01009
d D 6.9 93/07/12 13:50:02 mckusick 18 17
c final update for 3100 from ralph
e
s 00188/00030/00825
d D 6.8 93/07/11 17:53:45 mckusick 17 16
c ralph's update for 3100 install, plus edits for same by kirk
e
s 00012/00013/00843
d D 6.7 93/07/09 21:36:08 mckusick 16 15
c proofreading corrections (I've been looking at this document too long!)
e
s 00124/00059/00732
d D 6.6 93/07/09 20:47:45 mckusick 15 14
c typesetting nits
e
s 00041/00001/00750
d D 6.5 93/07/09 15:19:40 mckusick 14 13
c nit from Hibler; hardware support from Torek
e
s 00003/00003/00748
d D 6.4 93/07/09 01:03:08 mckusick 13 12
c minor typesetting nits
e
s 00065/00070/00686
d D 6.3 93/07/09 00:31:40 mckusick 12 11
c lots of minor nits
e
s 00272/00067/00484
d D 6.2 93/07/08 15:43:19 hibler 11 10
c hibler whacking: mostly working on the hp300 section
e
s 00303/00323/00248
d D 6.1 93/07/08 00:30:11 mckusick 10 8
c first pass at getting updated for 4.4BSD
e
s 00002/00002/00569
d R 8.1 93/06/08 13:57:58 bostic 9 8
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00011/00570
d D 1.8 91/05/07 22:43:12 bostic 8 7
c new copyright; att/bsd/shared
e
s 00004/00003/00577
d D 1.7 91/05/06 17:48:50 karels 7 6
c add hcx-9, updates (still only 4.3-tahoe vintage)
e
s 00014/00003/00566
d D 1.6 89/03/07 13:52:12 bostic 6 5
c add Berkeley copyright, networking release
e
s 00037/00043/00532
d D 1.5 88/07/29 14:49:18 bostic 5 4
c redo format of the tape so it will fit on 1600 bpi
e
s 00000/00002/00575
d D 1.4 88/07/19 16:15:25 bostic 4 3
c no need to set up /sys, it's on the distribution
e
s 00001/00001/00576
d D 1.3 88/07/17 09:36:46 karels 3 2
c add keywords
e
s 00236/00226/00341
d D 1.2 88/07/17 09:31:51 karels 2 1
c karels, bostic editing
e
s 00567/00000/00000
d D 1.1 88/06/13 14:20:00 bostic 1 0
c date and time created 88/06/13 14:20:00 by bostic
e
u
U
t
T
I 1
D 2
.\" Copyright (c) 1980 Regents of the University of California.
E 2
I 2
D 6
.\" Copyright (c) 1988 Regents of the University of California.
E 2
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 6
I 6
D 10
.\" Copyright (c) 1988 The Regents of the University of California.
E 10
I 10
.\" Copyright (c) 1988, 1993 The Regents of the University of California.
E 10
.\" All rights reserved.
.\"
D 8
.\" Redistribution and use in source and binary forms are permitted
.\" provided that the above copyright notice and this paragraph are
.\" duplicated in all such forms and that any documentation,
.\" advertising materials, and other materials related to such
.\" distribution and use acknowledge that the software was developed
.\" by the University of California, Berkeley.  The name of the
.\" University may not be used to endorse or promote products derived
.\" from this software without specific prior written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 8
I 8
.\" %sccs.include.redist.roff%
E 8
E 6
.\"
D 3
.\"	@(#)2.t	6.1 (Berkeley) 5/14/86
E 3
I 3
.\"	%W% (Berkeley) %G%
E 3
.\"
.ds lq ``
.ds rq ''
.ds LH "Installing/Operating \*(4B
.ds RH Bootstrapping
D 10
.ds CF \*(DY
.bp
.nr H1 2
.nr H2 0
.bp
.LG
.B
.ce
2. BOOTSTRAP PROCEDURE
.sp 2
.R
.NL
E 10
I 10
.ds CF \*(Dy
D 41
.NH 1
Bootstrap Procedure
E 41
I 41
.Sh 1 "Bootstrap procedure"
E 41
E 10
.PP
This section explains the bootstrap procedure that can be used
to get the kernel supplied with this distribution running on your machine.
D 10
If you are not currently running 4.2BSD you will
E 10
I 10
If you are not currently running \*(Ps you will
E 10
have to do a full bootstrap.
D 2
Chapter 3 describes how to upgrade an existing 4.2BSD system.
E 2
I 2
D 10
Chapter 3 describes how to upgrade a 4.2BSD system.
E 10
I 10
D 21
Chapter 3 describes how to upgrade a \*(Ps system.
E 21
I 21
Section 3 describes how to upgrade a \*(Ps system.
E 21
E 10
E 2
An understanding of the operations used in a full bootstrap
D 28
is very helpful in performing an upgrade as well.
E 28
I 28
is helpful in doing an upgrade as well.
E 28
In either case, it is highly desirable to read and understand
the remainder of this document before proceeding.
I 19
.PP
The distribution supports a somewhat wider set of machines than
those for which we have built binaries.
The architectures that are supported only in source form include:
.IP \(bu
Intel 386/486-based machines (ISA/AT or EISA bus only)
.IP \(bu
Sony News MIPS-based workstations
.IP \(bu
Omron Luna 68000-based workstations
.LP
D 27
If you wish to run one of these other architectures,
E 27
I 27
If you wish to run one of these architectures,
E 27
you will have to build a cross compilation environment.
Note that the distribution does
.B not
include the machine support for the Tahoe and VAX architectures
found in previous BSD distributions.
Our primary development environment is the HP9000/300 series machines.
The other architectures are developed and supported by
people outside the university.
Consequently, we are not able to directly test or maintain these 
other architectures, so cannot comment on their robustness,
reliability, or completeness.
E 19
D 41
.NH 2
D 10
Booting from tape
E 10
I 10
Bootstrapping from the tape
E 41
I 41
.Sh 2 "Bootstrapping from the tape"
E 41
E 10
D 16
.PP
E 16
I 16
.LP
E 16
I 10
The set of files on the distribution tape are as follows:
D 15
.DS
D 11
1) standalone copy program
2) disk image of the root filesystem
3) dump image of the root filesystem
4) tar image of the /var filesystem
5) tar image of the /usr filesystem
6) tar image of the rest of /usr/src
7) tar image of /usr/src/sys
8) (8mm tape only) tar image of /usr/src/X11R5
E 11
I 11
1) dd (HP300 and DecStation) or dump (Sparc) image of the root filesystem
2) tar image of the /var filesystem
3) tar image of the /usr filesystem
4) tar image of /usr/src/sys
5) tar image of the rest of /usr/src
6) (8mm tape only) tar image of /usr/src/X11R5
E 11
.DE
E 15
I 15
.IP 1)
D 16
dd (HP300 and DecStation) or dump (Sparc) image of the root filesystem
E 16
I 16
D 17
dd (HP300 and DecStation) or dump (SPARC) image of the root filesystem
E 17
I 17
D 21
dd (HP300 and DECstation) or dump (SPARC) image of the root filesystem
E 21
I 21
A
.Xr dd (1)
(HP300),
.Xr tar (1)
(DECstation), or
.Xr dump (8)
(SPARC) image of the root filesystem
E 21
E 17
E 16
.IP 2)
D 21
tar image of the
E 21
I 21
A
.Xr tar
image of the
E 21
.Pn /var
filesystem
.IP 3)
D 21
tar image of the
E 21
I 21
A
.Xr tar
image of the
E 21
.Pn /usr
filesystem
.IP 4)
D 21
tar image of
E 21
I 21
A
.Xr tar
image of
E 21
.Pn /usr/src/sys
.IP 5)
D 21
tar image of the rest of
E 21
I 21
A
.Xr tar
D 33
image of the rest of
E 33
I 33
image of
E 33
E 21
.Pn /usr/src
I 33
except sys and contrib
E 33
.IP 6)
I 33
A
.Xr tar
image of
.Pn /usr/src/contrib
.IP 7)
E 33
D 19
(8mm tape only) tar image of
E 19
I 19
D 21
(8mm Exabyte tape distributions only) tar image of
E 21
I 21
(8mm Exabyte tape distributions only)
A
.Xr tar
image of
E 21
E 19
.Pn /usr/src/X11R5
E 15
D 16
.PP
E 16
I 16
.LP
E 16
E 10
The tape bootstrap procedure used to create a
D 10
working system involves the following major
steps:
E 10
I 10
working system involves the following major steps:
E 10
.IP 1)
D 2
Format a disk pack with the \fIvdformat\fP program.
E 2
I 2
D 10
Format a disk pack with the \fIvdformat\fP program, if necessary.
E 10
I 10
Transfer a bootable root filesystem from the tape to a disk
and get it booted and running.
E 10
E 2
.IP 2)
D 10
Copy a ``mini root'' file system from the
tape onto the swap area of the disk.
.IP 3)
D 2
Boot the UNIX system on the ``mini root''.
E 2
I 2
Boot the UNIX system on the ``mini root.''
E 2
.IP 4)
Restore the full root file system using \fIrestore\fP\|(8).
.IP 5)
Reboot the completed root file system.
.IP 6)
Label the disks with the \fIdisklabel\fP\|(8) program.
.IP 7)
Build and restore the /usr file system from tape
E 10
I 10
D 12
Build and restore the /var and /usr file systems from tape
E 12
I 12
D 15
Build and restore the /var and /usr filesystems from tape
E 12
E 10
with \fItar\fP\|(1).
E 15
I 15
Build and restore the
.Pn /var
and
.Pn /usr
filesystems from tape with
.Xr tar (1).
E 15
D 10
.IP 8)
Extract the system and utility files and contributed software
as desired.
E 10
I 10
.IP 3)
Extract the system and utility source files as desired.
E 10
.PP
I 10
D 11
The details of the first step varies between architectures.
E 11
I 11
The following sections describe the above steps in detail.
The details of the first step vary between architectures.
E 11
D 16
The specific steps for the HP300, Sparc, and DecStation are
E 16
I 16
D 17
The specific steps for the HP300, SPARC, and DecStation are
E 17
I 17
The specific steps for the HP300, SPARC, and DECstation are
E 17
E 16
given in the next three sections respectively.
D 11
You should follow the specific instructions for your
particular architecture.
.PP
E 10
D 2
The following sections describe the above steps in detail.
In these sections references to disk drives are of the
form \fIxx\fP\|(\fIn\fP,\fIm\fP)
and references to files on tape drives are of the form
\fIyy\fP\|(\fIn\fP,\fIm\fP) where \fIxx\fP and \fIyy\fP
are names described in section 1.4 and \fIn\fP
and \fIm\fP are the unit and offset numbers described in
section 1.4.  Commands
you are expected to type are shown in Roman, while that
information printed by the system is shown emboldened.
E 2
I 2
The following sections describe the above steps in detail.  In these
sections references to disk drives are of the form \fIxx\fP\|(\fId\fP,
\fIp\fP) and references to files on tape drives are of the form
\fIxx\fP\|(\fIc\fP,\fId\fP, \fIp\fP)
D 10
where \fIxx\fP are device types described in section 1.4,
E 10
I 10
where \fIxx\fP are device types described in section 1.2,
E 10
\fIc\fP is the (optional) controller unit number,
\fId\fP is the drive unit number, and \fIp\fP is a disk partition
D 10
or tape file offset numbers as described in section 1.4.
E 10
I 10
or tape file offset numbers as described in section 1.2.
E 10
For the sake of simplicity, all disk examples will use the disk type
D 10
``dk'' and all tape examples will similarly use ``cy'';
E 10
I 10
``\*(Dk'' and all tape examples will similarly use ``\*(Mt'';
E 10
the examples assume drive 0, partition 0.
D 10
Commands you
are expected to type are shown in italics, while that information
printed by the system is shown emboldened.
E 2
.PP
If you encounter problems while following the instructions in
this part of the document, refer to Appendix B for help in
troubleshooting.
.NH 3
Step 1: formatting the disk
.PP
All disks used with \*(4B should be formatted to insure
the proper handling of physically corrupted disk sectors.
The
.I vdformat
program included in the distribution, or a vendor supplied
formatting program, may be used to format disks if this has not
D 2
already been done.
The
.I vdformat
program is capable of formatting
any of the disk drives listed in \(sc1.1.
E 2
I 2
already been done.  The \fIvdformat\fP program is capable of formatting
any of the disk drives listed in section 1.1, when booting from tape;
when booting from disk, it supports any drive listed in
\fI/etc/disktab\fP.
E 2
.PP
To load the \fIvdformat\fP program, perform the following steps.
.DS
E 10
I 10
Commands you are expected to type are shown in italics, while that
E 11
I 11
You should follow the instructions for your particular architecture.
In all sections,
commands you are expected to type are shown in italics, while that
E 11
information printed by the system is shown emboldened.
I 11
D 16
.PP
E 16
E 11
D 41
.NH 2
Booting the HP300
I 11
.NH 3
Supported hardware
E 41
I 41
.Sh 2 "Booting the HP300"
.Sh 3 "Supported hardware"
E 41
E 11
.LP
The hardware supported by \*(4B for the HP300/400 is as follows:
E 10
.TS
D 10
lw(2i) l.
(machine powered up)
\fBMIB POC\fP
\fBType '#' to cancel boot\fP
D 2
#	(cancel automatic reboot)
\fBCP [a10.h0]#>\fP\|h	(halt the cpu)
\fB#>\|\fPy	(initialize the machine)
\fB#>\|\fPfd cyp(0,0)	(make cypher default device)
\fB#>\|\fPp23 3. \fB00000000\fP	(set boot flags)
\fB#>\|\fPfb	(boot machine)
E 2
I 2
\fI#\fP	(cancel automatic reboot)
\fBCP [a10.h0]#>\fP\fI\|h\fP	(halt the cpu)
D 7
\fB#>\|\fP\fIy.\fP	(initialize the machine)
E 7
\fB#>\|\fP\fIfd cyp(0,0)\fP	(make cypher default device)
\fB#>\|\fP\fIp23 3.\fP \fB00000000\fP	(set boot flags)
I 7
\fB#>\|\fP\fIy.\fP	(initialize the machine)
E 7
\fB#>\|\fP\fIfb\fP	(boot machine)
E 2
\fBcyp(0,0)/etc/fstab\fP
\fBCP cold boot\fP
\fB4 way interleave set\fP
\fBCPU memory test\fP
\fBECC CPU memory test\fP
\fBcyp(0,0)/.\fP
\fBCPU POC1\fP
\fBcyp(0,0)/poc1\fP
\fBCPU POC2\fP
\fBcyp(0,0)/poc2\fP
\fBFPP POC\fR	(only if floating point processor present)
\fBcyp(0,0)/fppoc\fP
\fBFPP WCS\fR	(only if floating point processor present)
\fBcyp(0,0)/fppwcs\fP
\fBBOOT SYSTEM cyp(0,0)/boot\fP

\fBBoot\fP
D 2
\fB:\fRcy(0,0)stand/vdformat	(load and run from first tape file)
E 2
I 2
\fB:\fIcy(0,0)stand/vdformat\fR	(load and run from first tape file)
\fB52224+17408+1177716 start 0x1000\fP
\fBVDFORMAT     Berkeley Version 1.6\fP
E 10
I 10
center box;
lw(1i) lw(4i).
D 19
CPUs	T{
E 19
I 19
CPU's	T{
E 19
68020 based (318, 319, 320, 330 and 350),
68030 based (340, 345, 360, 370, 375, 400) and
68040 based (380, 425, 433).
T}
_
D 19
DISKs	T{
E 19
I 19
DISK's	T{
E 19
HP-IB/CS80 (7912, 7914, 7933, 7936, 7945, 7957, 7958, 7959, 2200, 2203)
and SCSI-I (including magneto-optical).
T}
_
D 19
TAPEs	T{
E 19
I 19
TAPE's	T{
E 19
Low-density CS80 cartridge (7914, 7946, 9144),
high-density CS80 cartridge (9145),
HP SCSI DAT and
D 28
SCSI exabyte.
E 28
I 28
SCSI Exabyte.
E 28
T}
_
RS232	T{
98644 built-in single-port, 98642 4-port and 98638 8-port interfaces.
T}
_
NETWORK	T{
98643 internal and external LAN cards.
T}
_
GRAPHICS	T{
Terminal emulation and raw frame buffer support for
D 19
98544/98545/98547 (Topcat color & monochrome),
98548/98549/98550 (Catseye color & monochrome),
98700/98710 (Gatorbox),
98720/98721 (Renaissance),
98730/98731 (DaVinci) and
E 19
I 19
98544 / 98545 / 98547 (Topcat color & monochrome),
98548 / 98549 / 98550 (Catseye color & monochrome),
98700 / 98710 (Gatorbox),
98720 / 98721 (Renaissance),
98730 / 98731 (DaVinci) and
E 19
A1096A (Hyperion monochrome).
T}
_
INPUT	T{
General interface supporting all HIL devices.
(e.g. keyboard, 2 and 3 button mice, ID module, ...)
T}
_
MISC	T{
Battery-backed real time clock,
builtin and 98625A/B HP-IB interfaces,
builtin and 98658A SCSI interfaces,
serial printers and plotters on HP-IB,
and SCSI autochanger device.
T}
E 10
E 2
.TE
D 2
.DE
.PP
The \fIvdformat\fP program should now be running and awaiting your input:
.DS
\fB:\fPcy(0,0)stand/vdformat
\fB50176+14336+776780 start 0x1000\fP
\fBVDFORMAT	Version 3.0\fP
E 2
D 10

\fBcontroller 0: smd\fP
\fBcontroller 1: smd-e\fP

\fBType `Help' for help, `Start' to execute operations.\fP

\fBvdformat>\fP
.DE
E 10
I 10
.LP
D 19
Major items not supported include the 310 and 332 CPUs, 400 series machines
E 19
I 19
D 28
Major items which are not supported
E 28
I 28
Major items that are not supported
E 28
include the 310 and 332 CPU's, 400 series machines
E 19
configured for Domain/OS, EISA and VME bus adaptors, audio, the centronics
port, 1/2" tape drives (7980), CD-ROM, and the PVRX/TVRX 3D graphics displays.
I 11
D 41
.NH 3
Standalone device file naming
E 41
I 41
.Sh 3 "Standalone device file naming"
E 41
D 16
.PP
E 16
I 16
.LP
E 16
The standalone system device name syntax on the HP300 is of the form:
.DS
xx(a,c,u,p)
.DE
where
\fIxx\fP is the device type,
\fIa\fP specifies the adaptor to use,
\fIc\fP the controller,
\fIu\fP the unit, and
\fIp\fP a partition.
The \fIdevice type\fP differentiates the various disks and tapes and is one of:
D 27
``rd'' (HP-IB CS80 disks),
``ct'' (HP-IB CS80 cartridge tape),
``sd'' (SCSI-I disks) or
``st'' (SCSI-I tapes).
E 27
I 27
``rd'' for HP-IB CS80 disks,
``ct'' for HP-IB CS80 cartridge tapes, or
``sd'' for SCSI-I disks
D 28
(SCSI-I tapes are not supported at this time).
E 28
I 28
(SCSI-I tapes are currently not supported).
E 28
E 27
The \fIadaptor\fP field is a logical HP-IB or SCSI bus adaptor card number.
This will typically be
D 27
0 for SCSI disks and tapes,
E 27
I 27
0 for SCSI disks,
E 27
0 for devices on the ``slow'' HP-IB interface (usually tapes) and
1 for devices on the ``fast'' HP-IB interface (usually disks).
To get a complete mapping of physical (select-code) to logical card numbers
just type a ^C at the standalone prompt.
The \fIcontroller\fP field is the disk or tape's target number on the
HP-IB or SCSI bus.
For SCSI the range is 0 to 6 (7 is the adaptor address) and
for HP-IB the range is 0 to 7.
The \fIunit\fP field is unused and should be 0.
The \fIpartition\fP field is interpreted differently for tapes
and disks: for disks it is a disk partition (in the range 0-7),
and for tapes it is a file number offset on the tape.
Thus, partition 2 of a SCSI disk drive at target 3 on SCSI bus 1
D 14
would be ``sd(1,0,3,2)''.
E 14
I 14
would be ``sd(1,3,0,2)''.
E 14
If you have only one of any type bus adaptor, you may omit the adaptor
and controller numbers;
e.g. ``sd(0,2)'' could be used instead of ``sd(0,0,0,2)''.
The following examples always use the full syntax for clarity.
D 41
.NH 3
The Procedure
E 41
I 41
.Sh 3 "The procedure"
E 41
E 11
.LP
The basic steps involved in bringing up the HP300 are as follows:
.IP 1)
D 11
Obtain a new disk and format it, if necessary.
E 11
I 11
Obtain a second disk and format it, if necessary.
E 11
.IP 2)
D 12
Copy a root file system from the
E 12
I 12
Copy a root filesystem from the
E 12
tape onto the beginning of the disk.
.IP 3)
Boot the UNIX system on the new disk.
.IP 4)
I 12
(Optional) Build a root filesystem optimized for your disk.
.IP 5)
E 12
D 11
If optimal performance is desired, restore the root file system
using \fIrestore\fP\|(8).
.IP 5)
E 11
D 15
Label the disks with the \fIdisklabel\fP\|(8) program.
E 15
I 15
Label the disks with the
.Xr disklabel (8)
program.
E 15
D 11
.NH 3
E 11
I 11
D 41
.NH 4
E 11
D 19
Step 1: formating a disk.
E 19
I 19
D 24
Step 1: formatting a disk.
E 24
I 24
Step 1: selecting and formatting a disk.
E 41
I 41
.Sh 4 "Step 1: selecting and formatting a disk"
E 41
E 24
E 19
E 10
I 2
.PP
D 10
The \fIvdformat\fP program should now be running and awaiting your input.
E 2
If you made a mistake loading the program off the tape
D 2
you should get either the ``:'' prompt again from the
boot program or the ``#>'' prompt from the console
E 2
I 2
you should get either the ``:'' prompt again (from the
boot program) or the ``#>'' prompt from the console
E 2
processor.  In either case you can retype the appropriate
command to try again.
If something else happened, you may have a bad distribution
tape, or your hardware may be broken; refer to
Appendix B for help in troubleshooting.
E 10
I 10
D 11
For your first system you will have to obtain a formatted disk.
E 11
I 11
For your first system you will have to obtain a formatted disk
of a type given in the ``supported hardware'' list above.
I 24
If you want to load an entire binary system
D 32
(i.e., everything except /usr/src),
E 32
I 32
(i.e., everything except
.Pn /usr/src ),
E 32
on the single disk you will need a minimum of 290MB,
D 27
ruling out anything smaller than a 7959B disk.
E 27
I 27
ruling out anything smaller than a 7959B/S disk.
E 27
D 28
The disklabel included in the bootstrap root image is layed out
to accomodate this scenerio.
E 28
I 28
The disklabel included in the bootstrap root image is laid out
to accommodate this scenario.
E 28
Note that an HP SCSI magneto-optical disk will work fine for this case.
\*(4B will boot and run (albeit slowly) using one.
If you want to load source on a single disk system,
you will need at least 640MB (at least a 2213A SCSI or 2203A HP-IB disk).
A disk as small as the 7945A (54MB) can be used for the bootstrap
procedure but will hold only the root and primary swap partitions.
If you plan to use multiple disks,
D 28
refer to section 2.5 for suggestions on paritioning.
E 28
I 28
refer to section 2.5 for suggestions on partitioning.
E 28
.PP
After selecting a disk, you may need to format it.
E 24
D 19
Since most HP disk drives, with the exception of optical media,
come pre-formatted there should be nothing to do.
E 19
I 19
Since most HP disk drives come pre-formatted
D 24
(with the exception of optical media),
there should be nothing to do.
E 19
D 15
If necessary, you can format a disk under HP-UX using
the \fImediainit\fP\|(1m) program.
E 15
I 15
If necessary, you can format a disk under HP-UX using the
E 24
I 24
D 28
(with the exception of optical media)
you probably won't but if necessary,
E 28
I 28
(except optical media)
you probably will not, but if necessary,
E 28
you can format a disk under HP-UX using the
E 24
.Xr mediainit (1m)
program.
E 15
E 11
D 19
Once you have \*(4B up and running on one machine you can use
D 15
the \fIscsiformat\fP\|(8) program to format additional disks.
E 15
I 15
the
E 19
I 19
Once you have \*(4B up and running on one machine you can use the
E 19
.Xr scsiformat (8)
D 19
program to format additional disks.
E 19
I 19
program to format additional SCSI disks.
I 24
Any additional HP-IB disks will have to be formatted using HP-UX.
E 24
E 19
E 15
D 11
.NH 3
E 11
I 11
D 41
.NH 4
E 11
D 12
Step 2: copying the root file system from tape to disk
E 12
I 12
Step 2: copying the root filesystem from tape to disk
E 41
I 41
.Sh 4 "Step 2: copying the root filesystem from tape to disk"
E 41
E 12
E 10
.PP
D 10
\fIVdformat\fP will create sector headers and verify
the integrity of each sector formatted.  
The program starts up by identifying the disk controllers
installed in the machine.  Old VDDC controllers which 
support only SMD drives are indicated
as ``smd'' while newer controllers capable of supporting both
SMD and extended-SMD drives are tagged as ``smd-e''. 
D 2
Remember \fIvdformat\fP works only with the drives listed above.
E 2
\fIVdformat\fP
will prompt for the information required as shown below.
If you err in answering questions,
D 2
``Delete'' erases the last character typed, and ``^U'' erases
E 2
I 2
``Delete'' or backspace erase the last character typed, and ``^U'' erases
E 2
the current input line.  At any point you can ask for
assistance by typing ``help''; \fIvdformat\fP will list
the possible answers to the current question.
E 10
I 10
D 12
There are two approaches to getting the root file system from tape to disk.
E 12
I 12
D 22
There are two approaches to getting the root filesystem from tape to disk.
E 12
D 11
If you have two disks, the easiest approach is to boot your vendor
operating system from the first disk, and then use \fIdd\fP\|(1)
to copy the root filesystem image from the tape to the beginning of the
second disk. 
The root filesystem image is the second file on the tape. 
E 11
I 11
D 15
If you have an extra disk, the easiest approach is to use \fIdd\fP\|(1)
E 15
I 15
If you have an extra disk, the easiest approach is to use
E 22
I 22
Once you have a formatted second disk you can use the
E 22
.Xr dd (1)
E 15
D 22
under HP-UX to copy the root filesystem image from the tape to the beginning
D 16
of the second disk. 
E 16
I 16
of the second disk.
E 22
I 22
command under HP-UX to copy the root filesystem image from
the tape to the beginning of the second disk.
E 22
E 16
D 19
For HPs, the root filesystem image is the first file on the tape.
E 19
I 19
For HP's, the root filesystem image is the first file on the tape.
E 19
E 11
It includes a disklabel and bootblock along with the root filesystem.
D 11
The set of commands to copy it from the tape to the beginning of the disk are:
E 11
I 11
An example command to copy the image from tape to the beginning of a disk is:
E 11
E 10
.DS
I 17
.ft CW
E 17
D 2
\fBvdformat>\fP\|format
  \fBFormat on which controllers?\fP\|1
    \fBDrives on controller 1?\fP\|0
      \fBNumber of patterns to use while verifying?\fP\|1
      \fBDrive type for controller 1, drive 0?\fP\|egl
        \fBModule serial number for controller 1, drive 0?\fP\|1
\fBvdformat>\fP\|list
E 2
I 2
D 10
\fBvdformat>\fP\|\fIformat\fP
  \fBFormat on which controllers?\fP\|\fI1\fP
    \fBDrives on controller 1?\fP\|\fI0\fP
      \fBNumber of patterns to use while verifying?\fP\|\fI1\fP
      \fBDrive type for controller 1, drive 0?\fP\|\fIegl\fP
        \fBModule serial number for controller 1, drive 0?\fP\|\fI1\fP
\fBvdformat>\fP\|\fIlist\fP
E 2
  \fBThe following operations will occur when Start is issued:\fP
    \fBFormat: Controller 1, drive 0, type EGL.\fP
D 2
\fBvdformat>\fP\|start
E 2
I 2
\fBvdformat>\fP\|\fIstart\fP
E 2
\fBStarting format on controller 1, drive 0, type EGL.\fP
(\fIbad sectors will be indicated\fP)
\fBvdformat>\fP
E 10
I 10
D 11
mt -f /dev/nr\*(Mt0 fsf 1
dd if=/dev/nr\*(Mt0 of=/dev/r\*(Dk1c bs=20b
E 11
I 11
D 27
dd if=/dev/rmt/0m of=/dev/rdsk/1s0 bs=20b
E 27
I 27
D 40
dd if=/dev/rmt/0m of=/dev/rdsk/1s0 bs=40b
E 40
I 40
dd if=/dev/rmt/0m of=/dev/rdsk/1s0 bs=\*(Bzb
E 40
E 27
E 11
E 10
.DE
I 11
The actual special file syntax may vary depending on unit numbers and
the version of HP-UX that is running.
D 15
Consult the HP-UX \fImt\fP(7) and \fIdisk\fP(7) man pages for details.
E 15
I 15
Consult the HP-UX
.Xr mt (7)
and
.Xr disk (7)
man pages for details.
E 15
E 11
D 10
Once the root device has been formatted, \fIvdformat\fP
will prompt for another command.
Return to the bootstrap by typing
.DS
D 2
\fBvdformat>\fP\|exit
E 2
I 2
\fBvdformat>\fP\|\fIexit\fP
E 2
.DE
or halt the machine by
typing ``~h''.
.DS
D 2
\fBvdformat>\fP ~h
E 2
I 2
\fBvdformat>\fP \fI~h\fP
E 2
\fB#>\|\fP
.DE
E 10
.PP
I 22
D 24
Note that an HP SCSI magneto-optical disk will work fine as a second disk.
\*(4B will boot and run (albeit slowly) from one.
Also note that if you have a SCSI disk, you don't necessarily have to use
E 24
I 24
Note that if you have a SCSI disk, you don't necessarily have to use
E 24
HP-UX (or an HP) to create the boot disk.
Any machine and operating system that will allow you to copy the
raw disk image out to block 0 of the disk will do.
.PP
E 22
D 10
It may be necessary to format other drives before constructing
file systems on them; this can be done at a later time with the
steps just performed, or \fIvdformat\fP may be brought in
off a disk drive as described in \(sc6.1.
.NH 3
Step 2: copying the mini-root file system
.PP
D 2
The second step is to run a simple program,
\fIcopy\fP, which copies a small root
file system into the second partition of the disk.
This file system will serve as the base for creating the actual root
file system to be restored.  The version of the operating
system maintained on the ``mini-root'' file system understands
that it should not swap on top of itself, thereby allowing double use
of the disk partition.
Disk 0 is normally used for this operation when doing an initial
boot.
Another disk may be substituted if necessary,
although several modifications to the procedure may be needed
to create special files for the alternate disk.
The actual disk number should be substituted for the \fIx\fP below.
\fICopy\fP is loaded just as the
\fIvdformat\fP program was loaded;
if you don't have the bootstrap running,
repeat the above instructions until you see the
prompt from Boot (a colon), and then:
E 2
I 2
The second step is to run a simple program, \fIcopy\fP, to copy a
small root file system into the \fBsecond\fP partition of the disk.  (Note
that the disk partitions used by \*(4B may not correspond to those
used by vendor supplied software.)  This file system will serve as the
base for creating the actual root file system to be restored.  The
generic version of the operating system maintained on the ``mini-root''
file system understands that it should not swap on top of itself, thereby
allowing double use of the disk partition.  Disk 0 is normally used for
E 10
I 10
If you have only a single machine with a single disk,
D 22
you need to use the more difficult approach of booting a
D 16
standalone copy program, and using that to copy the 
E 16
I 16
standalone copy program, and using that to copy the
E 22
I 22
you may still be able to install and boot \*(4B if you have an
HP-IB cartridge tape drive.
If so, you can use a more difficult approach of booting a
standalone copy program from the tape, and using that to copy the
E 22
E 16
root filesystem image from the tape to the disk.
D 11
Disk 0 is normally used for
E 10
this operation; this is reflected in the example procedure.  Another disk
may be substituted if necessary, although several modifications will
D 10
be necessary to create special files for the alternate disk.  \fICopy\fP
is loaded just as the \fIvdformat\fP program was loaded; if you don't
have the bootstrap running, repeat the previous instructions until you
see the prompt from boot (a colon), and then:
E 10
I 10
be necessary to create special files for the alternate disk.
\fICopy\fP is loaded from the first file on the tape, and then:
E 11
I 11
D 22
If your distribution is on 8mm tape and you have an 8mm drive attached
to the target machine, you should be able to boot from the distribution
tape directly.
If you have the 9-track distribution or only have a CS80 cartridge or
4mm DAT drive, you will need to create your own boot tape.
E 22
To do this, you need to extract the first file of the distribution tape
D 22
(the root image), copy it over to a machine with a supported HP tape
drive and then create a bootable cartridge or DAT tape.
E 22
I 22
(the root image), copy it over to a machine with a cartridge drive
and then copy the image onto tape.
E 22
For example:
E 11
E 10
E 2
.DS
I 17
.ft CW
E 17
I 11
D 27
dd if=/dev/rst0 of=bootimage bs=20b
E 27
I 27
D 40
dd if=/dev/rst0 of=bootimage bs=40b
E 40
I 40
dd if=/dev/rst0 of=bootimage bs=\*(Bzb
E 40
E 27
rcp bootimage foo:/tmp/bootimage
<login to foo>
D 27
dd if=/tmp/bootimage of=/dev/rct/0m bs=20b
E 27
I 27
D 40
dd if=/tmp/bootimage of=/dev/rct/0m bs=40b
E 40
I 40
dd if=/tmp/bootimage of=/dev/rct/0m bs=\*(Bzb
E 40
E 27
.DE
Once this tape is created you can boot and run the standalone tape
copy program from it.
The copy program is loaded just as any other program would be loaded
by the bootrom in ``attended'' mode:
reset the CPU,
hold down the space bar until the word ``Keyboard'' appears in the
installed interface list, and
enter the menu selection for SYS_TCOPY.
Once loaded and running:
.DS
E 11
.TS
lw(2i) l.
D 2
(copy mini root file system)
\fB:\|\fPcy(0,0)copy	(load and run copy program)
\fBFrom:\fP cy(0,1)	(unit 0, second tape file)
\fBTo:\fP dk(\fIx\fP,1)	(mini root is on drive \fIx\fP; second partition)
E 2
I 2
D 10
\fB:\|\fP\fIcy(0,0)copy\fP	(load and run copy program)
\fBFrom:\fP \fIcy(0,1)\fP	(tape drive unit 0, second tape file)
\fBTo:\fP \fIdk(0,1)\fP	(disk drive unit 0, second disk partition)
E 2
\fBCopy completed: 205 records copied\fP
\fBBoot\fP
\fB:\fP
E 10
I 10
D 11
\fB:\|\fP\fI\*(Mt(0,0)copy\fP	(load and run copy program)
\fBFrom:\fP \fI\*(Mt(0,1)\fP	(tape drive unit 0, second tape file)
\fBTo:\fP \fI\*(Dk(0,2)\fP	(disk drive unit 0, third disk partition)
\fBCopy completed: 1400 records copied\fP
E 11
I 11
\fBFrom:\fP \fI^C\fP	(control-C to see logical adaptor assignments)
\fBhpib0 at sc7\fP
\fBscsi0 at sc14\fP
D 27
\fBFrom:\fP \fIct(0,7,0,0)\fP	(HP-IB tape target 7, first tape file)
\fBTo:\fP \fIsd(0,0,0,2)\fP	(SCSI disk target 0, third disk partition)
\fBCopy completed: 2048 records copied\fP
E 27
I 27
\fBFrom:\fP \fIct(0,7,0,0)\fP	(HP-IB tape, target 7, first tape file)
\fBTo:\fP \fIsd(0,0,0,2)\fP	(SCSI disk, target 0, third partition)
\fBCopy completed: 1728 records copied\fP
E 27
E 11
E 10
.TE
D 2
(As above, `delete' erases characters and `^U' erases lines.)
E 2
.DE
I 2
D 10
As before, `delete' or backspace erase characters and `^U' erases lines.
E 10
E 2
D 11
.NH 3
E 11
I 11
.LP
This copy will likely take 30 minutes or more.
I 24
D 27
Unfortunately, this won't work for a SCSI DAT tape since \*(4B includes
no standalone driver for SCSI tapes.
E 27
E 24
D 41
.NH 4
E 11
D 10
Step 3: booting from the mini-root file system
E 10
I 10
Step 3: booting the root filesystem
E 41
I 41
.Sh 4 "Step 3: booting the root filesystem"
E 41
E 10
.PP
D 10
You now have the minimal set of tools necessary to create a
root file system and restore the file system contents from tape.
To access this file system load the bootstrap program
and boot the version of unix that has been placed in the
``mini-root.''
As before, load the bootstrap if you do not already have
it running.  At the colon prompt:
E 10
I 10
You now have a bootable root filesystem on the disk.
If you were previously running with two disks,
D 11
shut down the machine, remove the disk that you previously booted on,
set the unit number of the disk onto which you loaded \*(4B to zero,
and power up the machine.
If you used the standalone copy program,
you should power down the machine, switch the tape drive offline,
and power the machine back up.
It should now find, boot, and run \*(4B with output that looks
approximately like this:
E 11
I 11
it would be best if you shut down the machine and turn off power on
the HP-UX drive.
It will be less confusing and it will eliminate any chance of accidentally
destroying the HP-UX disk.
I 27
If you used a cartridge tape for booting you should also unload the tape
at this point.
E 27
Whether you booted from tape or copied from disk you should now reboot
D 28
the machine and perform another assisted boot, this time with SYS_TBOOT.
E 28
I 28
D 31
the machine and do another assisted boot, this time with SYS_TBOOT.
E 31
I 31
the machine and do another attended boot (see previous section),
this time with SYS_TBOOT.
E 31
E 28
Once loaded and running the boot program will display the CPU type and
prompt for a kernel file to boot:
E 11
E 10
.DS
D 10
.TS
lw(2i) l.
D 2
\fB: \fPdk(\fIx\fP,1)vmunix	(bring in \fIvmunix\fP off mini root)
E 2
I 2
\fB: \fP\fIdk(0,1)vmunix\fP	(get \fIvmunix\fP from disk drive 0, second partition)
E 2
.TE
.DE
The standalone boot program should then read the system from
the mini root file system you just created, and the system should boot:
.DS
E 10
.B
D 10
271944+78848+92812 start 0x12e8
D 2
4.3 BSD UNIX #1: Wed Apr  9 23:33:59 PST 1985
    sam@okeeffe.berkeley.edu:/usr/src/sys/GENERIC
real mem  = \fIxxx\fP
avail mem = \fIyyy\fP
\fI\&... information about available devices ...\fP
E 2
I 2
4.3 BSD #1: Sat Jun  4 17:11:42 PDT 1988
	(karels@okeeffe.Berkeley.EDU:/usr/src/sys/GENERIC)
E 10
I 10
D 11
597316+34120+139288 start 0x9ec
E 11
I 11
HP433 CPU
Boot
.R
\fB:\fP \fI/vmunix\fP
.DE
.LP
D 19
After providing the kernel name, the machine will boot and run \*(4B with
E 19
I 19
After providing the kernel name, the machine will boot \*(4B with
E 19
D 28
output that looks approximately like this:
E 28
I 28
output that looks about like this:
E 28
.DS
.B
D 32
597316+34120+139288 start 0xfe8019ec
E 32
I 32
597480+34120+139288 start 0xfe8019ec
E 32
Copyright (c) 1982, 1986, 1989, 1991, 1993
	The Regents of the University of California.
Copyright (c) 1992 Hewlett-Packard Company
Copyright (c) 1992 Motorola Inc.
All rights reserved.

E 11
D 15
4.4BSD UNIX #3: Tue Jul  6 14:02:20 PDT 1993
E 15
I 15
D 32
4.4BSD UNIX #1: Thu Jul  8 11:41:34 PDT 1993
E 32
I 32
4.4BSD UNIX #1: Tue Jul 20 11:40:36 PDT 1993
E 32
E 15
D 11
	(mckusick@vangogh.CS.Berkeley.EDU:/usr/obj/sys/compile/GENERIC.hp300)
E 10
real mem  = xxx
E 11
I 11
    mckusick@vangogh.CS.Berkeley.EDU:/usr/obj/sys/compile/GENERIC.hp300
HP9000/433 (33MHz MC68040 CPU+MMU+FPU, 4k on-chip physical I/D caches)
real mem = xxx
E 11
avail mem = ###
using ### buffers containing ### bytes of memory
(... information about available devices ...)
E 2
D 11
root device? 
E 11
I 11
root device?
E 11
.R
.DE
.PP
D 2
The first three numbers are printed out by the bootstrap
programs and are the sizes of different
parts of the system (text, initialized and uninitialized data).  The
system also allocates several system data structures after it starts
running.  The sizes of these structures are based on the amount of available
memory and the maximum count of active users expected, as declared in a system
configuration description.  This will be discussed later.
E 2
I 2
D 11
The first three numbers are printed out by the bootstrap programs and
E 11
I 11
The first three numbers are printed out by the bootstrap program and
E 11
are the sizes of different parts of the system (text, initialized and
uninitialized data).  The system also allocates several system data
structures after it starts running.  The sizes of these structures are
based on the amount of available memory and the maximum count of active
users expected, as declared in a system configuration description.  This
will be discussed later.
E 2
.PP
UNIX itself then runs for the first time and begins by printing out a banner
identifying the release and
D 16
version of the system that is in use and the date that it was compiled.  
E 16
I 16
version of the system that is in use and the date that it was compiled. 
E 16
.PP
Next the
.I mem
messages give the
amount of real (physical) memory and the
memory available to user programs
in bytes.
D 2
For example, if your machine has only 512K bytes of memory, then
\fIxxx\fP will be 520192, 4096 bytes less than 512K.
The system reserves the last 4096 bytes of memory for use in
error logging and doesn't count it as part of real memory.
E 2
I 2
For example, if your machine has 16Mb bytes of memory, then
\fBxxx\fP will be 16777216.
E 2
.PP
The messages that come out next show what devices were found on
the current processor.  These messages are described in
D 15
\fIautoconf\fP\|(4).
E 15
I 15
.Xr autoconf (4).
E 15
The distributed system may not have
D 2
found all the communications devices you have (vioc's),
E 2
I 2
D 10
found all the communications devices you have (VIOC's or MPCC's),
E 10
I 10
found all the communications devices you have
E 10
E 2
or all the mass storage peripherals you have, especially
if you have more than
D 2
two of anything.  You will correct this soon, when you create
a description of your machine from which to configure UNIX.
E 2
I 2
two of anything.  You will correct this when you create
a description of your machine from which to configure a site-dependent
version of UNIX.
E 2
The messages printed at boot here contain much of the information
that will be used in creating the configuration.
In a correctly configured system most of the information
present in the configuration description
is printed out at boot time as the system verifies that each device
is present.
.PP
D 16
The \*(lqroot device?\*(rq prompt was printed by the system 
E 16
I 16
The \*(lqroot device?\*(rq prompt was printed by the system
E 16
D 2
and is now asking you for the name of the root file system to use.
E 2
I 2
D 12
to ask you for the name of the root file system to use.
E 12
I 12
to ask you for the name of the root filesystem to use.
E 12
E 2
This happens because the distribution system is a \fIgeneric\fP
D 10
system, i.e. it can be bootstrapped on a Tahoe cpu with its root device
E 10
I 10
system, i.e., it can be bootstrapped on a cpu with its root device
E 10
D 2
and paging area on any available disk drive.  You should respond
to the root device question with \fIxx\fP0*.  This response
supplies two pieces of information:
first, \fIxx\fP0 shows that the disk it is running on is drive
0 of type \fIxx\fP, secondly the \*(lq*\*(rq shows that the system is
running \*(lqatop\*(rq the paging area.  The latter is most important,
otherwise the system will attempt to page on top of itself and
chaos will ensue.
You will later build a system tailored to your configuration that
will not ask this question when it is bootstrapped.
E 2
I 2
D 11
and paging area on any available disk drive.  You should respond to the
D 10
root device question with ``dk0*''.  This response supplies two pieces
of information: first, ``dk0'' shows that the disk it is running on is
drive 0 of type ``dk'', and, secondly, the \*(lq*\*(rq shows that the
system is running \*(lqatop\*(rq the paging area.  The latter is
extremely important, otherwise the system will attempt to page on top
of itself and chaos will ensue.  You will later build a system tailored
to your configuration that will not ask this question when it is
bootstrapped.
E 10
I 10
root device question with ``\*(Dk0''.  This response indicates that
E 11
I 11
and paging area on any available disk drive.
D 12
You should respond to the root device question with
 ``\*(Dk0''.  This response indicates that
E 12
I 12
D 19
You should respond to the root device question with ``\*(Dk0''.
This response indicates that
E 12
E 11
that the disk it is running on is drive 0 of type ``\*(Dk''.
E 19
I 19
D 24
You should respond to the root device question with ``sd0''
if you are booting from a SCSI disk;
you should respond to the root device question with ``rd0''
if you are booting from an HP-IB disk.
E 24
I 24
You will most likely respond to the root device question with ``sd0''
if you are booting from a SCSI disk,
or with ``rd0'' if you are booting from an HP-IB disk.
E 24
D 28
This response indicates that that the disk it is running
E 28
I 28
This response shows that the disk it is running
E 28
on is drive 0 of type ``sd'' or ``rd'' respectively.
I 24
If you have other disks attached to the system,
it is possible that the drive you are using will not be configured
as logical drive 0.
Check the autoconfiguration messages printed out by the kernel to
make sure.
D 28
These messages will reveal the type of every logical drive
E 28
I 28
These messages will show the type of every logical drive
E 28
and their associated controller and slave addresses.
E 24
E 19
You will later build a system tailored to your configuration
D 24
that will not ask this question when it is bootstrapped.
E 24
I 24
that will not prompt you for a root device when it is bootstrapped.
E 24
E 10
E 2
.DS
D 2
\fBroot device?\fP \fIxx\fP0*
E 2
I 2
D 10
\fBroot device?\fP \fIdk0*\fP
E 10
I 10
\fBroot device?\fP \fI\*(Dk0\fP
E 10
E 2
D 12
WARNING: preposterous time in file system \-\- CHECK AND RESET THE DATE!
E 12
I 12
D 27
WARNING: preposterous time in filesystem \-\- CHECK AND RESET THE DATE!
E 27
I 27
\fBWARNING: preposterous time in filesystem \-\- CHECK AND RESET THE DATE!\fP
E 27
E 12
\fBerase ^?, kill ^U, intr ^C\fP
\fB#\fP
.DE
.PP
D 15
The \*(lqerase ...\*(rq message is part of the /.profile
E 15
I 15
The \*(lqerase ...\*(rq message is part of the
.Pn /.profile
E 15
that was executed by the root shell when it started.  This message
D 28
is present to inform you as to what values the character erase,
line erase, and interrupt characters have been set.
E 28
I 28
tells you about the settings of the character erase,
line erase, and interrupt characters.
E 28
D 11
.NH 3
E 11
I 11
D 24
.NH 4
E 11
D 12
Step 4: restoring the root file system
E 12
I 12
D 16
Step 4: restoring the root filesystem
E 16
I 16
Step 4: (optional) restoring the root filesystem
E 24
E 16
E 12
.PP
UNIX is now running,
D 2
and the `UNIX Programmer's manual' applies.
The `#' is the prompt from the shell,
and lets you know that you are the super-user,
whose login name is \*(lqroot\*(rq.  To complete installation
of the bootstrap system one step remains:  the root
file system must be created.
E 2
I 2
D 19
and the \fIUNIX Programmer's manual\fP applies.  The ``#'' is the prompt
E 19
I 19
and the \fIUNIX Programmer's Manual\fP applies.  The ``#'' is the prompt
E 19
from the Bourne shell, and lets you know that you are the super-user,
whose login name is \*(lqroot\*(rq.
E 2
.PP
I 24
At this point, the root filesystem is mounted read-only.
Before continuing the installation, the filesystem needs to be ``updated''
to allow writing and device special files for the following steps need
to be created.
This is done as follows:
.DS
.TS
lw(2i) l.
D 27
\fB#\fP \fImount_mfs -s 1000 -T type /dev/null /tmp	(create a writable filesystem)
E 27
I 27
\fB#\fP \fImount_mfs -s 1000 -T type /dev/null /tmp\fP	(create a writable filesystem)
E 27
(\fItype\fP is the disk type as determined from /etc/disktab)
D 27
\fB#\fP \fIcd /tmp\fP	(go to that filesystem)
E 27
I 27
\fB#\fP \fIcd /tmp\fP	(connect to that directory)
E 27
\fB#\fP \fI../dev/MAKEDEV \*(Dk#\fP	(create special files for root disk)
(\fI\*(Dk\fP is the disk type, \fI#\fP is the unit number)
I 27
(ignore warning from ``sh'')
E 27
D 43
\fB#\fP \fImount -u /tmp/\*(Dk#a /\fP	(read-write mount root filesystem)
E 43
I 43
\fB#\fP \fImount \-uw /tmp/\*(Dk#a /\fP	(read-write mount root filesystem)
E 43
\fB#\fP \fIcd /dev\fP	(go to device directory)
\fB#\fP \fI./MAKEDEV \*(Dk#\fP	(create permanent special files for root disk)
I 27
(again, ignore warning from ``sh'')
E 27
.TE
.DE
D 41
.NH 4
Step 4: (optional) restoring the root filesystem
E 41
I 41
.Sh 4 "Step 4: (optional) restoring the root filesystem"
E 41
.PP
E 24
D 2
If the root file system is to reside on a disk other than
unit 0 (as the information printed out
during autoconfiguration shows), you will
have to create the necessary special files in /dev and use
the appropriate value. For example, if the root should be
placed on dk1, you must create /dev/rdk1a and /dev/dk1a using 
\fImknod\fP(8) or the MAKEDEV script in /dev.
E 2
I 2
D 10
To complete installation of the bootstrap system one step remains: the
root file system must be created.  If the root file system is to reside
on a disk other than unit 0, you will have to create the necessary special
files in /dev and use the appropriate value in the following example
procedures.
E 10
I 10
The root filesystem that you are currently running on is complete,
however it probably is not optimally laid out for the disk on
which you are running.
If you will be cloning copies of the system onto multiple disks for
other machines, you are advised to connect one of these disks to
this machine, and build and restore a properly laid out root filesystem
onto it.
If this is the only machine on which you will be running \*(4B
or peak performance is not an issue, you can skip this step and
proceed directly to step 5.
E 10
E 2
.PP
D 2
To create the root file system the shell script \*(lqxtr\*(rq
E 2
I 2
D 10
For example, if the root must be placed on dk1, you should
create /dev/rdk1a and /dev/dk1a using the MAKEDEV script in /dev
as follows:
.DS
\fB#\fP\|\fIcd /dev; MAKEDEV dk1\fP
.DE
E 10
I 10
Connect a second disk to your machine.
D 17
If you bootstraped using the two disk method, you can
E 17
I 17
If you bootstrapped using the two disk method, you can
E 17
D 27
overwrite your initial bootstrapping disk, as it will no longer
be needed.
E 27
I 27
overwrite your initial HP-UX disk, as it will no longer
be needed (assuming you have no plans to run HP-UX again).
E 27
E 10
.PP
D 10
To actually create the root file system the shell script \*(lqxtr\*(rq
E 2
should be run:
E 10
I 10
D 12
To actually create the root filesystem on drive 1 the shell script
\*(lqxtr\*(rq should be run:
E 12
I 12
D 28
To actually create the root filesystem on drive 1
E 28
I 28
To really create the root filesystem on drive 1
E 28
you should first label the disk as described in step 5 below.
Then run the following commands:
E 12
E 10
.DS
I 24
\fB#\fP \fIcd /dev\fP
\fB#\fP \fI./MAKEDEV \*(Dk1a\fP
E 24
D 2
\fB#\|\fPdisk=dk\fIx\fP tape=cy xtr
E 2
I 2
D 10
\fB#\fP\|\fIdisk=dk0 tape=cy xtr\fP
(Note, ``dk0'' specifies both the disk type and the unit number.  Modify
E 10
I 10
D 12
\fB#\fP\|\fIdisk=\*(Dk1 tape=\*(Mt0 xtr\fP
(Note, ``\*(Dk1'' specifies both the disk type and the unit number.  Modify
E 10
as necessary.)
E 12
I 12
\fB#\fP\|\fInewfs /dev/r\*(Dk1a\fP
\fB#\fP\|\fImount /dev/\*(Dk1a /mnt\fP
\fB#\fP\|\fIcd /mnt\fP
D 19
\fB#\fP\|\fIdump 0f \- /dev/r\(*Dk0a | restore xf \-\fP
E 19
I 19
\fB#\fP\|\fIdump 0f \- /dev/r\*(Dk0a | restore xf \-\fP
E 19
(Note: restore will ask if you want to ``set owner/mode for '.'''
to which you should reply ``yes''.)
E 12
E 2
.DE
I 2
.PP
E 2
D 21
This will generate many messages regarding the construction
D 12
of the file system and the restoration of the tape contents,
E 12
I 12
of the filesystem and the restoration of the tape contents,
E 12
D 2
but should eventually stop with the messages:
E 2
I 2
but should eventually stop with the message:
E 2
.DS
 ...
\fBRoot filesystem extracted\fP
\fB#\fP
.DE
D 10
.NH 3
Step 5: rebooting the completed root file system
E 10
.PP
D 10
With the above work completed, all that is left is to reboot:
.DS
.ta 3.5i
D 2
\fB#\|\fPsync	(synchronize file system state)
\fB#\|\fP~h	(halt cpu)
\fB#>\|\fPy	(initialize machine)
\fB#>\|\fPp23 2	(set boot flags)
\fB#>\|\fPfr boot
\fI\&...(boot program is eventually loaded)...\fP
E 2
I 2
\fB#\|\fP\fIsync\fP	(synchronize file system state)
\fB#\|\fP\fI~h\fP	(halt cpu)
\fB#>\|\fP\fIy.\fP	(initialize machine)
\fB#>\|\fP\fIp23 2.\fP	(set boot flags)
\fB#>\|\fP\fIfr boot\fP
\fB\&...(boot program is eventually loaded)...\fP
E 2
\fBBoot\fP
D 2
\fB:\fP dk(\fIx\fP,0)vmunix	(\fIvmunix\fP brought in off root)
\fB271944+78848+92812 start 0x12e8
\fB4.3 BSD UNIX #1: Wed Apr  9 23:33:59 PST 1985
\fB    karels@okeeffe.berkeley.edu:/usr/src/sys/GENERIC
\fBreal mem  = \fIxxx\fR
\fBavail mem = \fIyyy\fR
\fI\&... information about available devices ...\fP
\fBroot on xx0\fP
WARNING: preposterous time in file system \-\- CHECK AND RESET THE DATE!
\fBerase ^?, kill ^U, intr ^C\fP
\fB#\fP
E 2
I 2
\fB:\fP \fIdk(0,0)vmunix\fP	(\fIvmunix\fP from disk drive 0, partition 0)
(Modify unit number as necessary.)
.B
.nf
271944+78848+92812 start 0x12e8
4.3 BSD #1: Sat Jun  4 17:11:42 PDT 1988
        (karels@okeeffe.Berkeley.EDU:/usr/src/sys/GENERIC)
real mem  = ###
avail mem = ###
using ### buffers containing ### bytes of memory
(... information about available devices ...)
root on dk0
WARNING: preposterous time in file system -- CHECK AND RESET THE DATE!
erase ^?, kill ^U, intr ^C
#
.fi
E 2
.DE
I 2
.R
E 2
.PP
D 2
If the root device selected by the kernel is not correct,
it is necessary to reboot again using the option to ask for the root
device.  On the Tahoe use ``p23 3''.
At the prompt from the bootstrap, use the same device specification
above: dk(\fIx\fP,0)vmunix.
Then, to the question ``root device?,''
respond with dk0.
E 2
I 2
If the root device selected by the kernel is not correct, it is necessary
to reboot again using the option to ask for the root device.  On the Tahoe
use ``\fIp23 3.\fP''.  At the prompt from the bootstrap, use the same
disk driver unit specification as used above: ``\fIdk(0,0)vmunix\fP''.
Then, to the question ``root device?,'' respond with ``\fIdk0\fP''.
E 2
See section 6.1 and appendix C if the system does not reboot properly.
.PP
D 2
The system is now running single user on the installed
root file system.  The next section tells how to complete
the installation of distributed software on the /usr file system.
E 2
I 2
The system is now running single user on the installed root file system.
The next section tells how to complete the installation of distributed
software on the /usr file system.
E 10
I 10
You should then shut down the system, and boot on the disk that
E 21
I 21
When this completes,
you should then shut down the system, and boot on the disk that
E 21
you just created following the procedure in step (3) above.
E 10
E 2
D 11
.NH 3
E 11
I 11
D 41
.NH 4
E 11
D 10
Step 6: placing labels on the disks
E 10
I 10
Step 5: placing labels on the disks
E 41
I 41
.Sh 4 "Step 5: placing labels on the disks"
E 41
E 10
.PP
D 2
4.3BSD uses disk labels in the first sector of each disk to contain
E 2
I 2
D 24
\*(4B uses disk labels in the first sector of each disk to contain
E 2
information about the geometry of the drive and the partition layout.
E 24
I 24
For each disk on the HP300, \*(4B places information about the geometry
of the drive and the partition layout at byte offset 1024.
E 24
D 15
This information is written with \fIdisklabel\fP\|(8).
E 15
I 15
This information is written with
.Xr disklabel (8).
E 15
D 10
Note that recent CCI releases, and apparently Harris releases,
may use a different form of disk label, also in the first sector.
As the formats of these labels are incompatible,
skip this step if your machine is using disk labels already.
Recent firmware for the console processor (CP) may use these labels,
and thus the labels must be retained.
Eventually, it will be possible to use both formats simultaneously.
I 2
You may wish to experiment on a spare disk once the system is running.
E 10
E 2
.PP
D 24
For each disk that you wish to label, run the following command:
E 24
I 24
The root image just loaded includes a ``generic'' label intended to allow
D 32
easy installation of / and /usr and may not be suitable for the actual
E 32
I 32
easy installation of the root and
.Pn /usr
and may not be suitable for the actual
E 32
disk on which it was installed.
In particular,
D 28
it may make your disk appear larger or smaller than it actually is.
E 28
I 28
it may make your disk appear larger or smaller than its real size.
E 28
D 27
In the latter case, some of the partitions may include non-existent
space leading to errors if those partitions are used.
E 27
I 27
In the former case, you lose some capacity.
In the latter, some of the partitions may map non-existent sectors
leading to errors if those partitions are used.
E 27
It is also possible that the defined geometry will interact poorly with
the filesystem code resulting in reduced performance.
I 27
However, as long as you are willing to give up a little space,
D 28
not use certain partitions or suffer minor performance degredation,
E 28
I 28
not use certain partitions or suffer minor performance degradation,
E 28
you might want to avoid this step;
especially if you do not know how to use
.Xr ed (1).
E 27
.PP
D 27
At this time you can edit this label and fill in correct geometry
information from
.Pn /etc/disklabel .
E 27
I 27
If you choose to edit this label,
you can fill in correct geometry information from
.Pn /etc/disktab .
E 27
D 32
You may also want to rework the ``e'' and ``f'' partitions used for
loading /usr and /var.
E 32
I 32
You may also want to rework the ``e'' and ``f'' partitions used for loading
.Pn /usr
and
.Pn /var .
E 32
You should not attempt to, and
.Xr disklabel
will not let you, modify the ``a'', ``b'' and ``d'' partitions.
D 27
Since you must use
.Xr ed (1)
for this step, consider carefully whether you really want to do this.
E 27
To edit a label:
E 24
.DS
D 2
\fB#\|\fPdisklabel -w dk\fIx\fP \fItype\fP "\fIoptional_pack_name\fP"
E 2
I 2
D 10
\fB#\|\fP\fIdisklabel  -rw  dk\fP\fB#\fP  \fBtype\fP  \fI"optional_pack_name"\fP
E 10
I 10
D 19
\fB#\|\fP\fIdisklabel  -rw  \*(Dk\fP\fB#\fP  \fBtype\fP  \fI"optional_pack_name"\fP
E 19
I 19
D 24
\fB#\|\fP\fIdisklabel  -rw  \fBXX#  type\fP  \fI"optional_pack_name"\fP
E 24
I 24
\fB#\fP \fIEDITOR=ed\fP
D 27
\fB#\fP \fexport EDITOR\fP
\fB#\fP \fIdisklabel -r -e /dev/r\fBXX#\fPd
E 27
I 27
\fB#\fP \fIexport EDITOR\fP
\fB#\fP \fIdisklabel  -r  -e  /dev/r\fBXX#\fPd
E 27
E 24
E 19
E 10
E 2
.DE
D 2
The \fItype\fP is the CCI disk device name as listed in section 1.3,
or any other name listed in /etc/disktab.
E 2
I 2
D 10
The \fB#\fP is the unit number; the \fBtype\fP is the CCI disk device
name as listed in section 1.4 or any other name listed in /etc/disktab.
E 10
I 10
D 19
The \fB#\fP is the unit number; the \fBtype\fP is the HP300 disk device
D 12
name as listed in section 1.2 or any other name listed in /etc/disktab.
E 12
I 12
D 15
name as listed in section 2.2.1 or any other name listed in /etc/disktab.
E 15
I 15
name as listed in section 2.2.1 or any other name listed in
E 19
I 19
D 24
The \fBXX\fP is either ``sd'' for a SCSI disk or ``rd'' for an HP-IB disk;
the \fB#\fP is the unit number.
The \fBtype\fP is the HP300 disk device name as listed in
section 2.2.1 or any other name listed in
E 24
I 24
D 27
where \fBXX#\fP is the type and \fB#\fP is the logical drive number; e.g.
E 27
I 27
where \fBXX\fP is the type and \fB#\fP is the logical drive number; e.g.
E 27
.Pn /dev/rsd0d
or
.Pn /dev/rrd0d .
D 27
Note the use of the ``d'' partition.
This allows you to change the size of the ``c'' partition
(the partition normally used by
.Xr disklabel ).
E 27
I 27
Note the explicit use of the ``d'' partition.
This partition includes the bootblock as does ``c''
and using it allows you to change the size of ``c''.
E 27
.PP
D 28
If you wish to label any addtional disks, run the following command for each:
E 28
I 28
If you wish to label any additional disks, run the following command for each:
E 28
.DS
D 27
\fB#\|\fP\fIdisklabel -rw \fBXX# type\fP \fI"optional_pack_name"\fP
E 27
I 27
\fB#\|\fP\fIdisklabel  -rw  \fBXX#  type\fP  \fI"optional_pack_name"\fP
E 27
.DE
where \fBXX#\fP is the same as in the previous command
and \fBtype\fP is the HP300 disk device name as listed in
E 24
E 19
.Pn /etc/disktab .
E 15
E 12
E 10
E 2
The optional information may contain any descriptive name for the
D 2
contents of a disk, and may be up to 16 characters long.
This procedure will place the label on the disk using the information
found in /etc/disktab for the disk type named.
The default disk partitions in \*(4B are the mostly
the same as those in the CCI 1.21 release,
except for CDC 340Mb xfd drives;
see section 4.3.2 for details.
If you have changed the disk partition sizes,
you may add entries for the modified configuration in /etc/disktab
E 2
I 2
contents of a disk, and may be up to 16 characters long.  This procedure
D 15
will place the label on the disk using the information found in /etc/disktab
E 15
I 15
will place the label on the disk using the information found in
.Pn /etc/disktab
E 15
D 10
for the disk type named.  The default disk partitions in \*(4B are the mostly
the same as those in the CCI 1.21 release, except for CDC 340Mb xfd drives;
see section 4.2 for details.  If you have changed the disk partition sizes,
E 10
I 10
for the disk type named.
If you have changed the disk partition sizes,
E 10
D 15
you may wish to add entries for the modified configuration in /etc/disktab
E 15
I 15
you may wish to add entries for the modified configuration in
.Pn /etc/disktab
E 15
E 2
before labeling the affected disks.
I 2
.PP
D 10
Note that the partition sizes and sectors per track in /etc/disktab
are now specified in sectors, not units of kilobytes as in the vendors'
4.2BSD and System V systems.
D 7
For SMD disks, the sector size is 512 bytes, and is listed explicitly.
E 7
I 7
For most SMD disks, the sector size is 512 bytes, and is listed explicitly.
ESDI disks on a Power 6/32SX use a sector size of 1024 bytes.
E 7
E 2
.NH 3
Step 7: setting up the /usr file system
E 10
I 10
You have now completed the HP300 specific part of the installation.
D 27
You should now proceed to the generic part of the installation
E 27
I 27
Now proceed to the generic part of the installation
E 27
described starting in section 2.5 below.
I 19
Note that where the disk name ``sd'' is used throughout section 2.5,
you should substitute the name ``rd'' if you are running on an HP-IB disk.
I 25
Also, if you are loading on a single disk with the default disklabel,
D 32
/var should be restored to the ``f'' partition and
/usr to the ``e'' partition.
E 32
I 32
.Pn /var
should be restored to the ``f'' partition and
.Pn /usr
to the ``e'' partition.
I 45
.ne 1i
E 45
E 32
E 25
E 19
D 41
.NH 2
Booting the SPARC
I 11
.NH 3
Supported hardware
E 41
I 41
.Sh 2 "Booting the SPARC"
.Sh 3 "Supported hardware"
E 41
I 14
.LP
The hardware supported by \*(4B for the SPARC is as follows:
.TS
center box;
lw(1i) lw(4i).
D 16
CPUs    T{
E 16
I 16
D 19
CPUs	T{
E 19
I 19
CPU's	T{
E 19
E 16
SPARCstation 1 series (1, 1+, SLC, IPC) and
SPARCstation 2 series (2, IPX).
T}
_
D 19
DISKs	T{
E 19
I 19
DISK's	T{
E 19
SCSI.
T}
_
D 19
TAPEs	T{
E 19
I 19
TAPE's	T{
E 19
none.
T}
_
NETWORK	T{
SPARCstation Lance (le).
T}
_
GRAPHICS	T{
D 47
bwtwo and cgthree.
E 47
I 47
bwtwo, cgthree, and the GX (cgsix).
E 47
T}
_
INPUT	T{
Keyboard and mouse.
T}
_
MISC	T{
Battery-backed real time clock,
built-in serial devices,
Sbus SCSI controller,
and audio device.
T}
.TE
.LP
D 19
Major items not supported include the GX (cgnine) display,
E 19
I 19
D 24
Major items which are not supported include the GX (cgnine) display,
E 24
I 24
D 28
Major items which are not supported include
E 28
I 28
Major items that are not supported include
E 28
anything VME-based,
D 47
the GX (cgsix) display,
E 47
E 24
E 19
the floppy disk, and SCSI tapes.
E 14
D 41
.NH 3
Limitations
E 41
I 41
.Sh 3 "Limitations"
E 41
.LP
There are several important limitations on the \*(4B distribution
for the SPARC:
.IP 1)
D 28
You MUST have SunOS 4.1.x or Solaris in order to bring up \*(4B.
E 28
I 28
D 29
You MUST have SunOS 4.1.x or Solaris to bring up \*(4B.
E 29
I 29
You
.B must
have SunOS 4.1.x or Solaris to bring up \*(4B.
E 29
E 28
There is no SPARCstation bootstrap code in this distribution.  The
Sun-supplied boot loader will be used to boot \*(4B; you must copy
D 28
this from your SunOS distribution.  This imposes a number of
E 28
I 28
this from your SunOS distribution.  This imposes several
E 28
restrictions on the system, as detailed below.
.IP 2)
The \*(4B SPARC kernel does not remap SCSI IDs.  A SCSI disk at
target 0 will become ``sd0'', where in SunOS the same disk will
normally be called ``sd3''.  If your existing SunOS system is
diskful, it will be least painful to have SunOS running on the disk
D 47
on target 0 lun 0 and put \*(4B on the disk on target 3 lun 0.  Both
E 47
I 47
on target 3 lun 0 and put \*(4B on the disk on target 0 lun 0.  Both
E 47
systems will then think they are running on ``sd0'', and you can
boot either system as needed simply by changing the EEPROM's boot
device.
.IP 3)
There is no SCSI tape driver.
You must have another system for tape reading and backups.
.IP 4)
Although the \*(4B SPARC kernel will handle existing SunOS shared
libraries, it does not use or create them itself, and therefore
D 28
requires quite a bit more disk space than SunOS does.
E 28
I 28
requires much more disk space than SunOS does.
E 28
.IP 5)
It is currently difficult (though not completely impossible) to
run \*(4B diskless.  These instructions assume you will have a local
D 12
boot, swap, and root file system.
E 12
I 12
boot, swap, and root filesystem.
I 36
.IP 6)
D 38
Only port ttya can be used as the system console.
Attempts to use port ttyb will fail when the kernel tries
E 38
I 38
When using a serial port rather than a graphics display as the console,
only port
.Pn ttya
can be used.
Attempts to use port
.Pn ttyb
will fail when the kernel tries
E 38
to print the boot up messages to the console.
E 36
I 26
D 32
.IP 6)
Although serial consoles are supposed to be supported,
last-minute testing showed otherwise.
You will therefore need a keyboard, frame buffer, and video display,
at least to get started.
E 32
E 26
E 12
D 41
.NH 3
The Procedure
E 41
I 41
.Sh 3 "The procedure"
E 41
E 11
E 10
.PP
I 10
D 11
Chris promises to fill us in here!!!
E 11
I 11
You must have a spare disk on which to place \*(4B.
The steps involved in bootstrapping this tape are as follows:
.IP 1)
D 15
Bring up SunOS (preferably SunOS 4.1.x / Solaris 1.x, although
E 15
I 15
Bring up SunOS (preferably SunOS 4.1.x or Solaris 1.x, although
E 15
D 12
Solaris 2 may work -- this is untested).
E 12
I 12
Solaris 2 may work \(em this is untested).
E 12
.IP 2)
Attach auxiliary SCSI disk(s).  Format and label using the
D 19
SunOS formating and labeling programs as needed.
E 19
I 19
SunOS formatting and labeling programs as needed.
E 19
D 12
Note that the root file system currently requires at least 10 MB; 16 MB
E 12
I 12
Note that the root filesystem currently requires at least 10 MB; 16 MB
E 12
or more is recommended.  The b partition will be used for swap;
this should be at least 32 MB.
.IP 3)
D 12
Use the SunOS ``newfs'' to build the root file system.  You may also
want to build other file systems at the same time.  (By default, the
\*(4B newfs builds a file system that SunOS will not handle; if you
E 12
I 12
D 27
Use the SunOS ``newfs'' to build the root filesystem.  You may also
E 27
I 27
Use the SunOS
.Xr newfs
to build the root filesystem.  You may also
E 27
want to build other filesystems at the same time.  (By default, the
D 27
\*(4B newfs builds a filesystem that SunOS will not handle; if you
E 27
I 27
\*(4B
D 32
.Xr newfs builds a filesystem that SunOS will not handle; if you
E 32
I 32
.Xr newfs
builds a filesystem that SunOS will not handle; if you
E 32
E 27
E 12
plan to switch OSes back and forth you may want to sacrifice the
D 12
performance gain from the new file system format for compatibility.)
You can build an old-format filesystem on \*(4B by giving the -O
E 12
I 12
performance gain from the new filesystem format for compatibility.)
You can build an old-format filesystem on \*(4B by giving the \-O
E 12
D 15
option to \fInewfs\fP\|(8).
\fIFsck\fP\|(8) can convert old format filesystems to new format
E 15
I 15
option to
.Xr newfs (8).
.Xr Fsck (8)
can convert old format filesystems to new format
E 15
filesystems, but not vice versa,
so you may want to initially build old format filesystems so that they
can be mounted under SunOS,
and then later convert them to new format filesystems when you are
satisfied that \*(4B is running properly.
D 27
In any case, YOU MUST BUILD AN OLD-STYLE ROOT FILE SYSTEM
E 27
I 27
In any case,
.B
you must build an old-style root filesystem
.R
E 27
so that the SunOS boot program will work.
.IP 4)
D 15
Mount the new root, then copy the SunOS /boot into place and use the
SunOS ``installboot'' program to enable disk-based booting:
E 15
I 15
Mount the new root, then copy the SunOS
.Pn /boot
into place and use the SunOS ``installboot'' program
D 36
to enable disk-based booting:
E 36
I 36
to enable disk-based booting.
Note that the filesystem must be mounted when you do the ``installboot'':
E 36
E 15
.DS
I 17
.ft CW
E 17
# mount /dev/sd3a /mnt
# cp /boot /mnt/boot
D 36
# umount /dev/sd3a
D 24
# /usr/kvm/mdec/installboot installboot bootsd /dev/rsd3a
E 24
I 24
# /usr/kvm/mdec/installboot /mnt/boot bootsd /dev/rsd3a
E 36
I 36
# cd /usr/kvm/mdec
# installboot /mnt/boot bootsd /dev/rsd3a
E 36
E 24
.DE
D 12
.LP
E 12
D 15
The SunOS /boot will load \*(4B kernels; there is no SPARCstation
bootstrap code on the distribution.  Note that the SunOS /boot does
D 12
not handle the new \*(4B file sytem format.
E 12
I 12
not handle the new \*(4B filesystem format.
E 15
I 15
The SunOS
.Pn /boot
will load \*(4B kernels; there is no SPARCstation
bootstrap code on the distribution.  Note that the SunOS
.Pn /boot
does not handle the new \*(4B filesystem format.
E 15
E 12
.IP 5)
D 15
Mount the new root and restore /.
E 15
I 15
D 32
Mount the new root and restore the root.
E 32
I 32
D 36
Mount the new root and restore its contents.
E 36
I 36
Restore the contents of the \*(4B root filesystem.
E 36
E 32
E 15
.DS
I 17
.ft CW
E 17
D 36
# mount /dev/sd3a /mnt
E 36
# cd /mnt
# rrestore xf tapehost:/dev/nrst0
.DE
D 12
.LP
E 12
D 15
If you have chosen to use the SunOS newfs to build /usr, you may
mount and restore it now and skip the next step.
E 15
I 15
D 36
If you have chosen to use the SunOS newfs to build
.Pn /usr ,
you may mount and restore it now and skip the next step.
E 36
E 15
.IP 6)
D 15
Boot the supplied kernel.  Configure the network, build /usr, mount it,
and restore it:
E 15
I 15
D 27
Boot the supplied kernel.  Configure the network, build
.Pn /usr ,
mount it, and restore it:
E 27
I 27
Boot the supplied kernel:
E 27
E 15
.DS
I 17
.ft CW
E 17
# halt
D 24
ok boot disk3 -s			[for old proms] OR
ok boot sd(0,3)vmunix -s		[for new proms]
E 24
I 24
ok boot sd(0,3)vmunix -s		[for old proms] OR
ok boot disk3 -s			[for new proms]
E 24
\&... [\*(4B boot messages]
D 27
# ifconfig le0 [your address, subnet, etc, as needed]
# newfs /dev/rsd0g
\&... [newfs output, including a warning about being unable to
D 12
     update the label -- ignore this]
E 12
I 12
     update the label \(em ignore this]
E 12
# mount /dev/sd0g /usr
# cd /usr
# rrestore xf tapehost:/dev/nrst0
E 27
.DE
D 27
.IP 7)
At this point you may wish to set up \*(4B to reboot automatically:
E 27
I 27
.LP
To install the remaining filesystems, use the procedure described
starting in section 2.5.
D 28
In these instructions, /usr should be loaded into the ``e'' parition
E 28
I 28
D 32
In these instructions, /usr should be loaded into the ``e'' partition
E 28
and /var in the ``f'' partition.
E 32
I 32
In these instructions,
.Pn /usr
should be loaded into the ``e'' partition and
.Pn /var
in the ``f'' partition.
E 32
.LP
After completing the filesystem installation you may want
to set up \*(4B to reboot automatically:
E 27
.DS
I 17
.ft CW
E 17
# halt
ok setenv boot-from sd(0,3)vmunix	[for old proms] OR
ok setenv boot-device disk3		[for new proms]
.DE
D 12
.LP
If you build backwards-compatible file systems, either with the SunOS
newfs or with the \*(4B ``-O'' option, you can mount these under
SunOS.  The SunOS fsck will, however, always think that these file
systems are corrupted, as there are several new (previously unused)
superblock fields that are updated in \*(4B.  Running ``fsck -b32''
E 12
I 12
If you build backwards-compatible filesystems, either with the SunOS
newfs or with the \*(4B ``\-O'' option, you can mount these under
SunOS.  The SunOS fsck will, however, always think that these filesystems
are corrupted, as there are several new (previously unused)
superblock fields that are updated in \*(4B.  Running ``fsck \-b32''
E 12
and letting it ``fix'' the superblock will take care of this.
D 12
.PP
E 12
I 12
.sp 0.5
E 12
If you wish to run SunOS binaries that use SunOS shared libraries, you
D 28
simply need to copy all of the dynamic linker files from an existing
E 28
I 28
simply need to copy all the dynamic linker files from an existing
E 28
SunOS system:
.DS
I 17
.ft CW
E 17
# rcp sunos-host:/etc/ld.so.cache /etc/
# rcp sunos-host:'/usr/lib/*.so*' /usr/lib/
.DE
D 12
.LP
E 12
The SunOS compiler and linker should be able to produce SunOS binaries
under \*(4B, but this has not been tested.  If you plan to try it you
will need the appropriate .sa files as well.
I 45
.ne 1i
E 45
E 11
D 41
.NH 2
D 17
Booting the DecStation
E 17
I 17
Booting the DECstation
E 17
I 11
.NH 3
Supported hardware
E 41
I 41
.Sh 2 "Booting the DECstation"
.Sh 3 "Supported hardware"
E 41
I 17
.LP
The hardware supported by \*(4B for the DECstation is as follows:
.TS
center box;
lw(1i) lw(4i).
D 19
CPUs	T{
E 19
I 19
CPU's	T{
E 19
R2000 based (3100) and
R3000 based (5000/200, 5000/20, 5000/25, 5000/1xx).
T}
_
D 19
DISKs	T{
E 19
I 19
DISK's	T{
E 19
SCSI-I (tested RZ23, RZ55, RZ57, Maxtor 8760S).
T}
_
D 19
TAPEs	T{
E 19
I 19
TAPE's	T{
E 19
SCSI-I (tested DEC TK50, Archive DAT, Emulex MT02).
T}
_
RS232	T{
Internal DEC dc7085 and AMD 8530 based interfaces.
T}
_
NETWORK	T{
TURBOchannel PMAD-AA and internal LANCE based interfaces.
T}
_
GRAPHICS	T{
Terminal emulation and raw frame buffer support for
3100 (color & monochrome),
TURBOchannel PMAG-AA, PMAG-BA, PMAG-DV.
T}
_
INPUT	T{
Standard DEC keyboard (LK201) and mouse.
T}
_
MISC	T{
Battery-backed real time clock,
internal and TURBOchannel PMAZ-AA SCSI interfaces.
T}
.TE
.LP
D 19
Major items not supported include the 5000/240 (there is code but not
compiled in or tested),
E 19
I 19
D 28
Major items which are not supported include the 5000/240
E 28
I 28
Major items that are not supported include the 5000/240
E 28
(there is code but not compiled in or tested),
E 19
R4000 based machines, FDDI and audio interfaces.
Diskless machines are not supported but booting kernels and bootstrapping
over the network is supported on the 5000 series.
E 17
D 41
.NH 3
The Procedure
E 41
I 41
.Sh 3 "The procedure"
E 41
E 11
.PP
D 17
Steps to bootstrap a system.
.IP 1)
D 12
Load kernel and mini-root into memory with one of the PROM commands.
E 12
I 12
Load kernel and root filesystem into memory with one of the PROM commands.
E 12
This is the only step that depends on what type of machine you are using.
The 'cnfg' PROM command will display what devices are available
(DEC 5000 only).
D 12
The 'm' argument tells the kernel to look for a mini-root in memory.
E 12
I 12
The 'm' argument tells the kernel to look for a root filesystem in memory.
E 17
I 17
D 28
The first file on the distribution tape is a tar file which contains
E 28
I 28
The first file on the distribution tape is a tar file that contains
E 28
four files.
The first step requires a running UNIX (or ULTRIX) system that can
be used to extract the tar archive from the first file on the tape.
The command:
E 17
E 12
.DS
D 17
DEC 3100:	boot -f tz(0,5,0) m	# 5 is the SCSI id of the TK50
DEC 5000:	boot 5/tz6 m		# 6 is the SCSI id of the TK50
DEC 5000:	boot 6/tftp/bootfile m	# requires bootp on host
E 17
I 17
.ft CW
tar xf /dev/rmt0
E 17
.DE
D 17
.IP 2)
Format the disk if needed. Most SCSI disks are already formatted.
E 17
I 17
will extract the following four files:
E 17
.DS
D 17
format
E 17
I 17
A) root.image: \fIdd\fP image of the root filesystem
B) vmunix.tape: \fIdd\fP image for creating boot tapes
C) vmunix.net: file for booting over the network
D 27
D) root.dump: dump image of the root filesystem
E 27
I 27
D) root.dump: \fIdump\fP image of the root filesystem
E 27
E 17
.DE
D 17
.IP 3)
D 12
Label disks and create file systems.
E 12
I 12
Label disks and create filesystems.
E 17
I 17
There are three basic ways a system can be bootstrapped corresponding to the
first three files.
You may want to read the section on bootstrapping the HP300
since many of the steps are similar.
A spare, formatted SCSI disk is also useful.
D 41
.NH 4
Procedure A: copy root filesystem to disk
E 41
I 41
.Sh 4 "Procedure A: copy root filesystem to disk"
E 41
.PP
This procedure is similar to the HP300.
If you have an extra disk, the easiest approach is to use \fIdd\fP\|(1)
under ULTRIX to copy the root filesystem image to the beginning
of the spare disk. 
The root filesystem image includes a disklabel and bootblock along with the
root filesystem.
An example command to copy the image to the beginning of a disk is:
E 17
E 12
.DS
I 17
.ft CW
D 27
dd if=root.image of=/dev/rz1c bs=20b
E 27
I 27
D 40
dd if=root.image of=/dev/rz1c bs=40b
E 40
I 40
dd if=root.image of=/dev/rz1c bs=\*(Bzb
E 40
E 27
.DE
The actual special file syntax will vary depending on unit numbers and
the version of ULTRIX that is running.
D 18
This system is now ready to boot.
E 18
I 18
This system is now ready to boot. You can boot the kernel with one of the
following PROM commands. If you are booting on a 3100, the disk must be SCSI
D 28
id zero due to a bug.
E 28
I 28
id zero because of a bug.
E 28
.DS
.ft CW
DEC 3100:    boot \-f rz(0,0,0)vmunix
DEC 5000:    boot 5/rz0/vmunix
.DE
E 18
D 23
You will probably want to change the disk label
to create reasonable partitions for your machine (see section 4.2).
You can then proceed to section 2.5 to install the rest of the system.
E 23
I 23
You can then proceed to section 2.5
to create reasonable disk partitions for your machine
and then install the rest of the system.
E 23
D 41
.NH 4
Procedure B: bootstrap from tape
E 41
I 41
.Sh 4 "Procedure B: bootstrap from tape"
E 41
.PP
If you have only a single machine with a single disk,
you need to use the more difficult approach of booting a
kernel and mini-root from tape or the network, and using it to restore
the root filesystem.
.PP
First, you will need to create a boot tape. This can be done using
\fIdd\fP as in the following example.
.DS
.ft CW
dd if=vmunix.tape of=/dev/nrmt0 bs=1b
D 40
dd if=root.dump of=/dev/nrmt0 bs=20b
E 40
I 40
dd if=root.dump of=/dev/nrmt0 bs=\*(Bzb
E 40
.DE
The actual special file syntax for the tape drive will vary depending on
unit numbers, tape device and the version of ULTRIX that is running.
.PP
The first file on the boot tape contains a boot header, kernel, and
D 27
mini-root file system that the PROM can copy into memory.
E 27
I 27
mini-root filesystem that the PROM can copy into memory.
E 27
Installing from tape has only been tested
on a 3100 and a 5000/200 using a TK50 tape drive. Here are two example
PROM commands to boot from tape.
.DS
.ft CW
DEC 3100:    boot \-f tz(0,5,0) m    # 5 is the SCSI id of the TK50
DEC 5000:    boot 5/tz6 m           # 6 is the SCSI id of the TK50
.DE
The `m' argument tells the kernel to look for a root filesystem in memory.
Next you should proceed to section 2.4.3 to build a disk-based root filesystem.
D 41
.NH 4
Procedure C: bootstrap over the network
E 41
I 41
.Sh 4 "Procedure C: bootstrap over the network"
E 41
.PP
You will need a host machine that is running the \fIbootp\fP server 
D 32
with the vmunix.net file installed in the default directory defined by the
configuration file for \fIbootp\fP.
E 32
I 32
with the
.Pn vmunix.net
file installed in the default directory defined by the
configuration file for
.Xr bootp .
E 32
Here are two example PROM commands to boot across the net:
.DS
.ft CW
DEC 3100:	boot \-f tftp()vmunix.net m
DEC 5000:	boot 6/tftp/vmunix.net m
.DE
This command should load the kernel and mini-root into memory and
run the same as the tape install (procedure B).
D 20
The rest of the steps are the same except you will need to
execute the following to start the networking:
E 20
I 20
The rest of the steps are the same except
you will need to start the network
(if you are unsure how to fill in the <name> fields below,
see sections 4.4 and 5).
Execute the following to start the networking:
E 20
.DS
.ft CW
D 43
# mount -u /
E 43
I 43
# mount \-uw /
E 43
# echo 127.0.0.1 localhost >> /etc/hosts
# echo <your.host.inet.number> myname.my.domain myname >> /etc/hosts
# echo <friend.host.inet.number> myfriend.my.domain myfriend >> /etc/hosts
# ifconfig le0 inet myname
.DE
Next you should proceed to section 2.4.3 to build a disk-based root filesystem.
D 41
.NH 3
Label disk and create the root filesystem.
E 41
I 41
.Sh 3 "Label disk and create the root filesystem"
E 41
.LP
There are five steps to create a disk-based root filesystem.
.IP 1)
Label the disk.
.DS
.ft CW
E 17
# disklabel -W /dev/rrz?c		# This enables writing the label
# disklabel -w -r -B /dev/rrz?c $DISKTYPE
# newfs /dev/rrz?a
D 12
# newfs /dev/rrz?g
E 12
\&...
# fsck /dev/rrz?a
D 12
# fsck /dev/rrz?g
E 12
\&...
.DE
D 15
Supported disk types are listed in /etc/disktab.
E 15
I 15
Supported disk types are listed in
.Pn /etc/disktab .
I 45
.ne 1i
E 45
E 15
D 17
Feel free to add to this list.
.IP 4)
E 17
I 17
D 18
.IP 3)
E 18
I 18
.IP 2)
E 18
E 17
D 12
Restore / and /usr partitions.
E 12
I 12
Restore the root filesystem.
E 12
.DS
I 17
.ft CW
E 17
D 12
# mount -u /
E 12
I 12
D 43
# mount \-u /
E 43
I 43
# mount \-uw /
E 43
E 12
# mount /dev/rz?a /a
D 12
# mount /dev/rz?g /b
E 12
# cd /a
I 17
.DE
.ti +0.4i
If you are restoring locally (procedure B), run:
.DS
.ft CW
E 17
D 12
# mt -f /dev/nrmt0 rew
# restore -xsf 2 /dev/rmt0
# cd /b
# {change tapes or tape drive}
# restore -xf /dev/rmt0
E 12
I 12
# mt \-f /dev/nrmt0 rew
# restore \-xsf 2 /dev/rmt0
I 17
.DE
.ti +0.4i
If you are restoring across the net (procedure c), run:
.DS
.ft CW
# rrestore xf myfriend:/path/to/root.dump
.DE
.ti +0.4i
When the restore finishes, clean up with:
.DS
.ft CW
E 17
E 12
# cd /
# sync
# umount /a
D 12
# umount /b
# fsck /dev/rz?a /dev/rz?g
E 12
I 12
# fsck /dev/rz?a
E 12
.DE
D 17
.IP 5)
Initialize the PROM monitor to boot automatically.
E 17
I 17
D 18
.IP 4)
E 18
I 18
.IP 3)
E 18
Reset the system and initialize the PROM monitor to boot automatically.
E 17
.DS
D 12
# halt -q
E 12
I 12
D 17
# halt \-q
E 12

DEC 3100:	setenv bootpath boot -f rz(0,?,0)vmunix
E 17
I 17
.ft CW
DEC 3100:	setenv bootpath boot \-f rz(0,?,0)vmunix
E 17
DEC 5000:	setenv bootpath 5/rz?/vmunix -a
.DE
D 17
.IP 6)
E 17
I 17
D 18
.IP 5)
E 18
I 18
.IP 4)
E 18
E 17
D 15
After booting UNIX, you will need to create /dev/mouse in order to
run X windows. type `link /dev/xx /dev/mouse' where xx is one of the
E 15
I 15
After booting UNIX, you will need to create
.Pn /dev/mouse
D 17
to run X windows.
Type `link /dev/xx /dev/mouse' where xx is one of the
E 15
following:
E 17
I 17
to run X windows as in the following example.
E 17
.DS
I 17
.ft CW
rm /dev/mouse
ln /dev/xx /dev/mouse
.DE
The 'xx' should be one of the following:
.DS
E 17
pm0	raw interface to PMAX graphics devices
D 29
cfb0	raw interface to turbochannel PMAG-BA color frame buffer
E 29
I 29
cfb0	raw interface to TURBOchannel PMAG-BA color frame buffer
E 29
xcfb0	raw interface to maxine graphics devices
mfb0	raw interface to mono graphics devices
.DE
I 17
You can then proceed to section 2.5 to install the rest of the system.
I 19
Note that where the disk name ``sd'' is used throughout section 2.5,
you should substitute the name ``rz''.
E 19
E 17
D 41
.NH 2
D 23
Installing the rest of the system
E 23
I 23
Disk configuration
E 41
I 41
.Sh 2 "Disk configuration"
E 41
E 23
.PP
E 10
D 12
The next thing to do is to extract the rest of the data from
the tape.
E 12
I 12
D 16
All architectures now have a root filesystem up and running and now
E 16
I 16
All architectures now have a root filesystem up and running and
E 16
D 23
proceed from this point to extract the rest of the data from the tape.
E 23
I 23
proceed from this point to layout filesystems to make use
of the available space and to balance disk load for better system
performance.
D 41
.NH 3
Disk naming and divisions
E 41
I 41
.Sh 3 "Disk naming and divisions"
E 41
.PP
Each physical disk drive can be divided into up to 8 partitions;
UNIX typically uses only 3 or 4 partitions.
For instance, the first partition, \*(Dk0a,
is used for a root filesystem, a backup thereof,
or a small filesystem like,
D 32
.Pn /tmp ;
E 32
I 32
.Pn /var/tmp ;
E 32
the second partition, \*(Dk0b,
is used for paging and swapping; and
D 27
the third partition, \*(Dk0\*(Pa,
E 27
I 27
D 32
a third partition, typically \*(Dk0g,
E 32
I 32
a third partition, typically \*(Dk0e,
E 32
E 27
holds a user filesystem.
.PP
The space available on a disk varies per device.
Each disk typically has a paging area of 30 to 100 megabytes
and a root filesystem of about 17 megabytes.
.\" XXX check
D 32
The distributed system binaries occupy about 150 (175 with X11R5) megabytes
E 32
I 32
The distributed system binaries occupy about 150 (180 with X11R5) megabytes
E 32
.\" XXX check
D 32
while the major sources occupy another 250 (310 with X11R5) megabytes.
E 32
I 32
while the major sources occupy another 250 (340 with X11R5) megabytes.
I 39
The
.Pn /var
filesystem as delivered on the tape is only 2Mb,
however it should have at least 50Mb allocated to it just for
normal system activity.
Usually it is allocated the last partition on the disk
so that it can provide as much space as possible to the
.Pn /var/users
filesystem.
See section 2.5.4 for further details on disk layouts.
E 39
E 32
.PP
Be aware that the disks have their sizes
measured in disk sectors (usually 512 bytes), while the UNIX filesystem
blocks are variable sized.
If
.Sm BLOCKSIZE=1k
is set in the user's environment, all user programs report
disk space in kilobytes, otherwise,
disk sizes are always reported in units of 512-byte sectors\**.
.FS
D 29
You can thank System V intransigency and POSIX duplicity for
E 29
I 29
You can thank System V intransigence and POSIX duplicity for
E 29
requiring that 512-byte blocks be the units that programs report.
.FE
The
.Pn /etc/disktab
file used in labelling disks and making filesystems
specifies disk partition sizes in sectors.
D 41
.NH 3
Layout considerations
E 41
I 41
.Sh 3 "Layout considerations"
E 41
.PP
There are several considerations in deciding how
to adjust the arrangement of things on your disks.
The most important is making sure that there is adequate space
for what is required; secondarily, throughput should be maximized.
Paging space is an important parameter.
The system, as distributed, sizes the configured
paging areas each time the system is booted.  Further,
D 32
multiple paging areas of different size may be interleaved.
E 32
I 32
multiple paging areas of different sizes may be interleaved.
E 32
.PP
Many common system programs (C, the editor, the assembler etc.)
create intermediate files in the
.Pn /tmp
directory, so the filesystem where this is stored also should be made
large enough to accommodate most high-water marks.
Typically,
.Pn /tmp
is constructed from a memory-based filesystem (see
.Xr mount_mfs (8)).
Programs that want their temporary files to persist
across system reboots (such as editors) should use
.Pn /var/tmp .
If you plan to use a disk-based
.Pn /tmp
filesystem to avoid loss across system reboots, it makes
sense to mount this in a ``root'' (i.e. first partition)
filesystem on another disk.
All the programs that create files in
.Pn /tmp
take care to delete them, but are not immune to rare events
and can leave dregs.
The directory should be examined every so often and the old
files deleted.
.PP
The efficiency with which UNIX is able to use the CPU
is often strongly affected by the configuration of disk controllers;
it is critical for good performance to balance disk load.
There are at least five components of the disk load that you can
divide between the available disks:
.IP 1)
The root filesystem.
.IP 2)
The
D 43
.Pn /tmp
E 43
I 43
.Pn /var
E 43
and
.Pn /var/tmp
filesystems.
.IP 3)
The
.Pn /usr
filesystem.
.IP 4)
The user filesystems.
.IP 5)
The paging activity.
.LP
The following possibilities are ones we have used at times
when we had 2, 3 and 4 disks:
.TS
center doublebox;
l | c s s
l | lw(5) | lw(5) | lw(5).
	disks
what	2	3	4
_
root	0	0	0
D 43
tmp	1	2	3
E 43
I 43
var	1	2	3
E 43
usr	1	1	1
paging	0+1	0+2	0+2+3
users	0	0+2	0+2
archive	x	x	3
.TE
.PP
The most important things to consider are to
even out the disk load as much as possible, and to do this by
decoupling filesystems (on separate arms) between which heavy copying occurs.
Note that a long term average balanced load is not important; it is
much more important to have an instantaneously balanced
load when the system is busy.
.PP
Intelligent experimentation with a few filesystem arrangements can
pay off in much improved performance.  It is particularly easy to
move the root, the
D 43
.Pn /tmp
E 43
I 43
.Pn /var
E 43
and
.Pn /var/tmp
filesystems and the paging areas.  Place the
user files and the
.Pn /usr
directory as space needs dictate and experiment
with the other, more easily moved filesystems.
D 41
.NH 3
Filesystem parameters
E 41
I 41
.Sh 3 "Filesystem parameters"
E 41
.PP
Each filesystem is parameterized according to its block size,
fragment size, and the disk geometry characteristics of the
medium on which it resides.  Inaccurate specification of the disk
characteristics or haphazard choice of the filesystem parameters
can result in substantial throughput degradation or significant
waste of disk space.  As distributed,
filesystems are configured according to the following table.
.DS
.TS
center;
l l l.
Filesystem	Block size	Fragment size
_
root	8 kbytes	1 kbytes
usr	8 kbytes	1 kbytes
users	4 kbytes	512 bytes
.TE
.DE
.PP
The root filesystem block size is
made large to optimize bandwidth to the associated disk.
The large block size is important as many of the most
heavily used programs are demand paged out of the
.Pn /bin
directory.
The fragment size of 1 kbyte is a ``nominal'' value to use
with a filesystem.  With a 1 kbyte fragment size
disk space utilization is about the same
as with the earlier versions of the filesystem.
.PP
The filesystems for users have a 4 kbyte block
size with 512 byte fragment size.  These parameters
have been selected based on observations of the
performance of our user filesystems.  The 4 kbyte
block size provides adequate bandwidth while the
512 byte fragment size provides acceptable space compaction
and disk fragmentation.
.PP
Other parameters may be chosen in constructing filesystems,
but the factors involved in choosing a block
size and fragment size are many and interact in complex
ways.  Larger block sizes result in better
throughput to large files in the filesystem as
D 28
larger I/O requests will then be performed by the
E 28
I 28
larger I/O requests will then be done by the
E 28
system.  However,
consideration must be given to the average file sizes
found in the filesystem and the performance of the
internal system buffer cache.   The system
currently provides space in the inode for
12 direct block pointers, 1 single indirect block
pointer, 1 double indirect block pointer,
D 27
and 1 double indirect block pointer.
E 27
I 27
and 1 triple indirect block pointer.
E 27
If a file uses only direct blocks, access time to
it will be optimized by maximizing the block size.
If a file spills over into an indirect block,
increasing the block size of the filesystem may
decrease the amount of space used
by eliminating the need to allocate an indirect block.
However, if the block size is increased and an indirect
block is still required, then more disk space will be
used by the file because indirect blocks are allocated
according to the block size of the filesystem.
.PP
In selecting a fragment size for a filesystem, at least
two considerations should be given.  The major performance
tradeoffs observed are between an 8 kbyte block filesystem
and a 4 kbyte block filesystem.  Because of implementation
constraints, the block size versus fragment size ratio can not
be greater than 8.  This means that an 8 kbyte filesystem
will always have a fragment size of at least 1 kbytes.  If
a filesystem is created with a 4 kbyte block size and a
1 kbyte fragment size, then upgraded to an 8 kbyte block size
and 1 kbyte fragment size, identical space compaction will be
observed.  However, if a filesystem has a 4 kbyte block size
and 512 byte fragment size, converting it to an 8K/1K
filesystem will result in 4-8% more space being
used.  This implies that 4 kbyte block filesystems that
might be upgraded to 8 kbyte blocks for higher performance should
use fragment sizes of at least 1 kbytes to minimize the amount
of work required in conversion.
.PP
A second, more important, consideration when selecting the
fragment size for a filesystem is the level of fragmentation
on the disk.  With an 8:1 fragment to block ratio, storage fragmentation
occurs much sooner, particularly with a busy filesystem running
near full capacity.  By comparison, the level of fragmentation in a
4:1 fragment to block ratio filesystem is one tenth as severe.  This
means that on filesystems where many files are created and
deleted, the 512 byte fragment size is more likely to result in apparent
space exhaustion because of fragmentation.  That is, when the filesystem
is nearly full, file expansion that requires locating a
contiguous area of disk space is more likely to fail on a 512
byte filesystem than on a 1 kbyte filesystem.  To minimize
fragmentation problems of this sort, a parameter in the super
block specifies a minimum acceptable free space threshold.  When
normal users (i.e. anyone but the super-user) attempt to allocate
disk space and the free space threshold is exceeded, the user is
returned an error as if the filesystem were really full.  This
parameter is nominally set to 5%; it may be changed by supplying
a parameter to
.Xr newfs (8),
or by updating the super block of an existing filesystem using
.Xr tunefs (8).
.PP
D 27
In general, unless a filesystem is to be used
E 27
I 27
Finally, a third, less common consideration is the attributes of
the disk itself.  The fragment size should not be smaller than the
physical sector size of the disk.  As an example, the HP magneto-optical
disks have 1024 byte physical sectors.  Using a 512 byte fragment size
on such disks will work but is extremely inefficient.
.PP
Note that the above discussion considers block sizes of up to only 8k.
As of the 4.4 release, the maximum block size has been increased to 64k.
This allows an entirely new set of block/fragment combinations for which
there is little experience to date.
In general though, unless a filesystem is to be used
E 27
for a special purpose application (for example, storing
image processing data), we recommend using the
values supplied above.
Remember that the current
implementation limits the block size to at most 64 kbytes
and the ratio of block size versus fragment size must be 1, 2, 4, or 8.
.PP
The disk geometry information used by the filesystem
affects the block layout policies employed.  The file
.Pn /etc/disktab ,
as supplied, contains the data for most
all drives supported by the system.  Before constructing
a filesystem with
.Xr newfs (8)
you should label the disk (if it has not yet been labeled,
and the driver supports labels).
If labels cannot be used, you must instead
specify the type of disk on which the filesystem resides;
.Xr newfs
then reads
.Pn /etc/disktab
instead of the pack label.
This file also contains the default
filesystem partition
sizes, and default block and fragment sizes.  To
override any of the default values you can modify the file,
edit the disk label,
or use an option to
.Xr newfs .
D 41
.NH 3
Implementing a layout
E 41
I 41
.Sh 3 "Implementing a layout"
E 41
.PP
To put a chosen disk layout into effect, you should use the
.Xr newfs (8)
command to create each new filesystem.
Each filesystem must also be added to the file
.Pn /etc/fstab
so that it will be checked and mounted when the system is bootstrapped.
.PP
D 32
As an example, consider a system with two disks.
On the first disk, \*(Dk0,
we will put the root filesystem in \*(Dk0a, and the
E 32
I 32
First we will consider a system with a single disk.
There is little real choice on how to do the layout;
the root filesystem goes in the ``a'' partition,
E 32
.Pn /usr
D 32
filesystem in \*(Dk0g, which has enough space to hold it and then some.
The
.Pn /tmp
directory will be a memory-based filesystem.
If we had only one disk we would put user files and
E 32
I 32
goes in the ``e'' partition, and
E 32
.Pn /var
D 32
in the \*(Dk0g partition with the system source and binaries.
E 32
I 32
fills out the remainder of the disk in the ``f'' partition.
This is the organization used if you loaded the disk-image root filesystem.
With the addition of a memory-based
.Pn /tmp
filesystem, its fstab entry would be as follows:
.TS
center;
lfC lfC l l n n.
/dev/\*(Dk0a	/	ufs	rw	1	1
/dev/\*(Dk0b	none	swap	sw	0	0
/dev/\*(Dk0b	/tmp	mfs	rw,-s=14000,-b=8192,-f=1024,-T=sd660	0	0
/dev/\*(Dk0e	/usr	ufs	ro	1	2
/dev/\*(Dk0f	/var	ufs	rw	1	2
.TE
E 32
.PP
D 32
If we had a second disk, we would place
E 32
I 32
If we had a second disk, we would split the load between the drives.
On the second disk, we place the
E 32
.Pn /usr
D 32
in \*(Dk1g.
We would put user files in \*(Dk0g, calling the filesystem
.Pn /var/users .
We would put the
E 32
I 32
and
E 32
.Pn /var
D 32
filesystem in \*(Dk1a.
We would also interleave the paging
between the 2 disk's.
To do this we would build a system configuration that specified:
E 32
I 32
filesystems in their usual \*(Dk1e and \*(Dk1f
partitions respectively.
The \*(Dk1b partition would be used as a second paging area,
and the \*(Dk1a partition left as a spare root filesystem
(alternatively \*(Dk1a could be used for
.Pn /var/tmp ).
The first disk still holds the
the root filesystem in \*(Dk0a, and the primary swap area in \*(Dk0b.
The \*(Dk0e partition is used to hold home directories in
.Pn /var/users .
The \*(Dk0f partition can be used for
.Pn /usr/src
or alternately the \*(Dk0e partition can be extended to cover
the rest of the disk with
.Xr disklabel (8).
As before, the
.Pn /tmp
directory is a memory-based filesystem.
Note that to interleave the paging between the two disks
you must build a system configuration that specifies:
E 32
.DS
config	vmunix	root on \*(Dk0 swap on \*(Dk0 and \*(Dk1
.DE
D 32
to get the swap interleaved, and
E 32
I 32
The
E 32
.Pn /etc/fstab
D 32
would then contain
E 32
I 32
file would then contain
E 32
.TS
center;
lfC lfC l l n n.
/dev/\*(Dk0a	/	ufs	rw	1	1
/dev/\*(Dk0b	none	swap	sw	0	0
D 32
/dev/\*(Dk0b	/tmp	mfs	rw,-s=14000,-b=8192,-f=1024,-T=sd660	0	0
/dev/\*(Dk1a	/var	ufs	rw	1	2
/dev/\*(Dk0g	/var/users	ufs	rw	1	2
E 32
/dev/\*(Dk1b	none	swap	sw	0	0
D 32
/dev/\*(Dk1g	/usr	ufs	ro	1	2
E 32
I 32
/dev/\*(Dk0b	/tmp	mfs	rw,-s=14000,-b=8192,-f=1024,-T=sd660	0	0
/dev/\*(Dk1e	/usr	ufs	ro	1	2
/dev/\*(Dk0f	/usr/src	ufs	rw	1	2
/dev/\*(Dk1f	/var	ufs	rw	1	2
/dev/\*(Dk0e	/var/users	ufs	rw	1	2
E 32
.TE
D 32
We could set
.Pn /var
to be symbolic link into the
.Pn /usr
filesystem and
keep a backup copy of the root
filesystem in the \*(Dk1a disk partition.
E 32
.PP
To make the
D 32
.Pn /var/users
E 32
I 32
.Pn /var
E 32
filesystem we would do:
.DS
\fB#\fP \fIcd /dev\fP
\fB#\fP \fIMAKEDEV \*(Dk1\fP
\fB#\fP \fIdisklabel -wr \*(Dk1 "disk type" "disk name"\fP
D 32
\fB#\fP \fInewfs \*(Dk1g\fP
E 32
I 32
\fB#\fP \fInewfs \*(Dk1f\fP
E 32
(information about filesystem prints out)
D 32
\fB#\fP \fImkdir /var/users\fP
\fB#\fP \fImount /dev/\*(Dk1g /var/users\fP
E 32
I 32
\fB#\fP \fImkdir /var\fP
\fB#\fP \fImount /dev/\*(Dk1f /var\fP
E 32
.DE
D 41
.NH 2
Installing the rest of the system
E 41
I 41
.Sh 2 "Installing the rest of the system"
E 41
.PP
At this point you should have your disks partitioned.
The next step is to extract the rest of the data from the tape.
E 23
E 12
I 10
D 15
At a minimum you need to set up the /var and /usr filesystems.
E 15
I 15
At a minimum you need to set up the
.Pn /var
and
.Pn /usr
filesystems.
E 15
You may also want to extract some or all the program sources.
I 25
Since not all architectures support tape drives or don't support the
correct ones, you may need to extract the files indirectly using
.Xr rsh (1).
For example, for a directly connected tape drive you might do:
.DS
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP
D 40
\fB#\fP \fItar xbpf 40 /dev/nr\*(Mt0\fP
E 40
I 40
\fB#\fP \fItar xbpf \*(Bz /dev/nr\*(Mt0\fP
E 40
.DE
The equivalent indirect procedure (where the tape drive is on machine ``foo'')
is:
.DS
\fB#\fP \fIrsh foo mt -f /dev/nr\*(Mt0 fsf\fP
D 40
\fB#\fP \fIrsh foo dd if=/dev/nr\*(Mt0 bs=40b | tar xbpf 40 -\fP
E 40
I 40
\fB#\fP \fIrsh foo dd if=/dev/nr\*(Mt0 bs=\*(Bzb | tar xbpf \*(Bz -\fP
E 40
.DE
Obviously, the target machine must be connected to the local network
for this to work.
D 27
See section 5 if you need hints on how to do this.
E 27
I 27
To do this:
.DS
\fB#\fP \fIecho  127.0.0.1  localhost >> /etc/hosts\fP
\fB#\fP \fIecho  \fPyour.host.inet.number  myname.my.domain  myname\fI >> /etc/hosts\fP
\fB#\fP \fIecho  \fPfriend.host.inet.number  myfriend.my.domain  myfriend\fI >> /etc/hosts\fP
\fB#\fP \fIifconfig  le0  inet  \fPmyname
.DE
where the ``host.inet.number'' fields are the IP addresses for your host and
the host with the tape drive
and the ``my.domain'' fields are the names of your machine and the tape-hosting
machine.
See sections 4.4 and 5 for more information on setting up the network.
E 27
E 25
E 10
D 2
You might wish to review the disk configuration information in section 4.4
before continuing; the partitions used below are those most appropriate
E 2
I 2
D 23
You might wish to review the disk configuration information in section
4.2 before continuing; the partitions used below are those most appropriate
E 2
in size.
E 23
.PP
D 7
For the Cypher tape drive, execute the following commands:
E 7
I 7
D 10
For the Cipher tape drive, execute the following commands:
E 7
.DS
D 2
\fB#\fP cd /dev; MAKEDEV cy0; sync
E 2
I 2
\fB#\fP \fIcd /dev; MAKEDEV cy0\fP
E 2
.DE
E 10
D 12
Then perform the following:
E 12
I 12
D 25
Then do the following:
E 25
I 25
Assuming a directly connected tape drive, here is how to extract and
D 32
install /var and /usr:
E 32
I 32
install
.Pn /var
and
.Pn /usr :
E 32
E 25
E 12
.br
.ne 5
D 10
.sp
E 10
D 33
.DS
E 33
.TS
lw(2i) l.
I 24
D 25
\fB#\fP \fImount_mfs -s 1000 -T type /tmp	(create a writable filesystem)
(\fItype\fP is disk type as determined from /etc/disktab)
\fB#\fP \fIcd /tmp\fP	(go to writable filesystem)
\fB#\fP \fI../dev/MAKEDEV \*(Dk#\fP	(create special files for root disk)
\fB#\fP \fImount -u /tmp/\*(Dk#a /\fP	(read-write mount root filesystem)
\fB#\fP \fIcd /dev\fP	(go to device directory)
\fB#\fP \fI./MAKEDEV \*(Dk#\fP	(create permanent special files for root disk)
E 25
I 25
D 43
\fB#\fP \fImount -u /dev/\*(Dk#a /\fP	(read-write mount root filesystem)
I 27
(this step may fail if it was done earlier)
E 43
I 43
\fB#\fP \fImount \-uw /dev/\*(Dk#a /\fP	(read-write mount root filesystem)
E 43
E 27
E 25
E 24
D 2
\fB#\fP date \fIyymmddhhmm\fP	(set date, see \fIdate\fP\|(1))
E 2
I 2
\fB#\fP \fIdate yymmddhhmm\fP	(set date, see \fIdate\fP\|(1))
E 2
\&....
D 2
\fB#\fP passwd root	(set password for super-user)
E 2
I 2
D 29
\fB#\fP \fIpasswd root\fP	(set password for super-user)
E 29
I 29
\fB#\fP \fIpasswd -l root\fP	(set password for super-user)
E 29
E 2
\fBNew password:\fP	(password will not echo)
\fBRetype new password:\fP
I 35
\fB#\fP \fIpasswd -l toor\fP	(set password for super-user)
\fBNew password:\fP	(password will not echo)
\fBRetype new password:\fP
E 35
D 2
\fB#\fP hostname \fImysitename\fP	(set your hostname)
\fB#\fP newfs dk0c	(create empty user file system)
(this takes a few minutes)
\fB#\fP mount /dev/dk0c /usr	(mount the usr file system)
\fB#\fP cd /usr	(make /usr the current directory)
\fB#\fP mt fsf
\fB#\fP tar xpbf 20 /dev/rmt12 	(extract all of usr except usr/src)
E 2
I 2
\fB#\fP \fIhostname mysitename\fP	(set your hostname)
D 10
\fB#\fP \fInewfs dk#c\fP	(create empty user file system)
(\fIdk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP
E 10
I 10
D 12
\fB#\fP \fInewfs r\*(Dk#c\fP	(create empty user file system)
(\fIr\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP
E 12
I 12
D 27
\fB#\fP \fInewfs r\*(Dk#c\fP	(create empty user filesystem)
D 13
(\fI\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP\c
E 13
I 13
(\fI\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP
E 13
E 12
E 10
is the partition; this takes a few minutes)
D 10
\fB#\fP \fImount /dev/dk#c /usr\fP	(mount the usr file system)
E 10
I 10
D 12
\fB#\fP \fImount /dev/\*(Dk#c /var\fP	(mount the var file system)
E 12
I 12
\fB#\fP \fImount /dev/\*(Dk#c /var\fP	(mount the var filesystem)
E 27
I 27
\fB#\fP \fInewfs r\*(Dk#p\fP	(create empty user filesystem)
(\fI\*(Dk\fP is the disk type, \fI#\fP is the unit number,
\fIp\fP is the partition; this takes a few minutes)
\fB#\fP \fImount /dev/\*(Dk#p /var\fP	(mount the var filesystem)
E 27
E 12
\fB#\fP \fIcd /var\fP	(make /var the current directory)
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
E 25
D 40
\fB#\fP \fItar xbpf 40 /dev/nr\*(Mt0\fP	(extract all of var)
E 40
I 40
\fB#\fP \fItar xbpf \*(Bz /dev/nr\*(Mt0\fP	(extract all of var)
E 40
I 29
(this takes a few minutes)
E 29
D 12
\fB#\fP \fInewfs r\*(Dk#c\fP	(create empty user file system)
(as before \fIr\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP
E 12
I 12
D 27
\fB#\fP \fInewfs r\*(Dk#c\fP	(create empty user filesystem)
D 13
(as before \fI\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP\c
E 13
I 13
(as before \fI\*(Dk\fP is the disk type, \fI#\fP is the unit number, \fIc\fP
E 13
E 12
is the partition)
D 12
\fB#\fP \fImount /dev/\*(Dk#c /usr\fP	(mount the usr file system)
E 12
I 12
\fB#\fP \fImount /dev/\*(Dk#c /usr\fP	(mount the usr filesystem)
E 27
I 27
\fB#\fP \fInewfs r\*(Dk#p\fP	(create empty user filesystem)
(as before \fI\*(Dk\fP is the disk type, \fI#\fP is the unit number,
\fIp\fP is the partition)
D 29
\fB#\fP \fImount /dev/\*(Dk#p /usr\fP	(mount the usr filesystem)
E 27
E 12
E 10
\fB#\fP \fIcd /usr\fP	(make /usr the current directory)
E 29
I 29
D 32
\fB#\fP \fImount /dev/\*(Dk#p /mnt\fP	(mount the new /usr in tmp location)
E 32
I 32
\fB#\fP \fImount /dev/\*(Dk#p /mnt\fP	(mount the new /usr in temporary location)
E 32
\fB#\fP \fIcd /mnt\fP	(make /mnt the current directory)
E 29
D 5
\fB#\fP \fImt fsf\fP	(space to end of previous tape file)
\fB#\fP \fItar xpf /dev/rmt12\fP	(extract all of usr except usr/src)
E 5
I 5
D 10
\fB#\fP \fImt -t /dev/rmt12 fsf\fP	(space to end of previous tape file)
\fB#\fP \fItar xbpf 40 /dev/rmt12\fP	(extract all of usr except usr/src)
E 10
I 10
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
E 25
D 40
\fB#\fP \fItar xbpf 40 /dev/nr\*(Mt0\fP	(extract all of usr except usr/src)
E 40
I 40
\fB#\fP \fItar xbpf \*(Bz /dev/nr\*(Mt0\fP	(extract all of usr except usr/src)
E 40
E 10
E 5
E 2
(this takes about 15-20 minutes)
I 29
\fB#\fP \fIcd /\fP	(make / the current directory)
D 32
\fB#\fP \fIumount /dev/\*(Dk#p\fP	(unmount from tmp mount point)
(ignore ``fstab'' error message)
E 32
I 32
\fB#\fP \fIumount /mnt\fP	(unmount from temporary mount point)
E 32
D 30
\fB#\fP \fIrm -r /usr/*	(remove excess bootstrap binaries)
E 30
I 30
\fB#\fP \fIrm -r /usr/*\fP	(remove excess bootstrap binaries)
E 30
\fB#\fP \fImount /dev/\*(Dk#p /usr\fP	(remount /usr)
E 29
.TE
D 33
.DE
E 33
I 2
D 15
If no disk label has been installed on the disk, the \fInewfs\fP
E 15
I 15
If no disk label has been installed on the disk, the
.Xr newfs
E 15
command will require a third argument to specify the disk type,
D 15
using one of the names in /etc/disktab.
E 2
If the tape had been rewound or positioned incorrectly before the \fItar\fP,
D 10
it may be repositioned by the following commands.
E 10
I 10
to extract /var it may be repositioned by the following commands.
E 15
I 15
using one of the names in
.Pn /etc/disktab .
If the tape had been rewound or positioned incorrectly before the
.Xr tar ,
to extract
.Pn /var
it may be repositioned by the following commands.
E 15
E 10
.DS
D 2
\fB#\fP mt rew
\fB#\fP mt fsf 3
E 2
I 2
D 5
\fB#\fP \fImt rew\fP
\fB#\fP \fImt fsf 3\fP
E 5
I 5
D 10
\fB#\fP \fImt -t /dev/rmt12 rew\fP
\fB#\fP \fImt -t /dev/rmt12 fsf 3\fP
E 10
I 10
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 rew\fP
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf 3\fP
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 rew\fP
D 32
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf 3\fP
E 32
I 32
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf 1\fP
E 32
E 25
E 10
E 5
E 2
.DE
D 10
The data on the fourth tape file has now been extracted.
D 5
If you are using 1600bpi tapes,
the first reel of the distribution is no longer needed;
the remainder of the installation procedure uses the second
D 2
reel of tape that should be mounted in place of the first.
E 2
I 2
reel of tape which should now be mounted in place of the first.
E 2
The first instruction below should be ignored if using 1600bpi tapes.
The installation procedure continues from this point on the 6250bpi tape.
E 5
I 5
If you are using 1600bpi tapes, the first reel of the
E 10
I 10
D 32
The data on the fifth tape file has now been extracted.
E 32
I 32
The data on the second and third tape files has now been extracted.
E 32
If you are using 6250bpi tapes, the first reel of the
E 10
distribution is no longer needed; you should now mount the second
reel instead.  The installation procedure continues from this
D 10
point on the 6250bpi tape.
E 10
I 10
point on the 8mm tape.
I 32
The next step is to extract the sources.
As previously noted,
.Pn /usr/src
.\" XXX Check
D 43
requires about 250-350Mb of space.
E 43
I 43
requires about 250-340Mb of space.
E 43
Ideally sources should be in a separate filesystem;
if you plan to put them into your
.Pn /usr
filesystem, it will need at least 500Mb of space.
Assuming that you will be using a separate filesystem on \*(Dk0f for
.Pn /usr/src ,
you will start by creating and mounting it:
E 32
E 10
E 5
.DS
I 32
\fB#\fP \fInewfs \*(Dk0f\fP
(information about filesystem prints out)
\fB#\fP \fImkdir /usr/src\fP
\fB#\fP \fImount /dev/\*(Dk0f /usr/src\fP
.DE
.LP
First you will extract the kernel source:
.DS
I 34
.TS
lw(2i) l.
E 34
D 33
\fB#\fP \fImkdir /usr/src/sys\fP
\fB#\fP \fIchmod 755 /usr/src/sys\fP
\fB#\fP \fIcd /usr/src/sys\fP
E 33
I 33
\fB#\fP \fIcd /usr/src\fP
E 33
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
I 34
(this should only be done on Exabyte distributions)
E 34
D 40
\fB#\fP \fItar xpbf 40 /dev/nr\*(Mt0\fP	(extract the kernel sources)
E 40
I 40
\fB#\fP \fItar xpbf \*(Bz /dev/nr\*(Mt0\fP	(extract the kernel sources)
E 40
I 33
(this takes about 15-30 minutes)
I 34
.TE
E 34
E 33
.DE
D 34
.PP
E 34
I 34
.LP
E 34
I 33
The next tar file contains the sources for the utilities.
It is extracted as follows:
.DS
.TS
lw(2i) l.
\fB#\fP \fIcd /usr/src\fP
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
D 40
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP 	(extract the utility source)
E 40
I 40
\fB#\fP \fItar xpbf \*(Bz /dev/rmt12\fP 	(extract the utility source)
E 40
(this takes about 30-60 minutes)
.TE
.DE
.PP
E 33
If you are using 6250bpi tapes, the second reel of the
distribution is no longer needed; you should now mount the third
reel instead.  The installation procedure continues from this
point on the 8mm tape.
.PP
D 33
The next tar file contains the sources for the utilities.
E 33
I 33
The next tar file contains the sources for the contributed software.
E 33
It is extracted as follows:
.DS
E 32
.TS
lw(2i) l.
D 2
\fB#\fP mt fsf		(do not do on 1600bpi tapes)
\fB#\fP mkdir src	(make directory for source)
\fB#\fP mkdir src/sys	(make directory for system source)
\fB#\fP cd src/sys	(make /usr/sys the current directory)
\fB#\fP tar xpbf 20 /dev/rmt12 	(extract the system source)
E 2
I 2
D 5
\fB#\fP \fImt fsf\fP		(6250bpi tapes only)
E 5
D 32
\fB#\fP \fImkdir src\fP	(make directory for source)
D 5
\fB#\fP \fImkdir src/sys\fP	(make directory for system source)
\fB#\fP \fIcd src/sys\fP	(make /usr/src/sys the current directory)
\fB#\fP \fItar xpbf 20 /dev/rmt12\fP 	(extract the system source)
E 5
I 5
\fB#\fP \fIcd src\fP	(make source directory the current directory)
E 32
I 32
\fB#\fP \fIcd /usr/src\fP
E 32
D 10
\fB#\fP \fImt -t /dev/rmt12 fsf\fP	(space to end of previous tape file)
E 10
I 10
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
I 34
(this should only be done on Exabyte distributions)
E 34
E 25
E 10
D 32
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP 	(extract the system source)
E 5
E 2
(this takes about 5-10 minutes)
D 2
\fB#\fP cd /	(back to root)
\fB#\fP chmod 755  /  /usr  /usr/src /usr/src/sys
\fB#\fP rm \-f sys
\fB#\fP ln \-s usr/src/sys sys	(make a symbolic link to the system source)
\fB#\fP umount /dev/dk0c	(unmount /usr)
E 2
I 2
D 5
\fB#\fP \fIcd /\fP	(back to root)
\fB#\fP \fIchmod 755  /  /usr  /usr/src /usr/src/sys\fP
E 5
I 5
\fB#\fP \fIcd /\fP	(change directory, back to the root)
\fB#\fP \fIchmod 755  /usr/src\fP
E 5
D 4
\fB#\fP \fIrm \-f sys\fP
\fB#\fP \fIln \-s usr/src/sys sys\fP	(make a symbolic link to the system source)
E 4
D 10
\fB#\fP \fIumount /dev/dk#c\fP	(unmount /usr)
E 10
I 10
D 27
\fB#\fP \fIumount /dev/\*(Dk#c\fP	(unmount /usr)
E 27
I 27
\fB#\fP \fIumount /dev/\*(Dk#p\fP	(unmount /usr)
E 32
I 32
D 33
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP 	(extract the utility source)
E 33
I 33
D 40
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP 	(extract the contributed software source)
E 40
I 40
\fB#\fP \fItar xpbf \*(Bz /dev/rmt12\fP 	(extract the contributed software source)
E 40
E 33
(this takes about 30-60 minutes)
E 32
E 27
E 10
E 2
.TE
.DE
.PP
D 12
You can check the consistency of the /usr file system by doing
E 12
I 12
D 15
You can check the consistency of the /usr filesystem by doing
E 15
I 15
D 32
You can check the consistency of the
.Pn /usr
filesystem by doing
E 32
I 32
If you received a distribution on 8mm Exabyte tape,
there is one additional tape file on the distribution tape
that has not been installed to this point; it contains the
sources for X11R5 in
.Xr tar (1)
format.  As distributed, X11R5 should be placed in
.Pn /usr/src/X11R5 .
E 32
E 15
E 12
.DS
I 34
.TS
lw(2i) l.
E 34
D 2
\fB#\fP fsck /dev/rdk0c
E 2
I 2
D 10
\fB#\fP \fIfsck /dev/rdk#c\fP
E 10
I 10
D 27
\fB#\fP \fIfsck /dev/r\*(Dk#c\fP
E 27
I 27
D 32
\fB#\fP \fIfsck /dev/r\*(Dk#p\fP
E 32
I 32
\fB#\fP \fIcd /usr/src\fP
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP	(space to end of previous tape file)
D 40
\fB#\fP \fItar xpbf 40 /dev/nr\*(Mt0\fP	(extract the X11R5 source)
E 40
I 40
\fB#\fP \fItar xpbf \*(Bz /dev/nr\*(Mt0\fP	(extract the X11R5 source)
E 40
I 33
(this takes about 30-60 minutes)
I 34
.TE
E 34
E 33
E 32
E 27
E 10
E 2
.DE
I 32
Many of the X11 utilities search using the path
.Pn /usr/X11 ,
so be sure that you have a symbolic link that points at
the location of your X11 binaries (here, X11R5).
.PP
Having now completed the extraction of the sources, 
you may want to verify that your
.Pn /usr/src
filesystem is consistent.
To do so, you must unmount it, and run
.Xr fsck (8);
assuming that you used \*(Dk0f you would proceed as follows:
.DS
.TS
lw(2i) l.
\fB#\fP \fIcd /\fP	(change directory, back to the root)
\fB#\fP \fIumount /usr/src\fP	(unmount /usr/src)
\fB#\fP \fIfsck /dev/r\*(Dk0f\fP
.TE
.DE
E 32
The output from
D 15
.I fsck
E 15
I 15
.Xr fsck
E 15
should look something like:
.DS
.B
D 2
** /dev/rdk0c
E 2
I 2
D 10
** /dev/rdk#c
E 10
I 10
D 27
** /dev/r\*(Dk#c
E 27
I 27
D 32
** /dev/r\*(Dk#p
E 27
E 10
E 2
** Last Mounted on /usr
E 32
I 32
** /dev/r\*(Dk0f
** Last Mounted on /usr/src
E 32
** Phase 1 - Check Blocks and Sizes
** Phase 2 - Check Pathnames
** Phase 3 - Check Connectivity
** Phase 4 - Check Reference Counts
** Phase 5 - Check Cyl groups
D 32
671 files, 3497 used, 137067 free (75 frags, 34248 blocks)
E 32
I 32
23000 files, 261000 used, 39000 free (2200 frags, 4600 blocks)
E 32
.R
.DE
.PP
D 12
If there are inconsistencies in the file system, you may be prompted
D 2
to apply corrective action; see the document describing
.I fsck
for information.
E 2
I 2
to apply corrective action; see the \fIfsck\fP(8) or \fIFsck -- The UNIX
E 12
I 12
If there are inconsistencies in the filesystem, you may be prompted
D 15
to apply corrective action; see the \fIfsck\fP(8) or \fIFsck \(en The UNIX
E 12
D 13
File System Check Program\fP for more details.
E 13
I 13
File System Check Program\fP (SMM:3) for more details.
E 15
I 15
to apply corrective action; see the
.Xr fsck (8)
or \fIFsck \(en The UNIX File System Check Program\fP (SMM:3) for more details.
E 15
E 13
E 2
.PP
D 2
To use the /usr file system, you should now remount it by
saying
E 2
I 2
D 12
To use the /usr file system, you should now remount it with:
E 12
I 12
D 15
To use the /usr filesystem, you should now remount it with:
E 15
I 15
To use the
D 32
.Pn /usr
E 32
I 32
.Pn /usr/src
E 32
filesystem, you should now remount it with:
E 15
E 12
E 2
.DS
D 2
\fB#\fP /etc/mount /dev/dk0c /usr
E 2
I 2
D 10
\fB#\fP \fI/etc/mount /dev/dk#c /usr\fP
E 10
I 10
D 15
\fB#\fP \fI/etc/mount /dev/\*(Dk#c /usr\fP
E 15
I 15
D 27
\fB#\fP \fI/sbin/mount /dev/\*(Dk#c /usr\fP
E 27
I 27
D 32
\fB#\fP \fImount /dev/\*(Dk#p /usr\fP
E 32
I 32
\fB#\fP \fImount /dev/\*(Dk0f /usr/src\fP
E 32
E 27
E 15
E 10
E 2
.DE
D 5
You can then extract the source code for the commands:
E 5
I 5
D 32
.PP
D 10
If you are using 1600bpi tapes, the second reel of the
E 10
I 10
If you are using 6250bpi tapes, the second reel of the
E 10
distribution is no longer needed; you should now mount the third
reel instead.  The installation procedure continues from this
D 10
point on the 6250bpi tape.
E 10
I 10
point on the 8mm tape.
E 32
I 32
or if you have made an entry for it in
.Pn /etc/fstab
you can remount it with:
E 32
E 10
E 5
.DS
D 2
\fB#\fP cd /usr/src
\fB#\fP mt fsf
\fB#\fP tar xpb 20
E 2
I 2
D 5
\fB#\fP \fIcd /usr/src\fP
\fB#\fP \fImt fsf\fP
\fB#\fP \fItar xpb 20\fP
E 5
I 5
D 32
\fB#\fP \fImkdir /usr/src/sys\fP
\fB#\fP \fIchmod 755 /usr/src/sys\fP
\fB#\fP \fIcd /usr/src/sys\fP
D 10
\fB#\fP \fImt -t /dev/rmt12 fsf\fP
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP
E 10
I 10
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf\fP
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP
E 25
\fB#\fP \fItar xpbf 40 /dev/nr\*(Mt0\fP
E 32
I 32
\fB#\fP \fImount /usr/src\fP
E 32
E 10
E 5
E 2
.DE
D 5
If you get an error at this point, most likely it was
a problem with tape positioning.
You can reposition the tape by rewinding it and
then skipping over the files already read (see \fImt\fP\|(1)).
.NH 3
Additional software
E 5
D 32
.PP
D 2
There are three extra tape files on the distribution tape(s)
which have not been installed to this point.  They are
a font library for use with Varian and Versatec printers,
the Ingres database system, and user contributed software.
All three tape files are in \fItar\fP\|(1) format and
can be installed by positioning the tape 
E 2
I 2
D 10
There is one additional tape file on the distribution tape(s)
D 5
which has not been installed to this point;
it contains user contributed software in \fItar\fP\|(1) format.
On the 1600bpi tape set, this file is the sole file on the third tape.
It can be installed by positioning the tape 
E 2
using \fImt\fP\|(1) and reading
D 2
in the files as was done for /usr/src above.  As distributed,
the fonts should be placed in a directory /usr/lib/vfont, the
Ingres system should be placed in /usr/ingres, and the user
contributed software should be placed in /usr/src/new.  The
exact contents of the user contributed software is given in
a separate document.
E 2
I 2
in the files as was done for /usr/src above.
As distributed, the user contributed software should be placed in /usr/src/new.
It may be extracted by mounting the appropriate tape (if not already mounted),
positioning the tape at the beginning of this file (for 6250bpi),
and extracting with
.IR tar :
E 5
I 5
which has not been installed to this point; it contains user
contributed software in \fItar\fP\|(1) format.  As distributed,
the user contributed software should be placed in /usr/src/new.
E 10
I 10
D 19
If you received a distribution on 8mm tape,
E 19
I 19
If you received a distribution on 8mm Exabyte tape,
E 19
there is one additional tape file on the distribution tape
D 28
which has not been installed to this point; it contains the
E 28
I 28
that has not been installed to this point; it contains the
E 28
D 15
sources for X11R5 in \fItar\fP\|(1) format.  As distributed,
X11R5 should be placed in /usr/src/X11R5.
E 15
I 15
sources for X11R5 in
.Xr tar (1)
format.  As distributed, X11R5 should be placed in
.Pn /usr/src/X11R5 .
E 15
E 10
E 5
.DS
D 5
\fB#\fP \fIcd /usr/src\fP
\fB#\fP \fImkdir new\fP
\fB#\fP \fIchmod 755 new\fP
\fB#\fP \fIcd new\fP
\fB#\fP \fItar xpb 20\fP
E 5
I 5
D 10
\fB#\fP \fImkdir /usr/src/new\fP
\fB#\fP \fIchmod 755 /usr/src/new\fP
\fB#\fP \fIcd /usr/src/new\fP
\fB#\fP \fImt -t /dev/rmt12 fsf\fP
\fB#\fP \fItar xpbf 40 /dev/rmt12\fP
E 10
I 10
D 19
\fB#\fP \fImkdir /usr/src/X11R5\fP
\fB#\fP \fIchmod 755 /usr/src/X11R5\fP
\fB#\fP \fIcd /usr/src/X11R5\fP
E 19
I 19
\fB#\fP \fIcd /usr/src\fP
E 19
D 25
\fB#\fP \fImt -t /dev/nr\*(Mt0 fsf\fP
E 25
I 25
\fB#\fP \fImt -f /dev/nr\*(Mt0 fsf\fP
E 25
\fB#\fP \fItar xpbf 40 /dev/nr\*(Mt0\fP
E 10
E 5
.DE
I 19
Many of the X11 utilities search using the path /usr/X11,
so be sure that you have a symbolic link that points at
the location of your X11 binaries (here, X11R5).
E 32
E 19
D 10
Several of the directories for large contributed software subsystems
D 5
have been placed in a single archive file and compressed to allow
E 5
I 5
have been placed in a single archive file and compressed due to space
constraints within the distribution.
E 10
E 5
E 2
D 41
.NH 2
Additional conversion information
E 41
I 41
.Sh 2 "Additional conversion information"
E 41
.PP
D 2
After setting up the new \*(4B filesystems,
you may restore the user files that were saved on tape before beginning
the conversion.
Note that the \*(4B \fIrestore\fP program does
its work on a mounted file system using normal system operations
(unlike the older \fIrestor\fP that accessed the raw file
system device and deposited inodes in the appropriate locations
on disk).  This means that file system dumps may be restored even
if the characteristics of the file system changed.  To restore
a dump tape for, say, the /a file system something like the following
would be used:
E 2
I 2
After setting up the new \*(4B filesystems, you may restore the user
files that were saved on tape before beginning the conversion.
D 15
Note that the \*(4B \fIrestore\fP program does its work on a mounted
D 12
file system using normal system operations.  This means that file
system dumps may be restored even if the characteristics of the file
system changed.  To restore a dump tape for, say, the /a file system
E 12
I 12
filesystem using normal system operations.  This means that filesystem
dumps may be restored even if the characteristics of the filesystem changed.
To restore a dump tape for, say, the /a filesystem
E 12
something like the following would be used:
E 15
I 15
Note that the \*(4B
.Xr restore
program does its work on a mounted filesystem using normal system operations.
This means that filesystem dumps may be restored even
if the characteristics of the filesystem changed.
To restore a dump tape for, say, the
.Pn /a
filesystem something like the following would be used:
E 15
E 2
.DS
D 2
\fB#\fP mkdir /a
\fB#\fP newfs dk1c eagle
\fB#\fP mount /dev/dk1c /a
\fB#\fP cd /a
\fB#\fP restore x
E 2
I 2
\fB#\fP \fImkdir /a\fP
D 10
\fB#\fP \fInewfs dk#c\fI
\fB#\fP \fImount /dev/dk#c /a\fP
E 10
I 10
D 27
\fB#\fP \fInewfs \*(Dk#c\fI
\fB#\fP \fImount /dev/\*(Dk#c /a\fP
E 27
I 27
\fB#\fP \fInewfs \*(Dk#p\fI
\fB#\fP \fImount /dev/\*(Dk#p /a\fP
E 27
E 10
\fB#\fP \fIcd /a\fP
\fB#\fP \fIrestore x\fP
E 2
.DE
.PP
D 15
If \fItar\fP images were written instead of doing a dump, you should
E 15
I 15
If
.Xr tar
images were written instead of doing a dump, you should
E 15
D 2
be sure to use the `p' option when reading the files back.
No matter how you restore a file system, be sure and check its
integrity with \fIfsck\fP when the job is complete.
E 2
I 2
D 12
be sure to use its `-p' option when reading the files back.  No matter
how you restore a file system, be sure to unmount it and and check its
E 12
I 12
be sure to use its `\-p' option when reading the files back.  No matter
how you restore a filesystem, be sure to unmount it and and check its
E 12
D 15
integrity with \fIfsck\fP(8) when the job is complete.
E 15
I 15
integrity with
.Xr fsck (8)
when the job is complete.
E 15
I 5
D 10




E 10
E 5
E 2
E 1
