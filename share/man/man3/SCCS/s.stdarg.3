h58635
s 00002/00002/00177
d D 8.2 95/04/28 15:20:45 bostic 12 11
c unused variable in example; From: Chris Torek <torek@BSDI.COM>
e
s 00002/00002/00177
d D 8.1 93/06/05 13:23:00 bostic 11 10
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00005/00001/00174
d D 6.8 91/06/29 14:45:44 bostic 10 9
c add ANSI contribution notice
e
s 00020/00002/00155
d D 6.7 91/04/26 09:40:31 donn 9 8
c (1) stdarg.h is ANSI C not AT&T; (2) fix prototype declaration in example;
c (3) mention in BUGS section a problem with the new (standard!) scheme.
e
s 00002/00002/00155
d D 6.6 91/04/24 14:21:58 bostic 8 7
c move varargs.3 to stdarg.3
e
s 00079/00085/00078
d D 6.5 91/04/19 14:30:33 cael 7 6
c macro and text revision (-mdoc version 3)
e
s 00146/00115/00017
d D 6.4 90/05/14 09:26:02 bostic 6 5
c from the ANSI C man page
e
s 00007/00002/00125
d D 6.3 86/05/15 16:11:56 karels 5 4
c try again
e
s 00025/00001/00102
d D 6.2 86/05/15 14:20:27 karels 4 3
c caveats
e
s 00001/00001/00102
d D 6.1 85/05/15 15:06:46 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00037/00025/00066
d D 5.1 85/05/15 15:06:33 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00091/00000/00000
d D 4.1 85/05/15 15:06:25 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 6
D 7
.\" Copyright (c) 1990 The Regents of the University of California.
E 7
I 7
D 11
.\" Copyright (c) 1990, 1991 The Regents of the University of California.
E 7
.\" All rights reserved.
E 11
I 11
.\" Copyright (c) 1990, 1991, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 11
.\"
I 10
.\" This code is derived from software contributed to Berkeley by
.\" the American National Standards Committee X3, on Information
.\" Processing Systems.
.\"
E 10
.\" %sccs.include.redist.man%
.\"
E 6
I 1
D 7
.\"	%W% (Berkeley) %G%
E 7
I 7
D 10
.\"     %W% (Berkeley) %G%
E 10
I 10
.\"	%W% (Berkeley) %G%
E 10
E 7
.\"
D 2
.TH VARARGS 3 
E 2
I 2
D 3
.TH VARARGS 3  "19 January 1983"
E 3
I 3
D 7
.TH VARARGS 3  "%Q%"
E 3
E 2
.AT 3
.SH NAME
D 6
varargs \- variable argument list
E 6
I 6
varargs \- variable argument lists
E 6
.SH SYNOPSIS
D 2
.nf
#include <varargs.h>
\fIfunction\fR(\fBva_alist\fR)
\fBva_dcl
va_list \fIpvar\fR;
\fBva_start\fR(\fIpvar\fR);
f = \fBva_arg\fR(\fIpvar\fR, \fItype\fR);
\fBva_end\fR(\fIpvar\fR);
.fi
E 2
I 2
D 6
.B "#include <varargs.h>"
.PP
.I function\c
.RB ( va_alist )
.br
.B va_dcl
.br
.B va_list
.IR pvar ;
.br
.B va_start\c
.RI ( pvar );
.br
f =
.B va_arg\c
.RI ( pvar ,
.IR type );
.br
.B va_end\c
.RI ( pvar );
E 6
I 6
.nf
.ft B
#include <stdarg.h>

void
va_start(va_list ap, last);

type
va_arg(va_list ap, type);

void
va_end(va_list ap);
.ft R
.fi
E 6
E 2
.SH DESCRIPTION
E 7
I 7
.Dd %Q%
D 8
.Dt VARARGS 3
E 8
I 8
.Dt STDARG 3
E 8
D 9
.Os ATT 7th
E 9
I 9
.Os
E 9
.Sh NAME
D 8
.Nm varargs
E 8
I 8
.Nm stdarg
E 8
.Nd variable argument lists
.Sh SYNOPSIS
.Fd #include <stdarg.h>
.Ft void
.Fn va_start "va_list ap" last
.Ft type
.Fn va_arg "va_list ap" type
.Ft void
.Fn va_end "va_list ap"
.Sh DESCRIPTION
E 7
D 2
This set of macros allows portable procedures that accept variable
argument lists to be written.
Routines which have variable argument lists (such as
.IR printf(3))
E 2
I 2
D 6
This set of macros provides a means of writing portable procedures that
accept variable argument lists.
Routines having variable argument lists (such as
.IR printf (3))
E 2
that do not use varargs are inherently nonportable, since different
machines use different argument passing conventions.
E 6
I 6
A function may be called with a varying number of arguments of varying
types.
The include file
D 7
.I <stdarg.h>
declares a type (\fIva_list\fP) and defines three macros for stepping
E 7
I 7
.Aq Pa stdarg.h
declares a type
.Pq Em va_list
and defines three macros for stepping
E 7
through a list of arguments whose number and types are not known to
the called function.
E 6
D 7
.PP
E 7
I 7
.Pp
E 7
D 6
.B va_alist
is used in a function header to declare a variable argument list.
E 6
I 6
The called function must declare an object of type
D 7
.I va_list
E 7
I 7
.Em va_list
E 7
which is used by the macros
D 7
.IR va_start ,
.IR va_arg ,
E 7
I 7
.Fn va_start ,
.Fn va_arg ,
E 7
and
D 7
.IR va_end .
E 6
.PP
E 7
I 7
.Fn va_end .
.Pp
E 7
D 6
.B va_dcl
D 2
is a declaration for \fBva_alist\fP.
E 2
I 2
is a declaration for
.BR va_alist .
E 2
Note that there is no semicolon after
.B va_dcl.
E 6
I 6
The
D 7
.I va_start
E 7
I 7
.Fn va_start
E 7
macro initializes
D 7
.I ap
E 7
I 7
.Fa ap
E 7
for subsequent use by
D 7
.I va_arg
E 7
I 7
.Fn va_arg
E 7
and
D 7
.IR va_end ,
E 7
I 7
.Fn va_end ,
E 7
and must be called first.
E 6
D 7
.PP
E 7
I 7
.Pp
E 7
D 6
.B va_list
is a type which can be used for the variable
D 2
.I pvar,
E 2
I 2
.IR pvar ,
E 2
which is used to traverse the list.
One such variable must always be declared.
E 6
I 6
The parameter
D 7
.I last
E 7
I 7
.Fa last
E 7
is the name of the last parameter before the variable argument list,
i.e. the last parameter of which the calling function knows the type.
E 6
D 7
.PP
E 7
I 7
.Pp
E 7
D 2
.B va_start
E 2
I 2
D 6
.B va_start\c
E 2
.RI (pvar)
is called to initialize
.I pvar
to the beginning of the list.
E 6
I 6
Because the address of this parameter is used in the
D 7
.I va_start
E 7
I 7
.Fn va_start
E 7
macro, it should not be declared as a register variable, or as a
D 7
function or array type.
E 6
.PP
E 7
I 7
function or an array type.
.Pp
E 7
D 2
.B va_arg
.RI ( pvar , type )
will return the next argument in the list
pointed to by
E 2
I 2
D 6
.B va_arg\c
.RI ( pvar ,
.IR type )
will return the next argument in the list pointed to by
E 2
.IR pvar .
.I Type
D 4
is the type the argument is expected to be.
E 4
I 4
is the type to which the expected argument will be converted
when passed as an argument.
In standard C, arguments that are
.B char
or
.B short
should be accessed as
.BR int ,
.B "unsigned char
or
.B "unsigned short
are converted to
.BR "unsigned int" ,
and
.B float
arguments are converted to
.BR double .
E 4
Different types can be mixed, but it is up
to the routine to know what type of argument is
expected, since it cannot be determined at runtime.
E 6
I 6
The
D 7
.I va_start
E 7
I 7
.Fn va_start
E 7
macro returns no value.
E 6
D 7
.PP
E 7
I 7
.Pp
E 7
D 2
.B va_end
E 2
I 2
D 6
.B va_end\c
E 2
.RI ( pvar )
is used to finish up.
E 6
I 6
The
D 7
.I va_arg
E 7
I 7
.Fn va_arg
E 7
macro expands to an expression that has the type and value of the next
argument in the call.
The parameter
D 7
.I ap
E 7
I 7
.Fa ap
E 7
is the 
D 7
.I va_list ap
E 7
I 7
.Em va_list Fa ap
E 7
initialized by
D 7
.IR va_start .
E 7
I 7
.Fn va_start .
E 7
Each call to 
D 7
.I va_arg 
E 7
I 7
.Fn va_arg
E 7
modifies
D 7
.I ap
E 7
I 7
.Fa ap
E 7
so that the next call returns the next argument.
The parameter
D 7
.I type
E 7
I 7
.Fa type
E 7
is a type name specified so that the type of a pointer to an
object that has the specified type can be obtained simply by 
D 7
adding a 
.I *
E 7
I 7
adding a *
E 7
to
D 7
.IR type .
E 6
.PP
E 7
I 7
.Fa type .
.Pp
E 7
D 2
Multiple traversals, each bracketted by
E 2
I 2
D 6
Multiple traversals, each bracketed by
E 2
.B va_start
D 2
\&..
E 2
I 2
\&...
E 2
.B va_end,
are possible.
.SH EXAMPLE
.nf
	\fB#include\fP <varargs.h>
	execl(\fBva_alist\fP)
	\fBva_dcl\fP
	{
		\fBva_list\fP ap;
		\fBchar\fP *file;
		\fBchar\fP *args[100];
		\fBint\fP argno = 0;

		\fBva_start\fP(ap);
		file = \fBva_arg(ap, \fBchar\fP *);
		\fBwhile\fP (args[argno++] = \fBva_arg\fP(ap, \fBchar\fP *))
			\fB;\fP
		\fBva_end\fP(ap);
		\fBreturn\fP execv(file, args);
	}
.fi
.SH BUGS
It is up to the calling routine to determine how many arguments
there are, since it is not possible to determine this from the
stack frame.  For example,
.I execl
passes a 0 to signal the end of the list.
.I Printf
D 2
can tell how many arguments are there by the format.
E 2
I 2
can tell how many arguments are supposed to be there by the format.
E 6
I 6
If there is no next argument, or if
D 7
.I type
E 7
I 7
.Fa type
E 7
is not compatible with the type of the actual next argument
(as promoted according to the default argument promotions),
random errors will occur.
E 6
I 4
D 7
.PP
E 7
I 7
.Pp
E 7
D 6
The macros
.I va_start
E 6
I 6
The first use of the
D 7
.I va_arg
E 7
I 7
.Fn va_arg
E 7
macro after that of the 
D 7
.I va_start 
E 7
I 7
.Fn va_start
E 7
macro returns the argument after 
D 7
.IR last .
E 7
I 7
.Fa last .
E 7
Successive invocations return the values of the remaining
arguments.
D 7
.PP
E 7
I 7
.Pp
E 7
The
D 7
.I va_end
E 7
I 7
.Fn va_end
E 7
macro handles a normal return from the function whose variable argument
list was initialized by 
D 7
.IR va_start .
.PP
E 7
I 7
.Fn va_start .
.Pp
E 7
The
D 7
.I va_end
E 7
I 7
.Fn va_end
E 7
macro returns no value.
D 7
.SH STANDARDS
The
.IR va_start ,
.IR va_arg ,
E 6
and
.I va_end
D 5
may be arbitrarily complex,
and thus may only be used where they could
E 5
I 5
D 6
may be arbitrarily complex;
for example,
.I va_start
might contain an opening brace,
which is closed by a matching brace in
.IR va_end .
Thus, they should only be used where they could
E 5
be placed within a single complex statement.
E 6
I 6
macros are ANSI C compatible.
.SH COMPATIBILITY
These macros are
.B not
compatible with the historic macros they replace.
A backward compatible version can be found in the include
file 
.IR <varargs.h> .
.SH EXAMPLES
E 7
I 7
.Sh EXAMPLES
E 7
The function
D 7
.I foo
E 7
I 7
.Em foo
E 7
takes a string of format characters and prints out the argument
associated with each format character based on the type.
D 7
.sp
.nf
.RS
foo(fmt)
	char *fmt;
E 7
I 7
.Bd -literal -offset indent
D 9
foo(char *fmt)
E 9
I 9
void foo(char *fmt, ...)
E 9
E 7
{
	va_list ap;
	int d;
D 12
	char c, *p, *s;
E 12
I 12
	char c, *s;
E 12

	va_start(ap, fmt);
	while (*fmt)
D 12
		switch(*fmt++) {
E 12
I 12
		switch (*fmt++) {
E 12
		case 's':			/* string */
			s = va_arg(ap, char *);
			printf("string %s\en", s);
			break;
		case 'd':			/* int */
			d = va_arg(ap, int);
			printf("int %d\en", d);
			break;
		case 'c':			/* char */
			c = va_arg(ap, char);
			printf("char %c\en", c);
			break;
		}
	va_end(ap);
}
D 7
.fi
E 7
I 7
.Ed
.Sh STANDARDS
The
.Fn va_start ,
.Fn va_arg ,
and
.Fn va_end
macros conform to
.St -ansiC .
.Sh COMPATIBILITY
These macros are
.Em not
compatible with the historic macros they replace.
A backward compatible version can be found in the include
file 
.Aq Pa varargs.h .
I 9
.Sh BUGS
Unlike the
.Em varargs
macros, the
.Nm stdarg
macros do not permit programmers to
code a function with no fixed arguments.
This problem generates work mainly when converting
.Em varargs
code to
.Nm stdarg
code,
but it also creates difficulties for variadic functions that
wish to pass all of their arguments on to a function
that takes a
.Em va_list
argument, such as
.Xr vfprintf 3 .
E 9
E 7
E 6
E 4
E 2
E 1
