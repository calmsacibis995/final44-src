h08453
s 00004/00004/00364
d D 8.3 94/04/19 07:46:42 bostic 16 15
c spell
e
s 00014/00015/00354
d D 8.2 93/11/30 16:48:36 mckusick 15 14
c copy edit changes from Usenix
e
s 00002/00002/00367
d D 8.1 93/06/05 13:47:49 bostic 14 13
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00060/00080/00309
d D 6.11 92/08/15 09:55:13 cael 13 12
c touch ups, make like rest of man pages
e
s 00378/00954/00011
d D 6.10 92/08/14 16:45:37 marc 12 11
c update to posix
e
s 00004/00003/00961
d D 6.9 91/04/20 15:04:49 bostic 11 10
c new copyright; att/bsd/shared
e
s 00002/00000/00962
d D 6.8 89/02/24 08:33:28 jak 10 9
c missing .LP for Terminal/window section heading
e
s 00055/00004/00907
d D 6.7 86/05/19 16:37:30 karels 9 8
c more fixes
e
s 00048/00046/00863
d D 6.6 86/05/16 16:00:12 karels 8 7
c fix up Guy Harris's mods
e
s 00003/00003/00906
d D 6.5 86/05/01 09:19:12 mckusick 7 6
c minor addendum from Guy Harris
e
s 00183/00113/00726
d D 6.4 86/04/23 17:11:15 mckusick 6 5
c rewrite from Guy Harris
e
s 00004/00004/00835
d D 6.3 85/08/13 05:26:48 lepreau 5 4
c add PASS8: pass all 8 bits of input
e
s 00005/00004/00834
d D 6.2 85/06/06 00:32:54 lepreau 4 3
c wrong cross reference
e
s 00001/00001/00837
d D 6.1 85/05/15 17:15:54 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00044/00035/00794
d D 5.1 85/05/15 17:14:57 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00829/00000/00000
d D 4.1 85/05/15 17:13:54 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 5
.\" Copyright (c) 1980 Regents of the University of California.
E 5
I 5
D 11
.\" Copyright (c) 1983 Regents of the University of California.
E 5
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 11
I 11
D 12
.\" Copyright (c) 1985 The Regents of the University of California.
E 12
I 12
D 14
.\" Copyright (c) 1991, 1992 The Regents of the University of California.
E 12
.\" All rights reserved.
E 14
I 14
.\" Copyright (c) 1991, 1992, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 14
.\"
D 12
.\" %sccs.include.proprietary.roff%
E 12
I 12
.\" %sccs.include.redist.roff%
E 12
E 11
.\"
D 4
.\"	%W% (Berkeley) %G%
E 4
I 4
D 5
.\"	@(#)tty.4	6.1 (Berkeley) 5/15/85
E 5
I 5
D 12
.\"	%W% (Berkeley) %G%
E 12
I 12
.\"     %W% (Berkeley) %G%
E 12
E 5
E 4
.\"
D 2
.TH TTY 4
E 2
I 2
D 3
.TH TTY 4 "9 February 1983"
E 3
I 3
D 4
.TH TTY 4 "%Q%"
E 4
I 4
D 5
.TH TTY 4 "May 15, 1985"
E 5
I 5
D 12
.TH TTY 4 "%Q%"
E 5
E 4
E 3
E 2
.UC 4
.SH NAME
tty \- general terminal interface
I 2
.SH SYNOPSIS
.B #include <sgtty.h>
E 2
.SH DESCRIPTION
This section describes
both a particular special file
.B /dev/tty
and the terminal drivers used for conversational computing.
.LP
.B Line disciplines.
.PP
The system provides different
.I "line disciplines"
for controlling communications lines.
D 9
In this version of the system there are three disciplines available:
E 9
I 9
In this version of the system there are two disciplines available for use
with terminals:
E 9
.IP "old" 8
D 8
The old (standard) terminal driver.  This is used when using the
E 8
I 8
The old (Version 7) terminal driver.  This is sometimes used when using the
E 8
standard shell
D 8
.IR sh (1)
and for compatibility with other standard version 7 UNIX systems.
E 8
I 8
.IR sh (1).
E 8
.IP "new"
D 8
A newer terminal driver, with features for job control; this must
be used when using
E 8
I 8
The standard Berkeley terminal driver, with features for job control;
this must be used when using
E 8
.IR csh (1).
D 2
See
.IR newtty (1)
for a short user-level summary.
E 2
D 8
.IP "net"
A line discipline used for networking and loading data into
the system over communications lines.  It allows high speed input
at very low overhead, and is described in
.IR bk (4).
E 8
.LP
Line discipline switching is accomplished with the TIOCSETD 
D 6
.I ioctl:
E 6
I 6
.IR ioctl :
E 6
.IP
D 6
.B "int ldisc = LDISC; ioctl(filedes, TIOCSETD, &ldisc);"
E 6
I 6
.B "int ldisc = LDISC;"
.br
.B "ioctl(f, TIOCSETD, &ldisc);"
E 6
.LP
D 8
where LDISC is OTTYDISC for the standard tty driver, NTTYDISC for the new
driver and NETLDISC for the networking discipline.
E 8
I 8
where LDISC is OTTYDISC for the standard tty driver
and NTTYDISC for the ``new'' driver.
E 8
The standard (currently old) tty driver is discipline 0 by convention.
I 9
Other disciplines may exist for special purposes, such as use of communications
lines for network connections.
E 9
D 6
The current line discipline can be obtained with the TIOCGETD ioctl.
E 6
I 6
The current line discipline can be obtained with the TIOCGETD
.IR ioctl .
E 6
Pending input is discarded when the line discipline is changed.
.PP
All of the low-speed asynchronous
communications ports can use any
of the available line disciplines, no matter what
hardware is involved.
The remainder of this section discusses the
\*(lqold\*(rq and \*(lqnew\*(rq disciplines.
.LP
.B "The control terminal."
.LP
When a terminal file is opened, it causes the process to wait until a
connection is established.  In practice, user programs seldom open
these files; they are opened by
D 8
.IR init (8)
E 8
I 8
.IR getty (8)
E 12
I 12
D 13
.Dd %Q%
E 13
I 13
.Dd August 14, 1992
E 13
.Dt TTY 4
.Os BSD 4
.Sh NAME
.Nm tty
.Nd general terminal interface
.Sh SYNOPSIS
.Fd #include <sys/ioctl.h>
.Sh DESCRIPTION
This section describes the interface to the terminal drivers
in the system.
.Ss Terminal Special Files
Each hardware terminal port on the system usually has a terminal special device
file associated with it in the directory ``/dev/'' (for
example, ``/dev/tty03'').
When a user logs into
the system on one of these hardware terminal ports, the system has already
opened the associated device and prepared the line for normal interactive
use (see
.Xr getty 8 .)
There is also a special case of a terminal file that connects not to
a hardware terminal port, but to another program on the other side.
These special terminal devices are called
.Em ptys
and provide the mechanism necessary to give users the same interface to the
system when logging in over a network (using
.Xr rlogin 1 ,
E 12
or
D 12
.IR rlogind (8C)
E 8
and become a user's standard input and output file.
.PP
If a process which has no control terminal opens a terminal file, then
that terminal file becomes the control terminal for that process.
The control terminal is thereafter inherited by a child process during a
.IR fork (2),
even if the control terminal is closed.
.LP
The file
.B /dev/tty
is, in each process, a synonym for a
.I "control terminal"
associated with that process.  It is useful for programs that wish to
be sure of writing messages on the terminal
no matter how output has been redirected.
It can also be used for programs that demand a file name
for output, when typed output is desired
and it is tiresome to find out which terminal
is currently in use.
.LP
I 6
A process can remove the association it has with its controlling
terminal by opening the file
.B /dev/tty
D 8
and issuing a
E 8
I 8
and issuing an
E 8
.IP
.B "ioctl(f, TIOCNOTTY, 0);"
.LP
This is often desirable in server processes.
.LP
E 6
.B "Process groups."
.LP
D 2
As described more completely in
.IR jobs (3),
command processors such as
E 2
I 2
Command processors such as
E 2
.IR csh (1)
can arbitrate the terminal between different
.I jobs
by placing related jobs in a single process group and associating this
D 6
process group with the terminal.  A terminals associated process group
E 6
I 6
process group with the terminal.  A terminal's associated process group
E 6
may be set using the TIOCSPGRP
.IR ioctl (2):
.IP
D 6
\fBioctl(fildes, TIOCSPGRP, &pgrp)\fR
E 6
I 6
.B "ioctl(fildes, TIOCSPGRP, &pgrp);"
E 6
.LP
D 6
or examined using TIOCGPGRP rather than TIOCSPGRP, returning the current
E 6
I 6
or examined using TIOCGPGRP, which returns the current
E 6
process group in
D 6
.I pgrp.
E 6
I 6
.IR pgrp .
E 6
The new terminal driver aids in this arbitration by restricting access
to the terminal by processes which are not in the current process group;
see
.B "Job access control"
below.
.LP
.B "Modes."
.PP
The terminal drivers have three major modes, characterized by the
amount of processing on the input and output characters:
.IP cooked 10
The normal mode.  In this mode lines of input are collected and input editing
is done.  The edited line is made available when it is completed by
D 8
a newline
D 6
or when an EOT (control-D, hereafter ^D)
E 6
I 6
or when the \fIt_brkc\fP character, normally an EOT (control-D, hereafter ^D),
E 8
I 8
a newline,
or when the \fIt_brkc\fP character (normally undefined)
or \fIt_eofc\fP character (normally an EOT, control-D, hereafter ^D)
E 8
E 6
is entered.
A carriage return is usually made synonymous with newline in this mode,
and replaced with a newline whenever it is typed.
All driver functions
(input editing, interrupt generation,
output processing such as delay generation and tab expansion, etc.)
are available in this mode.
.IP CBREAK 10
This mode eliminates the character, word, and line editing input facilities,
making the input character available to the user program as it is typed.
Flow control, literal-next and interrupt processing are still done in this mode.
Output processing is done.
.IP RAW 10
This mode eliminates all input processing and makes all input characters
available as they are typed; no output processing is done either.
.PP
D 2
The style of input processing can also be very different when,
in the new terminal driver, a process asks for notification
via a SIGTTIN
.IR signal (2)
when input is ready to be read from the control terminal.  In this case a
E 2
I 2
The style of input processing can also be very different when
D 8
the terminal is put in non-blocking i/o mode; see
I 6
the FNDELAY flag as described in
E 8
I 8
the terminal is put in non-blocking I/O mode; see
the FNDELAY flag described in
E 8
E 6
.IR fcntl (2).
In this case a
E 2
.IR read (2)
from the control terminal will never block, but rather
D 2
return an error indication (EIO) if there is no input available.
E 2
I 2
return an error indication (EWOULDBLOCK) if there is no
input available.
.PP
D 9
A process may also request a SIGIO signal be sent it whenever input
is present.  To enable this mode the FASYNC flag should be set using
E 9
I 9
A process may also request that a SIGIO signal be sent it whenever input
is present and also whenever output queues fall below the low-water mark.
To enable this mode the FASYNC flag should be set using
E 9
.IR fcntl (2).
E 2
.LP
.B "Input editing."
.LP
A UNIX terminal ordinarily operates in full-duplex mode.
Characters may be typed at any time,
even while output is occurring, and are only lost when the
system's character input buffers become completely
choked, which is rare,
or when the user has accumulated the maximum allowed number of
input characters that have not yet been read by some program.
Currently this limit is 256 characters.
D 6
In the old terminal driver all the saved characters are thrown away
when the limit is reached, without notice; the new driver simply refuses
to accept any further input, and rings the terminal bell.
E 6
I 6
In RAW mode, the terminal driver
throws away all input and output without notice when the limit is reached.
In CBREAK or cooked mode it refuses to accept any further input and,
if in the new line discipline, rings the terminal bell.
E 6
.PP
Input characters are normally accepted in either even or odd parity
with the parity bit being stripped off before the character is given to
the program.  By clearing either the EVEN or ODD bit in the flags word
it is possible to have input characters with that parity discarded (see the
\fBSummary\fR below.)
.PP
In all of the line disciplines, it is possible to simulate terminal
D 6
input using the TIOCSTI ioctl, which takes, as its third argument,
E 6
I 6
input using the TIOCSTI
.IR ioctl ,
which takes, as its third argument,
E 6
the address of a character.  The system pretends that this character
was typed on the argument terminal, which must be the control terminal except
D 2
for the super-user (this call is not in standard version 7 UNIX)..
E 2
I 2
for the super-user (this call is not in standard version 7 UNIX).
E 2
.PP
Input characters are normally echoed by putting them in an output queue
as they arrive.  This may be disabled by clearing the ECHO bit in the
flags word using the
D 2
.IR stty (2)
E 2
I 2
D 6
.IR stty (3)
E 2
call or the TIOCSETN or TIOCSETP ioctls
E 6
I 6
.IR stty (3C)
call or the TIOCSETN or TIOCSETP
.IR ioctl s
E 6
(see the \fBSummary\fR below).
.PP
In cooked mode, terminal input is processed in units of lines.
A program attempting
to read will normally be suspended until an entire line has been
received
D 4
(but see the description of SIGTTIN in \fBModes\fR above and FIONREAD in
\fBSummary\fR below.)
E 4
I 4
(but see the description of SIGTTIN in \fBJob access control\fR
and of FIONREAD in
\fBSummary\fR, both below.)
E 4
No matter how many characters are requested
in the read call, at most one line will be returned.
It is not, however, necessary to read a whole line at
once; any number of characters may be
requested in a read, even one, without losing information.
.PP
D 6
During input, line editing is normally done, with the character `#'
logically erasing the last character typed and the character `@'
E 6
I 6
D 8
During input, line editing is normally done, with the DELETE character
logically erasing the last character typed and the character ^U (control-U)
E 8
I 8
During input, line editing is normally done, with the erase character
.I sg_erase
(by default, DELETE)
logically erasing the last character typed and the
.I sg_kill
character (default, ^U: control-U)
E 8
E 6
logically erasing the entire current input line.
D 6
These are often reset on crt's,
with ^H replacing #,
and ^U replacing @.
E 6
These characters
D 8
never erase beyond the beginning of the current input line or an ^D.
E 8
I 8
never erase beyond the beginning of the current input line or an eof.
E 8
These characters may be entered literally by
D 6
preceding them with `\e\|'; in the old teletype driver both the `\e\|' and
the character entered literally will appear on the screen; in the new
driver the `\e\|' will normally disappear.
E 6
I 6
preceding them with `\e\|'; the `\e\|' will normally be erased when the
character is typed.
E 6
.PP
The drivers normally treat either a carriage return or a newline character
as terminating an input line, replacing the return with a newline and echoing
a return and a line feed.
If the CRMOD bit is cleared in the local mode word then the processing
for carriage return is disabled, and it is simply echoed as a return,
and does not terminate cooked mode input.
.PP
D 8
In the new driver there is a literal-next character ^V which can be typed
E 8
I 8
In the new driver there is a literal-next character (normally ^V)
which can be typed
E 8
in both cooked and CBREAK mode preceding
D 6
.B any
E 6
I 6
.I any
E 6
D 8
character to prevent its special meaning.  This is to be preferred to the
E 8
I 8
character to prevent its special meaning to the terminal handler.
This is to be preferred to the
E 8
D 6
use of `\e\|' escaping erase and kill characters, but `\e\|' is (at least
temporarily) retained with its old function in the new driver for historical
reasons.
E 6
I 6
use of `\e\|' escaping erase and kill characters, but `\e\|' is
retained with its old function in the new line discipline.
E 6
.PP
The new terminal driver also provides two other editing characters in
normal mode.  The word-erase character, normally ^W, erases the preceding
word, but not any spaces before it.  For the purposes of ^W, a word
is defined as a sequence of non-blank characters, with tabs counted as
blanks.
Finally, the reprint character, normally ^R, retypes the pending input beginning
D 2
on a new line.  Retyping occurs automagically in cooked mode if characters
E 2
I 2
on a new line.  Retyping occurs automatically in cooked mode if characters
E 2
which would normally be erased from the screen are fouled by program output.
.LP
.B "Input echoing and redisplay"
.LP
D 6
In the old terminal driver, nothing special occurs when an erase character
is typed; the erase character is simply echoed.  When a kill character
is typed it is echoed followed by a new-line (even if the character is
not killing the line, because it was preceded by a `\e\|'!.)
.PP
The new terminal driver has several modes for handling the echoing of
E 6
I 6
The terminal driver has several modes (not present in standard UNIX
Version 7 systems) for handling the echoing of
E 6
terminal input, controlled by bits in a local mode word.
.LP
.I "Hardcopy terminals."
When a hardcopy terminal is in use, the LPRTERA bit is normally set in
the local mode word.  Characters which are logically erased are
then printed out backwards preceded by `\e\|' and followed by `/' in this mode.
.LP
D 6
.I "Crt terminals."
When a crt terminal is in use, the LCRTBS bit is normally set in the local
E 6
I 6
.I "CRT terminals."
When a CRT terminal is in use, the LCRTBS bit is normally set in the local
E 6
mode word.  The terminal driver then echoes the proper number of erase
characters when input is erased; in the normal case where the erase
character is a ^H this causes the cursor of the terminal to back up
to where it was before the logically erased character was typed.
If the input has become fouled due to interspersed asynchronous output,
D 2
the input is automagically retyped.
E 2
I 2
the input is automatically retyped.
E 2
.LP
D 6
.I "Erasing characters from a crt."
When a crt terminal is in use, the LCRTERA bit may be set to cause
E 6
I 6
.I "Erasing characters from a CRT."
When a CRT terminal is in use, the LCRTERA bit may be set to cause
E 6
input to be erased from the screen with a \*(lqbackspace-space-backspace\*(rq
sequence when character or word deleting sequences are used.
A LCRTKIL bit may be set as well, causing the input to
be erased in this manner on line kill sequences as well.
.LP
.I "Echoing of control characters."
If the LCTLECH bit is set in the local state word, then non-printing (control)
characters are normally echoed as ^X (for some X)
rather than being echoed unmodified; delete is echoed as ^?.
.LP
D 6
The normal modes for using the new terminal driver on crt terminals
are speed dependent.
E 6
I 6
The normal modes for use on CRT terminals are speed dependent.
E 6
At speeds less than 1200 baud, the LCRTERA and LCRTKILL processing
D 8
is painfully slow, so 
E 8
I 8
is painfully slow, and
E 8
.IR stty (1)
normally just sets LCRTBS and LCTLECH; at
speeds of 1200 baud or greater all of these bits are normally set.
.IR Stty (1)
summarizes these option settings and the use of the new terminal
driver as
\*(lqnewcrt.\*(rq
.LP
.B "Output processing."
.PP
When one or more
characters are written, they are actually transmitted
to the terminal as soon as previously-written characters
have finished typing.
(As noted above, input characters are normally 
echoed by putting them in the output queue
as they arrive.)
When a process produces characters more rapidly than they can be typed,
it will be suspended when its output queue exceeds some limit.
When the queue has drained down to some threshold
the program is resumed.
Even parity is normally generated on output.
The EOT character is not transmitted in cooked mode to prevent terminals
D 6
that respond to it from hanging up; programs using raw or cbreak mode
E 6
I 6
that respond to it from hanging up; programs using RAW or CBREAK mode
E 6
should be careful.
.PP
The terminal drivers provide necessary processing for cooked and CBREAK mode
output including delay generation for certain special characters and parity
generation.   Delays are available after backspaces ^H, form feeds ^L,
carriage returns ^M, tabs ^I and newlines ^J.  The driver will also optionally
expand tabs into spaces, where the tab stops are assumed to be set every
D 6
eight columns.  These functions are controlled by bits in the tty flags word;
see \fBSummary\fR below.
E 6
I 6
eight columns, and optionally convert newlines to carriage returns
followed by newline.  These functions are controlled by bits in the tty
flags word; see \fBSummary\fR below.
E 6
.PP
The terminal drivers provide for mapping between upper and lower case
on terminals lacking lower case, and for other special processing on
deficient terminals.
.PP
Finally, in the new terminal driver, there is a output flush character,
normally ^O, which sets the LFLUSHO bit in the local mode word, causing
subsequent output to be flushed until it is cleared by a program or more
input is typed.  This character has effect in both cooked and CBREAK modes
and causes pending input to be retyped if there is any pending input.
D 2
Ioctls to flush the characters in the input and output queues TIOCFLUSH,
and to return the number of character still in the output queue
TIOCOUTQ are also available.
E 2
I 2
D 6
An ioctl to flush the characters in the input and output queues TIOCFLUSH,
E 6
I 6
An
.I ioctl
to flush the characters in the input or output queues, TIOCFLUSH,
E 6
is also available.
E 2
.LP
.B "Upper case terminals and Hazeltines"
.PP
If the LCASE bit is set in the tty flags, then
all upper-case letters are mapped into
the corresponding lower-case letter.
The upper-case letter may be generated by preceding
it by `\\'.
D 6
If the new terminal driver is being used,
then upper case letters
are preceded by a `\e\|' when output.
E 6
I 6
Upper case letters are preceded by a `\e\|' when output.
E 6
In addition, the following escape sequences can be generated
on output and accepted on input:
.PP
.nf
for	\`	|	~	{	}
use	\e\|\'	\e\|!	\e\|^	\e\|(	\e\|)
.fi
.PP
To deal with Hazeltine terminals, which do not understand that ~ has
been made into an ASCII character, the LTILDE bit may be set in the local
D 6
mode word when using the new terminal driver; in this case the character
E 6
I 6
mode word; in this case the character
E 6
~ will be replaced with the character \` on output.
.LP
.B "Flow control."
.PP
There are two characters (the stop character, normally ^S, and the
start character, normally ^Q) which cause output to be suspended and
resumed respectively.  Extra stop characters typed when output
is already stopped have no effect, unless the start and stop characters
are made the same, in which case output resumes.
.PP
A bit in the flags word may be set to put the terminal into TANDEM mode.
In this mode the system produces a stop character (default ^S) when
the input queue is in danger of overflowing, and a start character (default
^Q) when the input has drained sufficiently.  This mode is useful
D 8
when the terminal is actually another machine that obeys the
E 8
I 8
when the terminal is actually another machine that obeys those
E 8
conventions.
.LP
.B "Line control and breaks."
.LP
There are several
.I ioctl
calls available to control the state of the terminal line.
D 6
The TIOCSBRK ioctl will set the break bit in the hardware interface
E 6
I 6
The TIOCSBRK
.I ioctl
will set the break bit in the hardware interface
E 6
causing a break condition to exist; this can be cleared (usually after a delay
with
.IR sleep (3))
by TIOCCBRK.
Break conditions in the input are reflected as a null character in RAW mode
or as the interrupt character in cooked or CBREAK mode.
D 6
The TIOCCDTR ioctl will clear the data terminal ready condition; it can
E 6
I 6
The TIOCCDTR
.I ioctl
will clear the data terminal ready condition; it can
E 6
be set again by TIOCSDTR.
.PP
When the carrier signal from the dataset drops (usually
because the user has hung up his terminal) a
SIGHUP hangup signal is sent to the processes in the distinguished
D 8
process group of the terminal; this usually causes them to terminate
(the SIGHUP can be suppressed by setting the LNOHANG bit in the local
state word of the driver.)
E 8
I 8
process group of the terminal; this usually causes them to terminate.
The SIGHUP can be suppressed by setting the LNOHANG bit in the local
state word of the driver.
E 8
Access to the terminal by other processes is then normally revoked,
so any further reads will fail, and programs that read a terminal and test for
end-of-file on their input will terminate appropriately.
.PP
D 8
When using an ACU
it is possible to ask that the phone line be hung up on the last close
E 8
I 8
It is possible to ask that the phone line be hung up on the last close
E 8
D 6
with the TIOCHPCL ioctl; this is normally done on the outgoing line.
E 6
I 6
with the TIOCHPCL
.IR ioctl ;
D 8
this is normally done on the outgoing line.
E 8
I 8
this is normally done on the outgoing lines and dialups.
E 8
E 6
.LP
.B "Interrupt characters."
.PP
There are several characters that generate interrupts in cooked and CBREAK
D 6
mode; all are sent the processes in the control group of the terminal,
as if a TIOCGPGRP ioctl were done to get the process group and then a
E 6
I 6
mode; all are sent to the processes in the control group of the terminal,
as if a TIOCGPGRP
.I ioctl
were done to get the process group and then a
E 6
.IR killpg (2)
system call were done,
except that these characters also flush pending input and output when
typed at a terminal
(\fI\z'a\`'la\fR TIOCFLUSH).
The characters shown here are the defaults; the field names in the structures
(given below)
are also shown.
D 6
The characters may be changed,
although this is not often done.
.IP ^?
D 2
\fBt_intrc\fR (Delete) generates a SIGINTR signal.
E 2
I 2
\fBt_intrc\fR (Delete) generates a SIGINT signal.
E 6
I 6
The characters may be changed.
.IP ^C
\fBt_intrc\fR (ETX) generates a SIGINT signal.
E 6
E 2
This is the normal way to stop a process which is no longer interesting,
or to regain control in an interactive program.
.IP ^\e
\fBt_quitc\fR (FS) generates a SIGQUIT signal.
This is used to cause a program to terminate and produce a core image,
if possible,
in the file
.B core
in the current directory.
.IP ^Z
\fBt_suspc\fR (EM) generates a SIGTSTP signal, which is used to suspend
the current process group.
.IP ^Y
D 2
\fBt_dstopc\fR (SUB) generates a SIGTSTP signal as ^Z does, but the
E 2
I 2
\fBt_dsuspc\fR (SUB) generates a SIGTSTP signal as ^Z does, but the
E 2
signal is sent when a program attempts to read the ^Y, rather than when
it is typed.
.LP
.B "Job access control."
.PP
When using the new terminal driver,
if a process which is not in the distinguished process group of its
control terminal attempts to read from that terminal its process group is
D 2
sent a SIGTTIN signal, which normally causes the members of that process group
to stop.  If, however, the process is ignoring or holding SIGTTIN signal
is an orphan
.IR "" ( i.e.
its parent has exited and it has been inherited by the
.IR init (8)
process, or if it is a process in the middle of process creation using
E 2
I 2
sent a SIGTTIN signal.  This signal normally causes the members of
that process group to stop. 
If, however, the process is ignoring SIGTTIN, has SIGTTIN blocked,
D 6
is an
.IR "orphan process" ,
E 6
or is in the middle of process creation using
E 2
.IR vfork (2)),
D 2
it is instead returned an end-of-file.  Under older UNIX systems
E 2
I 2
D 6
it is instead returned an end-of-file.  (An
.I "orphan process"
is a process whose
parent has exited and has been inherited by the
.IR init (8)
process.)
Under older UNIX systems
E 2
these processes would typically have had their input files reset to
.B /dev/null,
so this is a compatible change.
E 6
I 6
the read will return \-1 and set
.I errno
to EIO.
E 6
.PP
When using the new terminal driver with the LTOSTOP bit set in the local
modes, a process is prohibited from writing on its control terminal if it is
not in the distinguished process group for that terminal.
D 6
Processes which are holding or ignoring SIGTTOU signals, which are 
orphans, or which are in the middle of a
E 6
I 6
Processes which are holding or ignoring SIGTTOU signals
or which are in the middle of a
E 6
.IR vfork (2)
are excepted and allowed to produce output.
I 10
.LP
E 10
I 9
.B "Terminal/window sizes."
I 10
.LP
E 10
In order to accommodate terminals and workstations with variable-sized
windows, the terminal driver provides a mechanism for obtaining and setting
the current terminal size.
The driver does not use this information internally, but only stores it
and provides a uniform access mechanism.
When the size is changed, a SIGWINCH signal is sent to the terminal's process
group so that knowledgeable programs may detect size changes.
This facility was added in 4.3BSD and is not available in earlier
versions of the system.
E 9
.LP
.B "Summary of modes."
.LP
Unfortunately, due to the evolution of the terminal driver,
there are 4 different structures which contain various portions of the
driver data.  The first of these (\fBsgttyb\fR)
contains that part of the information
largely common between version 6 and version 7 UNIX systems.
The second contains additional control characters added in version 7.
D 6
The third is a word of local state peculiar to the new terminal driver,
E 6
I 6
The third is a word of local state added in 4BSD,
E 6
and the fourth is another structure of special characters added for the
new driver.  In the future a single structure may be made available
to programs which need to access all this information; most programs
need not concern themselves with all this state.
.de Ul
.ie t \\$1\l'|0\(ul'
.el \fI\\$1\fP
..
.LP
.Ul "Basic modes: sgtty."
.PP
The basic
.IR ioctl s
use the structure
defined in
.IR <sgtty.h> :
.PP
.ta .5i 1i
.nf
.ft 3
struct sgttyb {
	char	sg_ispeed;
	char	sg_ospeed;
	char	sg_erase;
	char	sg_kill;
	short	sg_flags;
};
.ft R
.fi
.PP
The
.I sg_ispeed 
and 
.I sg_ospeed
fields describe the input and output speeds of the
device according to the following table,
which corresponds to the DEC DH-11 interface.
If other hardware is used,
impossible speed changes are ignored.
Symbolic values in the table are as defined in
.IR <sgtty.h> .
.PP
.nf
.ta \w'B9600   'u +5n
B0	0	(hang up dataphone)
B50	1	50 baud
B75	2	75 baud
B110	3	110 baud
B134	4	134.5 baud
B150	5	150 baud
B200	6	200 baud
B300	7	300 baud
B600	8	600 baud
B1200	9	1200 baud
B1800	10	1800 baud
B2400	11	2400 baud
B4800	12	4800 baud
B9600	13	9600 baud
EXTA	14	External A
EXTB	15	External B
.fi
.DT
.PP
D 6
In the current configuration,
only 110, 150, 300 and 1200 baud are really supported on dial-up lines.
E 6
Code conversion and line control required for
IBM 2741's (134.5 baud)
must be implemented by the user's
program.
The half-duplex line discipline
required for the 202 dataset (1200 baud)
is not supplied; full-duplex 212 datasets work fine.
.PP
The
.I sg_erase
E 12
I 12
.Xr telnet 1
for example.)  Even in these cases the details of how the terminal
file was opened and set up is already handled by special software
in the system.
Thus, users do not normally need to worry about the details of
how these lines are opened or used.  Also, these lines are often used
for dialing out of a system (through an out-calling modem), but again
the system provides programs that hide the details of accessing
these terminal special files (see
.Xr tip 2 .)
.Pp
When an interactive user logs in, the system prepares the line to
behave in a certain way (called a
D 15
.Em "line discipline" ),
E 15
I 15
.Em "line discipline" ) ,
E 15
the particular details of which is described in
.Xr stty 1
at the command level, and in
.Xr termios 4
at the programming level.  A user may be concerned with changing
settings associated with his particular login terminal and should refer
D 13
to the preceding man pages for the common cases.  The remainder of 
E 13
I 13
to the preceding man pages for the common cases.  The remainder of
E 13
this man page is concerned
with describing details of using and controlling terminal devices
at a low level, such as that possibly required by a program wishing
to provide features similar to those provided by the system.
.Ss Line disciplines
A terminal file is used like any other file in the system in that
it can be opened, read, and written to using standard system
D 15
calls.  For each existing terminal file, a software processing module
E 15
I 15
calls.  For each existing terminal file, there is a software processing module
E 15
called a
.Em "line discipline"
is associated with it.  The
.Em "line discipline"
essentially glues the low level device driver code with the high
level generic interface routines (such as
.Xr read 2
E 12
and
D 12
.I sg_kill
fields of the argument structure
specify the erase and kill characters respectively.
D 6
(Defaults are # and @.)
E 6
I 6
(Defaults are DELETE and ^U.)
E 6
.PP
The
.I sg_flags
field of the argument structure
contains several bits that determine the
system's treatment of the terminal:
.PP
.ta \w'ALLDELAY 'u +\w'0100000 'u
.nf
ALLDELAY	0177400	Delay algorithm selection
BSDELAY	0100000	Select backspace delays (not implemented):
BS0	0
BS1	0100000
VTDELAY	0040000	Select form-feed and vertical-tab delays:
FF0	0
D 7
FF1	0100000
E 7
I 7
FF1	0040000
E 7
CRDELAY	0030000	Select carriage-return delays:
CR0	0
CR1	0010000
CR2	0020000
CR3	0030000
TBDELAY	0006000	Select tab delays:
TAB0	0
D 7
TAB1	0001000
E 7
I 7
TAB1	0002000
E 7
TAB2	0004000
XTABS	0006000
NLDELAY	0001400	Select new-line delays:
NL0	0
NL1	0000400
NL2	0001000
NL3	0001400
D 6
EVENP	0000200	Even parity allowed on input (most terminals)
ODDP	0000100	Odd parity allowed on input
E 6
I 6
D 8
EVENP	0000200	Even parity allowed on input and generated on output
ODDP	0000100	Odd parity allowed on input and generated on output
E 8
I 8
EVENP	0000200	Even parity allowed on input
ODDP	0000100	Odd parity allowed on input
E 8
E 6
RAW	0000040	Raw mode: wake up on all characters, 8-bit interface
D 6
CRMOD	0000020	Map CR into LF; echo LF or CR as CR-LF
E 6
I 6
CRMOD	0000020	Map CR into LF; output LF as CR-LF
E 6
ECHO	0000010	Echo (full duplex)
D 6
LCASE	0000004	Map upper case to lower on input
E 6
I 6
LCASE	0000004	Map upper case to lower on input and lower to upper on output
E 6
CBREAK	0000002	Return each character as soon as typed
TANDEM	0000001	Automatic flow control
.DT
.fi
.PP
The delay bits specify how long
transmission stops to allow for mechanical or other movement
when certain characters are sent to the terminal.
In all cases a value of 0 indicates no delay.
.PP
Backspace delays are currently ignored but might
be used for Terminet 300's.
.PP
If a form-feed/vertical tab delay is specified,
it lasts for about 2 seconds.
.PP
Carriage-return delay type 1 lasts about .08 seconds
and is suitable for the Terminet 300.
Delay type 2 lasts about .16 seconds and is suitable
for the VT05 and the TI 700.
Delay type 3 is suitable for the concept-100 and pads lines
to be at least 9 characters at 9600 baud.
.PP
New-line delay type 1 is dependent on the current column
and is tuned for Teletype model 37's.
Type 2 is useful for the VT05 and is about .10 seconds.
Type 3 is unimplemented and is 0.
.PP
Tab delay type 1 is dependent on the amount of movement
and is tuned to the Teletype model
37.
Type 3, called XTABS,
is not a delay at all but causes tabs to be replaced
by the appropriate number of spaces on output.
.PP
D 8
Input characters with the wrong parity, as determined by bits 200 and
100, are ignored in cooked and CBREAK mode.
E 8
I 8
The flags for even and odd parity control parity checking on input
and generation on output in cooked and CBREAK mode
(unless LPASS8 is enabled, see below).
Even parity is generated on output unless ODDP is set and EVENP
is clear, in which case odd parity is generated.
Input characters with the wrong parity, as determined by EVENP and
ODDP, are ignored in cooked and CBREAK mode.
E 8
.PP
RAW
disables all processing save output flushing with LFLUSHO;
full 8 bits of input are given as soon as
it is available; all 8 bits are passed on output.
A break condition in the input is reported as a null character.
D 6
If the input queue overflows in raw mode it is discarded; this applies
to both new and old drivers.
E 6
I 6
If the input queue overflows in raw mode all data in the input and output
queues are discarded; this applies to both new and old drivers.
E 6
.PP
CRMOD causes input carriage returns to be turned into
D 6
new-lines;
input of either CR or LF causes LF-CR both to
be echoed
(for terminals with a new-line function).
E 6
I 6
new-lines, and output and echoed new-lines to be output as a carriage return
followed by a line feed.
E 6
.PP
CBREAK is a sort of half-cooked (rare?) mode.
Programs can read each character as soon as typed, instead
of waiting for a full line;
all processing is done except the input editing:
character and word erase and line kill, input reprint,
D 6
and the special treatment of \e or EOT are disabled.
E 6
I 6
and the special treatment of \e and EOT are disabled.
E 6
.PP
TANDEM mode causes the system to produce
a stop character (default ^S) whenever the input
queue is in danger of overflowing, and a start character
(default ^Q)
when the input queue has drained sufficiently.
It is useful for flow control when the `terminal'
is really another computer which understands the conventions.
.LP
I 6
.B Note:
The same ``stop'' and ``start'' characters are used for both directions
of flow control; the
.I t_stopc
character is accepted on input as the character that stops output and is
produced on output as the character to stop input, and the
.I t_startc
character is accepted on input as the character that restarts output and is
produced on output as the character to restart input.
.LP
E 6
.Ul "Basic ioctls"
.PP
D 6
In addition to the TIOCSETD and TIOCGETD disciplines discussed
in \fBLine disciplines\fR above,
a large number of other
E 6
I 6
A large number of
E 6
.IR ioctl (2)
D 6
calls apply to terminals, and have the general form:
E 6
I 6
calls apply to terminals.  Some have the general form:
E 6
.PP
.B #include <sgtty.h>
.PP
.B ioctl(fildes, code, arg)
.br
.B struct sgttyb *arg;
.PP
The applicable codes are:
.IP TIOCGETP 15
Fetch the basic parameters associated with the terminal, and store
in the pointed-to \fIsgttyb\fR structure.
.IP TIOCSETP
Set the parameters according to the pointed-to \fIsgttyb\fR structure.
The interface delays until output is quiescent,
then throws away any unread characters,
before changing the modes.
.IP TIOCSETN
Set the parameters like TIOCSETP but do not delay or flush input.
Input is not preserved, however, when changing to or from RAW.
.PP
D 6
With the following codes the
E 6
I 6
With the following codes
E 6
.I arg
is ignored.
.IP TIOCEXCL 15
Set \*(lqexclusive-use\*(rq mode:
no further opens are permitted until the file has been closed.
.IP TIOCNXCL
Turn off \*(lqexclusive-use\*(rq mode.
.IP TIOCHPCL
When the file is closed for the last time,
hang up the terminal.
This is useful when the line is associated
with an ACU used to place outgoing calls.
I 6
.PP
With the following codes
.I arg
is a pointer to an
.BR int .
.IP TIOCGETD 15
.I arg
is a pointer to an
.B int
into which is placed the current line discipline number.
.IP TIOCSETD
.I arg
is a pointer to an
.B int
whose value becomes the current line discipline number.
E 6
.IP TIOCFLUSH
D 6
All characters waiting in input or output queues are flushed.
E 6
I 6
If the
.B int
pointed to by
.I arg
has a zero value, all characters waiting in input or output queues are flushed.
Otherwise, the value of the
.B int
D 8
is treated as the logical OR of the FREAD and FWRITE defined in
E 8
I 8
is for the FREAD and FWRITE bits defined in
E 8
.BR <sys/file.h> ;
if the FREAD bit is set, all characters waiting in input queues are flushed,
and if the FWRITE bit is set, all characters waiting in output queues are
flushed.
E 6
.LP
The remaining calls are not available in vanilla version 7 UNIX.
In cases where arguments are required, they are described; \fIarg\fR
should otherwise be given as 0.
.IP TIOCSTI 15
D 6
the argument is the address of a character which the system
pretends was typed on the terminal.
E 6
I 6
the argument points to a character which the system
pretends had been typed on the terminal.
E 6
.IP TIOCSBRK 15
the break bit is set in the terminal.
.IP TIOCCBRK
the break bit is cleared.
.IP TIOCSDTR 
data terminal ready is set.
.IP TIOCCDTR
data terminal ready is cleared.
I 6
.IP TIOCSTOP 15
output is stopped as if the ``stop'' character had been typed.
.IP TIOCSTART
output is restarted as if the ``start'' character had been typed.
E 6
.IP TIOCGPGRP
D 6
arg is the address of a word into which is placed the process group
number of the control terminal.
E 6
I 6
.I arg
is a pointer to an
.B int
into which is placed the process group ID of the process group
for which this terminal is the control terminal.
E 6
.IP TIOCSPGRP
D 6
arg is a word (typically a process id) which becomes the process
group for the control terminal.
E 6
I 6
.I arg
is a pointer to an
.B int
D 8
(typically a process ID); the process group whose process group ID
is the value of this
.B int
becomes the process group for which this terminal is the control terminal.
E 8
I 8
which is the value to which the process group ID
for this terminal will be set.
E 8
.IP TIOCOUTQ
returns in the
.B int
pointed to by
.I arg
D 8
the number of characters queued up to be output to the terminal.
E 8
I 8
the number of characters queued for output to the terminal.
E 8
E 6
.IP FIONREAD
D 6
returns in the long integer whose address is arg the number
of immediately readable characters from the argument unit.
This works for files, pipes, and terminals, but not (yet)
for multiplexed channels.
.LP
E 6
I 6
returns in the
.B int
pointed to by
.I arg
D 8
the number of immediately readable characters from the argument unit.
E 8
I 8
the number of characters immediately readable from the argument descriptor.
E 8
This works for files, pipes, and terminals.
.PP
E 6
.Ul Tchars
.PP
The second structure associated with each terminal specifies
characters that are special in both the old and new terminal interfaces:
The following structure is defined in
.IR <sys/ioctl.h> ,
which is automatically included in
.IR <sgtty.h> :
.PP
.nf
.ft 3
.ta .5i 1i 2i 
struct tchars {
	char	t_intrc;	/* interrupt */
	char	t_quitc;	/* quit */
	char	t_startc;	/* start output */
	char	t_stopc;	/* stop output */
	char	t_eofc;		/* end-of-file */
	char	t_brkc;		/* input delimiter (like nl) */
};
.DT
.fi
.ft R
.PP
The default values for these characters are
D 7
^?, ^\e\|, ^Q, ^S, ^D, and \-1.
E 7
I 7
^C, ^\e\|, ^Q, ^S, ^D, and \-1.
E 7
A character value of \-1
eliminates the effect of that character.
The
.I t_brkc
character, by default \-1,
acts like a new-line in that it terminates a `line,'
is echoed, and is passed to the program.
The `stop' and `start' characters may be the same,
to produce a toggle effect.
It is probably counterproductive to make
other special characters (including erase and kill)
identical.
D 6
The applicable ioctl calls are:
E 6
I 6
The applicable
.I ioctl
calls are:
E 6
.IP TIOCGETC 12
Get the special characters and put them in the specified structure.
.IP TIOCSETC 12
Set the special characters to those given in the structure.
.LP
.Ul "Local mode"
.PP
D 6
The third structure associated with each terminal is a local mode word;
except for the LNOHANG bit, this word is interpreted only when the new
driver is in use.
E 6
I 6
The third structure associated with each terminal is a local mode word.
E 6
The bits of the local mode word are:
E 12
I 12
.Xr write 2 ),
and is responsible for implementing the semantics associated
with the device.  When a terminal file is first opened by a program,
the default
.Em "line discipline"
called the
.Dv termios
line discipline is associated with the file.  This is the primary
line discipline that is used in most cases and provides the semantics
that users normally associate with a terminal.  When the
.Dv termios
line discipline is in effect, the terminal file behaves and is
operated according to the rules described in
.Xr termios 4 .
Please refer to that man page for a full description of the terminal
semantics.
The operations described here
generally represent features common
across all
D 13
.Em "line disciplines" 
E 13
I 13
D 15
.Em "line disciplines"
E 13
however, some of these calls may not
E 15
I 15
.Em "line disciplines" ,
however some of these calls may not
E 15
make sense in conjunction with a line discipline other than
.Dv termios ,
and some may not be supported by the underlying
D 15
hardware or (lack thereof, as in the case of ptys).
E 15
I 15
hardware (or lack thereof, as in the case of ptys).
E 15
.Ss Terminal File Operations
All of the following operations are invoked using the
.Xr ioctl 2
system call.  Refer to that man page for a description of
the
.Em request
and
.Em argp
D 15
parameter.
E 15
I 15
parameters.
E 15
D 13
In addition to the ioctl 
.Em requests 
E 13
I 13
In addition to the ioctl
.Em requests
E 13
defined here, the specific line discipline
D 13
in effect will define other 
E 13
I 13
in effect will define other
E 13
.Em requests
specific to it (actually
.Xr termios 4
D 13
defines them as function calls, not ioctl 
E 13
I 13
defines them as function calls, not ioctl
E 13
D 15
.Em requests .)
E 15
I 15
.Em requests . )
E 15
The following section lists the available ioctl requests.  The
D 15
name of the request and the typed
E 15
I 15
name of the request, a description of its purpose, and the typed
E 15
.Em argp
parameter (if any)
D 15
is listed along with a description of its
purpose.  For example, the first entry says
E 15
I 15
are listed.  For example, the first entry says
E 15
E 12
D 13
.sp
D 12
.nf
LCRTBS	000001	Backspace on erase rather than echoing erase
LPRTERA	000002	Printing terminal erase mode
LCRTERA	000004	Erase character echoes as backspace-space-backspace
LTILDE	000010	Convert ~ to \` on output (for Hazeltine terminals)
LMDMBUF	000020	Stop/start output when carrier drops
LLITOUT	000040	Suppress output translations
LTOSTOP	000100	Send SIGTTOU for background output
LFLUSHO	000200	Output is being flushed
LNOHANG	000400	Don't send hangup when carrier drops
LETXACK	001000	Diablo style buffer hacking (unimplemented)
LCRTKIL	002000	BS-space-BS erase entire line on line kill
D 5
LINTRUP	004000	Generate interrupt SIGTINT when input ready to read
E 5
I 5
LPASS8	004000	Pass all 8 bits through on input, in any mode
E 5
LCTLECH	010000	Echo input control chars as ^X, delete as ^?
LPENDIN	020000	Retype pending input at next read or input character
LDECCTQ	040000	Only ^Q restarts output after ^S, like DEC systems
I 6
LNOFLSH	100000	Inhibit flushing of pending I/O when an interrupt character is typed.
E 6
.fi
E 12
I 12
.D1 Em "TIOCSETD	int *ldisc"
E 12
.sp
E 13
I 13
.Pp
.D1 Em "TIOCSETD int *ldisc"
.Pp
E 13
D 12
The applicable
.I ioctl
functions are:
.IP TIOCLBIS 15
D 6
arg is the address of a 
mask which is the bits to be set in the local mode word.
E 6
I 6
.I arg
is a pointer to an
.B int
whose value is a mask containing the bits to be set in the local mode word.
E 6
.IP TIOCLBIC
D 6
arg is the address of a mask of bits to be cleared in the local mode word.
E 6
I 6
.I arg
is a pointer to an
.B int
whose value is a mask containing the bits to be cleared in the local mode word.
E 6
.IP TIOCLSET
D 6
arg is the address of a mask to be placed in the local mode word.
E 6
I 6
.I arg
is a pointer to an
.B int
whose value is stored in the local mode word.
E 6
.IP TIOCLGET
D 6
arg is the address of a word into which the current mask is placed.
E 6
I 6
.I arg
is a pointer to an
.B int
into which the current local mode word is placed.
E 6
.LP
.Ul "Local special chars"
.PP
The
D 9
final structure associated with each terminal is the
E 9
I 9
final control structure associated with each terminal is the
E 9
.I ltchars
D 6
structure which defines interrupt characters
E 6
I 6
structure which defines control characters
E 6
for the new terminal driver.
Its structure is:
.nf
E 12
I 12
and would be called on the terminal associated with
D 15
file discriptor zero by the following code fragment:
E 15
I 15
file descriptor zero by the following code fragment:
E 15
.Bd -literal
	int ldisc;

	ldisc = TTYDISC;
	ioctl(0, TIOCSETD, &ldisc);
.Ed
.Ss Terminal File Request Descriptions
D 13
.Bl -tag -width XXX
.It Va Dv TIOCSETD Fa \t\tint *ldisc
E 12
.sp
E 13
I 13
.Bl -tag -width TIOCGWINSZ
.It Dv TIOCSETD Fa int *ldisc
E 13
D 12
.ta .5i 1i 2i
.ft B
struct ltchars {
	char	t_suspc;	/* stop process signal */
D 2
	char	t_dstopc;	/* delayed stop process signal */
E 2
I 2
	char	t_dsuspc;	/* delayed stop process signal */
E 2
	char	t_rprntc;	/* reprint line */
	char	t_flushc;	/* flush output (toggles) */
D 2
	char	t_werasec;	/* word erase */
E 2
I 2
	char	t_werasc;	/* word erase */
E 2
	char	t_lnextc;	/* literal next character */
};
.ft R
.fi
E 12
I 12
Change to the new line discipline pointed to by
.Fa ldisc .
D 13
The available line disciplines are listed in 
.Pa <sys/termios.h>
E 13
I 13
The available line disciplines are listed in
.Pa Aq sys/termios.h
E 13
and currently are:
D 13
.Bl -hang -width XXXXXXXXXXX
E 13
I 13
.Pp
.Bl -tag -width TIOCGWINSZ -compact
E 13
.It TTYDISC
Termios interactive line discipline.
.It TABLDISC
Tablet line discipline.
.It SLIPDISC
Serial IP line discipline.
.El
D 13
.It Va Dv TIOCGETD Fa \t\tint *ldisc
E 12
.sp
E 13
I 13
.Pp
.It Dv TIOCGETD Fa int *ldisc
E 13
D 12
The default values for these characters are ^Z, ^Y, ^R, ^O, ^W, and ^V.
A value of \-1 disables the character.
.PP
The applicable \fIioctl\fR functions are:
.IP TIOCSLTC 12
D 6
args is the address of a 
E 6
I 6
.I arg
is a pointer to an
E 6
.I ltchars
structure which defines the new local special characters.
.IP TIOCGLTC 12
D 6
args is the address of a
E 6
I 6
.I arg
is a pointer to an
E 6
.I ltchars
structure into which is placed the current set of local special characters.
I 9
.LP
.Ul "Window/terminal sizes"
.PP
Each terminal has provision for storage of the current terminal or window
size in a
.I winsize
structure, with format:
.nf
E 12
I 12
Return the current line discipline in the integer pointed to by
.Fa ldisc .
D 13
.It Va Dv TIOCSBRK Fa \t\tvoid
E 12
.sp
E 13
I 13
.It Dv TIOCSBRK Fa void
E 13
D 12
.ft B
.ta .5i +\w'unsigned short\ \ \ \ 'u +\w'ws_ypixel;\ \ \ \ \ 'u
struct winsize {
	unsigned short	ws_row;	/* rows, in characters */
	unsigned short	ws_col;	/* columns, in characters */
	unsigned short	ws_xpixel;	/* horizontal size, pixels */
	unsigned short	ws_ypixel;	/* vertical size, pixels */
};
.ft R
.fi
.LP
A value of 0 in any field is interpreted as ``undefined;''
the entire structure is zeroed on final close.
.PP
The applicable \fIioctl\fP functions are:
.IP TIOCGWINSZ
.I arg
is a pointer to a
.B "struct winsize"
into which will be placed the current terminal or window size information.
.IP TIOCSWINSZ
.I arg
is a pointer to a
.B "struct winsize"
which will be used to set the current terminal or window size information.
If the new information is different than the old information,
a SIGWINCH signal will be sent to the terminal's process group.
E 9
.SH FILES
/dev/tty
.br
/dev/tty*
.br
/dev/console
.SH SEE ALSO
D 2
csh(1), stty(1),
ioctl(2), signal(2), sigsys(2), stty(2),
getty(8), init(8), newtty(4)
E 2
I 2
csh(1),
stty(1),
I 9
tset(1),
E 9
ioctl(2),
sigvec(2),
stty(3C),
D 8
getty(8),
init(8)
E 2
.SH BUGS
Half-duplex terminals are not supported.
E 8
I 8
getty(8)
E 12
I 12
Set the terminal hardware into BREAK condition.
D 13
.It Va Dv TIOCCBRK Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCCBRK Fa void
E 13
Clear the terminal hardware BREAK condition.
D 13
.It Va Dv TIOCSDTR Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCSDTR Fa void
E 13
Assert data terminal ready (DTR).
D 13
.It Va Dv TIOCCDTR Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCCDTR Fa void
E 13
Clear data terminal ready (DTR).
D 13
.It Va Dv TIOCGPGRP Fa \t\tint *tpgrp
.sp
E 13
I 13
.It Dv TIOCGPGRP Fa int *tpgrp
E 13
Return the current process group the terminal is associated
with in the integer pointed to by
.Fa tpgrp .
This is the underlying call that implements the
.Xr termios 4
.Fn tcgetattr
call.
D 13
.It Va Dv TIOCSPGRP Fa \t\tint *tpgrp
E 13
I 13
.It Dv TIOCSPGRP Fa int *tpgrp
E 13
Associate the terminal with the process group (as an integer) pointed to by
.Fa tpgrp .
This is the underlying call that implements the
.Xr termios 4
.Fn tcsetattr
call.
D 13
.sp
.It Va Dv TIOCGETA Fa \t\tstruct termios *term
.sp
E 13
I 13
.It Dv TIOCGETA Fa struct termios *term
E 13
Place the current value of the termios state associated with the
device in the termios structure pointed to by
.Fa term .
This is the underlying call that implements the
.Xr termios 4
.Fn tcgetattr
call.
D 13
.It Va Dv TIOCSETA Fa \t\tstruct termios *term
.sp
E 13
I 13
.It Dv TIOCSETA Fa struct termios *term
E 13
D 16
Set the termios state associated with the device immediatly.
E 16
I 16
Set the termios state associated with the device immediately.
E 16
This is the underlying call that implements the
.Xr termios 4
.Fn tcsetattr
D 13
call with the 
E 13
I 13
call with the
E 13
.Dv TCSANOW
option.
D 13
.It Va Dv TIOCSETAW Fa \t\tstruct termios *term
.sp
E 13
I 13
.It Dv TIOCSETAW Fa struct termios *term
E 13
First wait for any output to complete, then set the termios state
associated with the device.
This is the underlying call that implements the
.Xr termios 4
.Fn tcsetattr
D 13
call with the 
E 13
I 13
call with the
E 13
.Dv TCSADRAIN
option.
D 13
.It Va Dv TIOCSETAF Fa \t\tstruct termios *term
.sp
E 13
I 13
.It Dv TIOCSETAF Fa struct termios *term
E 13
First wait for any output to complete, clear any pending input,
then set the termios state associated with the device.
This is the underlying call that implements the
.Xr termios 4
.Fn tcsetattr
D 13
call with the 
E 13
I 13
call with the
E 13
.Dv TCSAFLUSH
option.
D 13
.It Va Dv TIOCOUTQ Fa \t\tint *num
.sp
E 13
I 13
.It Dv TIOCOUTQ Fa int *num
E 13
Place the current number of characters in the output queue in the
integer pointed to by
.Fa num .
D 13
.It Va Dv TIOCSTI Fa \t\tchar *cp
.sp
E 13
I 13
.It Dv TIOCSTI Fa char *cp
E 13
D 15
Simulate typed input.  Pretend as if the terminal recieved the
E 15
I 15
Simulate typed input.  Pretend as if the terminal received the
E 15
character pointed to by
.Fa cp .
D 13
.It Va Dv TIOCNOTTY Fa \t\tvoid
E 13
I 13
.It Dv TIOCNOTTY Fa void
E 13
D 16
This call is obsolete but left for compatability.  In the past, when
E 16
I 16
This call is obsolete but left for compatibility.  In the past, when
E 16
a process that didn't have a controlling terminal (see
.Em The Controlling Terminal
in
.Xr termios 4 )
first opened a terminal device, it acquired that terminal as its
controlling terminal.  For some programs this was a hazard as they
didn't want a controlling terminal in the first place, and this
provided a mechanism to disassociate the controlling terminal from
the calling process.  It
.Em must
be called by opening the file
.Pa /dev/tty
and calling
.Dv TIOCNOTTY
on that file descriptor.
.Pp
The current system does not allocate a controlling terminal to
a process on an
.Fn open
call: there is a specific ioctl called
.Dv TIOSCTTY
to make a terminal the controlling
terminal.
In addition, a program can
.Fn fork
and call the
.Fn setsid
system call which will place the process into its own session - which
has the effect of disassociating it from the controlling terminal.  This
D 16
is the new and prefered method for programs to lose their controlling
E 16
I 16
is the new and preferred method for programs to lose their controlling
E 16
terminal.
D 13
.sp
.It Va Dv TIOCSTOP Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCSTOP Fa void
E 13
Stop output on the terminal (like typing ^S at the keyboard).
D 13
.It Va Dv TIOCSTART Fa \t\tvoid
.sp
Start output on the terminal (like typing ^Q at the kayboard).  
.It Va Dv TIOCSCTTY Fa \t\tvoid
E 13
I 13
.It Dv TIOCSTART Fa void
D 15
Start output on the terminal (like typing ^Q at the kayboard).
E 15
I 15
Start output on the terminal (like typing ^Q at the keyboard).
E 15
.It Dv TIOCSCTTY Fa void
E 13
Make the terminal the controlling terminal for the process (the process
must not currently have a controlling terminal).
D 13
.sp
.It Va Dv TIOCDRAIN Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCDRAIN Fa void
E 13
Wait until all output is drained.
D 13
.It Va Dv TIOCEXCL Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCEXCL Fa void
E 13
Set exclusive use on the terminal.  No further opens are permitted
except by root.  Of course, this means that programs that are run by
D 13
root (or setuid) will not obey the exclusive setting - which limits 
E 13
I 13
root (or setuid) will not obey the exclusive setting - which limits
E 13
D 16
the usefullness of this feature.
E 16
I 16
the usefulness of this feature.
E 16
D 13
.It Va Dv TIOCNXCL Fa \t\tvoid
.sp
E 13
I 13
.It Dv TIOCNXCL Fa void
E 13
Clear exclusive use of the terminal.  Further opens are permitted.
D 13
.It Va Dv TIOCFLUSH Fa \t\tint *what
.sp
E 13
I 13
.It Dv TIOCFLUSH Fa int *what
E 13
If the value of the int pointed to by
.Fa what
contains the
.Dv FREAD
bit as defined in
D 13
.Pa <sys/file.h> ,
E 13
I 13
.Pa Aq sys/file.h ,
E 13
then all characters in the input queue are cleared.  If it contains
the
.Dv FWRITE
bit, then all characters in the output queue are cleared.  If the
D 13
value of the integer is zero, then it behaves as if both the FREAD
and FWRITE bits were set (i.e. clears both queues).
.It Va Dv TIOCGWINSZ Fa \t\tstruct winsize *ws
.sp
E 13
I 13
value of the integer is zero, then it behaves as if both the
.Dv FREAD
and
.Dv FWRITE
bits were set (i.e. clears both queues).
.It Dv TIOCGWINSZ Fa struct winsize *ws
E 13
Put the window size information associated with the terminal in the
.Va winsize
structure pointed to by
.Fa ws .
The window size structure contains the number of rows and columns (and pixels
D 15
if appropiate) of the devices attached to the terminal.  It is set by user software
E 15
I 15
if appropriate) of the devices attached to the terminal.  It is set by user software
E 15
and is the means by which most full\&-screen oriented programs determine the
screen size.  The
.Va winsize
structure is defined in
D 13
.Pa <sys/ioctl.h> .
.It Va Dv TIOCSWINSZ Fa \t\tstruct winsize *ws
.sp
E 13
I 13
.Pa Aq sys/ioctl.h .
.It Dv TIOCSWINSZ Fa struct winsize *ws
E 13
Set the window size associated with the terminal to be the value in
the
.Va winsize
structure pointed to by
.Fa ws
(see above).
D 13
.It Va Dv TIOCCONS Fa \t\tint *on
.sp
E 13
I 13
.It Dv TIOCCONS Fa int *on
E 13
If
.Fa on
points to a non-zero integer, redirect kernel console output (kernel printf's)
to this terminal.
If
.Fa on
points to a zero integer, redirect kernel console output back to the normal
console.  This is usually used on workstations to redirect kernel messages
to a particular window.
D 13
.It Va Dv TIOCMSET Fa \t\tint *state
.sp
E 13
I 13
.It Dv TIOCMSET Fa int *state
E 13
The integer pointed to by
.Fa state
contains bits that correspond to modem state.  Following is a list
of defined variables and the modem state they represent:
D 13
.Bl -hang -width XXXXXXXXXXX
E 13
I 13
.Pp
.Bl -tag -width TIOCMXCTS -compact
E 13
.It TIOCM_LE
Line Enable.
.It TIOCM_DTR
Data Terminal Ready.
.It TIOCM_RTS
Request To Send.
.It TIOCM_ST
Secondary Transmit.
.It TIOCM_SR
D 15
Secondary Recieve.
E 15
I 15
Secondary Receive.
E 15
.It TIOCM_CTS
Clear To Send.
.It TIOCM_CAR
Carrier Detect.
.It TIOCM_CD
Carier Detect (synonym).
.It TIOCM_RNG
Ring Indication.
.It TIOCM_RI
Ring Indication (synonym).
.It TIOCM_DSR
Data Set Ready.
.El
D 13
.sp
E 13
I 13
.Pp
E 13
This call sets the terminal modem state to that represented by
.Fa state .
Not all terminals may support this.
D 13
.It Va Dv TIOCMGET Fa \t\tint *state
E 13
I 13
.It Dv TIOCMGET Fa int *state
E 13
Return the current state of the terminal modem lines as represented
above in the integer pointed to by
.Fa state .
D 13
.It Va Dv TIOCMBIS Fa \t\tint *state
E 13
I 13
.It Dv TIOCMBIS Fa int *state
E 13
The bits in the integer pointed to by
.Fa state
represent modem state as described above, however the state is OR-ed
in with the current state.
D 13
.It Va Dv TIOCMBIC Fa \t\tint *state
E 13
I 13
.It Dv TIOCMBIC Fa int *state
E 13
The bits in the integer pointed to by
.Fa state
represent modem state as described above, however each bit which is on
in
.Fa state
is cleared in the terminal.
.El
.Sh SEE ALSO
.Xr getty 8 ,
.Xr ioctl 2 ,
.Xr pty 4 ,
.Xr stty 1 ,
.Xr termios 4
E 12
E 8
E 1
