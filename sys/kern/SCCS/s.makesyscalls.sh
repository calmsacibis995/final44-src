h17140
s 00334/00140/00031
d D 8.2 95/02/14 10:16:10 cgd 11 10
c generate new-style syscalls files.
e
s 00000/00000/00171
d D 8.1 93/06/10 21:56:58 bostic 10 9
c 4.4BSD snapshot (revision 8.1)
e
s 00005/00005/00166
d D 7.8 93/05/27 18:35:21 torek 9 8
c emit fully-bracketed initializers, to keep gcc2 -W quiet
e
s 00002/00002/00169
d D 7.7 92/10/11 10:25:29 bostic 8 7
c make kernel includes standard
e
s 00001/00001/00170
d D 7.6 91/04/20 15:34:08 karels 7 6
c use __CONCAT
e
s 00033/00005/00138
d D 7.5 90/06/21 22:32:23 karels 6 5
c add LIBCOMPAT (bostic); check for bad keywords
e
s 00002/00002/00141
d D 7.4 90/05/23 14:54:05 marc 5 4
c make sure syscall names are a single token
e
s 00004/00004/00139
d D 7.3 90/02/20 16:37:58 marc 4 3
c add underscores to make all syscall names a single token
e
s 00026/00024/00117
d D 7.2 89/08/17 20:34:30 karels 3 2
c chmod 444 output files
e
s 00000/00000/00141
d D 7.1 89/04/08 17:37:25 karels 2 1
c rev 7
e
s 00141/00000/00000
d D 1.1 89/04/08 17:35:48 karels 1 0
c script to build init_sysent.c, etc
e
u
U
t
T
I 1
#! /bin/sh -
I 11
#
E 11
#	%W% (Berkeley) %G%

I 6
set -e

E 6
D 11
# name of compat option:
compat=COMPAT_43
E 11
I 11
case $# in
    2)	;;
    *)	echo "Usage: $0 config-file input-file" 1>&2
	exit 1
	;;
esac
E 11

D 11
# output files:
sysnames="syscalls.c"
D 3
syshdr="syscall.h"
E 3
I 3
syshdr="../sys/syscall.h"
E 3
syssw="init_sysent.c"
E 11
I 11
# source the config file.
. $1
E 11

I 11
# the config file sets the following variables:
#	sysnames	the syscall names file
#	sysnumhdr	the syscall numbers file
#	syssw		the syscall switch file
#	sysarghdr	the syscall argument struct definitions
#	compatopts	those syscall types that are for 'compat' syscalls
#	switchname	the name for the 'struct sysent' we define
#	namesname	the name for the 'char *[]' we define
#	constprefix	the prefix for the system call constants
#
# NOTE THAT THIS makesyscalls.sh DOES NOT SUPPORT 'LIBCOMPAT'.

E 11
# tmp files:
sysdcl="sysent.dcl"
D 11
syscompat="sysent.compat"
E 11
I 11
syscompat_pref="sysent."
E 11
sysent="sysent.switch"

I 6
D 11
trap "rm $sysdcl $syscompat $sysent" 0
E 11
I 11
syscompat_files=""
for file in $compatopts; do
	syscompat_files="$syscompat_files $syscompat_pref$file"
done
E 11

E 6
D 11
case $# in
    0)	echo "Usage: $0 input-file" 1>&2
	exit 1
	;;
esac
E 11
I 11
trap "rm $sysdcl $syscompat_files $sysent" 0
E 11

D 11
awk < $1 "
D 3
	BEGIN { 
E 3
I 3
	BEGIN {
E 3
		sysdcl = \"$sysdcl\"
		syscompat = \"$syscompat\"
		sysent = \"$sysent\"
		sysnames = \"$sysnames\"
		syshdr = \"$syshdr\"
		compat = \"$compat\"
I 6
		infile = \"$1\"
E 6
		"'
E 11
I 11
# Awk program (must support nawk extensions)
# Use "awk" at Berkeley, "nawk" or "gawk" elsewhere.
awk=${AWK:-awk}
E 11

D 11
		printf "/*\n * System call switch table.\n *\n" > sysdcl
		printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysdcl
E 11
I 11
# Does this awk have a "toupper" function? (i.e. is it GNU awk)
isgawk=`$awk 'BEGIN { print toupper("true"); exit; }' 2>/dev/null`
E 11

D 11
		printf "\n#ifdef %s\n", compat > syscompat
D 7
		printf "#define compat(n, name) n, o/**/name\n\n" > syscompat
E 7
I 7
		printf "#define compat(n, name) n, __CONCAT(o,name)\n\n" > syscompat
E 11
I 11
# If this awk does not define "toupper" then define our own.
if [ "$isgawk" = TRUE ] ; then
	# GNU awk provides it.
	toupper=
else
	# Provide our own toupper()
	toupper='
function toupper(str) {
	_toupper_cmd = "echo "str" |tr a-z A-Z"
	_toupper_cmd | getline _toupper_str;
	close(_toupper_cmd);
	return _toupper_str;
}'
fi
E 11
E 7

D 11
		printf "/*\n * System call names.\n *\n" > sysnames
		printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnames
E 11
I 11
# before handing it off to awk, make a few adjustments:
#	(1) insert spaces around {, }, (, ), *, and commas.
#	(2) get rid of any and all dollar signs (so that rcs id use safe)
#
# The awk script will deal with blank lines and lines that
# start with the comment character (';').
E 11

D 11
		printf "/*\n * System call numbers.\n *\n" > syshdr
		printf " * DO NOT EDIT-- this file is automatically generated.\n" > syshdr
E 11
I 11
sed -e '
s/\$//g
:join
	/\\$/{a\

	N
	s/\\\n//
	b join
E 11
D 3
	} 
E 3
I 3
	}
E 3
D 11
	NR == 1 {
		printf " * created from%s\n */\n\n", $0 > sysdcl
D 8
		printf "#include \"param.h\"\n" > sysdcl
		printf "#include \"systm.h\"\n\n" > sysdcl
E 8
I 8
		printf "#include <sys/param.h>\n" > sysdcl
		printf "#include <sys/systm.h>\n\n" > sysdcl
E 8
		printf "int\tnosys();\n\n" > sysdcl
E 11
I 11
2,${
	/^#/!s/\([{}()*,]\)/ \1 /g
}
' < $2 | $awk "
$toupper
BEGIN {
	sysnames = \"$sysnames\"
	sysnumhdr = \"$sysnumhdr\"
	sysarghdr = \"$sysarghdr\"
	switchname = \"$switchname\"
	namesname = \"$namesname\"
	constprefix = \"$constprefix\"
E 11

D 11
		printf "struct sysent sysent[] = {\n" > sysent
E 11
I 11
	sysdcl = \"$sysdcl\"
	syscompat_pref = \"$syscompat_pref\"
	sysent = \"$sysent\"
	infile = \"$2\"
E 11

D 11
		printf " * created from%s\n */\n\n", $0 > sysnames
		printf "char *syscallnames[] = {\n" > sysnames
E 11
I 11
	compatopts = \"$compatopts\"
	"'
E 11

D 11
		printf " * created from%s\n */\n\n", $0 > syshdr
		next
E 11
I 11
	printf "/*\n * System call switch table.\n *\n" > sysdcl
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysdcl

	ncompat = split(compatopts,compat)
	for (i = 1; i <= ncompat; i++) {
		compat_upper[i] = toupper(compat[i])
		compat_file[i] = sprintf("%s%s", syscompat_pref, compat[i])

		printf "\n#ifdef %s\n", compat_upper[i] > compat_file[i]
		printf "#define %s(func) __CONCAT(%s_,func)\n\n", \
		    compat[i], compat[i] > compat_file[i]
E 11
	}
D 3
	NF == 0 || $1 ~ /^;/ { 
E 3
I 3
D 11
	NF == 0 || $1 ~ /^;/ {
E 3
		next
E 11
I 11

	printf "/*\n * System call names.\n *\n" > sysnames
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnames

	printf "/*\n * System call numbers.\n *\n" > sysnumhdr
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysnumhdr

	printf "/*\n * System call argument lists.\n *\n" > sysarghdr
	printf " * DO NOT EDIT-- this file is automatically generated.\n" > sysarghdr
}
NR == 1 {
	printf " * created from%s\n */\n\n", $0 > sysdcl

	printf "#define\ts(type)\tsizeof(type)\n\n" > sysent
	printf "struct sysent %s[] = {\n",switchname > sysent

	printf " * created from%s\n */\n\n", $0 > sysnames
	printf "char *%s[] = {\n",namesname > sysnames

	printf " * created from%s\n */\n\n", $0 > sysnumhdr

	printf " * created from%s\n */\n\n", $0 > sysarghdr
	printf "#define\tsyscallarg(x)\tunion { x datum; register_t pad; }\n" \
		> sysarghdr
	next
}
NF == 0 || $1 ~ /^;/ {
	next
}
$1 ~ /^#[ 	]*include/ {
	print > sysdcl
	next
}
$1 ~ /^#[ 	]*if/ {
	print > sysent
	print > sysdcl
	for (i = 1; i <= ncompat; i++)
		print > compat_file[i]
	print > sysnames
	savesyscall = syscall
	next
}
$1 ~ /^#[ 	]*else/ {
	print > sysent
	print > sysdcl
	for (i = 1; i <= ncompat; i++)
		print > compat_file[i]
	print > sysnames
	syscall = savesyscall
	next
}
$1 ~ /^#/ {
	print > sysent
	print > sysdcl
	for (i = 1; i <= ncompat; i++)
		print > compat_file[i]
	print > sysnames
	next
}
syscall != $1 {
	printf "%s: line %d: syscall number out of sync at %d\n", \
	   infile, NR, syscall
	printf "line is:\n"
	print
	exit 1
}
function parserr(was, wanted) {
	printf "%s: line %d: unexpected %s (expected %s)\n", \
	    infile, NR, was, wanted
	exit 1
}
function parseline() {
	f=3			# toss number and type
	if ($NF != "}") {
		funcalias=$NF
		end=NF-1
	} else {
		funcalias=""
		end=NF
E 11
	}
D 3
	$1 ~ /^#[ 	]*if/ { 
E 3
I 3
D 11
	$1 ~ /^#[ 	]*if/ {
E 3
		print > sysent
		print > sysdcl
		print > syscompat
		print > sysnames
		savesyscall = syscall
		next
E 11
I 11
	if ($f != "{")
		parserr($f, "{")
	f++
	if ($end != "}")
		parserr($end, "}")
	end--
	if ($end != ";")
		parserr($end, ";")
	end--
	if ($end != ")")
		parserr($end, ")")
	end--

	f++			# toss return type

	funcname=$f
	if (funcalias == "")
		funcalias=funcname
	f++

	if ($f != "(")
		parserr($f, ")")
	f++

	argc= 0;
	if (f == end) {
		if ($f != "void")
			parserr($f, "argument definition")
		return
E 11
D 3
	} 
	$1 ~ /^#[ 	]*else/ { 
E 3
I 3
	}
D 11
	$1 ~ /^#[ 	]*else/ {
E 3
		print > sysent
		print > sysdcl
		print > syscompat
		print > sysnames
		syscall = savesyscall
		next
E 11
I 11

	while (f <= end) {
		argc++
		argtype[argc]=""
		oldf=""
		while (f < end && $(f+1) != ",") {
			if (argtype[argc] != "" && oldf != "*")
				argtype[argc] = argtype[argc]" ";
			argtype[argc] = argtype[argc]$f;
			oldf = $f;
			f++
		}
		if (argtype[argc] == "")
			parserr($f, "argument definition")
		argname[argc]=$f;
		f += 2;			# skip name, and any comma
E 11
D 3
	} 
	$1 ~ /^#/ { 
E 3
I 3
	}
D 11
	$1 ~ /^#/ {
E 3
		print > sysent
		print > sysdcl
		print > syscompat
		print > sysnames
		next
E 11
I 11
}
function putent(nodefs, declfile, compatwrap) {
	# output syscall declaration for switch table
	if (compatwrap == "")
		printf("int\t%s();\n", funcname) > declfile
	else
		printf("int\t%s(%s)();\n", compatwrap, funcname) > declfile

	# output syscall switch entry
#	printf("\t{ { %d", argc) > sysent
#	for (i = 1; i <= argc; i++) {
#		if (i == 5) 		# wrap the line
#			printf(",\n\t    ") > sysent
#		else
#			printf(", ") > sysent
#		printf("s(%s)", argtypenospc[i]) > sysent
#	}
	printf("\t{ %d, ", argc) > sysent
	if (argc == 0)
		printf("0") > sysent
	else if (compatwrap == "")
		printf("s(struct %s_args)", funcname) > sysent
	else
		printf("s(struct %s_%s_args)", compatwrap, funcname) > sysent
	if (compatwrap == "")
		wfn = sprintf("%s", funcname);
	else
		wfn = sprintf("%s(%s)", compatwrap, funcname);
	printf(",\n\t    %s },", wfn) > sysent
	for (i = 0; i < (33 - length(wfn)) / 8; i++)
		printf("\t") > sysent
	if (compatwrap == "")
		printf("/* %d = %s */\n", syscall, funcalias) > sysent
	else
		printf("/* %d = %s %s */\n", syscall, compatwrap,
		    funcalias) > sysent

	# output syscall name for names table
	if (compatwrap == "")
		printf("\t\"%s\",\t\t\t/* %d = %s */\n", funcalias, syscall,
		    funcalias) > sysnames
	else
		printf("\t\"%s_%s\",\t/* %d = %s %s */\n", compatwrap,
		    funcalias, syscall, compatwrap, funcalias) > sysnames

	# output syscall number of header, if appropriate
	if (nodefs == "" || nodefs == "NOARGS")
		printf("#define\t%s%s\t%d\n", constprefix, funcalias,
		    syscall) > sysnumhdr
	else if (nodefs != "NODEF")
		printf("\t\t\t\t/* %d is %s %s */\n", syscall,
		    compatwrap, funcalias) > sysnumhdr

	# output syscall argument structure, if it has arguments
	if (argc != 0 && nodefs != "NOARGS") {
		if (compatwrap == "")
			printf("\nstruct %s_args {\n", funcname) > sysarghdr
		else
			printf("\nstruct %s_%s_args {\n", compatwrap,
			    funcname) > sysarghdr
		for (i = 1; i <= argc; i++)
			printf("\tsyscallarg(%s) %s;\n", argtype[i],
			    argname[i]) > sysarghdr
		printf("};\n") > sysarghdr
E 11
D 3
	} 
	syscall != $1 { 
E 3
I 3
	}
D 11
	syscall != $1 {
E 3
D 6
		printf "syscall number out of sync at %d; line is:\n", syscall
E 6
I 6
		printf "%s: line %d: syscall number out of sync at %d\n", \
		   infile, NR, syscall
		printf "line is:\n"
E 6
		print
		exit 1
E 11
I 11
}
$2 == "STD" {
	parseline()
	putent("", sysdcl, "")
	syscall++
	next
}
$2 == "NODEF" || $2 == "NOARGS" {
	parseline()
	putent($2, sysdcl, "")
	syscall++
	next
}
$2 == "OBSOL" || $2 == "UNIMPL" {
	if ($2 == "OBSOL")
		comment="obsolete"
	else
		comment="unimplemented"
	for (i = 3; i <= NF; i++)
		comment=comment " " $i

	printf("\t{ 0, 0,\n\t    nosys },\t\t\t\t/* %d = %s */\n", \
	    syscall, comment) > sysent
	printf("\t\"#%d (%s)\",\t\t/* %d = %s */\n", \
	    syscall, comment, syscall, comment) > sysnames
	if ($2 != "UNIMPL")
		printf("\t\t\t\t/* %d is %s */\n", syscall, comment) > sysnumhdr
	syscall++
	next
}
{
	for (i = 1; i <= ncompat; i++) {
		if ($2 == compat_upper[i]) {
			parseline();
			putent("COMMENT", compat_file[i], compat[i])
			syscall++
			next
		}
E 11
D 3
	} 
E 3
I 3
	}
E 3
D 11
	{	comment = $4
D 3
		for (i = 5; i <= NF; i++) 
E 3
I 3
		for (i = 5; i <= NF; i++)
E 3
			comment = comment " " $i
D 3
		if (NF < 5) 
E 3
I 3
		if (NF < 5)
E 3
			$5 = $4
D 3
	} 
	$2 == "STD" { 
E 3
I 3
	}
	$2 == "STD" {
E 3
		printf("int\t%s();\n", $4) > sysdcl
D 9
		printf("\t%d, %s,\t\t\t/* %d = %s */\n", \
E 9
I 9
		printf("\t{ %d, %s },\t\t\t/* %d = %s */\n", \
E 9
		    $3, $4, syscall, $5) > sysent
		printf("\t\"%s\",\t\t\t/* %d = %s */\n", \
		    $5, syscall, $5) > sysnames
		printf("#define\tSYS_%s\t%d\n", \
		    $5, syscall) > syshdr
I 6
		syscall++
		next
E 6
D 3
	} 
	$2 == "COMPAT" { 
E 3
I 3
	}
	$2 == "COMPAT" {
E 3
		printf("int\to%s();\n", $4) > syscompat
D 4
		printf("\tcompat(%d,%s),\t\t/* %d = old %s */\n", \
E 4
I 4
D 5
		printf("\tcompat(%d,%s),\t\t/* %d = old_%s */\n", \
E 5
I 5
D 9
		printf("\tcompat(%d,%s),\t\t/* %d = old %s */\n", \
E 9
I 9
		printf("\t{ compat(%d,%s) },\t\t/* %d = old %s */\n", \
E 9
E 5
E 4
		    $3, $4, syscall, $5) > sysent
D 4
		printf("\t\"old %s\",\t\t/* %d = old %s */\n", \
E 4
I 4
D 5
		printf("\t\"old %s\",\t\t/* %d = old_%s */\n", \
E 5
I 5
D 6
		printf("\t\"old_%s\",\t\t/* %d = old %s */\n", \
E 6
I 6
		printf("\t\"old.%s\",\t\t/* %d = old %s */\n", \
E 6
E 5
E 4
		    $5, syscall, $5) > sysnames
D 4
		printf("\t\t\t\t/* %d is old %s */\n", \
E 4
I 4
D 6
		printf("\t\t\t\t/* %d is old_%s */\n", \
E 6
I 6
		printf("\t\t\t\t/* %d is old %s */\n", \
E 6
E 4
		    syscall, comment) > syshdr
I 6
		syscall++
		next
E 6
D 3
	} 
	$2 == "OBSOL" { 
E 3
I 3
	}
I 6
	$2 == "LIBCOMPAT" {
		printf("int\to%s();\n", $4) > syscompat
D 9
		printf("\tcompat(%d,%s),\t\t/* %d = old %s */\n", \
E 9
I 9
		printf("\t{ compat(%d,%s) },\t\t/* %d = old %s */\n", \
E 9
		    $3, $4, syscall, $5) > sysent
		printf("\t\"old.%s\",\t\t/* %d = old %s */\n", \
		    $5, syscall, $5) > sysnames
		printf("#define\tSYS_%s\t%d\t/* compatibility; still used by libc */\n", \
		    $5, syscall) > syshdr
		syscall++
		next
	}
E 6
	$2 == "OBSOL" {
E 3
D 9
		printf("\t0, nosys,\t\t\t/* %d = obsolete %s */\n", \
E 9
I 9
		printf("\t{ 0, nosys },\t\t\t/* %d = obsolete %s */\n", \
E 9
		    syscall, comment) > sysent
D 4
		printf("\t\"obs %s\",\t\t\t/* %d = obsolete %s */\n", \
E 4
I 4
		printf("\t\"obs_%s\",\t\t\t/* %d = obsolete %s */\n", \
E 4
		    $4, syscall, comment) > sysnames
		printf("\t\t\t\t/* %d is obsolete %s */\n", \
		    syscall, comment) > syshdr
I 6
		syscall++
		next
E 6
D 3
	} 
	$2 == "UNIMPL" { 
E 3
I 3
	}
	$2 == "UNIMPL" {
E 3
D 9
		printf("\t0, nosys,\t\t\t/* %d = %s */\n", \
E 9
I 9
		printf("\t{ 0, nosys },\t\t\t/* %d = %s */\n", \
E 9
		    syscall, comment) > sysent
		printf("\t\"#%d\",\t\t\t/* %d = %s */\n", \
		    syscall, syscall, comment) > sysnames
I 6
		syscall++
		next
E 6
D 3
	} 
E 3
I 3
	}
E 3
D 6
	{ syscall++ }
E 6
I 6
	{
		printf "%s: line %d: unrecognized keyword %s\n", infile, NR, $2
		exit 1
	}
E 6
D 3
	END { 
E 3
I 3
	END {
E 3
		printf("\n#else /* %s */\n", compat) > syscompat
		printf("#define compat(n, name) 0, nosys\n") > syscompat
		printf("#endif /* %s */\n\n", compat) > syscompat
E 11
I 11
	printf "%s: line %d: unrecognized keyword %s\n", infile, NR, $2
	exit 1
}
END {
	printf "\n#undef\tsyscallarg\n" > sysarghdr
E 11

D 11
		printf("};\n\n") > sysent
		printf("int\tnsysent = sizeof(sysent) / sizeof(sysent[0]);\n") > sysent
E 11
I 11
        for (i = 1; i <= ncompat; i++) {
		printf("\n#else /* %s */\n", compat_upper[i]) > compat_file[i]
		printf("#define %s(func) nosys\n", compat[i]) > \
		    compat_file[i]
		printf("#endif /* %s */\n\n", compat_upper[i]) > compat_file[i]
        }
E 11

D 11
		printf("};\n") > sysnames
	} '
E 11
I 11
	printf("};\n\n") > sysent
	printf("int\tn%s= sizeof(%s) / sizeof(%s[0]);\n", switchname,
	    switchname, switchname) > sysent
E 11

D 11
cat $sysdcl $syscompat $sysent >$syssw
E 11
I 11
	printf("};\n") > sysnames
} '
E 11
D 6
rm $sysdcl $syscompat $sysent
E 6
I 3

D 11
chmod 444 $sysnames $syshdr $syssw
E 11
I 11
cat $sysdcl $syscompat_files $sysent > $syssw

#chmod 444 $sysnames $syshdr $syssw
E 11
E 3
E 1
