h35501
s 00000/00000/01316
d D 8.1 93/06/10 23:27:01 bostic 25 23
c 4.4BSD snapshot (revision 8.1)
e
s 00000/00000/01316
d R 8.1 93/06/10 23:17:53 bostic 24 23
c 4.4BSD snapshot (revision 8.1)
e
s 00002/00002/01314
d D 7.22 93/06/10 23:17:40 bostic 23 22
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00018/00017/01298
d D 7.21 92/10/11 12:20:54 bostic 22 21
c make kernel includes standard
e
s 00001/00000/01314
d D 7.20 92/09/21 18:57:30 mckusick 21 20
c add systm.h
e
s 00002/00000/01312
d D 7.19 92/05/27 16:11:58 sklower 20 19
c when cancelling sendack timer, must also clear fasttimo request
e
s 00004/00002/01308
d D 7.18 91/10/02 20:19:11 sklower 19 18
c make timeout calls macros
e
s 00007/00000/01303
d D 7.17 91/10/02 19:45:32 sklower 18 17
c simulate TCP's persist window probe and exponential backoff of it.
e
s 00003/00005/01300
d D 7.16 91/09/30 17:55:19 sklower 17 16
c remove back pointer to entry in tp_ref table; use tp_lref instead.
e
s 00010/00001/01295
d D 7.15 91/09/30 13:46:55 sklower 16 15
c reinstate connection refused socket error
e
s 00088/00174/01208
d D 7.14 91/09/26 17:02:34 sklower 15 14
c These changes represent a rewrite of retransmission policies to
c imitate the TCP algorithms more closely.  More tuning and testing need to
c be done, but the code runs at least somewhat, and these represent a checkpoint
e
s 00011/00010/01371
d D 7.13 91/09/06 17:15:17 sklower 14 13
c adopt TCP's policies concerning acks & (among others) use the fast
c timeout mechanism and delayed acks.
e
s 00002/00004/01379
d D 7.12 91/09/03 21:17:52 sklower 13 12
c call tp_getoptions as soon as paramters are known
e
s 00025/00036/01358
d D 7.11 91/08/28 12:55:59 sklower 12 11
c changes to get rid of RTC structure
e
s 00014/00006/01380
d D 7.10 91/08/14 17:19:52 sklower 11 10
c mark suggested change by mostek@crah
e
s 00001/00001/01385
d D 7.9 91/05/07 13:32:39 bostic 10 9
c add additional SCCS id string so appears in generated code
e
s 00009/00001/01377
d D 7.8 91/05/06 19:24:13 bostic 9 8
c new copyright; att/bsd/shared
e
s 00007/00013/01371
d D 7.7 91/04/26 15:03:21 sklower 8 7
c change conventions on disconnect and ER_TPDU -- reason now passed
c as ancillary datum.
e
s 00008/00015/01376
d D 7.6 91/03/12 16:03:46 sklower 7 6
c fixes from mostek@cray; also add processing for opening tp0 window
e
s 00014/00013/01377
d D 7.5 90/06/06 17:27:07 sklower 6 5
c about the first third of the COS failures attempted fixes, chkpoint for testing.
e
s 00072/00008/01318
d D 7.4 90/01/16 22:42:34 sklower 5 3
c more mitre decbit changes
e
s 00072/00008/01318
d R 7.4 90/01/16 22:18:00 sklower 4 3
c mitre decbit changes
e
s 00044/00022/01282
d D 7.3 89/08/29 13:44:43 sklower 3 2
c checkpoint for ``alpha tape''; tp is still a little broken.
e
s 00055/00063/01249
d D 7.2 89/04/22 11:54:34 sklower 2 1
c Checkpoint as of first successful tp connection, before posix, &
c before mckusick starts incorporating gnodes
e
s 01312/00000/00000
d D 7.1 88/12/14 15:29:53 sklower 1 0
c date and time created 88/12/14 15:29:53 by sklower
e
u
U
t
T
I 11
/* NEW */
E 11
I 9
/*-
D 23
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
E 23
I 23
 * Copyright (c) 1991, 1993
 *	The Regents of the University of California.  All rights reserved.
E 23
 *
 * %sccs.include.redist.c%
 *
 *	%W% (Berkeley) %G%
 */

E 9
I 1
/***********************************************************
		Copyright IBM Corporation 1987

                      All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the name of IBM not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.  

IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

/*
 * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison
 */
/* $Header: tp.trans,v 5.1 88/10/12 12:22:07 root Exp $
 *
 * Transition file for TP.
 *
 * DO NOT:
 * - change the order of any of the events or states.  to do so will
 *   make tppt, netstat, etc. cease working.
 *
 * NOTE:
 * some hooks exist for data on (dis)connect, but it's ***NOT***SUPPORTED***
 * (read: may not work!)
 *
 * I tried to put everything that causes a change of state in here, hence 
 * there are some seemingly trivial events  like T_DETACH and T_LISTEN_req.
 *
 * Almost everything having to do w/ setting & cancelling timers is here
 * but once it was debugged, I moved the setting of the 
 * keepalive (sendack) timer to tp_emit(), where an AK_TPDU is sent.
 * This is so the code wouldn't be duplicated all over creation in here.
 *
 */
*PROTOCOL tp

*INCLUDE
D 10

E 10
{
I 10
/* %W% (Berkeley) %G% */
E 10
D 3

E 3
I 3
D 9
/*	%W% (Berkeley) %G% */
E 9
E 3
D 22
#include "param.h"
I 21
#include "systm.h"
E 21
#include "socket.h"
#include "socketvar.h"
#include "protosw.h"
#include "mbuf.h"
#include "time.h"
#include "errno.h"
#include "../netiso/tp_param.h"
#include "../netiso/tp_stat.h"
#include "../netiso/tp_pcb.h"
#include "../netiso/tp_tpdu.h"
#include "../netiso/argo_debug.h"
#include "../netiso/tp_trace.h"
#include "../netiso/iso_errno.h"
#include "../netiso/tp_seq.h"
#include "../netiso/cons.h"
E 22
I 22
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/socketvar.h>
#include <sys/protosw.h>
#include <sys/mbuf.h>
#include <sys/time.h>
#include <sys/errno.h>

#include <netiso/tp_param.h>
#include <netiso/tp_stat.h>
#include <netiso/tp_pcb.h>
#include <netiso/tp_tpdu.h>
#include <netiso/argo_debug.h>
#include <netiso/tp_trace.h>
#include <netiso/iso_errno.h>
#include <netiso/tp_seq.h>
#include <netiso/cons.h>
E 22

#define DRIVERTRACE TPPTdriver
I 2
#define sbwakeup(sb)	sowakeup(p->tp_sock, sb);
#define MCPY(d, w) (d ? m_copym(d, 0, (int)M_COPYALL, w): 0)
E 2

static 	trick_hc = 1;

int 	tp_emit(),
		tp_goodack(),				tp_goodXack(),
		tp_stash()
;
void	tp_indicate(),				tp_getoptions(),	
		tp_soisdisconnecting(), 	tp_soisdisconnected(),
		tp_recycle_tsuffix(),		
I 19
#ifdef TP_DEBUG_TIMERS
E 19
		tp_etimeout(),				tp_euntimeout(),
D 15
		tp_euntimeout_lss(),		tp_ctimeout(),
E 15
I 15
D 19
		tp_ctimeout(),
E 15
		tp_cuntimeout(),			tp_ctimeout_MIN(),
E 19
I 19
		tp_ctimeout(),				tp_cuntimeout(),
		tp_ctimeout_MIN(),
#endif
E 19
		tp_freeref(),				tp_detach(),
		tp0_stash(), 				tp0_send(),
		tp_netcmd(),				tp_send()
;

typedef  struct tp_pcb tpcb_struct;


}

*PCB    tpcb_struct 	SYNONYM  P

*STATES

TP_CLOSED 	
TP_CRSENT
TP_AKWAIT
TP_OPEN
TP_CLOSING 
TP_REFWAIT
TP_LISTENING	/* Local to this implementation */
I 3
TP_CONFIRMING	/* Local to this implementation */
E 3

*EVENTS		{ struct timeval e_time; } 		SYNONYM  E

 /*
  * C (typically cancelled) timers  - 
  *
  * let these be the first ones so for the sake of convenience
  * their values are 0--> n-1
  * DO NOT CHANGE THE ORDER OF THESE TIMER EVENTS!! 
  */
 TM_inact		
 TM_retrans		
				/* TM_retrans is used for all 
				 * simple retransmissions - CR,CC,XPD,DR 
				 */

 TM_sendack		
D 15
				/* TM_sendack does dual duty - keepalive AND sendack.
E 15
I 15
				/* TM_sendack does dual duty - keepalive AND closed-window
				 * Probes.
E 15
				 * It's set w/ keepalive-ticks every time an ack is sent.
				 * (this is done in (void) tp_emit() ).
D 15
				 * It's cancelled and reset whenever a DT
				 * arrives and it doesn't require immediate acking.
				 * Note that in this case it's set w/ the minimum of
				 * its prev value and the sendack-ticks value so the 
				 * purpose of the keepalive is preserved.
E 15
I 15
				 * Whenever a DT arrives which doesn't require immediate acking,
				 * a separate fast-timeout flag is set ensuring 200ms response.
E 15
				 */
 TM_notused	

 /* 
  * E (typically expired) timers - these may be in any order. 
  * These cause procedures to be executed directly; may not
  * cause an 'event' as we know them here.
  */
 TM_reference		{ SeqNum e_low; SeqNum e_high; int e_retrans; }
 TM_data_retrans	{ SeqNum e_low; SeqNum e_high; int e_retrans; }

/* NOTE: in tp_input is a minor optimization that assumes that
 * for all tpdu types that can take e_data and e_datalen, these
 * fields fall in the same place in the event structure, that is,
 * e_data is the first field and e_datalen is the 2nd field.
 */

 ER_TPDU  	 	{
				  u_char		e_reason;
				}
 CR_TPDU  	 	{ struct mbuf 	*e_data;	/* first field */
				  int 			e_datalen; /* 2nd field */
				  u_int			e_cdt;
				}
 DR_TPDU   	 	{ struct mbuf 	*e_data;	/* first field */
				  int 			e_datalen; /* 2nd field */
				  u_short		e_sref;
				  u_char		e_reason;
				}
 DC_TPDU		
 CC_TPDU   	 	{ struct mbuf 	*e_data;	/* first field */
				  int 			e_datalen; /* 2nd field */
				  u_short		e_sref;
				  u_int			e_cdt;
				}
 AK_TPDU		{ u_int			e_cdt;	
				  SeqNum 	 	e_seq;		
				  SeqNum 	 	e_subseq;		
				  u_char 	 	e_fcc_present;		
				}
 DT_TPDU		{ struct mbuf	*e_data; 	/* first field */
				  int 			e_datalen; /* 2nd field */
				  u_int 		e_eot;
				  SeqNum		e_seq; 
				}
 XPD_TPDU		{ struct mbuf 	*e_data;	/* first field */
				  int 			e_datalen; 	/* 2nd field */
				  SeqNum 		e_seq;	
				}
 XAK_TPDU		{ SeqNum 		e_seq;		}

 T_CONN_req 
 T_DISC_req		{ u_char		e_reason; 	}
 T_LISTEN_req
 T_DATA_req
 T_XPD_req	
 T_USR_rcvd	
 T_USR_Xrcvd	
 T_DETACH
 T_NETRESET
I 3
 T_ACPT_req
E 3


*TRANSITIONS


/* TP_AKWAIT doesn't exist in TP 0 */
SAME			<==			TP_AKWAIT			[ CC_TPDU, DC_TPDU, XAK_TPDU ]
	DEFAULT
	NULLACTION
;


/* applicable in TP4, TP0 */
SAME			<==			TP_REFWAIT								DR_TPDU
	( $$.e_sref !=  0 ) 
	{
		(void) tp_emit(DC_TPDU_type, $P, 0, 0, MNULL);
	}
;
	
/* applicable in TP4, TP0 */
SAME			<==			TP_REFWAIT			[ CR_TPDU, CC_TPDU, DT_TPDU, 
					DR_TPDU, XPD_TPDU, AK_TPDU, XAK_TPDU, DC_TPDU, ER_TPDU ]
	DEFAULT
	{
#		ifdef TP_DEBUG
		if( $E.ev_number != AK_TPDU )
			printf("TPDU 0x%x in REFWAIT!!!!\n", $E.ev_number);
#		endif TP_DEBUG
	}
;

/* applicable in TP4, TP0 */
SAME			<==			TP_REFWAIT				[ T_DETACH, T_DISC_req ]
	DEFAULT
	NULLACTION
;

/* applicable in TP4, TP0 */
SAME			<==			TP_CRSENT								 AK_TPDU
	($P.tp_class == TP_CLASS_0)
	{
		/* oh, man is this grotesque or what? */
		(void) tp_goodack($P, $$.e_cdt, $$.e_seq,  $$.e_subseq);
		/* but it's necessary because this pseudo-ack may happen
		 * before the CC arrives, but we HAVE to adjust the
		 * snduna as a result of the ack, WHENEVER it arrives
		 */
	}
;

/* applicable in TP4, TP0 */
SAME			<==			TP_CRSENT	
					[ CR_TPDU, DC_TPDU, DT_TPDU, XPD_TPDU,  XAK_TPDU ]
	DEFAULT
	NULLACTION
;

/* applicable in TP4, TP0 */
SAME			<==			TP_CLOSED					[ DT_TPDU, XPD_TPDU,
										ER_TPDU, DC_TPDU, AK_TPDU, XAK_TPDU ] 
	DEFAULT
	NULLACTION
;

/* TP_CLOSING doesn't exist in TP 0 */
SAME 			<== 		TP_CLOSING
					[ CC_TPDU, CR_TPDU, DT_TPDU, XPD_TPDU, AK_TPDU, XAK_TPDU ]
	DEFAULT
	NULLACTION
;


/* DC_TPDU doesn't exist in TP 0 */
SAME			<==			TP_OPEN						  DC_TPDU
	DEFAULT
	NULLACTION
;

/* applicable in TP4, TP0 */
SAME			<==		 	TP_LISTENING  [DR_TPDU, CC_TPDU, DT_TPDU, XPD_TPDU,
										 ER_TPDU, DC_TPDU, AK_TPDU, XAK_TPDU ] 
	DEFAULT	
	NULLACTION
;

/* applicable in TP4, TP0 */
TP_LISTENING	<==			TP_CLOSED  							T_LISTEN_req 
	DEFAULT
	NULLACTION
;

/* applicable in TP4, TP0 */
TP_CLOSED  		<== 		[ TP_LISTENING, TP_CLOSED ] 			T_DETACH
	DEFAULT
	{
		tp_detach($P);
	}
;

D 3
TP_OPEN		<==		 TP_LISTENING  								CR_TPDU 
	( $P.tp_class == TP_CLASS_0 )
E 3
I 3
TP_CONFIRMING	<==		 TP_LISTENING  								CR_TPDU 
	( $P.tp_class == TP_CLASS_0)
E 3
	{
D 3
		IncStat(ts_tp0_conn);
		IFTRACE(D_CONN)
			tptrace(TPPTmisc, "CR datalen data", $$.e_datalen, $$.e_data,0,0);
		ENDTRACE
		IFDEBUG(D_CONN)
			printf("CR datalen 0x%x data 0x%x", $$.e_datalen, $$.e_data);
		ENDDEBUG
		soisconnected($P.tp_sock);
E 3
D 15
		$P.tp_refp->tpr_state = REF_OPEN; /* has timers ??? */
E 15
I 15
		$P.tp_refstate = REF_OPEN; /* has timers ??? */
E 15
D 3
		(void) tp_emit(CC_TPDU_type, $P, 0,0, MNULL) ;
		$P.tp_fcredit = 1;
E 3
	}
;

D 3
TP_AKWAIT		<==		 TP_LISTENING  								CR_TPDU 
D 2
	( tp_emit(CC_TPDU_type, $P, 0,0, MNULL) == 0 )
E 2
I 2
	( tp_emit(CC_TPDU_type, $P, 0,0, MCPY($P.tp_ucddata, M_NOWAIT)) == 0 )
E 3
I 3
TP_CONFIRMING		<==		 TP_LISTENING  							CR_TPDU 
	DEFAULT
E 3
E 2
	{
D 3
		IncStat(ts_tp4_conn); /* even though not quite open */
E 3
		IFTRACE(D_CONN)
			tptrace(TPPTmisc, "CR datalen data", $$.e_datalen, $$.e_data,0,0);
		ENDTRACE
		IFDEBUG(D_CONN)
			printf("CR datalen 0x%x data 0x%x", $$.e_datalen, $$.e_data);
		ENDDEBUG
D 15
		$P.tp_refp->tpr_state = REF_OPEN; /* has timers */
E 15
I 15
		$P.tp_refstate = REF_OPEN; /* has timers */
E 15
I 3
		$P.tp_fcredit = $$.e_cdt;
E 3

		if ($$.e_datalen > 0) {
			/* n/a for class 0 */
			ASSERT($P.tp_Xrcv.sb_cc == 0); 
			sbappendrecord(&$P.tp_Xrcv, $$.e_data);
D 2
			$P.tp_flags |= TPF_CONN_DATA_IN;
E 2
I 2
D 7
			/*$P.tp_flags |= TPF_CONN_DATA_IN;*/
E 7
E 2
			$$.e_data = MNULL; 
		} 
D 3
		$P.tp_fcredit = $$.e_cdt;
E 3
I 3
	}
;

TP_OPEN		<==		 TP_CONFIRMING  								T_ACPT_req 
	( $P.tp_class == TP_CLASS_0 )
	{
		IncStat(ts_tp0_conn);
		IFTRACE(D_CONN)
			tptrace(TPPTmisc, "Confiming", $P, 0,0,0);
		ENDTRACE
		IFDEBUG(D_CONN)
			printf("Confirming connection: $P" );
		ENDDEBUG
		soisconnected($P.tp_sock);
		(void) tp_emit(CC_TPDU_type, $P, 0,0, MNULL) ;
		$P.tp_fcredit = 1;
	}
;

TP_AKWAIT		<==		 TP_CONFIRMING  							T_ACPT_req
	(tp_emit(CC_TPDU_type, $P, 0,0, MCPY($P.tp_ucddata, M_NOWAIT)) == 0)
	{
		IncStat(ts_tp4_conn); /* even though not quite open */
		IFTRACE(D_CONN)
			tptrace(TPPTmisc, "Confiming", $P, 0,0,0);
		ENDTRACE
		IFDEBUG(D_CONN)
			printf("Confirming connection: $P" );
		ENDDEBUG
I 13
		tp_getoptions($P);
E 13
		soisconnecting($P.tp_sock);
E 3
D 7
		if($P.tp_rx_strat & TPRX_FASTSTART)
E 7
I 7
		if (($P.tp_rx_strat & TPRX_FASTSTART) && ($P.tp_fcredit > 0))
E 7
D 3
			$P.tp_cong_win = $$.e_cdt;
E 3
I 3
D 15
			$P.tp_cong_win = $P.tp_fcredit;
E 15
I 15
			$P.tp_cong_win = $P.tp_fcredit * $P.tp_l_tpdusize;
E 15
E 3
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_cc_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_cc_ticks);
E 15
D 3
	 }
E 3
I 3
	}
E 3
;

/* TP4 only */
D 3
TP_CLOSED		<==		 TP_LISTENING  								CR_TPDU 
E 3
I 3
TP_CLOSED		<==		 TP_CONFIRMING								T_ACPT_req
E 3
	DEFAULT /* emit failed */
	{
D 17
		register struct tp_ref *r = $P.tp_refp;

E 17
		IFDEBUG(D_CONN)
			printf("event: CR_TPDU emit CC failed done " );
		ENDDEBUG
I 3
		soisdisconnected($P.tp_sock);
E 3
D 17
		tp_recycle_tsuffix( $P );
		tp_freeref(r);
E 17
I 17
		tp_recycle_tsuffix($P);
		tp_freeref($P.tp_lref);
E 17
		tp_detach($P);
	}
;

/* applicable in TP4, TP0 */
TP_CRSENT		<==		TP_CLOSED								T_CONN_req 
	DEFAULT
	{
		int error;
D 2
		extern struct mbuf *m_copy();
E 2
		struct mbuf *data = MNULL;

		IFTRACE(D_CONN)
D 2
			tptrace(TPPTmisc, "T_CONN_req flags sbcc", (int)$P.tp_flags,
			$P.tp_sock->so_snd.sb_cc, 0, 0);
E 2
I 2
			tptrace(TPPTmisc, "T_CONN_req flags ucddata", (int)$P.tp_flags,
			$P.tp_ucddata, 0, 0);
E 2
		ENDTRACE
D 2
		if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
E 2
I 2
		data =  MCPY($P.tp_ucddata, M_WAIT);
		if (data) {
E 2
			IFDEBUG(D_CONN)
				printf("T_CONN_req.trans m_copy cc 0x%x\n", 
D 2
					$P.tp_sock->so_snd.sb_cc);
				dump_mbuf($P.tp_sock->so_snd.sb_mb, "sosnd @ T_CONN_req");
E 2
I 2
					$P.tp_ucddata);
				dump_mbuf(data, "sosnd @ T_CONN_req");
E 2
			ENDDEBUG
D 2
			data = 
				m_copy($P.tp_sock->so_snd.sb_mb, 0, $P.tp_sock->so_snd.sb_cc);
			if( data == MNULL ) {
				return ENOBUFS;
			}
E 2
		}

		if (error = tp_emit(CR_TPDU_type, $P, 0, 0, data) )
			return error; /* driver WON'T change state; will return error */
		
D 15
		$P.tp_refp->tpr_state = REF_OPEN; /* has timers */
E 15
I 15
		$P.tp_refstate = REF_OPEN; /* has timers */
E 15
		if($P.tp_class != TP_CLASS_0) {
			$P.tp_retrans = $P.tp_Nretrans;
D 15
			tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_cr_ticks);
E 15
I 15
			tp_ctimeout($P, TM_retrans, (int)$P.tp_cr_ticks);
E 15
		}
	}
;

/* applicable in TP4, TP0, but state TP_AKWAIT doesn't apply to TP0 */
TP_REFWAIT 		<==		[ TP_CRSENT, TP_AKWAIT, TP_OPEN ] 			DR_TPDU 
	DEFAULT
	{
D 8
		if ($$.e_datalen > 0 && $P.tp_class != TP_CLASS_0) {
D 2
			sbdrop(&$P.tp_Xrcv, $P.tp_Xrcv.sb_cc); /* purge expedited data */
E 2
I 2
			/*sbdrop(&$P.tp_Xrcv, $P.tp_Xrcv.sb_cc); /* purge expedited data */
			sbflush(&$P.tp_Xrcv);
E 8
I 8
		sbflush(&$P.tp_Xrcv); /* purge non-delivered data data */
		if ($$.e_datalen > 0) {
E 8
E 2
D 7
			$P.tp_flags |= TPF_DISC_DATA_IN;
E 7
			sbappendrecord(&$P.tp_Xrcv, $$.e_data);
			$$.e_data = MNULL;
		} 
D 8
		tp_indicate(T_DISCONNECT, $P, TP_ERROR_MASK | (u_short)$$.e_reason);
E 8
I 8
D 16
		tp_indicate(T_DISCONNECT, $P, 0);
E 16
I 16
		if ($P.tp_state == TP_OPEN)
			tp_indicate(T_DISCONNECT, $P, 0);
		else {
			int so_error = ECONNREFUSED;
			if ($$.e_reason != (E_TP_NO_SESSION ^ TP_ERROR_MASK) &&
			    $$.e_reason != (E_TP_NO_CR_ON_NC ^ TP_ERROR_MASK) &&
			    $$.e_reason != (E_TP_REF_OVERFLOW ^ TP_ERROR_MASK))
				so_error = ECONNABORTED;
			tp_indicate(T_DISCONNECT, $P, so_error);
		}
E 16
E 8
		tp_soisdisconnected($P);
		if ($P.tp_class != TP_CLASS_0) {
			if ($P.tp_state == TP_OPEN ) {
D 15
				tp_euntimeout($P.tp_refp, TM_data_retrans); /* all */
				tp_cuntimeout($P.tp_refp, TM_retrans);
				tp_cuntimeout($P.tp_refp, TM_inact);
				tp_cuntimeout($P.tp_refp, TM_sendack);
E 15
I 15
				tp_euntimeout($P, TM_data_retrans); /* all */
				tp_cuntimeout($P, TM_retrans);
				tp_cuntimeout($P, TM_inact);
				tp_cuntimeout($P, TM_sendack);
I 20
				$P.tp_flags &= ~TPF_DELACK;
E 20
E 15
			}
D 15
			tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
			tp_cuntimeout($P, TM_retrans);
E 15
			if( $$.e_sref !=  0 ) 
				(void) tp_emit(DC_TPDU_type, $P, 0, 0, MNULL);
		}
	}
;

SAME 			<==		TP_CLOSED 									DR_TPDU 
	DEFAULT
	{
		if( $$.e_sref != 0 )
			(void) tp_emit(DC_TPDU_type, $P, 0, 0, MNULL); 
		/* reference timer already set - reset it to be safe (???) */
D 15
		tp_euntimeout($P.tp_refp, TM_reference); /* all */
		tp_etimeout($P.tp_refp, TM_reference, 0, 0, 0, (int)$P.tp_refer_ticks);
E 15
I 15
		tp_euntimeout($P, TM_reference); /* all */
		tp_etimeout($P, TM_reference, (int)$P.tp_refer_ticks);
E 15
	}
;

/* NBS(34) */
TP_REFWAIT 		<==  	TP_CRSENT  									ER_TPDU
	DEFAULT
	{	
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
D 8
		tp_indicate(T_DISCONNECT, $P, 
			TP_ERROR_MASK |(u_short)($$.e_reason | 0x40));
E 8
I 8
		tp_indicate(ER_TPDU, $P, $$.e_reason);
E 8
		tp_soisdisconnected($P);
	}
;

/* NBS(27) */
TP_REFWAIT		<==		TP_CLOSING									DR_TPDU
	DEFAULT
	{	 
D 8
		$P.tp_sock->so_error = (u_short)$$.e_reason;
E 8
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
		tp_soisdisconnected($P);
	}
;
/* these two transitions are the same but can't be combined because xebec
 * can't handle the use of $$.e_reason if they're combined
 */
/* NBS(27) */
TP_REFWAIT		<==		TP_CLOSING									ER_TPDU
	DEFAULT
	{	 
D 8
		$P.tp_sock->so_error = (u_short)$$.e_reason;
E 8
I 8
		tp_indicate(ER_TPDU, $P, $$.e_reason);
E 8
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
		tp_soisdisconnected($P);
	}
;
/* NBS(27) */
TP_REFWAIT		<==		TP_CLOSING									DC_TPDU 
	DEFAULT
	{	 
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
		tp_soisdisconnected($P);
	}
;

/* NBS(21) */
SAME 			<== 	TP_CLOSED 						[ CC_TPDU, CR_TPDU ]
	DEFAULT
	{	/* don't ask me why we have to do this - spec says so */
		(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_NO_SESSION, MNULL);
		/* don't bother with retransmissions of the DR */
	}
;

/* NBS(34) */
TP_REFWAIT 		<== 	TP_OPEN  				 					ER_TPDU
	($P.tp_class == TP_CLASS_0)
	{
		tp_soisdisconnecting($P.tp_sock);
D 8
		tp_indicate(T_DISCONNECT, $P, 
			TP_ERROR_MASK |(u_short)($$.e_reason | 0x40));

E 8
I 8
		tp_indicate(ER_TPDU, $P, $$.e_reason);
E 8
		tp_soisdisconnected($P);
		tp_netcmd( $P, CONN_CLOSE );
	}
;

TP_CLOSING 		<== 	[ TP_AKWAIT, TP_OPEN ]  					ER_TPDU
	DEFAULT
	{
		if ($P.tp_state == TP_OPEN) {
D 15
			tp_euntimeout($P.tp_refp, TM_data_retrans); /* all */
			tp_cuntimeout($P.tp_refp, TM_inact);
			tp_cuntimeout($P.tp_refp, TM_sendack);
E 15
I 15
			tp_euntimeout($P, TM_data_retrans); /* all */
			tp_cuntimeout($P, TM_inact);
			tp_cuntimeout($P, TM_sendack);
E 15
		}
		tp_soisdisconnecting($P.tp_sock);
D 8
		tp_indicate(T_DISCONNECT, $P, 
			TP_ERROR_MASK |(u_short)($$.e_reason | 0x40));
E 8
I 8
		tp_indicate(ER_TPDU, $P, $$.e_reason);
E 8
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15
		(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_PROTO_ERR, MNULL);
	}
;
/* NBS(6) */
TP_OPEN			<==		TP_CRSENT									CC_TPDU 
	($P.tp_class == TP_CLASS_0) 
	{	
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
		IncStat(ts_tp0_conn);
		$P.tp_fcredit = 1;
		soisconnected($P.tp_sock);
	}
;

TP_OPEN			<==		TP_CRSENT									CC_TPDU 
	DEFAULT
	{	
		IFDEBUG(D_CONN)
			printf("trans: CC_TPDU in CRSENT state flags 0x%x\n", 
				(int)$P.tp_flags);
		ENDDEBUG
		IncStat(ts_tp4_conn);
		$P.tp_fref = $$.e_sref;
		$P.tp_fcredit = $$.e_cdt;
I 5
D 15
		$P.tp_ackrcvd = 0;
E 15
E 5
D 7
		if($P.tp_rx_strat & TPRX_FASTSTART)
E 7
I 7
		if (($P.tp_rx_strat & TPRX_FASTSTART) && ($$.e_cdt > 0))
E 7
D 15
			$P.tp_cong_win = $$.e_cdt;
E 15
I 15
			$P.tp_cong_win = $$.e_cdt * $P.tp_l_tpdusize;
E 15
		tp_getoptions($P);
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15
D 2
		if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
E 2
I 2
		if ($P.tp_ucddata) {
E 2
			IFDEBUG(D_CONN)
D 2
				printf("dropping %d octets of connect data cc 0x%x\n",
					$P.tp_sock->so_snd.sb_mb->m_len, 
					$P.tp_sock->so_snd.sb_cc);
E 2
I 2
				printf("dropping user connect data cc 0x%x\n",
					$P.tp_ucddata->m_len);
E 2
			ENDDEBUG
D 2
			sbdrop(&$P.tp_sock->so_snd, $P.tp_sock->so_snd.sb_cc);
			$P.tp_flags &= ~TPF_CONN_DATA_OUT;
E 2
I 2
			m_freem($P.tp_ucddata);
			$P.tp_ucddata = 0;
E 2
		}
		soisconnected($P.tp_sock);
		if ($$.e_datalen > 0) {
			ASSERT($P.tp_Xrcv.sb_cc == 0); /* should be empty */
			sbappendrecord(&$P.tp_Xrcv, $$.e_data);
D 7
			$P.tp_flags |= TPF_CONN_DATA_IN;
E 7
			$$.e_data = MNULL;
		}

		(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL);
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
	}
;

/* TP4 only */
SAME			<==		TP_CRSENT									TM_retrans 
	(	$P.tp_retrans > 0 )
	{
D 2
		extern struct mbuf *m_copy();
E 2
		struct mbuf *data = MNULL;
		int error;

		IncStat(ts_retrans_cr);
I 5
D 15
		$P.tp_cong_win = 1;
		$P.tp_ackrcvd = 0;
E 15
I 15
		$P.tp_cong_win = 1 * $P.tp_l_tpdusize;
E 15
E 5
D 2
		if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
E 2
I 2
		data = MCPY($P.tp_ucddata, M_NOWAIT);
		if($P.tp_ucddata) {
E 2
			IFDEBUG(D_CONN)
D 2
				printf("TM_retrans.trans m_copy cc 0x%x\n", 
					$P.tp_sock->so_snd.sb_cc);
				dump_mbuf($P.tp_sock->so_snd.sb_mb, "sosnd @ TM_retrans");
E 2
I 2
				printf("TM_retrans.trans m_copy cc 0x%x\n", data);
				dump_mbuf($P.tp_ucddata, "sosnd @ TM_retrans");
E 2
			ENDDEBUG
D 2
			data = 
				m_copy($P.tp_sock->so_snd.sb_mb, 0, $P.tp_sock->so_snd.sb_cc);
E 2
			if( data == MNULL )
				return ENOBUFS;
		}

		$P.tp_retrans --;
		if( error = tp_emit(CR_TPDU_type, $P, 0, 0, data) ) {
			$P.tp_sock->so_error = error;
		}
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_cr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_cr_ticks);
E 15
	}
;

/* TP4 only  */
TP_REFWAIT		<==		TP_CRSENT									TM_retrans 
	DEFAULT /* no more CR retransmissions */
	{ 	
		IncStat(ts_conn_gaveup);
		$P.tp_sock->so_error = ETIMEDOUT;
		tp_indicate(T_DISCONNECT, $P, ETIMEDOUT);
		tp_soisdisconnected($P);
	}
;

/* TP4 only */
SAME 			<==	 TP_AKWAIT											CR_TPDU 
	DEFAULT
	/* duplicate CR (which doesn't really exist in the context of
	 * a connectionless network layer) 
	 * Doesn't occur in class 0.
	 */
	{	
		int error;
I 2
		struct mbuf *data = MCPY($P.tp_ucddata, M_WAIT);
E 2

D 2
		if( error = tp_emit(CC_TPDU_type, $P, 0, 0, MNULL) ) {
E 2
I 2
		if( error = tp_emit(CC_TPDU_type, $P, 0, 0, data) ) {
E 2
			$P.tp_sock->so_error = error;
		}
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_cc_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_cc_ticks);
E 15
	}
;

/* TP4 only */
TP_OPEN			<==		TP_AKWAIT 										DT_TPDU 
	( IN_RWINDOW( $P, $$.e_seq,
					$P.tp_rcvnxt, SEQ($P, $P.tp_rcvnxt + $P.tp_lcredit)) )
	{
		int doack;

D 2
		if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
			sbdrop(&$P.tp_sock->so_snd, $P.tp_sock->so_snd.sb_cc);
			$P.tp_flags &= ~TPF_CONN_DATA_OUT;
E 2
I 2
		/*
		 * Get rid of any confirm or connect data, so that if we
		 * crash or close, it isn't thought of as disconnect data.
		 */
		if ($P.tp_ucddata) {
			m_freem($P.tp_ucddata);
			$P.tp_ucddata = 0;
E 2
		}
D 2

E 2
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
		tp_cuntimeout($P, TM_retrans);
E 15
		soisconnected($P.tp_sock);
D 13
		tp_getoptions($P);
E 13
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15

		/* see also next 2 transitions, if you make any changes */

		doack = tp_stash($P, $E);
		IFDEBUG(D_DATA)
			printf("tp_stash returns %d\n",doack);
		ENDDEBUG

D 15
		if(doack) {
E 15
I 15
		if (doack) {
E 15
			(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL ); 
D 15
			tp_ctimeout($P.tp_refp, TM_sendack, (int)$P.tp_keepalive_ticks);
E 15
I 15
			tp_ctimeout($P, TM_sendack, (int)$P.tp_keepalive_ticks);
E 15
		} else
D 15
			tp_ctimeout( $P.tp_refp, TM_sendack, (int)$P.tp_sendack_ticks);
E 15
I 15
			tp_ctimeout( $P, TM_sendack, (int)$P.tp_sendack_ticks);
E 15
		
		IFDEBUG(D_DATA)
			printf("after stash calling sbwakeup\n");
		ENDDEBUG
	}
;

SAME			<==		TP_OPEN 									DT_TPDU 
	( $P.tp_class == TP_CLASS_0 )
	{
		tp0_stash($P, $E);
		sbwakeup( &$P.tp_sock->so_rcv );

		IFDEBUG(D_DATA)
			printf("after stash calling sbwakeup\n");
		ENDDEBUG
	}
;

/* TP4 only */
SAME			<==		TP_OPEN 									DT_TPDU 
	( IN_RWINDOW( $P, $$.e_seq,
					$P.tp_rcvnxt, SEQ($P, $P.tp_rcvnxt + $P.tp_lcredit)) )
	{
		int doack; /* tells if we must ack immediately */

D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		sbwakeup( &$P.tp_sock->so_rcv );

		doack = tp_stash($P, $E);
		IFDEBUG(D_DATA)
			printf("tp_stash returns %d\n",doack);
		ENDDEBUG

		if(doack)
			(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL ); 
		else
D 15
			tp_ctimeout_MIN( $P.tp_refp, TM_sendack, (int)$P.tp_sendack_ticks);
E 15
I 15
			tp_ctimeout_MIN( $P, TM_sendack, (int)$P.tp_sendack_ticks);
E 15
		
		IFDEBUG(D_DATA)
			printf("after stash calling sbwakeup\n");
		ENDDEBUG
	}
;

/* Not in window  - we must ack under certain circumstances, namely
 * a) if the seq number is below lwe but > lwe - (max credit ever given)
 * (to handle lost acks) Can use max-possible-credit for this ^^^.
 * and 
 * b) seq number is > uwe but < uwe + previously sent & withdrawn credit
 *
 * (see 12.2.3.8.1 of ISO spec, p. 73)
 * We just always ack.
 */
/* TP4 only */
SAME 			<== 	[ TP_OPEN, TP_AKWAIT ]							DT_TPDU
	DEFAULT /* Not in window */
	{ 	
		IFTRACE(D_DATA)
			tptrace(TPPTmisc, "NIW seq rcvnxt lcredit ",
				$$.e_seq, $P.tp_rcvnxt, $P.tp_lcredit, 0);
		ENDTRACE
		IncStat(ts_dt_niw);
		m_freem($$.e_data);
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL ); 
	}
;

/* TP4 only */
TP_OPEN			<==		TP_AKWAIT										AK_TPDU
	DEFAULT
	{
D 2
		if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
			sbdrop(&$P.tp_sock->so_snd, $P.tp_sock->so_snd.sb_cc);
			$P.tp_flags &= ~TPF_CONN_DATA_OUT;
E 2
I 2
		if ($P.tp_ucddata) {
			m_freem($P.tp_ucddata);
			$P.tp_ucddata = 0;
E 2
		}
D 2

E 2
		(void) tp_goodack($P, $$.e_cdt, $$.e_seq, $$.e_subseq);
D 15
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_cuntimeout($P, TM_retrans);
E 15

D 13
		tp_getoptions($P);
E 13
		soisconnected($P.tp_sock);
		IFTRACE(D_CONN)
			struct socket *so = $P.tp_sock;
			tptrace(TPPTmisc, 
			"called sosiconn: so so_state rcv.sb_sel rcv.sb_flags",
				so, so->so_state, so->so_rcv.sb_sel, so->so_rcv.sb_flags);
			tptrace(TPPTmisc, 
			"called sosiconn 2: so_qlen so_error so_rcv.sb_cc so_head",
				so->so_qlen, so->so_error, so->so_rcv.sb_cc, so->so_head);
		ENDTRACE

D 15
		tp_ctimeout($P.tp_refp, TM_sendack, (int)$P.tp_keepalive_ticks);
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_sendack, (int)$P.tp_keepalive_ticks);
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
	}
;

/* TP4 only */
TP_OPEN 		<== 	[ TP_OPEN, TP_AKWAIT ]						XPD_TPDU
D 2
	( $P.tp_Xrcvnxt == $$.e_seq  && $P.tp_Xrcv.sb_cc == 0)
E 2
I 2
D 7
	( $P.tp_Xrcvnxt == $$.e_seq  /* && $P.tp_Xrcv.sb_cc == 0*/)
E 7
I 7
	($P.tp_Xrcvnxt == $$.e_seq)
E 7
E 2
	{
		if( $P.tp_state == TP_AKWAIT ) {
D 2
			if( $P.tp_flags & TPF_CONN_DATA_OUT ) {
				sbdrop(&$P.tp_sock->so_snd, $P.tp_sock->so_snd.sb_cc);
				$P.tp_flags &= ~TPF_CONN_DATA_OUT;
E 2
I 2
			if ($P.tp_ucddata) {
				m_freem($P.tp_ucddata);
				$P.tp_ucddata = 0;
E 2
			}
D 15
			tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
			tp_cuntimeout($P, TM_retrans);
E 15
D 13
			tp_getoptions($P);
E 13
			soisconnected($P.tp_sock);
D 15
			tp_ctimeout($P.tp_refp, TM_sendack, (int)$P.tp_keepalive_ticks);
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
			tp_ctimeout($P, TM_sendack, (int)$P.tp_keepalive_ticks);
			tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		} 
		IFTRACE(D_XPD)
		tptrace(TPPTmisc, "XPD tpdu accepted Xrcvnxt, e_seq datalen m_len\n",
				$P.tp_Xrcvnxt,$$.e_seq,  $$.e_datalen, $$.e_data->m_len);
		ENDTRACE

D 2
		sbappendrecord(&$P.tp_Xrcv, $$.e_data);
E 2
I 2
		$P.tp_sock->so_state |= SS_RCVATMARK;
I 7
		$$.e_data->m_flags |= M_EOR;
E 7
		sbinsertoob(&$P.tp_Xrcv, $$.e_data);
E 2
		IFDEBUG(D_XPD)
			dump_mbuf($$.e_data, "XPD TPDU: tp_Xrcv");
		ENDDEBUG
D 2
		$P.tp_flags |= TPF_XPD_PRESENT;
		/* kludge for select(): */ 
		$P.tp_sock->so_state |= SS_OOBAVAIL;
E 2
		tp_indicate(T_XDATA, $P, 0);
		sbwakeup( &$P.tp_Xrcv );

		(void) tp_emit(XAK_TPDU_type, $P, $P.tp_Xrcvnxt, 0, MNULL);
		SEQ_INC($P, $P.tp_Xrcvnxt);
	}
;

/* TP4 only */
SAME			<==		TP_OPEN 									T_USR_Xrcvd
	DEFAULT
	{
		if( $P.tp_Xrcv.sb_cc == 0 ) {
D 2
			$P.tp_flags &= ~TPF_XPD_PRESENT;
E 2
I 2
D 7
			/*$P.tp_flags &= ~TPF_XPD_PRESENT;*/
E 7
E 2
			/* kludge for select(): */ 
D 2
			$P.tp_sock->so_state &= ~SS_OOBAVAIL;
E 2
I 2
			/* $P.tp_sock->so_state &= ~SS_OOBAVAIL; */
E 2
		}
	}
	/* OLD WAY:
	 * Ack only after the user receives the XPD.  This is better for 
	 * users that use one XPD right after another.
	 * Acking right away (the NEW WAY, see the prev. transition) is 
	 * better for occasional * XPD, when the receiving user doesn't 
	 * want to read the XPD immediately (which is session's behavior).
	 *
		int error = tp_emit(XAK_TPDU_type, $P, $P.tp_Xrcvnxt, 0, MNULL);
		SEQ_INC($P, $P.tp_Xrcvnxt);
		return error;
	*/
;

/* NOTE: presently if the user doesn't read the connection data
 * before and expedited data PDU comes in, the connection data will
 * be dropped. This is a bug.  To avoid it, we need somewhere else
 * to put the connection data.
 * On the other hand, we need not to have it sitting around forever.
 * This is a problem with the idea of trying to accommodate
 * data on connect w/ a passive-open user interface. 
 */
/* TP4 only */

SAME	 		<== 	[ TP_AKWAIT, TP_OPEN ] 							XPD_TPDU
	DEFAULT /* not in window or cdt==0 */
	{
		IFTRACE(D_XPD)
			tptrace(TPPTmisc, "XPD tpdu niw (Xrcvnxt, e_seq) or not cdt (cc)\n",
				$P.tp_Xrcvnxt, $$.e_seq,  $P.tp_Xrcv.sb_cc , 0);
		ENDTRACE
		if( $P.tp_Xrcvnxt != $$.e_seq )
			IncStat(ts_xpd_niw);
		if( $P.tp_Xrcv.sb_cc ) {
I 2
D 7
#ifdef notdef
E 2
			if( $P.tp_flags & TPF_CONN_DATA_IN ) {
				/* user isn't reading the connection data; see note above */
				sbdrop(&$P.tp_Xrcv, $P.tp_Xrcv.sb_cc);
				$P.tp_flags &= ~TPF_CONN_DATA_IN;
			}
I 2
#endif notdef
E 7
E 2
			/* might as well kick 'em again */
			tp_indicate(T_XDATA, $P, 0);
			IncStat(ts_xpd_dup);
		}
		m_freem($$.e_data);
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		/* don't send an xack because the xak gives "last one received", not
		 * "next one i expect" (dumb)
		 */
	}
;

/* Occurs (AKWAIT, OPEN) when parent (listening) socket gets aborted, and tries
 * to detach all its "children"
 * Also (CRSENT) when user kills a job that's doing a connect()
 */
TP_REFWAIT		<== 	TP_CRSENT 										T_DETACH
	($P.tp_class == TP_CLASS_0)
	{
		struct socket *so = $P.tp_sock;

		/* detach from parent socket so it can finish closing */
		if (so->so_head) {
			if (!soqremque(so, 0) && !soqremque(so, 1))
				panic("tp: T_DETACH");
			so->so_head = 0;
		}
		tp_soisdisconnecting($P.tp_sock);
		tp_netcmd( $P, CONN_CLOSE);
		tp_soisdisconnected($P);
	}
;

/* TP4 only */
D 3
TP_CLOSING		<== 	[ TP_CLOSING, TP_AKWAIT, TP_CRSENT ]			T_DETACH
E 3
I 3
TP_CLOSING		<== [ TP_CLOSING, TP_AKWAIT, TP_CRSENT, TP_CONFIRMING ]	T_DETACH
E 3
	DEFAULT
	{
		struct socket *so = $P.tp_sock;
I 2
		struct mbuf *data = MNULL;
E 2

		/* detach from parent socket so it can finish closing */
		if (so->so_head) {
			if (!soqremque(so, 0) && !soqremque(so, 1))
				panic("tp: T_DETACH");
			so->so_head = 0;
		}
		if ($P.tp_state != TP_CLOSING) {
			tp_soisdisconnecting($P.tp_sock);
D 2
			(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_NORMAL_DISC, MNULL);
E 2
I 2
			data = MCPY($P.tp_ucddata, M_NOWAIT);
			(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_NORMAL_DISC, data);
E 2
			$P.tp_retrans = $P.tp_Nretrans;
D 15
			tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
			tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15
		}
	}
;

TP_REFWAIT		<==		[ TP_OPEN, TP_CRSENT ]		 	  			T_DISC_req
	( $P.tp_class == TP_CLASS_0 )
	{
		tp_soisdisconnecting($P.tp_sock);
		tp_netcmd( $P, CONN_CLOSE);
		tp_soisdisconnected($P);
	}
;

/* TP4 only */
D 3
TP_CLOSING		<==		[ TP_AKWAIT, TP_OPEN, TP_CRSENT ]		 	  T_DISC_req
E 3
I 3
TP_CLOSING		<==	[ TP_AKWAIT, TP_OPEN, TP_CRSENT, TP_CONFIRMING ]  T_DISC_req
E 3
	DEFAULT
	{
D 2
		struct mbuf *data = MNULL;
		extern struct mbuf *m_copy();
E 2
I 2
		struct mbuf *data = MCPY($P.tp_ucddata, M_WAIT);
E 2

		if($P.tp_state == TP_OPEN) {
D 15
			tp_euntimeout($P.tp_refp, TM_data_retrans); /* all */
			tp_cuntimeout($P.tp_refp, TM_inact);
			tp_cuntimeout($P.tp_refp, TM_sendack);
E 15
I 15
			tp_euntimeout($P, TM_data_retrans); /* all */
			tp_cuntimeout($P, TM_inact);
			tp_cuntimeout($P, TM_sendack);
I 20
			$P.tp_flags &= ~TPF_DELACK;
E 20
E 15
		}
D 2
		if( $P.tp_flags & TPF_DISC_DATA_OUT ) {
E 2
I 2
		if (data) {
E 2
			IFDEBUG(D_CONN)
D 2
				printf("T_DISC_req.trans m_copy cc 0x%x\n", 
					$P.tp_sock->so_snd.sb_cc);
				dump_mbuf($P.tp_sock->so_snd.sb_mb, "sosnd @ T_DISC_req");
E 2
I 2
				printf("T_DISC_req.trans tp_ucddata 0x%x\n", 
					$P.tp_ucddata);
				dump_mbuf(data, "ucddata @ T_DISC_req");
E 2
			ENDDEBUG
D 2
			data = 
				m_copy($P.tp_sock->so_snd.sb_mb, 0, $P.tp_sock->so_snd.sb_cc);
E 2
		}
D 2

E 2
		tp_soisdisconnecting($P.tp_sock);
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15

		if( trick_hc )
			return tp_emit(DR_TPDU_type, $P, 0, $$.e_reason, data);
	}
;

/* TP4 only */
SAME			<==		TP_AKWAIT									TM_retrans
	( $P.tp_retrans > 0 )
	{
		int error;
I 2
		struct mbuf *data = MCPY($P.tp_ucddata, M_WAIT);
E 2

		IncStat(ts_retrans_cc);
		$P.tp_retrans --;
I 5
D 15
		$P.tp_cong_win = 1;
		$P.tp_ackrcvd = 0;
E 15
I 15
		$P.tp_cong_win = 1 * $P.tp_l_tpdusize;
E 15

E 5
D 2
		if( error = tp_emit(CC_TPDU_type, $P, 0, 0, MNULL) ) 
E 2
I 2
		if( error = tp_emit(CC_TPDU_type, $P, 0, 0, data) ) 
E 2
			$P.tp_sock->so_error = error;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_cc_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_cc_ticks);
E 15
	}
;

/* TP4 only */
TP_CLOSING		<==		TP_AKWAIT									TM_retrans
	DEFAULT  /* out of time */
	{
		IncStat(ts_conn_gaveup);
		tp_soisdisconnecting($P.tp_sock);
		$P.tp_sock->so_error = ETIMEDOUT;
		tp_indicate(T_DISCONNECT, $P, ETIMEDOUT);
		(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_CONGEST, MNULL);
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15
	}
;

/* the retrans timers had better go off BEFORE the inactivity timer does,
 * if transmissions are going on.
 * (i.e., TM_inact should be greater than timer for all retrans plus ack
 * turnaround)
 */
/* TP4 only */
TP_CLOSING 		<==		TP_OPEN		   [ TM_inact, TM_retrans, TM_data_retrans ]
	DEFAULT
	{
D 15
		tp_euntimeout($P.tp_refp, TM_data_retrans); /* all */
		tp_cuntimeout($P.tp_refp, TM_inact); 
		tp_cuntimeout($P.tp_refp, TM_sendack);
E 15
I 15
		tp_euntimeout($P, TM_data_retrans); /* all */
		tp_cuntimeout($P, TM_inact); 
		tp_cuntimeout($P, TM_sendack);
E 15

		IncStat(ts_conn_gaveup);
		tp_soisdisconnecting($P.tp_sock);
		$P.tp_sock->so_error = ETIMEDOUT;
		tp_indicate(T_DISCONNECT, $P, ETIMEDOUT);
		(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_CONGEST_2, MNULL);
		$P.tp_retrans = $P.tp_Nretrans;
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15
	}
;

/* TP4 only */
SAME			<==		TP_OPEN										TM_retrans
	( $P.tp_retrans > 0 )
	{
I 5
D 15
		$P.tp_cong_win = 1;
		$P.tp_ackrcvd = 0;
E 15
I 15
		$P.tp_cong_win = 1 * $P.tp_l_tpdusize;
E 15
E 5
		/* resume XPD */
		if	( $P.tp_Xsnd.sb_mb )  {
D 2
			extern struct mbuf *m_copy();
			struct mbuf *m = m_copy($P.tp_Xsnd.sb_mb, 0, $P.tp_Xsnd.sb_cc);
E 2
I 2
			struct mbuf *m = m_copy($P.tp_Xsnd.sb_mb, 0, (int)$P.tp_Xsnd.sb_cc);
E 2
D 15
			/* m_copy doesn't preserve the m_xlink field, but at this pt.
			 * that doesn't matter
			 */
E 15
I 15
			int shift;
E 15

			IFTRACE(D_XPD)
D 15
				tptrace(TPPTmisc, "XPD retrans: Xuna Xsndnxt sndhiwat snduna",
					$P.tp_Xuna, $P.tp_Xsndnxt, $P.tp_sndhiwat, 
E 15
I 15
				tptrace(TPPTmisc, "XPD retrans: Xuna Xsndnxt sndnxt snduna",
					$P.tp_Xuna, $P.tp_Xsndnxt, $P.tp_sndnxt, 
E 15
					$P.tp_snduna); 
			ENDTRACE
			IFDEBUG(D_XPD)
				dump_mbuf(m, "XPD retrans emitting M");
			ENDDEBUG
			IncStat(ts_retrans_xpd);
			$P.tp_retrans --;
I 15
			shift = max($P.tp_Nretrans - $P.tp_retrans, 6);
E 15
			(void) tp_emit(XPD_TPDU_type, $P, $P.tp_Xuna, 1, m);
D 15
			tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_xpd_ticks);
E 15
I 15
			tp_ctimeout($P, TM_retrans, ((int)$P.tp_dt_ticks) << shift);
E 15
		}
	}
;

/* TP4 only */
SAME 			<==		TP_OPEN									TM_data_retrans
D 15
	( $$.e_retrans > 0 )
E 15
I 15
	($P.tp_rxtshift < TP_NRETRANS)
E 15
	{	
D 15
		register 	SeqNum			low, lowsave = 0;
D 12
		register	struct tp_rtc 	*r = $P.tp_snduna_rtc;
		register	struct mbuf 	*m;
E 12
I 12
		register	struct mbuf 	*m, *n = $P.tp_sock->so_snd.sb_mb;
E 12
		register	SeqNum			high = $$.e_high;
D 2
		extern		struct mbuf		*m_copy();
E 2

D 5
		low =
			SEQ_GT($P, $P.tp_snduna, $$.e_low )? $P.tp_snduna: $$.e_low;
		lowsave = low;
E 5
I 5
		low = $P.tp_snduna;
		lowsave = high = low;

		tp_euntimeout_lss($P.tp_refp, TM_data_retrans,
			SEQ_ADD($P, $P.tp_sndhiwat, 1));
		$P.tp_retrans_hiwat = $P.tp_sndhiwat;

E 5
		if (($P.tp_rx_strat & TPRX_EACH) == 0)
			high = (high>low)?low:high;

		if( $P.tp_rx_strat & TPRX_USE_CW ) {
			register int i;

			$P.tp_cong_win = 1;
D 5

E 5
I 5
			$P.tp_ackrcvd = 0;
E 5
			i = SEQ_ADD($P, low, $P.tp_cong_win);
D 5
			if(SEQ_LT($P, i, high ))
				high = i;
E 5
I 5

			high = SEQ_MIN($P, high, $P.tp_sndhiwat);

E 5
		}

D 12
		while( SEQ_LEQ($P, low, high) ){
			if ( r == (struct tp_rtc *)0 ){
				IFDEBUG(D_RTC)
					printf( "tp: retrans rtc list is GONE!\n");
				ENDDEBUG
				break;
			}
			if ( r->tprt_seq == low ){
				if(( m = m_copy(r->tprt_data, 0, r->tprt_octets ))== MNULL)
E 12
I 12
		while (SEQ_LEQ($P, low, high)) {
			if (n) {
				if ((m = m_copy(n, 0, M_COPYALL))== MNULL)
E 12
					break;
D 12
				(void) tp_emit(DT_TPDU_type, $P, low, r->tprt_eot, m);
E 12
I 12
				(void) tp_emit(DT_TPDU_type, $P,
					low, (m->m_flags & M_EOR) != 0, m);
E 12
				IncStat(ts_retrans_dt);
				SEQ_INC($P, low );
			}
D 12
			r = r->tprt_next;
E 12
I 12
			n = n->m_nextpkt;
E 12
		}
I 5
/* CE_BIT
E 5
		if ( SEQ_LEQ($P, lowsave, high) ){
I 5
*/
E 5
			$$.e_retrans --;
			tp_etimeout($P.tp_refp, TM_data_retrans, (caddr_t)lowsave,
					(caddr_t)high, $$.e_retrans,
					($P.tp_Nretrans - $$.e_retrans) * (int)$P.tp_dt_ticks);
I 5
/* CE_BIT
E 5
		}
I 5
*/
E 15
I 15
		$P.tp_rxtshift++;
		(void) tp_data_retrans($P);
E 15
E 5
	}
;

/* TP4 only */
SAME	 		<==		TP_CLOSING									TM_retrans
	(	$P.tp_retrans > 0 )
	{	
		$P.tp_retrans --;
		(void) tp_emit(DR_TPDU_type, $P, 0, E_TP_DR_NO_REAS, MNULL);
		IncStat(ts_retrans_dr);
D 15
		tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_dr_ticks);
E 15
I 15
		tp_ctimeout($P, TM_retrans, (int)$P.tp_dr_ticks);
E 15
	}
;

/* TP4 only */
TP_REFWAIT 		<==		TP_CLOSING									TM_retrans
	DEFAULT	/* no more retrans - gave up */
	{	
		$P.tp_sock->so_error = ETIMEDOUT;
D 15
		$P.tp_refp->tpr_state = REF_FROZEN;
E 15
I 15
		$P.tp_refstate = REF_FROZEN;
E 15
		tp_recycle_tsuffix( $P );
D 15
		tp_etimeout($P.tp_refp, TM_reference, 0,0,0, (int)$P.tp_refer_ticks);
E 15
I 15
		tp_etimeout($P, TM_reference, (int)$P.tp_refer_ticks);
E 15
	}
;

/*
 * The resources are kept around until the ref timer goes off.
 * The suffices are wiped out sooner so they can be reused right away.
 */
/* applicable in TP4, TP0 */
TP_CLOSED 		<==		TP_REFWAIT 									TM_reference
	DEFAULT
	{
D 17
		tp_freeref($P.tp_refp);
E 17
I 17
		tp_freeref($P.tp_lref);
E 17
		tp_detach($P);
	}
;

/* applicable in TP4, TP0 */
/* A duplicate CR from connectionless network layer can't happen */
SAME 			<== 	TP_OPEN 							[ CR_TPDU, CC_TPDU ]
	DEFAULT
	{	
		if( $P.tp_class != TP_CLASS_0) {
D 15
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
			tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
			if ( $E.ev_number == CC_TPDU )
				(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL); 
		}
		/* ignore it if class 0 - state tables are blank for this */
	}
;

/* applicable in TP4, TP0 */
SAME			<== 	TP_OPEN									T_DATA_req
	DEFAULT
	{
		IFTRACE(D_DATA)
D 15
			tptrace(TPPTmisc, "T_DATA_req sndhiwat snduna fcredit, tpcb",
				$P.tp_sndhiwat, $P.tp_snduna, $P.tp_fcredit, $P);
E 15
I 15
			tptrace(TPPTmisc, "T_DATA_req sndnxt snduna fcredit, tpcb",
				$P.tp_sndnxt, $P.tp_snduna, $P.tp_fcredit, $P);
E 15
		ENDTRACE

		tp_send($P);
	}
;

/* TP4 only */
SAME			<==		TP_OPEN										T_XPD_req
	DEFAULT
		/* T_XPD_req was issued by sosend iff xpd socket buf was empty
		 * at time of sosend(), 
		 * AND (which means) there were no unacknowledged XPD tpdus outstanding!
		 */
	{
		int error = 0;

		/* resume XPD */
		if	( $P.tp_Xsnd.sb_mb )  {
D 2
			extern struct mbuf *m_copy();
			struct mbuf *m = m_copy($P.tp_Xsnd.sb_mb, 0, $P.tp_Xsnd.sb_cc);
E 2
I 2
			struct mbuf *m = m_copy($P.tp_Xsnd.sb_mb, 0, (int)$P.tp_Xsnd.sb_cc);
E 2
			/* m_copy doesn't preserve the m_xlink field, but at this pt.
			 * that doesn't matter
			 */

			IFTRACE(D_XPD)
D 15
				tptrace(TPPTmisc, "XPD req: Xuna Xsndnxt sndhiwat snduna",
					$P.tp_Xuna, $P.tp_Xsndnxt, $P.tp_sndhiwat, 
E 15
I 15
				tptrace(TPPTmisc, "XPD req: Xuna Xsndnxt sndnxt snduna",
					$P.tp_Xuna, $P.tp_Xsndnxt, $P.tp_sndnxt, 
E 15
					$P.tp_snduna); 
			ENDTRACE
			IFDEBUG(D_XPD)
				printf("T_XPD_req: sb_cc 0x%x\n", $P.tp_Xsnd.sb_cc);
				dump_mbuf(m, "XPD req emitting M");
			ENDDEBUG
			error = 
				tp_emit(XPD_TPDU_type, $P, $P.tp_Xuna, 1, m);
			$P.tp_retrans = $P.tp_Nretrans;
D 15
			tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_xpd_ticks);
E 15
I 15

			tp_ctimeout($P, TM_retrans, (int)$P.tp_rxtcur);
E 15
			SEQ_INC($P, $P.tp_Xsndnxt);
		} 
		if(trick_hc)
			return error;
	}
;

/* TP4, faked ack in TP0 when cons send completes */
SAME 			<==		TP_OPEN 									AK_TPDU
	( tp_goodack($P, $$.e_cdt, $$.e_seq, $$.e_subseq)  )

	/* tp_goodack == true means 
	 * EITHER it actually acked something heretofore unacknowledged
	 * OR no news but the credit should be processed.
	 */
	{
I 12
		struct sockbuf *sb = &$P.tp_sock->so_snd;

E 12
		IFDEBUG(D_ACKRECV)
			printf("GOOD ACK seq 0x%x cdt 0x%x\n", $$.e_seq, $$.e_cdt);
		ENDDEBUG
		if( $P.tp_class != TP_CLASS_0) {
D 15
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
			tp_euntimeout_lss($P.tp_refp, TM_data_retrans, $$.e_seq);
E 15
I 15
			tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		}
D 12
		sbwakeup( &$P.tp_sock->so_snd );

E 12
I 12
		sbwakeup(sb);
E 12
D 5
		tp_send($P);
E 5
I 5
D 15
		if ($P.tp_sndhiwat <= $P.tp_retrans_hiwat &&
			$P.tp_snduna <= $P.tp_retrans_hiwat) {

D 12
			register    struct mbuf     *m;
			/* extern      struct mbuf     *m_copy(); */
			register    struct tp_rtc   *r;
			SeqNum      high, retrans, low_save;
E 12
I 12
			register struct mbuf     *m, *n = sb->sb_mb;
			SeqNum		high, retrans, lowsave;
E 12

			high = SEQ_MIN($P, SEQ_ADD($P, $P.tp_snduna,
					MIN($P.tp_cong_win, $P.tp_fcredit)) - 1,
					$P.tp_sndhiwat);
D 12
			low_save = retrans = SEQ_MAX($P, SEQ_ADD($P, $P.tp_last_retrans, 1),
E 12
I 12
			retrans = SEQ_MAX($P, SEQ_ADD($P, $P.tp_last_retrans, 1),
E 12
					$P.tp_snduna);
I 12
			for (lowsave = $P.tp_snduna;
					SEQ_LT($P, lowsave, retrans); SEQ_INC($P, lowsave))
				n = n->m_nextpkt;
E 12
			for (; SEQ_LEQ($P, retrans, high); SEQ_INC($P, retrans)) {
D 12

				for (r = $P.tp_snduna_rtc; r; r = r->tprt_next){
					if ( r->tprt_seq == retrans ){
						if(( m = m_copy(r->tprt_data, 0, r->tprt_octets ))
								== MNULL)
							break;
						(void) tp_emit(DT_TPDU_type, $P, retrans,
							r->tprt_eot, m);
						$P.tp_last_retrans = retrans;
						IncStat(ts_retrans_dt);
						break;
					}
				}
				if ( r == (struct tp_rtc *)0 ){
E 12
I 12
				if (n == 0) {
E 12
					IFDEBUG(D_RTC)
D 12
						printf( "tp: retrans rtc list is GONE!\n");
E 12
I 12
						printf("tp: retrans list is GONE!\n");
E 12
					ENDDEBUG
					break;
I 12
				} else if (m = m_copy(n, 0, M_COPYALL)) {
					(void) tp_emit(DT_TPDU_type, $P, retrans,
						(m->m_flags & M_EOR) != 0, m);
					$P.tp_last_retrans = retrans;
					IncStat(ts_retrans_dt);
E 12
				}
I 12
				n = n->m_nextpkt;
E 12
			}
D 12
			tp_etimeout($P.tp_refp, TM_data_retrans, (caddr_t)low_save,
E 12
I 12
			tp_etimeout($P.tp_refp, TM_data_retrans, (caddr_t)lowsave,
E 12
					(caddr_t)high, $P.tp_retrans, (int)$P.tp_dt_ticks);
			if (SEQ_DEC($P, retrans) == $P.tp_retrans_hiwat)
				tp_send($P);
		}
		else {
			tp_send($P);
		}
E 15
E 5
		IFDEBUG(D_ACKRECV)
D 15
			printf("GOOD ACK new sndhiwat 0x%x\n", $P.tp_sndhiwat);
E 15
I 15
			printf("GOOD ACK new sndnxt 0x%x\n", $P.tp_sndnxt);
E 15
		ENDDEBUG
	}
;

/* TP4, and TP0 after sending a CC or possibly a CR */
D 6
SAME			<==		TP_OPEN 			 						XAK_TPDU
	DEFAULT
	{
		IFTRACE(D_ACKRECV)
			tptrace(TPPTmisc, "BOGUS XACK eventtype ", $E.ev_number, 0, 0,0);
		ENDTRACE
		if( $P.tp_class != TP_CLASS_0 ) {
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
		} 
	}
;
/* TP4, and TP0 after sending a CC or possibly a CR */
E 6
SAME			<==		TP_OPEN 			 						 AK_TPDU
	DEFAULT
	{
		IFTRACE(D_ACKRECV)
			tptrace(TPPTmisc, "BOGUS ACK fcc_present, tp_r_subseq e_subseq", 
				$$.e_fcc_present, $P.tp_r_subseq, $$.e_subseq, 0);
		ENDTRACE
		if( $P.tp_class != TP_CLASS_0 ) {

			if ( !$$.e_fcc_present ) {
				/* send ACK with FCC */
				IncStat( ts_ackreason[_ACK_FCC_] );
				(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 1, MNULL);
			}
D 15
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
			tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		} 
	}
;

/* NBS(47) */
	/* goes in at *** */
		/* just so happens that this is never true now, because we allow
		 * only 1 packet in the queue at once (this could be changed)
		if	( $P.tp_Xsnd.sb_mb )  {
D 2
			extern struct mbuf *m_copy();
E 2
			struct mbuf *m = m_copy($P.tp_Xsnd.sb_mb, 0, ??);

			(void) tp_emit(XPD_TPDU_type, $P, $P.tp_Xuna, 1, m);
			$P.tp_retrans = $P.tp_Nretrans;
D 15
			tp_ctimeout($P.tp_refp, TM_retrans, (int)$P.tp_xpd_ticks);
E 15
I 15
			tp_ctimeout($P, TM_retrans, (int)$P.tp_xpd_ticks);
E 15
			SEQ_INC($P, $P.tp_Xsndnxt);
		}
		 */
	/* end of the above hack */

/* TP4 only */
D 6
SAME			<== 	TP_OPEN 										XAK_TPDU
E 6
I 6
SAME			<== 	TP_OPEN										XAK_TPDU
E 6
	( tp_goodXack($P, $$.e_seq) )
	/* tp_goodXack checks for good ack, removes the correct 
	 * tpdu from the queue and  returns 1 if ack was legit, 0 if not.
	 * also updates tp_Xuna
	 */
	{	
D 15
		tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
		tp_cuntimeout($P.tp_refp, TM_retrans);
E 15
I 15
		tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
		tp_cuntimeout($P, TM_retrans);
E 15

		sbwakeup( &$P.tp_sock->so_snd );

		/* resume normal data */
		tp_send($P);
I 6
	}
;

/* TP4, and TP0 after sending a CC or possibly a CR */
SAME			<==		TP_OPEN 			 						XAK_TPDU
	DEFAULT
	{
		IFTRACE(D_ACKRECV)
			tptrace(TPPTmisc, "BOGUS XACK eventtype ", $E.ev_number, 0, 0,0);
		ENDTRACE
		if( $P.tp_class != TP_CLASS_0 ) {
D 15
			tp_ctimeout($P.tp_refp, TM_inact, (int)$P.tp_inact_ticks);
E 15
I 15
			tp_ctimeout($P, TM_inact, (int)$P.tp_inact_ticks);
E 15
		} 
E 6
	}
;

/* TP4 only */
SAME			<==		TP_OPEN 								TM_sendack 
	DEFAULT
	{	
I 15
		int timo;
E 15
		IFTRACE(D_TIMER)
			tptrace(TPPTsendack, -1, $P.tp_lcredit, $P.tp_sent_uwe, 
			$P.tp_sent_lcdt, 0);
		ENDTRACE
		IncPStat($P, tps_n_TMsendack);
		(void) tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL);
I 18
		if ($P.tp_fcredit == 0) {
			if ($P.tp_rxtshift < TP_MAXRXTSHIFT)
				$P.tp_rxtshift++;
			timo = ($P.tp_dt_ticks) << $P.tp_rxtshift;
		} else
			timo = $P.tp_sendack_ticks;
		tp_ctimeout($P, TM_sendack, timo);
E 18
	}
;

/* TP0 only */
SAME			<==		TP_OPEN 									T_USR_rcvd
	($P.tp_class == TP_CLASS_0)
D 7
	NULLACTION
E 7
I 7
	{
		if (sbspace(&$P.tp_sock->so_rcv) > 0)
			tp0_openflow($P);
	}
E 7
;

/* TP4 only */
		/* If old credit was zero, 
		 * we'd better inform other side that we now have space
		 * But this is not enough.  Sender might not yet have
		 * seen an ack with cdt 0 but it might still think the
		 * window is closed, so it's going to wait.
		 * Best to send an ack each time.
		 * Strictly speaking, this ought to be a function of the
		 * general ack strategy.
		 */
SAME			<==		TP_OPEN 									T_USR_rcvd
	DEFAULT
	{	
		if( trick_hc ) {
D 11
			IncStat(ts_ackreason[_ACK_USRRCV_]);
E 11
D 5
			return tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL);
E 5
I 5
D 14

D 11
			/* send an ACK only if there's new information */
			LOCAL_CREDIT( $P );
			if (($P.tp_rcvnxt != $P.tp_sent_rcvnxt) ||
				($P.tp_lcredit != $P.tp_sent_lcdt))

E 11
I 11
			LOCAL_CREDIT($P);
E 14
I 14
			SeqNum ack_thresh;
E 14
			/*
D 13
			 * If the window has is now closed or has only
E 13
I 13
D 14
			 * If the window is now closed or has only
E 13
			 * one slot left and an ACK will increase this (local
			 * credit is greater than or equal to 1) send an AK
			 * here. Otherwise, we will wait for more data or
			 * the ack timer to fire.
E 14
I 14
			 * If the upper window edge has advanced a reasonable
			 * amount beyond what was known, send an ACK.
			 * A reasonable amount is 2 packets, unless the max window
			 * is only 1 or 2 packets, in which case we
			 * should send an ack for any advance in the upper window edge.
E 14
			 */
D 14
#define CREDIT_SMALL 1
			if (SEQ_GEQ($P, $P.tp_rcvnxt, $P.tp_sent_uwe) &&
				$P.tp_lcredit > CREDIT_SMALL) {
E 14
I 14
			LOCAL_CREDIT($P);
			ack_thresh = SEQ_SUB($P, $P.tp_lcredit + $P.tp_rcvnxt,
									 ($P.tp_maxlcredit > 2 ? 2 : 1));
			if (SEQ_GT($P, ack_thresh, $P.tp_sent_uwe)) {
E 14
				IncStat(ts_ackreason[_ACK_USRRCV_]);
I 14
				$P.tp_flags &= ~TPF_DELACK;
E 14
E 11
				return tp_emit(AK_TPDU_type, $P, $P.tp_rcvnxt, 0, MNULL);
I 11
			}
E 11
E 5
		}
	}
;

/* applicable in TP4, TP0 */
SAME			<==		TP_REFWAIT 				[ T_USR_rcvd, T_USR_Xrcvd ]
	DEFAULT
	/* This happens if other end sent a DR when  the user was waiting 
	 * on a receive.  
	 * Processing the DR includes putting us in REFWAIT state.
	 */
	{
		if(trick_hc)
		return ECONNABORTED;
	}
;

/* TP0 only */
TP_REFWAIT		<==		[ TP_OPEN, TP_CRSENT, TP_LISTENING ] 	T_NETRESET
	( $P.tp_class != TP_CLASS_4 ) 
		/* 0 or (4 and 0) */
		/* in OPEN class will be 0 or 4 but not both */
		/* in CRSENT or LISTENING it could be in negotiation, hence both */
		/* Actually, this shouldn't ever happen in LISTENING */
	{
		ASSERT( $P.tp_state != TP_LISTENING );
		tp_indicate(T_DISCONNECT, $P, ECONNRESET);
		tp_soisdisconnected($P);
	}
;

/* TP4: ignore resets */
SAME		<==		[ TP_OPEN, TP_CRSENT, TP_AKWAIT,
						TP_CLOSING, TP_LISTENING ] 				T_NETRESET
	DEFAULT
	NULLACTION
;
 
/* applicable in TP4, TP0 */
SAME			<==		[ TP_CLOSED, TP_REFWAIT ]				T_NETRESET
	DEFAULT
	NULLACTION
;

/* C'EST TOUT */
E 1
