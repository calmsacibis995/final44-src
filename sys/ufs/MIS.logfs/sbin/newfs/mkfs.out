# 1 "mkfs.c"
 

































static char sccsid[] = "@(#)mkfs.c	8.3 (Berkeley) 2/3/94";


# 1 "/usr/include/unistd.h" 1 3
 





































# 1 "../../sys/sys/cdefs.h" 1
 
















































 






















# 98 "../../sys/sys/cdefs.h"


 















 






# 39 "/usr/include/unistd.h" 2 3

# 1 "../../sys/sys/types.h" 1
 










































 
# 1 "/usr/include/machine/endian.h" 1 3
 





































 






 











 
unsigned long	htonl (unsigned long)		;
unsigned short	htons (unsigned short)		;
unsigned long	ntohl (unsigned long)		;
unsigned short	ntohs (unsigned short)		;
 

 






















# 45 "../../sys/sys/types.h" 2



typedef	unsigned char	u_char;
typedef	unsigned short	u_short;
typedef	unsigned int	u_int;
typedef	unsigned long	u_long;
typedef	unsigned short	ushort;		 
typedef	unsigned int	uint;		 


typedef	unsigned long long u_quad_t;	 
typedef	long long	quad_t;
typedef	quad_t *	qaddr_t;

typedef	char *		caddr_t;	 
typedef	long		daddr_t;	 
typedef	unsigned long	dev_t;		 
typedef unsigned long	fixpt_t;	 
typedef	unsigned long	gid_t;		 
typedef	unsigned long	ino_t;		 
typedef	unsigned short	mode_t;		 
typedef	unsigned short	nlink_t;	 
typedef	quad_t		off_t;		 
typedef	long		pid_t;		 
typedef	long		segsz_t;	 
typedef	long		swblk_t;	 
typedef	unsigned long	uid_t;		 

 






 
off_t	 lseek (int, off_t, int)		;
 








# 1 "/usr/include/machine/ansi.h" 1 3
 





































 

















 

















# 92 "../../sys/sys/types.h" 2

# 1 "/usr2/src/sys/compile/MISLITE/machine/types.h" 1
 

















































typedef struct _physadr {
	short r[1];
} *physadr;

typedef struct label_t {
	int val[2];
} label_t;


typedef	unsigned long	vm_offset_t;
typedef	unsigned long	vm_size_t;

 



typedef	signed  char		   int8_t;
typedef	unsigned char		 u_int8_t;
typedef	short			  int16_t;
typedef	unsigned short		u_int16_t;
typedef	int			  int32_t;
typedef	unsigned int		u_int32_t;
typedef	long long		  int64_t;
typedef	unsigned long long	u_int64_t;


# 93 "../../sys/sys/types.h" 2



typedef	unsigned long			clock_t;




typedef	unsigned int			size_t;




typedef	int				ssize_t;




typedef	long				time_t;






 









typedef long	fd_mask;






typedef	struct fd_set {
	fd_mask	fds_bits[(((256 )+(( (sizeof(fd_mask) * 8		)	)-1))/( (sizeof(fd_mask) * 8		)	)) ];
} fd_set;







# 159 "../../sys/sys/types.h"




# 40 "/usr/include/unistd.h" 2 3

# 1 "../../sys/sys/unistd.h" 1
 





































 


 












 
				 

				 

				 


 





 





 





 










 




























 



# 41 "/usr/include/unistd.h" 2 3










 
	volatile   void
	 _exit (int)		;
int	 access (const char *, int)		;
unsigned int	 alarm (unsigned int)		;
int	 chdir (const char *)		;
int	 chown (const char *, uid_t, gid_t)		;
int	 close (int)		;
size_t	 confstr (int, char *, size_t)		;
int	 dup (int)		;
int	 dup2 (int, int)		;
int	 execl (const char *, const char *, ...)		;
int	 execle (const char *, const char *, ...)		;
int	 execlp (const char *, const char *, ...)		;
int	 execv (const char *, char * const *)		;
int	 execve (const char *, char * const *, char * const *)		;
int	 execvp (const char *, char * const *)		;
pid_t	 fork (void)		;
long	 fpathconf (int, int)		;
char	*getcwd (char *, size_t)		;
gid_t	 getegid (void)		;
uid_t	 geteuid (void)		;
gid_t	 getgid (void)		;
int	 getgroups (int, int *)		;		 
char	*getlogin (void)		;
pid_t	 getpgrp (void)		;
pid_t	 getpid (void)		;
pid_t	 getppid (void)		;
uid_t	 getuid (void)		;
int	 isatty (int)		;
int	 link (const char *, const char *)		;
off_t	 lseek (int, off_t, int)		;
long	 pathconf (const char *, int)		;
int	 pause (void)		;
int	 pipe (int *)		;
ssize_t	 read (int, void *, size_t)		;
int	 rmdir (const char *)		;
int	 setgid (gid_t)		;
int	 setpgid (pid_t, pid_t)		;
pid_t	 setsid (void)		;
int	 setuid (uid_t)		;
unsigned int	 sleep (unsigned int)		;
long	 sysconf (int)		;
pid_t	 tcgetpgrp (int)		;
int	 tcsetpgrp (int, pid_t)		;
char	*ttyname (int)		;
int	 unlink (const char *)		;
ssize_t	 write (int, const void *, size_t)		;



 
# 1 "../../sys/sys/time.h" 1
 





































 



struct timeval {
	long	tv_sec;		 
	long	tv_usec;	 
};

 


struct timespec {
	long	ts_sec;		 
	long	ts_nsec;	 
};










struct timezone {
	int	tz_minuteswest;	 
	int	tz_dsttime;	 
};








 







 







struct	itimerval {
	struct	timeval it_interval;	 
	struct	timeval it_value;	 
};

 


struct clockinfo {
	int	hz;		 
	int	tick;		 
	int	stathz;		 
	int	profhz;		 
};


# 1 "/usr/include/time.h" 1 3
 


























































struct tm {
	int	tm_sec;		 
	int	tm_min;		 
	int	tm_hour;	 
	int	tm_mday;	 
	int	tm_mon;		 
	int	tm_year;	 
	int	tm_wday;	 
	int	tm_yday;	 
	int	tm_isdst;	 
	long	tm_gmtoff;	 
	char	*tm_zone;	 
};



 
char *asctime (const struct tm *)		;
clock_t clock (void)		;
char *ctime (const time_t *)		;
double difftime (time_t, time_t)		;
struct tm *gmtime (const time_t *)		;
struct tm *localtime (const time_t *)		;
time_t mktime (struct tm *)		;
size_t strftime (char *, size_t, const char *, const struct tm *)		;
time_t time (time_t *)		;


void tzset (void)		;



char *timezone (int, int)		;
void tzsetwall (void)		;

 


# 109 "../../sys/sys/time.h" 2





 
int	adjtime (const struct timeval *, struct timeval *)		;
int	getitimer (int, struct itimerval *)		;
int	gettimeofday (struct timeval *, struct timezone *)		;
int	setitimer (int, const struct itimerval *, struct itimerval *)		;
int	settimeofday (const struct timeval *, const struct timezone *)		;
int	utimes (const char *, const struct timeval *)		;
 





# 103 "/usr/include/unistd.h" 2 3


int	 acct (const char *)		;
int	 async_daemon (void)		;
char	*brk (const char *)		;
int	 chroot (const char *)		;
char	*crypt (const char *, const char *)		;
int	 des_cipher (const char *, char *, long, int)		;
int	 des_setkey (const char *key)		;
int	 encrypt (char *, int)		;
void	 endusershell (void)		;
int	 exect (const char *, char * const *, char * const *)		;
int	 fchdir (int)		;
int	 fchown (int, int, int)		;
int	 fsync (int)		;
int	 ftruncate (int, off_t)		;
int	 getdtablesize (void)		;
long	 gethostid (void)		;
int	 gethostname (char *, int)		;
mode_t	 getmode (const void *, mode_t)		;
		const		  int
	 getpagesize (void)		;
char	*getpass (const char *)		;
char	*getusershell (void)		;
char	*getwd (char *)		;			 
int	 initgroups (const char *, int)		;
int	 iruserok (unsigned long, int, const char *, const char *)		;
int	 mknod (const char *, mode_t, dev_t)		;
int	 mkstemp (char *)		;
char	*mktemp (char *)		;
int	 nfssvc (int, caddr_t)		;
int	 nice (int)		;
void	 psignal (unsigned int, const char *)		;
extern const char *const sys_siglist[];
int	 profil (char *, int, int, int)		;
int	 rcmd (char **, int, const char *,
		const char *, const char *, int *)		;
char	*re_comp (const char *)		;
int	 re_exec (const char *)		;
int	 readlink (const char *, char *, int)		;
int	 reboot (int)		;
int	 revoke (const char *)		;
int	 rresvport (int *)		;
int	 ruserok (const char *, int, const char *, const char *)		;
char	*sbrk (int)		;
int	 select (int, fd_set *, fd_set *, fd_set *, struct timeval *)		;
int	 setegid (gid_t)		;
int	 seteuid (uid_t)		;
int	 setgroups (int, const int *)		;
void	 sethostid (long)		;
int	 sethostname (const char *, int)		;
int	 setkey (const char *)		;
int	 setlogin (const char *)		;
void	*setmode (const char *)		;
int	 setpgrp (pid_t pid, pid_t pgrp)		;	 
int	 setregid (int, int)		;
int	 setreuid (int, int)		;
int	 setrgid (gid_t)		;
int	 setruid (uid_t)		;
void	 setusershell (void)		;
int	 swapon (const char *)		;
int	 symlink (const char *, const char *)		;
void	 sync (void)		;
int	 syscall (int, ...)		;
int	 truncate (const char *, off_t)		;
int	 ttyslot (void)		;
unsigned int	 ualarm (unsigned int, unsigned int)		;
void	 usleep (unsigned int)		;
void	*valloc (size_t)		;			 
int	 vfork (void)		;


 


# 38 "mkfs.c" 2

# 1 "../../sys/sys/param.h" 1
 



















































 






# 1 "../../sys/sys/syslimits.h" 1
 





















































# 60 "../../sys/sys/param.h" 2












 









 
# 1 "../../sys/sys/signal.h" 1
 













































# 1 "/usr2/src/sys/compile/MISLITE/machine/signal.h" 1
 














































typedef int sig_atomic_t;

 








struct sigcontext {
	int	sc_onstack;		 
	int	sc_mask;		 
	 
	int	sc_sp;			 
	int	sc_pc;			 
	int	sc_npc;			 
	int	sc_psr;			 
	int	sc_g1;			 
	int	sc_o0;			 
};









 











# 47 "../../sys/sys/signal.h" 2
















































# 103 "../../sys/sys/signal.h"







typedef unsigned int sigset_t;

 


struct	sigaction {
	void	(*sa_handler)();	 
	sigset_t sa_mask;		 
	int	sa_flags;		 
};










 










typedef	void (*sig_t) (int)		;	 

 


struct	sigaltstack {
	char	*ss_base;		 
	int	ss_size;		 
	int	ss_flags;		 
};



 



struct	sigvec {
	void	(*sv_handler)();	 
	int	sv_mask;		 
	int	sv_flags;		 
};





 


struct	sigstack {
	char	*ss_sp;			 
	int	ss_onstack;		 
};

 










 



 
void	(*signal (int, void (*) (int)		)		) (int)		;
 

# 83 "../../sys/sys/param.h" 2


 
# 1 "/usr2/src/sys/compile/MISLITE/machine/param.h" 1
 













































 








 























 



 



















 






 




 


 







 














# 86 "../../sys/sys/param.h" 2

# 1 "/usr/include/machine/limits.h" 1 3
 








































 




























 


 

					 





# 87 "../../sys/sys/param.h" 2


 


























 






















				 



 











 











 





 






 





 

















 












# 39 "mkfs.c" 2


# 1 "../../sys/sys/wait.h" 1
 


































 




 

























 












 

 







 





union wait {
	int	w_status;		 
	 


	struct {







		unsigned int	w_Filler:16,	 
				w_Retcode:8,	 
				w_Coredump:1,	 
				w_Termsig:7;	 

	} w_T;
	 




	struct {






		unsigned int	w_Filler:16,	 
				w_Stopsig:8,	 
				w_Stopval:8;	 

	} w_S;
};













 
struct rusage;	 

pid_t	wait (int *)		;
pid_t	waitpid (pid_t, int *, int)		;

pid_t	wait3 (int *, int, struct rusage *)		;
pid_t	wait4 (pid_t, int *, int, struct rusage *)		;

 

# 41 "mkfs.c" 2

# 1 "../../sys/sys/resource.h" 1
 





































 









 






struct	rusage {
	struct timeval ru_utime;	 
	struct timeval ru_stime;	 
	long	ru_maxrss;		 

	long	ru_ixrss;		 
	long	ru_idrss;		 
	long	ru_isrss;		 
	long	ru_minflt;		 
	long	ru_majflt;		 
	long	ru_nswap;		 
	long	ru_inblock;		 
	long	ru_oublock;		 
	long	ru_msgsnd;		 
	long	ru_msgrcv;		 
	long	ru_nsignals;		 
	long	ru_nvcsw;		 
	long	ru_nivcsw;		 

};

 
















struct orlimit {
	long	rlim_cur;		 
	long	rlim_max;		 
};

struct rlimit {
	quad_t	rlim_cur;		 
	quad_t	rlim_max;		 
};

 
struct loadavg {
	fixpt_t ldavg[3];
	long fscale;
};







 
int	getpriority (int, int)		;
int	getrlimit (int, struct rlimit *)		;
int	getrusage (int, struct rusage *)		;
int	setpriority (int, int, int)		;
int	setrlimit (int, const struct rlimit *)		;
 



# 42 "mkfs.c" 2

# 1 "../../sys/ufs/ufs/dinode.h" 1
 







































 







 







struct dinode {
	u_short		di_mode;	 
	short		di_nlink;	 
	union {
		u_short	oldids[2];	 
		ino_t	inumber;	 
	} di_u;
	u_quad_t	di_size;	 
	struct timespec	di_atime;	 
	struct timespec	di_mtime;	 
	struct timespec	di_ctime;	 
	daddr_t		di_db[12			];	 
	daddr_t		di_ib[3			];	 
	u_long		di_flags;	 
	long		di_blocks;	 
	long		di_gen;		 
	u_long		di_uid;		 
	u_long		di_gid;		 
	long		di_spare[2];	 
};

 













 







 








# 43 "mkfs.c" 2

# 1 "../../sys/ufs/ufs/dir.h" 1
 










































 



























struct	direct {
	u_long	d_ino;			 
	u_short	d_reclen;		 
	u_char	d_type; 		 
	u_char	d_namlen;		 
	char	d_name[255  + 1];	 
};

 











 





 

















 




struct dirtemplate {
	u_long	dot_ino;
	short	dot_reclen;
	u_char	dot_type;
	u_char	dot_namlen;
	char	dot_name[4];		 
	u_long	dotdot_ino;
	short	dotdot_reclen;
	u_char	dotdot_type;
	u_char	dotdot_namlen;
	char	dotdot_name[4];		 
};

 


struct odirtemplate {
	u_long	dot_ino;
	short	dot_reclen;
	u_short	dot_namlen;
	char	dot_name[4];		 
	u_long	dotdot_ino;
	short	dotdot_reclen;
	u_short	dotdot_namlen;
	char	dotdot_name[4];		 
};

# 44 "mkfs.c" 2

# 1 "../../sys/ufs/ffs/fs.h" 1
 


































 






























 


















 










 










 







 














 








struct csum {
	long	cs_ndir;	 
	long	cs_nbfree;	 
	long	cs_nifree;	 
	long	cs_nffree;	 
};

 


struct fs {
	struct	fs *fs_link;		 
	struct	fs *fs_rlink;		 
	daddr_t	fs_sblkno;		 
	daddr_t	fs_cblkno;		 
	daddr_t	fs_iblkno;		 
	daddr_t	fs_dblkno;		 
	long	fs_cgoffset;		 
	long	fs_cgmask;		 
	time_t 	fs_time;    		 
	long	fs_size;		 
	long	fs_dsize;		 
	long	fs_ncg;			 
	long	fs_bsize;		 
	long	fs_fsize;		 
	long	fs_frag;		 
 
	long	fs_minfree;		 
	long	fs_rotdelay;		 
	long	fs_rps;			 
 
	long	fs_bmask;		 
	long	fs_fmask;		 
	long	fs_bshift;		 
	long	fs_fshift;		 
 
	long	fs_maxcontig;		 
	long	fs_maxbpg;		 
 
	long	fs_fragshift;		 
	long	fs_fsbtodb;		 
	long	fs_sbsize;		 
	long	fs_csmask;		 
	long	fs_csshift;		 
	long	fs_nindir;		 
	long	fs_inopb;		 
	long	fs_nspf;		 
 
	long	fs_optim;		 
 
	long	fs_npsect;		 
	long	fs_interleave;		 
	long	fs_trackskew;		 
	long	fs_headswitch;		 
	long	fs_trkseek;		 
 
	daddr_t fs_csaddr;		 
	long	fs_cssize;		 
	long	fs_cgsize;		 
 
	long	fs_ntrak;		 
	long	fs_nsect;		 
	long  	fs_spc;   		 
 
	long	fs_ncyl;   		 
 
	long	fs_cpg;			 
	long	fs_ipg;			 
	long	fs_fpg;			 
 
	struct	csum fs_cstotal;	 
 
	char   	fs_fmod;    		 
	char   	fs_clean;    		 
	char   	fs_ronly;   		 
	char   	fs_flags;   		 
	char	fs_fsmnt[512 ];	 
 
	long	fs_cgrotor;		 
	struct	csum *fs_csp[32 ]; 
	long	fs_cpc;			 
	short	fs_opostbl[16][8];	 
	long	fs_sparecon[50];	 
	long	fs_contigsumsize;	  
	long	fs_maxsymlinklen;	 
	long	fs_inodefmt;		 
	u_quad_t fs_maxfilesize;	 
	quad_t	fs_qbmask;		 
	quad_t	fs_qfmask;		 
	long	fs_state;		 
	long	fs_postblformat;	 
	long	fs_nrpos;		 
	long	fs_postbloff;		 
	long	fs_rotbloff;		 
	long	fs_magic;		 
	u_char	fs_space[1];		 
 
};
 






 





 




 











 






# 283 "../../sys/ufs/ffs/fs.h"

 







 



struct	cg {
	struct	cg *cg_link;		 
	long	cg_magic;		 
	time_t	cg_time;		 
	long	cg_cgx;			 
	short	cg_ncyl;		 
	short	cg_niblk;		 
	long	cg_ndblk;		 
	struct	csum cg_cs;		 
	long	cg_rotor;		 
	long	cg_frotor;		 
	long	cg_irotor;		 
	long	cg_frsum[	8 ];	 
	long	cg_btotoff;		 
	long	cg_boff;		 
	long	cg_iusedoff;		 
	long	cg_freeoff;		 
	long	cg_nextfreeoff;		 
	long	cg_clustersumoff;	 
	long	cg_clusteroff;		 
	long	cg_nclusterblks;	 
	long	cg_sparecon[13];	 
	u_char	cg_space[1];		 
 
};
 

























 



struct	ocg {
	struct	ocg *cg_link;		 
	struct	ocg *cg_rlink;		 
	time_t	cg_time;		 
	long	cg_cgx;			 
	short	cg_ncyl;		 
	short	cg_niblk;		 
	long	cg_ndblk;		 
	struct	csum cg_cs;		 
	long	cg_rotor;		 
	long	cg_frotor;		 
	long	cg_irotor;		 
	long	cg_frsum[8];		 
	long	cg_btot[32];		 
	short	cg_b[32][8];		 
	char	cg_iused[256];		 
	long	cg_magic;		 
	u_char	cg_free[1];		 
 
};

 






 











 











 






 












 



























 







 











 





 





 




extern int inside[], around[];
extern u_char *fragtbl[];
# 45 "mkfs.c" 2

# 1 "../../sys/sys/disklabel.h" 1
 


































 





 






 




















struct disklabel {
	u_long	d_magic;		 
	short	d_type;			 
	short	d_subtype;		 
	char	d_typename[16];		 
	 










	union {
		char	un_d_packname[16];	  
		struct {
			char *un_d_boot0;	 
			char *un_d_boot1;	 
		} un_b; 
	} d_un; 




			 
	u_long	d_secsize;		 
	u_long	d_nsectors;		 
	u_long	d_ntracks;		 
	u_long	d_ncylinders;		 
	u_long	d_secpercyl;		 
	u_long	d_secperunit;		 
	 





	u_short	d_sparespertrack;	 
	u_short	d_sparespercyl;		 
	 



	u_long	d_acylinders;		 

			 
	 















	u_short	d_rpm;			 
	u_short	d_interleave;		 
	u_short	d_trackskew;		 
	u_short	d_cylskew;		 
	u_long	d_headswitch;		 
	u_long	d_trkseek;		 
	u_long	d_flags;		 

	u_long	d_drivedata[5 ];	 

	u_long	d_spare[5 ];	 
	u_long	d_magic2;		 
	u_short	d_checksum;		 

			 
	u_short	d_npartitions;		 
	u_long	d_bbsize;		 
	u_long	d_sbsize;		 
	struct	partition {		 
		u_long	p_size;		 
		u_long	p_offset;	 
		u_long	p_fsize;	 
		u_char	p_fstype;	 
		u_char	p_frag;		 
		union {
			u_short	cpg;	 
			u_short	sgs;	 
		} __partition_u1;


	} d_partitions[8 ];	 
};
# 178 "../../sys/sys/disklabel.h"


 










# 207 "../../sys/sys/disklabel.h"


 



















# 248 "../../sys/sys/disklabel.h"


 








 








 





 





 






struct format_op {
	char	*df_buf;
	int	df_count;		 
	daddr_t	df_startblk;
	int	df_reg[8];		 
};

 



struct partinfo {
	struct disklabel *disklab;
	struct partition *part;
};

 


		 





 















 
struct disklabel *getdiskbyname (const char *)		;
 


# 46 "mkfs.c" 2



# 1 "/usr/include/a.out.h" 1 3
 






































# 1 "/usr2/src/sys/compile/MISLITE/machine/exec.h" 1
 













































 








 




 









 




 









 




 




 


 
struct exec {
	u_char	a_dynamic:1;	 
	u_char	a_toolversion:7; 









	u_char	a_mid;		 




	u_short	a_magic;	 

	u_long	a_text;		 
	u_long	a_data;		 
	u_long	a_bss;		 
	u_long	a_syms;		 
	u_long	a_entry;	 
	u_long	a_trsize;	 
	u_long	a_drsize;	 
};

# 40 "/usr/include/a.out.h" 2 3

# 1 "/usr2/src/sys/compile/MISLITE/machine/reloc.h" 1
 













































 




enum reloc_type {
		 
	RELOC_8,		 
	RELOC_16,		 
	RELOC_32,		 
	RELOC_DISP8,		 
	RELOC_DISP16,		 
	RELOC_DISP32,		 
	RELOC_WDISP30,		 
	RELOC_WDISP22,		 
	RELOC_HI22,		 
	RELOC_22,		 
	RELOC_13,		 
	RELOC_LO10,		 

		 
	RELOC_SFA_BASE,		 
	RELOC_SFA_OFF13,	 
	RELOC_BASE10,		 
	RELOC_BASE13,		 
	RELOC_BASE22,		 

		 
		 

	RELOC_PC10,		 
	RELOC_PC22,		 
	RELOC_JMP_TBL,		 
	RELOC_SEGOFF16,		 
	RELOC_GLOB_DAT,		 
	RELOC_JMP_SLOT,		 
	RELOC_RELATIVE,		 
};

 









struct reloc_info_sparc {
	u_long	r_address;	 
	u_int	r_index:24,	 
		r_extern:1,	 
		:2;		 
	enum reloc_type r_type:5;  
	long	r_addend;	 
};
# 41 "/usr/include/a.out.h" 2 3



# 1 "/usr/include/nlist.h" 1 3
 





































 



struct nlist {

	union {
		char *n_name;	 
		long n_strx;	 
	} n_un;














	unsigned char n_type;	 

	char n_other;		 

	short n_desc;		 
	unsigned long n_value;	 
};






 
int nlist (const char *, struct nlist *)		;
 


# 44 "/usr/include/a.out.h" 2 3



# 49 "mkfs.c" 2

# 1 "/usr/include/stdio.h" 1 3
 
























































 











typedef off_t fpos_t;








 





 
struct __sbuf {
	unsigned char *_base;
	int	_size;
};

 

























typedef	struct __sFILE {
	unsigned char *_p;	 
	int	_r;		 
	int	_w;		 
	short	_flags;		 
	short	_file;		 
	struct	__sbuf _bf;	 
	int	_lbfsize;	 

	 
	void	*_cookie;	 
	int	(*_close) (void *)		;
	int	(*_read)  (void *, char *, int)		;
	fpos_t	(*_seek)  (void *, fpos_t, int)		;
	int	(*_write) (void *, const char *, int)		;

	 
	struct	__sbuf _ub;	 
	unsigned char *_up;	 
	int	_ur;		 

	 
	unsigned char _ubuf[3];	 
	unsigned char _nbuf[1];	 

	 
	struct	__sbuf _lb;	 

	 
	int	_blksize;	 
	fpos_t	_offset;	 
} FILE;

 
extern FILE __sF[];
 





	 











 















 







 




















 


 
void	 clearerr (FILE *)		;
int	 fclose (FILE *)		;
int	 feof (FILE *)		;
int	 ferror (FILE *)		;
int	 fflush (FILE *)		;
int	 fgetc (FILE *)		;
int	 fgetpos (FILE *, fpos_t *)		;
char	*fgets (char *, size_t, FILE *)		;
FILE	*fopen (const char *, const char *)		;
int	 fprintf (FILE *, const char *, ...)		;
int	 fputc (int, FILE *)		;
int	 fputs (const char *, FILE *)		;
size_t	 fread (void *, size_t, size_t, FILE *)		;
FILE	*freopen (const char *, const char *, FILE *)		;
int	 fscanf (FILE *, const char *, ...)		;
int	 fseek (FILE *, long, int)		;
int	 fsetpos (FILE *, const fpos_t *)		;
long	 ftell (const FILE *)		;
size_t	 fwrite (const void *, size_t, size_t, FILE *)		;
int	 getc (FILE *)		;
int	 getchar (void)		;
char	*gets (char *)		;

extern int sys_nerr;			 
extern const char *const sys_errlist[];

void	 perror (const char *)		;
int	 printf (const char *, ...)		;
int	 putc (int, FILE *)		;
int	 putchar (int)		;
int	 puts (const char *)		;
int	 remove (const char *)		;
int	 rename  (const char *, const char *)		;
void	 rewind (FILE *)		;
int	 scanf (const char *, ...)		;
void	 setbuf (FILE *, char *)		;
int	 setvbuf (FILE *, char *, int, size_t)		;
int	 sprintf (char *, const char *, ...)		;
int	 sscanf (const char *, const char *, ...)		;
FILE	*tmpfile (void)		;
char	*tmpnam (char *)		;
int	 ungetc (int, FILE *)		;
int	 vfprintf (FILE *, const char *, char *			)		;
int	 vprintf (const char *, char *			)		;
int	 vsprintf (char *, const char *, char *			)		;
 

 






 
char	*ctermid (char *)		;
FILE	*fdopen (int, const char *)		;
int	 fileno (FILE *)		;
 


 



 
char	*fgetline (FILE *, size_t *)		;
int	 fpurge (FILE *)		;
int	 getw (FILE *)		;
int	 pclose (FILE *)		;
FILE	*popen (const char *, const char *)		;
int	 putw (int, FILE *)		;
void	 setbuffer (FILE *, char *, int)		;
int	 setlinebuf (FILE *)		;
char	*tempnam (const char *, const char *)		;
int	 snprintf (char *, size_t, const char *, ...)		;
int	 vsnprintf (char *, size_t, const char *, char *			)		;
int	 vscanf (const char *, char *			)		;
int	 vsscanf (const char *, const char *, char *			)		;
FILE	*zopen (const char *, const char *, int)		;
 

 






 


 
FILE	*funopen (const void *,
		int (*)(void *, char *, int),
		int (*)(void *, const char *, int),
		fpos_t (*)(void *, fpos_t, int),
		int (*)(void *))		;
 




 


 
int	__srget (FILE *)		;
int	__svfscanf (FILE *, const char *, char *			)		;
int	__swbuf (int, FILE *)		;
 

 





static __inline int __sputc(int _c, FILE *_p) {
	if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
		return (*_p->_p++ = _c);
	else
		return (__swbuf(_c, _p));
}
# 355 "/usr/include/stdio.h" 3























# 50 "mkfs.c" 2



 



 












 


extern int	mfs;		 
extern int	Nflag;		 
extern int	Oflag;		 
extern int	fssize;		 
extern int	ntracks;	 
extern int	nsectors;	 
extern int	nphyssectors;	 
extern int	secpercyl;	 
extern int	sectorsize;	 
extern int	rpm;		 
extern int	interleave;	 
extern int	trackskew;	 
extern int	headswitch;	 
extern int	trackseek;	 
extern int	fsize;		 
extern int	bsize;		 
extern int	cpg;		 
extern int	cpgflg;		 
extern int	minfree;	 
extern int	opt;		 
extern int	density;	 
extern int	maxcontig;	 
extern int	rotdelay;	 
extern int	maxbpg;		 
extern int	nrpos;		 
extern int	bbsize;		 
extern int	sbsize;		 
extern u_long	memleft;	 
extern caddr_t	membase;	 
extern caddr_t	malloc(), calloc();

union {
	struct fs fs;
	char pad[	8192 ];
} fsun;

struct	csum *fscs;

union {
	struct cg cg;
	char pad[	(64 * 1024)  ];
} cgun;


struct dinode zino[	(64 * 1024)   / sizeof(struct dinode)];

int	fsi, fso;
daddr_t	alloc();

mkfs(pp, fsys, fi, fo, id)
	struct partition *pp;
	char *fsys;
	int fi, fo;
	long id;
{
	register long i, mincpc, mincpg, inospercg;
	long cylno, rpos, blk, j, warn = 0;
	long used, mincpgcnt, bpcg;
	long mapcramped, inodecramped;
	long postblsize, rotblsize, totalsbsize;
	int ppid, status;
	time_t utime;
	quad_t sizepb;
	void started();


	time(&utime);

	if (mfs) {
		ppid = getpid();
		(void) signal(30	, started);
		if (i = fork()) {
			if (i == -1) {
				perror("mfs");
				exit(10);
			}
			if (waitpid(i, &status, 0) != -1 && (((*(int *)&(status))	 & 0177)  == 0) )
				exit(((*(int *)&(status))	 >> 8) );
			exit(11);
			 
		}
		(void)malloc(0);
		if (fssize * sectorsize > memleft)
			fssize = (memleft - 16384) / sectorsize;
		if ((membase = malloc(fssize * sectorsize)) == 0)
			exit(12);
	}
	fsi = fi;
	fso = fo;
	if (Oflag) {
		fsun.fs .fs_inodefmt = -1		;
		fsun.fs .fs_maxsymlinklen = 0;
	} else {
		fsun.fs .fs_inodefmt = 2		;
		fsun.fs .fs_maxsymlinklen = ((12			 + 3			) * sizeof(daddr_t)) ;
	}
	 



	if (fssize <= 0)
		printf("preposterous size %d\n", fssize), exit(13);
	wtfs(fssize - 1, sectorsize, (char *)&fsun.fs );
	 


	fsun.fs .fs_nsect = nsectors;
	fsun.fs .fs_ntrak = ntracks;
	if (fsun.fs .fs_ntrak <= 0)
		printf("preposterous ntrak %d\n", fsun.fs .fs_ntrak), exit(14);
	if (fsun.fs .fs_nsect <= 0)
		printf("preposterous nsect %d\n", fsun.fs .fs_nsect), exit(15);
	 


	fsun.fs .fs_bsize = bsize;
	fsun.fs .fs_fsize = fsize;
	if (!(((fsun.fs .fs_bsize) & ((fsun.fs .fs_bsize) - 1)) == 0) ) {
		printf("block size must be a power of 2, not %d\n",
		    fsun.fs .fs_bsize);
		exit(16);
	}
	if (!(((fsun.fs .fs_fsize) & ((fsun.fs .fs_fsize) - 1)) == 0) ) {
		printf("fragment size must be a power of 2, not %d\n",
		    fsun.fs .fs_fsize);
		exit(17);
	}
	if (fsun.fs .fs_fsize < sectorsize) {
		printf("fragment size %d is too small, minimum is %d\n",
		    fsun.fs .fs_fsize, sectorsize);
		exit(18);
	}
	if (fsun.fs .fs_bsize < 4096 ) {
		printf("block size %d is too small, minimum is %d\n",
		    fsun.fs .fs_bsize, 4096 );
		exit(19);
	}
	if (fsun.fs .fs_bsize < fsun.fs .fs_fsize) {
		printf("block size (%d) cannot be smaller than fragment size (%d)\n",
		    fsun.fs .fs_bsize, fsun.fs .fs_fsize);
		exit(20);
	}
	fsun.fs .fs_bmask = ~(fsun.fs .fs_bsize - 1);
	fsun.fs .fs_fmask = ~(fsun.fs .fs_fsize - 1);
	fsun.fs .fs_qbmask = ~fsun.fs .fs_bmask;
	fsun.fs .fs_qfmask = ~fsun.fs .fs_fmask;
	for (fsun.fs .fs_bshift = 0, i = fsun.fs .fs_bsize; i > 1; i >>= 1)
		fsun.fs .fs_bshift++;
	for (fsun.fs .fs_fshift = 0, i = fsun.fs .fs_fsize; i > 1; i >>= 1)
		fsun.fs .fs_fshift++;
	fsun.fs .fs_frag = (( fsun.fs .fs_bsize) >> (&fsun.fs )->fs_fshift) ;
	for (fsun.fs .fs_fragshift = 0, i = fsun.fs .fs_frag; i > 1; i >>= 1)
		fsun.fs .fs_fragshift++;
	if (fsun.fs .fs_frag > 	8 ) {
		printf("fragment size %d is too small, minimum with block size %d is %d\n",
		    fsun.fs .fs_fsize, fsun.fs .fs_bsize,
		    fsun.fs .fs_bsize / 	8 );
		exit(21);
	}
	fsun.fs .fs_nrpos = nrpos;
	fsun.fs .fs_nindir = fsun.fs .fs_bsize / sizeof(daddr_t);
	fsun.fs .fs_inopb = fsun.fs .fs_bsize / sizeof(struct dinode);
	fsun.fs .fs_nspf = fsun.fs .fs_fsize / sectorsize;
	for (fsun.fs .fs_fsbtodb = 0, i = ((&fsun.fs )->fs_nspf) ; i > 1; i >>= 1)
		fsun.fs .fs_fsbtodb++;
	fsun.fs .fs_sblkno =
	    (((((((bbsize + sbsize)+(( fsun.fs .fs_fsize)-1))/( fsun.fs .fs_fsize)) )+(( fsun.fs .fs_frag)-1))/( fsun.fs .fs_frag))*( fsun.fs .fs_frag)) ;
	fsun.fs .fs_cblkno = (daddr_t)(fsun.fs .fs_sblkno +
	    (((((((sbsize)+(( fsun.fs .fs_fsize)-1))/( fsun.fs .fs_fsize)) )+(( fsun.fs .fs_frag)-1))/( fsun.fs .fs_frag))*( fsun.fs .fs_frag)) );
	fsun.fs .fs_iblkno = fsun.fs .fs_cblkno + fsun.fs .fs_frag;
	fsun.fs .fs_cgoffset = ((((
	    (((fsun.fs .fs_nsect)+(( ((&fsun.fs )->fs_nspf) )-1))/( ((&fsun.fs )->fs_nspf) )) )+(( fsun.fs .fs_frag)-1))/( fsun.fs .fs_frag))*( fsun.fs .fs_frag)) ;
	for (fsun.fs .fs_cgmask = 0xffffffff, i = fsun.fs .fs_ntrak; i > 1; i >>= 1)
		fsun.fs .fs_cgmask <<= 1;
	if (!(((fsun.fs .fs_ntrak) & ((fsun.fs .fs_ntrak) - 1)) == 0) )
		fsun.fs .fs_cgmask <<= 1;
	fsun.fs .fs_maxfilesize = fsun.fs .fs_bsize * 12			 - 1;
	for (sizepb = fsun.fs .fs_bsize, i = 0; i < 3			; i++) {
		sizepb *= ((&fsun.fs )->fs_nindir) ;
		fsun.fs .fs_maxfilesize += sizepb;
	}
	 



	fsun.fs .fs_spc = secpercyl;
	for (fsun.fs .fs_cpc = ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) , i = fsun.fs .fs_spc;
	     fsun.fs .fs_cpc > 1 && (i & 1) == 0;
	     fsun.fs .fs_cpc >>= 1, i >>= 1)
		 ;
	mincpc = fsun.fs .fs_cpc;
	bpcg = fsun.fs .fs_spc * sectorsize;
	inospercg = ((((bpcg / sizeof(struct dinode))+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) )) ;
	if (inospercg > (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))  )
		inospercg = (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))  ;
	used = (fsun.fs .fs_iblkno + inospercg / ((&fsun.fs )->fs_inopb >> (&fsun.fs )->fs_fragshift) ) * ((&fsun.fs )->fs_nspf) ;
	mincpgcnt = (((fsun.fs .fs_cgoffset * (~fsun.fs .fs_cgmask) + used)+((
	    fsun.fs .fs_spc)-1))/(	    fsun.fs .fs_spc)) ;
	mincpg = ((((mincpgcnt)+(( mincpc)-1))/( mincpc))*( mincpc)) ;
	 



	fsun.fs .fs_cpg = mincpg;
	fsun.fs .fs_ipg = inospercg;
	if (maxcontig > 1)
		fsun.fs .fs_contigsumsize = (((maxcontig)<( 16 ))?(maxcontig):( 16 )) ;
	mapcramped = 0;
	while ( 	(sizeof(struct cg) + sizeof(long) +  	(&fsun.fs )->fs_cpg * sizeof(long) +  	(&fsun.fs )->fs_cpg * (&fsun.fs )->fs_nrpos * sizeof(short) +  	((((&fsun.fs )->fs_ipg)+(( 8		)-1))/( 8		))  +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		))  +  	((&fsun.fs )->fs_contigsumsize <= 0 ? 0 :  	(&fsun.fs )->fs_contigsumsize * sizeof(long) +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) )+(( 8		)-1))/( 8		)) ))  > fsun.fs .fs_bsize) {
		mapcramped = 1;
		if (fsun.fs .fs_bsize < 	(64 * 1024)  ) {
			fsun.fs .fs_bsize <<= 1;
			if ((i & 1) == 0) {
				i >>= 1;
			} else {
				fsun.fs .fs_cpc <<= 1;
				mincpc <<= 1;
				mincpg = ((((mincpgcnt)+(( mincpc)-1))/( mincpc))*( mincpc)) ;
				fsun.fs .fs_cpg = mincpg;
			}
			fsun.fs .fs_frag <<= 1;
			fsun.fs .fs_fragshift += 1;
			if (fsun.fs .fs_frag <= 	8 )
				continue;
		}
		if (fsun.fs .fs_fsize == fsun.fs .fs_bsize) {
			printf("There is no block size that");
			printf(" can support this disk\n");
			exit(22);
		}
		fsun.fs .fs_frag >>= 1;
		fsun.fs .fs_fragshift -= 1;
		fsun.fs .fs_fsize <<= 1;
		fsun.fs .fs_nspf <<= 1;
	}
	 


	inodecramped = 0;
	used *= sectorsize;
	inospercg = (((((mincpg * bpcg - used) / density)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) )) ;
	fsun.fs .fs_ipg = inospercg;
	while (inospercg > (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))  ) {
		inodecramped = 1;
		if (mincpc == 1 || fsun.fs .fs_frag == 1 ||
		    fsun.fs .fs_bsize == 4096 )
			break;
		printf("With a block size of %d %s %d\n", fsun.fs .fs_bsize,
		    "minimum bytes per inode is",
		    (mincpg * bpcg - used) / (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))   + 1);
		fsun.fs .fs_bsize >>= 1;
		fsun.fs .fs_frag >>= 1;
		fsun.fs .fs_fragshift -= 1;
		mincpc >>= 1;
		fsun.fs .fs_cpg = ((((mincpgcnt)+(( mincpc)-1))/( mincpc))*( mincpc)) ;
		if ( 	(sizeof(struct cg) + sizeof(long) +  	(&fsun.fs )->fs_cpg * sizeof(long) +  	(&fsun.fs )->fs_cpg * (&fsun.fs )->fs_nrpos * sizeof(short) +  	((((&fsun.fs )->fs_ipg)+(( 8		)-1))/( 8		))  +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		))  +  	((&fsun.fs )->fs_contigsumsize <= 0 ? 0 :  	(&fsun.fs )->fs_contigsumsize * sizeof(long) +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) )+(( 8		)-1))/( 8		)) ))  > fsun.fs .fs_bsize) {
			fsun.fs .fs_bsize <<= 1;
			break;
		}
		mincpg = fsun.fs .fs_cpg;
		inospercg =
		    (((((mincpg * bpcg - used) / density)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) )) ;
		fsun.fs .fs_ipg = inospercg;
	}
	if (inodecramped) {
		if (inospercg > (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))  ) {
			printf("Minimum bytes per inode is %d\n",
			    (mincpg * bpcg - used) / (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))   + 1);
		} else if (!mapcramped) {
			printf("With %d bytes per inode, ", density);
			printf("minimum cylinders per group is %d\n", mincpg);
		}
	}
	if (mapcramped) {
		printf("With %d sectors per cylinder, ", fsun.fs .fs_spc);
		printf("minimum cylinders per group is %d\n", mincpg);
	}
	if (inodecramped || mapcramped) {
		if (fsun.fs .fs_bsize != bsize)
			printf("%s to be changed from %d to %d\n",
			    "This requires the block size",
			    bsize, fsun.fs .fs_bsize);
		if (fsun.fs .fs_fsize != fsize)
			printf("\t%s to be changed from %d to %d\n",
			    "and the fragment size",
			    fsize, fsun.fs .fs_fsize);
		exit(23);
	}
	 


	fsun.fs .fs_cpg = cpg;
	if (fsun.fs .fs_cpg % mincpc != 0) {
		printf("%s groups must have a multiple of %d cylinders\n",
			cpgflg ? "Cylinder" : "Warning: cylinder", mincpc);
		fsun.fs .fs_cpg = ((((fsun.fs .fs_cpg)+(( mincpc)-1))/( mincpc))*( mincpc)) ;
		if (!cpgflg)
			cpg = fsun.fs .fs_cpg;
	}
	 


	fsun.fs .fs_ipg = (((((fsun.fs .fs_cpg * bpcg - used) / density)+((
		((&fsun.fs )->fs_inopb) )-1))/(		((&fsun.fs )->fs_inopb) ))*(		((&fsun.fs )->fs_inopb) )) ;
	while (fsun.fs .fs_ipg > (((((&fsun.fs )->fs_bsize * 8		 / 3)+(( ((&fsun.fs )->fs_inopb) )-1))/( ((&fsun.fs )->fs_inopb) ))*( ((&fsun.fs )->fs_inopb) ))  ) {
		inodecramped = 1;
		fsun.fs .fs_cpg -= mincpc;
		fsun.fs .fs_ipg = (((((fsun.fs .fs_cpg * bpcg - used) / density)+((
			((&fsun.fs )->fs_inopb) )-1))/(			((&fsun.fs )->fs_inopb) ))*(			((&fsun.fs )->fs_inopb) )) ;
	}
	 


	while ( 	(sizeof(struct cg) + sizeof(long) +  	(&fsun.fs )->fs_cpg * sizeof(long) +  	(&fsun.fs )->fs_cpg * (&fsun.fs )->fs_nrpos * sizeof(short) +  	((((&fsun.fs )->fs_ipg)+(( 8		)-1))/( 8		))  +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		))  +  	((&fsun.fs )->fs_contigsumsize <= 0 ? 0 :  	(&fsun.fs )->fs_contigsumsize * sizeof(long) +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) )+(( 8		)-1))/( 8		)) ))  > fsun.fs .fs_bsize) {
		mapcramped = 1;
		fsun.fs .fs_cpg -= mincpc;
		fsun.fs .fs_ipg = (((((fsun.fs .fs_cpg * bpcg - used) / density)+((
			((&fsun.fs )->fs_inopb) )-1))/(			((&fsun.fs )->fs_inopb) ))*(			((&fsun.fs )->fs_inopb) )) ;
	}
	fsun.fs .fs_fpg = (fsun.fs .fs_cpg * fsun.fs .fs_spc) / ((&fsun.fs )->fs_nspf) ;
	if ((fsun.fs .fs_cpg * fsun.fs .fs_spc) % ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift)  != 0) {
		printf("panic (fs_cpg * fs_spc) % NSPF != 0");
		exit(24);
	}
	if (fsun.fs .fs_cpg < mincpg) {
		printf("cylinder groups must have at least %d cylinders\n",
			mincpg);
		exit(25);
	} else if (fsun.fs .fs_cpg != cpg) {
		if (!cpgflg)
			printf("Warning: ");
		else if (!mapcramped && !inodecramped)
			exit(26);
		if (mapcramped && inodecramped)
			printf("Block size and bytes per inode restrict");
		else if (mapcramped)
			printf("Block size restricts");
		else
			printf("Bytes per inode restrict");
		printf(" cylinders per group to %d.\n", fsun.fs .fs_cpg);
		if (cpgflg)
			exit(27);
	}
	fsun.fs .fs_cgsize = (((  	(sizeof(struct cg) + sizeof(long) +  	(&fsun.fs )->fs_cpg * sizeof(long) +  	(&fsun.fs )->fs_cpg * (&fsun.fs )->fs_nrpos * sizeof(short) +  	((((&fsun.fs )->fs_ipg)+(( 8		)-1))/( 8		))  +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		))  +  	((&fsun.fs )->fs_contigsumsize <= 0 ? 0 :  	(&fsun.fs )->fs_contigsumsize * sizeof(long) +  	((((&fsun.fs )->fs_cpg * (&fsun.fs )->fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) )+(( 8		)-1))/( 8		)) )) ) + (&fsun.fs )->fs_qfmask) & (&fsun.fs )->fs_fmask) ;
	 



	fsun.fs .fs_size = fssize = (( fssize) >> (&fsun.fs )->fs_fsbtodb) ;
	fsun.fs .fs_ncyl = fssize * ((&fsun.fs )->fs_nspf)  / fsun.fs .fs_spc;
	if (fssize * ((&fsun.fs )->fs_nspf)  > fsun.fs .fs_ncyl * fsun.fs .fs_spc) {
		fsun.fs .fs_ncyl++;
		warn = 1;
	}
	if (fsun.fs .fs_ncyl < 1) {
		printf("file systems must have at least one cylinder\n");
		exit(28);
	}
	 










	fsun.fs .fs_interleave = interleave;
	fsun.fs .fs_trackskew = trackskew;
	fsun.fs .fs_npsect = nphyssectors;
	fsun.fs .fs_postblformat = 1	;
	fsun.fs .fs_sbsize = ((( sizeof(struct fs)) + (&fsun.fs )->fs_qfmask) & (&fsun.fs )->fs_fmask) ;
	if (fsun.fs .fs_ntrak == 1) {
		fsun.fs .fs_cpc = 0;
		goto next;
	}
	postblsize = fsun.fs .fs_nrpos * fsun.fs .fs_cpc * sizeof(short);
	rotblsize = fsun.fs .fs_cpc * fsun.fs .fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) ;
	totalsbsize = sizeof(struct fs) + rotblsize;
	if (fsun.fs .fs_nrpos == 8 && fsun.fs .fs_cpc <= 16) {
		 
		fsun.fs .fs_postbloff = (char *)(&fsun.fs .fs_opostbl[0][0]) -
		    (char *)(&fsun.fs .fs_link);
		fsun.fs .fs_rotbloff = &fsun.fs .fs_space[0] -
		    (u_char *)(&fsun.fs .fs_link);
	} else {
		 
		fsun.fs .fs_postbloff = &fsun.fs .fs_space[0] -
		    (u_char *)(&fsun.fs .fs_link);
		fsun.fs .fs_rotbloff = fsun.fs .fs_postbloff + postblsize;
		totalsbsize += postblsize;
	}
	if (totalsbsize > 	8192  ||
	    fsun.fs .fs_nsect > (1 << 8		) * ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) ) {
		printf("%s %s %d %s %d.%s",
		    "Warning: insufficient space in super block for\n",
		    "rotational layout tables with nsect", fsun.fs .fs_nsect,
		    "and ntrak", fsun.fs .fs_ntrak,
		    "\nFile system performance may be impaired.\n");
		fsun.fs .fs_cpc = 0;
		goto next;
	}
	fsun.fs .fs_sbsize = ((( totalsbsize) + (&fsun.fs )->fs_qfmask) & (&fsun.fs )->fs_fmask) ;
	 


	for (cylno = 0; cylno < fsun.fs .fs_cpc; cylno++)
		for (rpos = 0; rpos < fsun.fs .fs_nrpos; rpos++)
			(((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_opostbl[ cylno]) : ((short *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_postbloff) + ( cylno) * (&fsun.fs )->fs_nrpos)) [rpos] = -1;
	for (i = (rotblsize - 1) * fsun.fs .fs_frag;
	     i >= 0; i -= fsun.fs .fs_frag) {
		cylno = (( i) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ;
		rpos = ((( i) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc / (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_trackskew + ( i) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_interleave) % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_nrpos / (&fsun.fs )->fs_npsect) ;
		blk = (( i) >> (&fsun.fs )->fs_fragshift) ;
		if ((((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_opostbl[ cylno]) : ((short *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_postbloff) + ( cylno) * (&fsun.fs )->fs_nrpos)) [rpos] == -1)
			(((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_space) : ((u_char *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_rotbloff))) [blk] = 0;
		else
			(((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_space) : ((u_char *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_rotbloff))) [blk] =
			    (((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_opostbl[ cylno]) : ((short *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_postbloff) + ( cylno) * (&fsun.fs )->fs_nrpos)) [rpos] - blk;
		(((&fsun.fs )->fs_postblformat == 	-1	) ? ((&fsun.fs )->fs_opostbl[ cylno]) : ((short *)((char *)(&fsun.fs ) + (&fsun.fs )->fs_postbloff) + ( cylno) * (&fsun.fs )->fs_nrpos)) [rpos] = blk;
	}
next:
	 


	fsun.fs .fs_ncg = fsun.fs .fs_ncyl / fsun.fs .fs_cpg;
	if (fsun.fs .fs_ncyl % fsun.fs .fs_cpg)
		fsun.fs .fs_ncg++;
	fsun.fs .fs_dblkno = fsun.fs .fs_iblkno + fsun.fs .fs_ipg / ((&fsun.fs )->fs_inopb >> (&fsun.fs )->fs_fragshift) ;
	i = (((~fsun.fs .fs_cgmask)<( fsun.fs .fs_ncg - 1))?(~fsun.fs .fs_cgmask):( fsun.fs .fs_ncg - 1)) ;
	if (((((daddr_t)((&fsun.fs )->fs_fpg * (   i)))  + (&fsun.fs )->fs_cgoffset * ((  i) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 - ((daddr_t)((&fsun.fs )->fs_fpg * ( i)))  >= fsun.fs .fs_fpg) {
		printf("inode blocks/cyl group (%d) >= data blocks (%d)\n",
		    ((((daddr_t)((&fsun.fs )->fs_fpg * (   i)))  + (&fsun.fs )->fs_cgoffset * ((  i) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 - ((daddr_t)((&fsun.fs )->fs_fpg * ( i)))  / fsun.fs .fs_frag,
		    fsun.fs .fs_fpg / fsun.fs .fs_frag);
		printf("number of cylinders per cylinder group (%d) %s.\n",
		    fsun.fs .fs_cpg, "must be increased");
		exit(29);
	}
	j = fsun.fs .fs_ncg - 1;
	if ((i = fssize - j * fsun.fs .fs_fpg) < fsun.fs .fs_fpg &&
	    ((((daddr_t)((&fsun.fs )->fs_fpg * (   j)))  + (&fsun.fs )->fs_cgoffset * ((  j) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 - ((daddr_t)((&fsun.fs )->fs_fpg * ( j)))  > i) {
		if (j == 0) {
			printf("Filesystem must have at least %d sectors\n",
			    ((&fsun.fs )->fs_nspf)  *
			    (((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 + 3 * fsun.fs .fs_frag));
			exit(30);
		}
		printf("Warning: inode blocks/cyl group (%d) >= data blocks (%d) in last\n",
		    (((((daddr_t)((&fsun.fs )->fs_fpg * (   j)))  + (&fsun.fs )->fs_cgoffset * ((  j) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 - ((daddr_t)((&fsun.fs )->fs_fpg * ( j))) ) / fsun.fs .fs_frag,
		    i / fsun.fs .fs_frag);
		printf("    cylinder group. This implies %d sector(s) cannot be allocated.\n",
		    i * ((&fsun.fs )->fs_nspf) );
		fsun.fs .fs_ncg--;
		fsun.fs .fs_ncyl -= fsun.fs .fs_ncyl % fsun.fs .fs_cpg;
		fsun.fs .fs_size = fssize = fsun.fs .fs_ncyl * fsun.fs .fs_spc /
		    ((&fsun.fs )->fs_nspf) ;
		warn = 0;
	}
	if (warn && !mfs) {
		printf("Warning: %d sector(s) in last cylinder unallocated\n",
		    fsun.fs .fs_spc -
		    (fssize * ((&fsun.fs )->fs_nspf)  - (fsun.fs .fs_ncyl - 1)
		    * fsun.fs .fs_spc));
	}
	 


	fsun.fs .fs_csaddr = ((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	;
	fsun.fs .fs_cssize =
	    ((( fsun.fs .fs_ncg * sizeof(struct csum)) + (&fsun.fs )->fs_qfmask) & (&fsun.fs )->fs_fmask) ;
	i = fsun.fs .fs_bsize / sizeof(struct csum);
	fsun.fs .fs_csmask = ~(i - 1);
	for (fsun.fs .fs_csshift = 0; i > 1; i >>= 1)
		fsun.fs .fs_csshift++;
	fscs = (struct csum *)calloc(1, fsun.fs .fs_cssize);
	fsun.fs .fs_magic = 0x011954	;
	fsun.fs .fs_rotdelay = rotdelay;
	fsun.fs .fs_minfree = minfree;
	fsun.fs .fs_maxcontig = maxcontig;
	fsun.fs .fs_headswitch = headswitch;
	fsun.fs .fs_trkseek = trackseek;
	fsun.fs .fs_maxbpg = maxbpg;
	fsun.fs .fs_rps = rpm / 60;
	fsun.fs .fs_optim = opt;
	fsun.fs .fs_cgrotor = 0;
	fsun.fs .fs_cstotal.cs_ndir = 0;
	fsun.fs .fs_cstotal.cs_nbfree = 0;
	fsun.fs .fs_cstotal.cs_nifree = 0;
	fsun.fs .fs_cstotal.cs_nffree = 0;
	fsun.fs .fs_fmod = 0;
	fsun.fs .fs_ronly = 0;
	fsun.fs .fs_id = id;
	 


	if (!mfs) {
		printf("%s:\t%d sectors in %d %s of %d tracks, %d sectors\n",
		    fsys, fsun.fs .fs_size * ((&fsun.fs )->fs_nspf) , fsun.fs .fs_ncyl,
		    "cylinders", fsun.fs .fs_ntrak, fsun.fs .fs_nsect);

		printf("\t%.1fMB in %d cyl groups (%d c/g, %.2fMB/g, %d i/g)\n",
		    (float)fsun.fs .fs_size * fsun.fs .fs_fsize * (1 / (1024.0 * 1024.0)) ,
		    fsun.fs .fs_ncg, fsun.fs .fs_cpg,
		    (float)fsun.fs .fs_fpg * fsun.fs .fs_fsize * (1 / (1024.0 * 1024.0)) ,
		    fsun.fs .fs_ipg);

	}
	 



	if (!mfs)
		printf("super-block backups (for fsck -b #) at:");
	for (cylno = 0; cylno < fsun.fs .fs_ncg; cylno++) {
		initcg(cylno, utime);
		if (mfs)
			continue;
		if (cylno % 9 == 0)
			printf("\n");
		printf(" %d,", (( ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_sblkno)	) << (&fsun.fs )->fs_fsbtodb) );
	}
	if (!mfs)
		printf("\n");
	if (Nflag && !mfs)
		exit(0);
	 



	fsinit(utime);
	fsun.fs .fs_time = utime;
	wtfs((int)	((off_t)(	((off_t)(0))  + 	8192 ))  / sectorsize, sbsize, (char *)&fsun.fs );
	for (i = 0; i < fsun.fs .fs_cssize; i += fsun.fs .fs_bsize)
		wtfs((( fsun.fs .fs_csaddr + (( i) >> (&fsun.fs )->fs_fshift) ) << (&fsun.fs )->fs_fsbtodb) ,
			fsun.fs .fs_cssize - i < fsun.fs .fs_bsize ?
			    fsun.fs .fs_cssize - i : fsun.fs .fs_bsize,
			((char *)fscs) + i);
	 


	for (cylno = 0; cylno < fsun.fs .fs_ncg; cylno++)
		wtfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_sblkno)	) << (&fsun.fs )->fs_fsbtodb) ,
		    sbsize, (char *)&fsun.fs );
	 



	pp->p_fstype = 7		;
	pp->p_fsize = fsun.fs .fs_fsize;
	pp->p_frag = fsun.fs .fs_frag;
	pp->__partition_u1.cpg  = fsun.fs .fs_cpg;
	 



	if (mfs) {
		kill(ppid, 30	);
		(void) setsid();
		(void) close(0);
		(void) close(1);
		(void) close(2);
		(void) chdir("/");
	}
}

 


initcg(cylno, utime)
	int cylno;
	time_t utime;
{
	daddr_t cbase, d, dlower, dupper, dmax, blkno;
	long i, j, s;
	register struct csum *cs;

	 




	cbase = ((daddr_t)((&fsun.fs )->fs_fpg * ( cylno))) ;
	dmax = cbase + fsun.fs .fs_fpg;
	if (dmax > fsun.fs .fs_size)
		dmax = fsun.fs .fs_size;
	dlower = ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_sblkno)	 - cbase;
	dupper = ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_dblkno)	 - cbase;
	if (cylno == 0)
		dupper += (((fsun.fs .fs_cssize)+(( fsun.fs .fs_fsize)-1))/( fsun.fs .fs_fsize)) ;
	cs = fscs + cylno;
	bzero(&cgun.cg , fsun.fs .fs_cgsize);
	cgun.cg .cg_time = utime;
	cgun.cg .cg_magic = 0x090255 ;
	cgun.cg .cg_cgx = cylno;
	if (cylno == fsun.fs .fs_ncg - 1)
		cgun.cg .cg_ncyl = fsun.fs .fs_ncyl % fsun.fs .fs_cpg;
	else
		cgun.cg .cg_ncyl = fsun.fs .fs_cpg;
	cgun.cg .cg_niblk = fsun.fs .fs_ipg;
	cgun.cg .cg_ndblk = dmax - cbase;
	if (fsun.fs .fs_contigsumsize > 0)
		cgun.cg .cg_nclusterblks = cgun.cg .cg_ndblk / fsun.fs .fs_frag;
	cgun.cg .cg_btotoff = &cgun.cg .cg_space[0] - (u_char *)(&cgun.cg .cg_link);
	cgun.cg .cg_boff = cgun.cg .cg_btotoff + fsun.fs .fs_cpg * sizeof(long);
	cgun.cg .cg_iusedoff = cgun.cg .cg_boff + 
		fsun.fs .fs_cpg * fsun.fs .fs_nrpos * sizeof(short);
	cgun.cg .cg_freeoff = cgun.cg .cg_iusedoff + (((fsun.fs .fs_ipg)+(( 8		)-1))/( 8		)) ;
	if (fsun.fs .fs_contigsumsize <= 0) {
		cgun.cg .cg_nextfreeoff = cgun.cg .cg_freeoff +
		   (((fsun.fs .fs_cpg * fsun.fs .fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		)) ;
	} else {
		cgun.cg .cg_clustersumoff = cgun.cg .cg_freeoff + (((fsun.fs .fs_cpg * fsun.fs .fs_spc / ((&fsun.fs )->fs_nspf) )+(( 8		)-1))/( 8		))  -

		    sizeof(long);
		cgun.cg .cg_clustersumoff =
		    ((((cgun.cg .cg_clustersumoff)+(( sizeof(long))-1))/( sizeof(long)))*( sizeof(long))) ;
		cgun.cg .cg_clusteroff = cgun.cg .cg_clustersumoff +
		    (fsun.fs .fs_contigsumsize + 1) * sizeof(long);
		cgun.cg .cg_nextfreeoff = cgun.cg .cg_clusteroff + (((fsun.fs .fs_cpg * fsun.fs .fs_spc / ((&fsun.fs )->fs_nspf << (&fsun.fs )->fs_fragshift) )+(( 8		)-1))/( 8		)) ;

	}
	if (cgun.cg .cg_nextfreeoff - (long)(&cgun.cg .cg_link) > fsun.fs .fs_cgsize) {
		printf("Panic: cylinder group too big\n");
		exit(37);
	}
	cgun.cg .cg_cs.cs_nifree += fsun.fs .fs_ipg;
	if (cylno == 0)
		for (i = 0; i < ((ino_t)2) ; i++) {
			(((((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_iused) : ((char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_iusedoff))) )[( i)/8		] |= 1<<(( i)%8		)) ;
			cgun.cg .cg_cs.cs_nifree--;
		}
	for (i = 0; i < fsun.fs .fs_ipg / ((&fsun.fs )->fs_inopb >> (&fsun.fs )->fs_fragshift) ; i += fsun.fs .fs_frag)
		wtfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_iblkno)	 + i) << (&fsun.fs )->fs_fsbtodb) ,
		    fsun.fs .fs_bsize, (char *)zino);
	if (cylno > 0) {
		 



		for (d = 0; d < dlower; d += fsun.fs .fs_frag) {
			blkno = d / fsun.fs .fs_frag;
			setblock(&fsun.fs , (((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) , blkno);
			if (fsun.fs .fs_contigsumsize > 0)
				((((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_clusteroff)) )[( blkno)/8		] |= 1<<(( blkno)%8		)) ;
			cgun.cg .cg_cs.cs_nbfree++;
			(((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_btot) : ((long *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_btotoff))) [(( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]++;
			((( &cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)( &cgun.cg ))->cg_b[ (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]) : ((short *)((char *)( &cgun.cg ) + ( &cgun.cg )->cg_boff) + ( (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ) * (&fsun.fs )->fs_nrpos)) 
			    [((( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc / (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_trackskew + ( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_interleave) % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_nrpos / (&fsun.fs )->fs_npsect) ]++;
		}
		fsun.fs .fs_dsize += dlower;
	}
	fsun.fs .fs_dsize += cgun.cg .cg_ndblk - dupper;
	if (i = dupper % fsun.fs .fs_frag) {
		cgun.cg .cg_frsum[fsun.fs .fs_frag - i]++;
		for (d = dupper + fsun.fs .fs_frag - i; dupper < d; dupper++) {
			(((((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) )[( dupper)/8		] |= 1<<(( dupper)%8		)) ;
			cgun.cg .cg_cs.cs_nffree++;
		}
	}
	for (d = dupper; d + fsun.fs .fs_frag <= dmax - cbase; ) {
		blkno = d / fsun.fs .fs_frag;
		setblock(&fsun.fs , (((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) , blkno);
		if (fsun.fs .fs_contigsumsize > 0)
			((((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_clusteroff)) )[( blkno)/8		] |= 1<<(( blkno)%8		)) ;
		cgun.cg .cg_cs.cs_nbfree++;
		(((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_btot) : ((long *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_btotoff))) [(( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]++;
		((( &cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)( &cgun.cg ))->cg_b[ (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]) : ((short *)((char *)( &cgun.cg ) + ( &cgun.cg )->cg_boff) + ( (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ) * (&fsun.fs )->fs_nrpos)) 
		    [((( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc / (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_trackskew + ( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_interleave) % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_nrpos / (&fsun.fs )->fs_npsect) ]++;
		d += fsun.fs .fs_frag;
	}
	if (d < dmax - cbase) {
		cgun.cg .cg_frsum[dmax - cbase - d]++;
		for (; d < dmax - cbase; d++) {
			(((((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) )[( d)/8		] |= 1<<(( d)%8		)) ;
			cgun.cg .cg_cs.cs_nffree++;
		}
	}
	if (fsun.fs .fs_contigsumsize > 0) {
		long *sump = ((long *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_clustersumoff)) ;
		u_char *mapp = ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_clusteroff)) ;
		int map = *mapp++;
		int bit = 1;
		int run = 0;

		for (i = 0; i < cgun.cg .cg_nclusterblks; i++) {
			if ((map & bit) != 0) {
				run++;
			} else if (run != 0) {
				if (run > fsun.fs .fs_contigsumsize)
					run = fsun.fs .fs_contigsumsize;
				sump[run]++;
				run = 0;
			}
			if ((i & (8		 - 1)) != (8		 - 1)) {
				bit <<= 1;
			} else {
				map = *mapp++;
				bit = 1;
			}
		}
		if (run != 0) {
			if (run > fsun.fs .fs_contigsumsize)
				run = fsun.fs .fs_contigsumsize;
			sump[run]++;
		}
	}
	fsun.fs .fs_cstotal.cs_ndir += cgun.cg .cg_cs.cs_ndir;
	fsun.fs .fs_cstotal.cs_nffree += cgun.cg .cg_cs.cs_nffree;
	fsun.fs .fs_cstotal.cs_nbfree += cgun.cg .cg_cs.cs_nbfree;
	fsun.fs .fs_cstotal.cs_nifree += cgun.cg .cg_cs.cs_nifree;
	*cs = cgun.cg .cg_cs;
	wtfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   cylno)))  + (&fsun.fs )->fs_cgoffset * ((  cylno) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_cblkno)	) << (&fsun.fs )->fs_fsbtodb) ,
		fsun.fs .fs_bsize, (char *)&cgun.cg );
}

 


struct dinode node;







struct direct root_dir[] = {
	{ ((ino_t)2) , sizeof(struct direct), 	 4 , 1, "." },
	{ ((ino_t)2) , sizeof(struct direct), 	 4 , 2, ".." },



};
struct odirect {
	u_long	d_ino;
	u_short	d_reclen;
	u_short	d_namlen;
	u_char	d_name[255  + 1];
} oroot_dir[] = {
	{ ((ino_t)2) , sizeof(struct direct), 1, "." },
	{ ((ino_t)2) , sizeof(struct direct), 2, ".." },



};
# 831 "mkfs.c"

char buf[	(64 * 1024)  ];

fsinit(utime)
	time_t utime;
{
	int i;

	 


	node.di_atime.ts_sec = utime;
	node.di_mtime.ts_sec = utime;
	node.di_ctime.ts_sec = utime;
# 867 "mkfs.c"

	 


	if (mfs)
		node.di_mode = 	0040000		 | 01777;
	else
		node.di_mode = 	0040000		 | 	0755 ;
	node.di_nlink = 2 ;
	if (Oflag)
		node.di_size = makedir((struct direct *)oroot_dir, 2 );
	else
		node.di_size = makedir(root_dir, 2 );
	node.di_db[0] = alloc(fsun.fs .fs_fsize, node.di_mode);
	node.di_blocks = ((unsigned)(((( node.di_size) + (&fsun.fs )->fs_qfmask) & (&fsun.fs )->fs_fmask) ) >> 9		) ;
	wtfs((( node.di_db[0]) << (&fsun.fs )->fs_fsbtodb) , fsun.fs .fs_fsize, buf);
	iput(&node, ((ino_t)2) );
}

 



makedir(protodir, entries)
	register struct direct *protodir;
	int entries;
{
	char *cp;
	int i, spcleft;

	spcleft = 512  ;
	for (cp = buf, i = 0; i < entries - 1; i++) {
		protodir[i].d_reclen = ((sizeof (struct direct) - (255 +1)) + ((( &protodir[i])->d_namlen+1 + 3) &~ 3)) ;
		bcopy(&protodir[i], cp, protodir[i].d_reclen);
		cp += protodir[i].d_reclen;
		spcleft -= protodir[i].d_reclen;
	}
	protodir[i].d_reclen = spcleft;
	bcopy(&protodir[i], cp, ((sizeof (struct direct) - (255 +1)) + ((( &protodir[i])->d_namlen+1 + 3) &~ 3)) );
	return (512  );
}

 


daddr_t
alloc(size, mode)
	int size;
	int mode;
{
	int i, frag;
	daddr_t d, blkno;

	rdfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_cblkno)	) << (&fsun.fs )->fs_fsbtodb) , fsun.fs .fs_cgsize,
	    (char *)&cgun.cg );
	if (cgun.cg .cg_magic != 0x090255 ) {
		printf("cg 0: bad magic number\n");
		return (0);
	}
	if (cgun.cg .cg_cs.cs_nbfree == 0) {
		printf("first cylinder group ran out of space\n");
		return (0);
	}
	for (d = 0; d < cgun.cg .cg_ndblk; d += fsun.fs .fs_frag)
		if (isblock(&fsun.fs , (((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) , d / fsun.fs .fs_frag))
			goto goth;
	printf("internal error: can't find block in cyl 0\n");
	return (0);
goth:
	blkno = (( d) >> (&fsun.fs )->fs_fragshift) ;
	clrblock(&fsun.fs , (((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) , blkno);
	((((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_clusteroff)) )[( blkno)/8		] &= ~(1<<(( blkno)%8		))) ;
	cgun.cg .cg_cs.cs_nbfree--;
	fsun.fs .fs_cstotal.cs_nbfree--;
	fscs[0].cs_nbfree--;
	if (mode & 	0040000		) {
		cgun.cg .cg_cs.cs_ndir++;
		fsun.fs .fs_cstotal.cs_ndir++;
		fscs[0].cs_ndir++;
	}
	(((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_btot) : ((long *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_btotoff))) [(( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]--;
	((( &cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)( &cgun.cg ))->cg_b[ (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ]) : ((short *)((char *)( &cgun.cg ) + ( &cgun.cg )->cg_boff) + ( (( d) * ((&fsun.fs )->fs_nspf)  / (&fsun.fs )->fs_spc) ) * (&fsun.fs )->fs_nrpos)) [((( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc / (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_trackskew + ( d) * ((&fsun.fs )->fs_nspf)  % (&fsun.fs )->fs_spc % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_interleave) % (&fsun.fs )->fs_nsect * (&fsun.fs )->fs_nrpos / (&fsun.fs )->fs_npsect) ]--;
	if (size != fsun.fs .fs_bsize) {
		frag = (((size)+(( fsun.fs .fs_fsize)-1))/( fsun.fs .fs_fsize)) ;
		fscs[0].cs_nffree += fsun.fs .fs_frag - frag;
		fsun.fs .fs_cstotal.cs_nffree += fsun.fs .fs_frag - frag;
		cgun.cg .cg_cs.cs_nffree += fsun.fs .fs_frag - frag;
		cgun.cg .cg_frsum[fsun.fs .fs_frag - frag]++;
		for (i = frag; i < fsun.fs .fs_frag; i++)
			(((((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_free) : ((u_char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_freeoff))) )[( d + i)/8		] |= 1<<(( d + i)%8		)) ;
	}
	wtfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_cblkno)	) << (&fsun.fs )->fs_fsbtodb) , fsun.fs .fs_cgsize,
	    (char *)&cgun.cg );
	return (d);
}

 


iput(ip, ino)
	register struct dinode *ip;
	register ino_t ino;
{
	struct dinode buf[(	(64 * 1024)   / sizeof(struct dinode)) ];
	daddr_t d;
	int c;

	c = (( ino) / (&fsun.fs )->fs_ipg) ;
	rdfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_cblkno)	) << (&fsun.fs )->fs_fsbtodb) , fsun.fs .fs_cgsize,
	    (char *)&cgun.cg );
	if (cgun.cg .cg_magic != 0x090255 ) {
		printf("cg 0: bad magic number\n");
		exit(31);
	}
	cgun.cg .cg_cs.cs_nifree--;
	(((((&cgun.cg )->cg_magic != 0x090255 ) ? (((struct ocg *)(&cgun.cg ))->cg_iused) : ((char *)((char *)(&cgun.cg ) + (&cgun.cg )->cg_iusedoff))) )[( ino)/8		] |= 1<<(( ino)%8		)) ;
	wtfs((( ((((daddr_t)((&fsun.fs )->fs_fpg * (   0)))  + (&fsun.fs )->fs_cgoffset * ((  0) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_cblkno)	) << (&fsun.fs )->fs_fsbtodb) , fsun.fs .fs_cgsize,
	    (char *)&cgun.cg );
	fsun.fs .fs_cstotal.cs_nifree--;
	fscs[0].cs_nifree--;
	if (ino >= fsun.fs .fs_ipg * fsun.fs .fs_ncg) {
		printf("fsinit: inode value out of range (%d).\n", ino);
		exit(32);
	}
	d = (( ((daddr_t)(((((daddr_t)((&fsun.fs )->fs_fpg * (   ((  ino) / (&fsun.fs )->fs_ipg) )))  + (&fsun.fs )->fs_cgoffset * ((  ((  ino) / (&fsun.fs )->fs_ipg) ) & ~((&fsun.fs )->fs_cgmask)))  + (&fsun.fs )->fs_iblkno)	 +	((( ((( ino) % (&fsun.fs )->fs_ipg) / ((&fsun.fs )->fs_inopb) )) << ((&fsun.fs ))->fs_fragshift) ))) ) << (&fsun.fs )->fs_fsbtodb) ;
	rdfs(d, fsun.fs .fs_bsize, buf);
	buf[(( ino) % ((&fsun.fs )->fs_inopb) ) ] = *ip;
	wtfs(d, fsun.fs .fs_bsize, buf);
}

 


void
started()
{

	exit(0);
}

 


caddr_t
malloc(size)
	register u_long size;
{
	char *base, *i;
	static u_long pgsz;
	struct rlimit rlp;

	if (pgsz == 0) {
		base = sbrk(0);
		pgsz = getpagesize() - 1;
		i = (char *)((u_long)(base + pgsz) &~ pgsz);
		base = sbrk(i - base);
		if (getrlimit(2		, &rlp) < 0)
			perror("getrlimit");
		rlp.rlim_cur = rlp.rlim_max;
		if (setrlimit(2		, &rlp) < 0)
			perror("setrlimit");
		memleft = rlp.rlim_max - (u_long)base;
	}
	size = (size + pgsz) &~ pgsz;
	if (size > memleft)
		size = memleft;
	memleft -= size;
	if (size == 0)
		return (0);
	return ((caddr_t)sbrk(size));
}

 


caddr_t
realloc(ptr, size)
	char *ptr;
	u_long size;
{
	void *p;

	if ((p = malloc(size)) == 	0	)
		return (	0	);
	bcopy(ptr, p, size);
	free(ptr);
	return (p);
}

 


char *
calloc(size, numelm)
	u_long size, numelm;
{
	caddr_t base;

	size *= numelm;
	base = malloc(size);
	bzero(base, size);
	return (base);
}

 


free(ptr)
	char *ptr;
{
	
	 
}

 


rdfs(bno, size, bf)
	daddr_t bno;
	int size;
	char *bf;
{
	int n;

	if (mfs) {
		bcopy(membase + bno * sectorsize, bf, size);
		return;
	}
	if (lseek(fsi, (off_t)bno * sectorsize, 0) < 0) {
		printf("seek error: %ld\n", bno);
		perror("rdfs");
		exit(33);
	}
	n = read(fsi, bf, size);
	if (n != size) {
		printf("read error: %ld\n", bno);
		perror("rdfs");
		exit(34);
	}
}

 


wtfs(bno, size, bf)
	daddr_t bno;
	int size;
	char *bf;
{
	int n;

	if (mfs) {
		bcopy(bf, membase + bno * sectorsize, size);
		return;
	}
	if (Nflag)
		return;
	if (lseek(fso, (off_t)bno * sectorsize, 0	) < 0) {
		printf("seek error: %ld\n", bno);
		perror("wtfs");
		exit(35);
	}
	n = write(fso, bf, size);
	if (n != size) {
		printf("write error: %ld\n", bno);
		perror("wtfs");
		exit(36);
	}
}

 


isblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
{
	unsigned char mask;

	switch (fs->fs_frag) {
	case 8:
		return (cp[h] == 0xff);
	case 4:
		mask = 0x0f << ((h & 0x1) << 2);
		return ((cp[h >> 1] & mask) == mask);
	case 2:
		mask = 0x03 << ((h & 0x3) << 1);
		return ((cp[h >> 2] & mask) == mask);
	case 1:
		mask = 0x01 << (h & 0x7);
		return ((cp[h >> 3] & mask) == mask);
	default:



		fprintf((&__sF[2]) , "isblock bad fs_frag %d\n", fs->fs_frag);

		return (0);
	}
}

 


clrblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
{
	switch ((fs)->fs_frag) {
	case 8:
		cp[h] = 0;
		return;
	case 4:
		cp[h >> 1] &= ~(0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] &= ~(0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] &= ~(0x01 << (h & 0x7));
		return;
	default:



		fprintf((&__sF[2]) , "clrblock bad fs_frag %d\n", fs->fs_frag);

		return;
	}
}

 


setblock(fs, cp, h)
	struct fs *fs;
	unsigned char *cp;
	int h;
{
	switch (fs->fs_frag) {
	case 8:
		cp[h] = 0xff;
		return;
	case 4:
		cp[h >> 1] |= (0x0f << ((h & 0x1) << 2));
		return;
	case 2:
		cp[h >> 2] |= (0x03 << ((h & 0x3) << 1));
		return;
	case 1:
		cp[h >> 3] |= (0x01 << (h & 0x7));
		return;
	default:



		fprintf((&__sF[2]) , "setblock bad fs_frag %d\n", fs->fs_frag);

		return;
	}
}
