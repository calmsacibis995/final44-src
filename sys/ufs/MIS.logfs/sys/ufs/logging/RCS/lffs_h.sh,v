head     1.3;
access   ;
symbols  ;
locks    ; strict;
comment  @# @;


1.3
date     94.10.11.10.43.49;  author margo;  state Exp;
branches ;
next     1.2;

1.2
date     94.08.11.15.42.18;  author margo;  state Exp;
branches ;
next     1.1;

1.1
date     94.06.23.16.45.38;  author margo;  state Exp;
branches ;
next     ;


desc
@Original rev
@


1.3
log
@Pass DB structure to recovery routines.  We use DB to track aborted
ops and two-phase ops.
@
text
@#!/bin/sh
# This script generates the lffs.h file from the lffs.src file.
# We need to create:
# 	defines for the physical record types (logical types are
#		defined in lffs.h manually)
#	structures for the physical record types
#	function prototypes for the log and read functions
#	
PROG=lffs_h.sh
if [ $# -ne 1 ]; then
	echo "Usage: lffs_h.sh <name>.src"
	exit 1
fi

ifile=$1
ofile=`basename $ifile .src`
ofile="$ofile"_auto.h

if [ $ifile = $ofile ]; then
	echo "$PROG: Invalid input; source file should not end in .h"
	exit 1
fi

echo "/* DO NOT EDIT THIS FILE */" > $ofile
echo "#include <db.h>" >> $ofile
# Put a header on the output file.
awk  '
/^[ 	]*BEGIN/ {
	if (in_begin) {
		print "Invalid format: missing END statement"
		error++;
	}
	in_begin = 1;
	structs++;
	nvars=0;
	funcname=$2;
}
/^[ 	]*(ARG|STRING|POINTER)/ {
	vars[nvars] = $2;
	types[nvars] = $3;
	modes[nvars] = $1;
	for (i = 4; i < NF; i++)
		types[nvars] = sprintf("%s %s", types[nvars], $i);

	nvars++;
}
/^[ 	]*END/ {
	if (!in_begin) {
		print "Invalid format: missing BEGIN statement"
		error++;
	} else {
		# define
		printf("\n#define\tREC_%s\t%d\n", funcname, structs);

		# structure declarations
		printf("typedef struct _%s_args {\n", funcname);
		printf("\tu_long machine;\n\tstruct timeval time;\n");
		for (i = 0; i < nvars; i++)
			printf("\t%s\t%s;\n", types[i], vars[i]);
		printf("} %s_args;\n", funcname);

		# Read function prototype
		printf("%s_args * %s_READ(char *buf);\n\n",
		    funcname, funcname);

		# Log function prototype
		printf("int %s_LOG(struct vnode *vp, struct lwrite_entry *lwp",
		    funcname);
		for (i = 0; i < nvars; i++) {
			printf(", ");
			if ((i % 4) == 0)
				printf("\n\t");
			printf("%s %s", types[i], vars[i]);
		}
		printf(");\n\n");

		# Print function prototype
		printf("void %s_PRINT(%s_args *argp);\n\n",
		    funcname, funcname);

		# Recovery function prototype
		printf("void %s_RECOVER(DB *dbp, %s_args *argp);\n\n",
			funcname, funcname);
	}
	in_begin = 0;
}
END {
	# Write lffs_switch function prototype
	printf("void *\nlffs_switch(char *buf, long type);\n");
	printf("void *\nlffs_print(long type, void *rp);\n");
	printf("void\nlffs_apply_record(DB *dbp, long type, void *rp);\n");
	printf("void *\nlffs_read(int fd, char **bufpp, size_t *len, long *typep);\n");
	if (error || in_begin)
		print "Unsuccessful"
}
' < $ifile >> $ofile


@


1.2
log
@Length fields not needed for read routines.  Also, add code to
generate prototypes for all the print, recover, etc. routines.
@
text
@d25 1
d82 1
a82 1
		printf("void %s_RECOVER(%s_args *argp);\n\n",
d91 1
a91 1
	printf("void *\nlffs_apply_record(long type, void *rp);\n");
@


1.1
log
@Initial revision
@
text
@d41 1
a41 1
	for (i = 4; i <= NF; i++)
d52 1
a52 1
		printf("#define\tREC_%s\t%d\n", funcname, structs);
d56 1
d59 1
a59 1
		printf("} %s_args;\n\n\n", funcname);
d62 1
a62 1
		printf("%s_args * %s_READ(char *buf, int len);\n",
d66 2
a67 1
		printf("int\n%s_LOG(struct vnode *vp", funcname);
d69 4
a72 1
			printf(", %s %s", types[i], vars[i]);
d74 9
a82 1
		printf(");\n");
d88 4
a91 1
	printf("void *\nlffs_switch(char *buf, size_t length, long type);\n");
@
