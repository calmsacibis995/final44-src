/* DO NOT EDIT THIS FILE */
#include <stddef.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/signal.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <sys/uio.h>
#include <sys/tty.h>
#include <sys/systm.h>
#include <sys/proc.h>
#include <sys/kernel.h>
#include <sys/vnode.h>
#include <sys/malloc.h>
#include <ufs/ufs/quota.h>
#include <ufs/ufs/inode.h>
#include "lffs.h"
#include "lffs_auto.h"

int
CREATE_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t new_inum, long new_gen, u_long new_uid, u_long new_gid, u_short new_mode, char * new_name, ino_t dir_inum, long dir_gen, short dir_nlink)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_CREATE;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(new_inum)
		     + sizeof(new_gen)
		     + sizeof(new_uid)
		     + sizeof(new_gid)
		     + sizeof(new_mode)
		     + strlen(new_name)
		     + 1 + sizeof(long)
		     + sizeof(dir_inum)
		     + sizeof(dir_gen)
		     + sizeof(dir_nlink);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(new_inum);
	bcopy(&new_inum, bp, n);
	bp += n;
	n = sizeof(new_gen);
	bcopy(&new_gen, bp, n);
	bp += n;
	n = sizeof(new_uid);
	bcopy(&new_uid, bp, n);
	bp += n;
	n = sizeof(new_gid);
	bcopy(&new_gid, bp, n);
	bp += n;
	n = sizeof(new_mode);
	bcopy(&new_mode, bp, n);
	bp += n;
	n = strlen(new_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(new_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = sizeof(dir_inum);
	bcopy(&dir_inum, bp, n);
	bp += n;
	n = sizeof(dir_gen);
	bcopy(&dir_gen, bp, n);
	bp += n;
	n = sizeof(dir_nlink);
	bcopy(&dir_nlink, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 1);
	free(buf, M_LOGBUF);
	return(ret);
}
int
IALLOC_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t new_inum)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_IALLOC;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(new_inum);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(new_inum);
	bcopy(&new_inum, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 0);
	free(buf, M_LOGBUF);
	return(ret);
}
int
REMOVE_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, struct dinode * rem_dip, char * rem_name, ino_t dir_inum, long dir_gen)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_REMOVE;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(*rem_dip)
		     + strlen(rem_name)
		     + 1 + sizeof(long)
		     + sizeof(dir_inum)
		     + sizeof(dir_gen);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(*rem_dip);
	bcopy(rem_dip, bp, n);
	bp += n;
	n = strlen(rem_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(rem_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = sizeof(dir_inum);
	bcopy(&dir_inum, bp, n);
	bp += n;
	n = sizeof(dir_gen);
	bcopy(&dir_gen, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 1);
	free(buf, M_LOGBUF);
	return(ret);
}
int
LINK_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, char * new_name, short new_link_nlink, ino_t link_inum, long link_gen, ino_t dir_inum, long dir_gen, short new_dir_nlink)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_LINK;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + strlen(new_name)
		     + 1 + sizeof(long)
		     + sizeof(new_link_nlink)
		     + sizeof(link_inum)
		     + sizeof(link_gen)
		     + sizeof(dir_inum)
		     + sizeof(dir_gen)
		     + sizeof(new_dir_nlink);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = strlen(new_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(new_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = sizeof(new_link_nlink);
	bcopy(&new_link_nlink, bp, n);
	bp += n;
	n = sizeof(link_inum);
	bcopy(&link_inum, bp, n);
	bp += n;
	n = sizeof(link_gen);
	bcopy(&link_gen, bp, n);
	bp += n;
	n = sizeof(dir_inum);
	bcopy(&dir_inum, bp, n);
	bp += n;
	n = sizeof(dir_gen);
	bcopy(&dir_gen, bp, n);
	bp += n;
	n = sizeof(new_dir_nlink);
	bcopy(&new_dir_nlink, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 1);
	free(buf, M_LOGBUF);
	return(ret);
}
int
SYMLINK_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t new_inum, long new_gen, u_long new_uid, u_long new_gid, u_short new_mode, char * new_name, char * link_name, ino_t dir_inum, long dir_gen)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_SYMLINK;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(new_inum)
		     + sizeof(new_gen)
		     + sizeof(new_uid)
		     + sizeof(new_gid)
		     + sizeof(new_mode)
		     + strlen(new_name)
		     + 1 + sizeof(long)
		     + strlen(link_name)
		     + 1 + sizeof(long)
		     + sizeof(dir_inum)
		     + sizeof(dir_gen);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(new_inum);
	bcopy(&new_inum, bp, n);
	bp += n;
	n = sizeof(new_gen);
	bcopy(&new_gen, bp, n);
	bp += n;
	n = sizeof(new_uid);
	bcopy(&new_uid, bp, n);
	bp += n;
	n = sizeof(new_gid);
	bcopy(&new_gid, bp, n);
	bp += n;
	n = sizeof(new_mode);
	bcopy(&new_mode, bp, n);
	bp += n;
	n = strlen(new_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(new_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = strlen(link_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(link_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = sizeof(dir_inum);
	bcopy(&dir_inum, bp, n);
	bp += n;
	n = sizeof(dir_gen);
	bcopy(&dir_gen, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 1);
	free(buf, M_LOGBUF);
	return(ret);
}
int
RENAME_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t ren_inum, long ren_gen, char * old_name, char * new_name, ino_t old_dir_inum, long old_dir_gen, short old_dir_nlink, ino_t new_dir_inum, long new_dir_gen, short new_dir_nlink)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_RENAME;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(ren_inum)
		     + sizeof(ren_gen)
		     + strlen(old_name)
		     + 1 + sizeof(long)
		     + strlen(new_name)
		     + 1 + sizeof(long)
		     + sizeof(old_dir_inum)
		     + sizeof(old_dir_gen)
		     + sizeof(old_dir_nlink)
		     + sizeof(new_dir_inum)
		     + sizeof(new_dir_gen)
		     + sizeof(new_dir_nlink);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(ren_inum);
	bcopy(&ren_inum, bp, n);
	bp += n;
	n = sizeof(ren_gen);
	bcopy(&ren_gen, bp, n);
	bp += n;
	n = strlen(old_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(old_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = strlen(new_name);
	bcopy(&n, bp, sizeof(n));
	bp += sizeof(n);
	bcopy(new_name, bp, n);
	bp += n;
	*bp = 0;
	n = 1;
	bp += n;
	n = sizeof(old_dir_inum);
	bcopy(&old_dir_inum, bp, n);
	bp += n;
	n = sizeof(old_dir_gen);
	bcopy(&old_dir_gen, bp, n);
	bp += n;
	n = sizeof(old_dir_nlink);
	bcopy(&old_dir_nlink, bp, n);
	bp += n;
	n = sizeof(new_dir_inum);
	bcopy(&new_dir_inum, bp, n);
	bp += n;
	n = sizeof(new_dir_gen);
	bcopy(&new_dir_gen, bp, n);
	bp += n;
	n = sizeof(new_dir_nlink);
	bcopy(&new_dir_nlink, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 1);
	free(buf, M_LOGBUF);
	return(ret);
}
int
ALLOC_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t inum, long gen, daddr_t lbn, daddr_t pbn, u_long nfrags)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_ALLOC;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(inum)
		     + sizeof(gen)
		     + sizeof(lbn)
		     + sizeof(pbn)
		     + sizeof(nfrags);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(inum);
	bcopy(&inum, bp, n);
	bp += n;
	n = sizeof(gen);
	bcopy(&gen, bp, n);
	bp += n;
	n = sizeof(lbn);
	bcopy(&lbn, bp, n);
	bp += n;
	n = sizeof(pbn);
	bcopy(&pbn, bp, n);
	bp += n;
	n = sizeof(nfrags);
	bcopy(&nfrags, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 0);
	free(buf, M_LOGBUF);
	return(ret);
}
int
ABORT_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t inum, long gen, u_long atype)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_ABORT;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(inum)
		     + sizeof(gen)
		     + sizeof(atype);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(inum);
	bcopy(&inum, bp, n);
	bp += n;
	n = sizeof(gen);
	bcopy(&gen, bp, n);
	bp += n;
	n = sizeof(atype);
	bcopy(&atype, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 0);
	free(buf, M_LOGBUF);
	return(ret);
}
int
LOGICAL_LOG(struct vnode *vp, struct lwrite_entry *lwp, u_long type, ino_t inum, long gen, daddr_t lbn)
{
	char	*buf, *bp;
	long	len, n, rectype;
	int machine, ret;
	if (vp == NULL) {
		if (lwp) {
			lwp->logrec_end = 0;
			lwp->logrec_begin = 0;
		}
		return(0);
	}
	machine = 1;
	rectype = REC_LOGICAL;
	len = sizeof(rectype) + sizeof(int) +sizeof(struct timeval)
		+ sizeof(type)
		     + sizeof(inum)
		     + sizeof(gen)
		     + sizeof(lbn);
	buf = (char *)malloc(len, M_LOGBUF, M_WAITOK);
	bp = buf;
	bcopy(&rectype, bp, sizeof(rectype));
	bp += sizeof(rectype);
	bcopy(&machine, bp, sizeof(int));
	bp += sizeof(int);
	bcopy(&time, bp, sizeof(struct timeval));
	bp += sizeof(struct timeval);
	n = sizeof(type);
	bcopy(&type, bp, n);
	bp += n;
	n = sizeof(inum);
	bcopy(&inum, bp, n);
	bp += n;
	n = sizeof(gen);
	bcopy(&gen, bp, n);
	bp += n;
	n = sizeof(lbn);
	bcopy(&lbn, bp, n);
	bp += n;
	if (bp - buf != len)
		panic("Error in log record length");
	ret = lffs_log(vp, lwp, buf, len, curproc->p_ucred, curproc, 0);
	free(buf, M_LOGBUF);
	return(ret);
}
