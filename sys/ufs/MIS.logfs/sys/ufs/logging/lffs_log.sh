#!/bin/sh
# This script generates the XXX_LOG routines in the file
# lffs_log.c, from the lffs.src file.
# We need to create:
# 	A READ function for every record type.
#	A function prototype in the .h file
#	
PROG=lffs_log.sh
if [ $# -ne 1 ]; then
	echo "Usage: lffs_log.sh <name>.src"
	exit 1
fi

ifile=$1
ofile=`basename $ifile .src`
ofile="$ofile"_log.c

if [ $ifile = $ofile ]; then
	echo "$PROG: Invalid input; source file should not end in .c"
	exit 1
fi

echo "/* DO NOT EDIT THIS FILE */" > $ofile
# Put a header on the output file.
awk  '
BEGIN {
	printf("#include <stddef.h>\n");
	printf("#include <sys/types.h>\n");
	printf("#include <sys/param.h>\n");
	printf("#include <sys/signal.h>\n");
	printf("#include <sys/ioctl.h>\n");
	printf("#include <sys/time.h>\n");
	printf("#include <sys/uio.h>\n");
	printf("#include <sys/tty.h>\n");
	printf("#include <sys/systm.h>\n");
	printf("#include <sys/proc.h>\n");
	printf("#include <sys/kernel.h>\n");
	printf("#include <sys/vnode.h>\n");
	printf("#include <sys/malloc.h>\n");
	printf("#include <ufs/ufs/quota.h>\n");
	printf("#include <ufs/ufs/inode.h>\n");
	printf("#include \"lffs.h\"\n");
	printf("#include \"lffs_auto.h\"\n\n");
}
/^[ 	]*BEGIN/ {
	if (in_begin) {
		print "Invalid format: missing END statement"
		error++;
	}
	in_begin = 1;
	nvars=0;
	funcname=$2;
	is_sync = $3;
}
/^[ 	]*(ARG|STRING|POINTER)/ {
	vars[nvars] = $2;
	types[nvars] = $3;
	modes[nvars] = $1;
	atypes[nvars] = $1
	for (i = 4; i < NF; i++)
		types[nvars] = sprintf("%s %s", types[nvars], $i);

	if ($1 == "ARG")
		sizes[nvars] = sprintf("sizeof(%s)", $2);
	else if ($1 == "POINTER")
		sizes[nvars] = sprintf("sizeof(*%s)", $2);
	else 
		sizes[nvars] = sprintf("strlen(%s)", $2);
	nvars++;
}
/^[ 	]*END/ {
	if (!in_begin) {
		print "Invalid format: missing BEGIN statement"
		error++;
	} else {
		# Function declaration
		printf("int\n%s_LOG(struct vnode *vp, struct lwrite_entry *lwp",
		    funcname);
		for (i = 0; i < nvars; i++) {
			printf(", %s %s", types[i], vars[i]);
		}
		printf(")\n");

		# Function body and local decls
		printf("{\n\tchar\t*buf, *bp;\n\tlong\tlen, n, rectype;\n");
		printf("\tint machine, ret;\n");

		# Check no log case
		printf("\tif (vp == NULL) {\n\t\tif (lwp) {\n");
		printf("\t\t\tlwp->logrec_end = 0;\n");
		printf("\t\t\tlwp->logrec_begin = 0;\n\t\t}\n");
		printf("\t\treturn(0);\n\t}\n");

		# Record time
		printf("\tmachine = 1;\n");

		# MALLOC
		printf("\trectype = REC_%s;\n", funcname);
		printf("\tlen = sizeof(rectype) + sizeof(int) +");
		printf("sizeof(struct timeval)\n");
		printf("\t\t+ %s", sizes[0]);
		for (i = 1; i < nvars; i++) {
			printf("\n\t\t     + %s", sizes[i]);
			if (atypes[i] == "STRING")
				printf("\n\t\t     + 1 + sizeof(long)");
		} printf(";\n\tbuf = (char *)malloc(len, M_LOGBUF, M_WAITOK);\n");

		# Copy args into buffer

		printf("\tbp = buf;\n");
		printf("\tbcopy(&rectype, bp, sizeof(rectype));\n");
		printf("\tbp += sizeof(rectype);\n");
		printf("\tbcopy(&machine, bp, sizeof(int));\n");
		printf("\tbp += sizeof(int);\n");
		printf("\tbcopy(&time, bp, sizeof(struct timeval));\n");
		printf("\tbp += sizeof(struct timeval);\n");

		for (i = 0; i < nvars; i ++) {
			printf("\tn = %s;\n", sizes[i]);
			if (modes[i] == "ARG")
				printf("\tbcopy(&%s, bp, n);\n", vars[i]);
			else if (modes[i] == "STRING") {
				printf("\tbcopy(&n, bp, sizeof(n));\n");
				printf("\tbp += sizeof(n);\n");
				printf("\tbcopy(%s, bp, n);\n", vars[i]);
				printf("\tbp += n;\n\t*bp = '\0';\n\tn = 1;\n");
			} else 	# POINTER
				printf("\tbcopy(%s, bp, n);\n", vars[i]);
			printf("\tbp += n;\n");
		}

		# Error checking
		printf("\tif (bp - buf != len)\n\t\tpanic(\"%s\");\n",
		    "Error in log record length");

		# Issue VOP call
		printf("\tret = lffs_log(vp, lwp, buf, len, ");
		if (is_sync == "SYNC")
			sflag = 1;
		else
			sflag = 0;
		printf("curproc->p_ucred, curproc, %d);\n", sflag);

		# Free and return
		printf("\tfree(buf, M_LOGBUF);\n\treturn(ret);\n}\n");
	}
	in_begin = 0;
}
END {
	if (error || in_begin)
		print "Unsuccessful"
}
' < $ifile >> $ofile


