#!/bin/sh
# This script generates the XXX_READ routines in the file
# lffs_read_utils.c, from the lffs.src file.
# We need to create:
# 	A READ function for every record type.
#	
PROG=lffs_read.sh
if [ $# -ne 1 ]; then
	echo "Usage: lffs_read.sh <name>.src"
	exit 1
fi

ifile=$1
ofile=`basename $ifile .src`
ofile="$ofile"_read_utils.c
if [ $ifile = $ofile ]; then
	echo "$PROG: Invalid input; source file should not end in .c"
	exit 1
fi

echo "/* DO NOT EDIT THIS FILE */" > $ofile
# Put a header on the output file.
awk  '
BEGIN {
	num_funcs = 0;
	printf("#include <stddef.h>\n");
	printf("#include <db.h>\n");
	printf("#include <sys/types.h>\n");
	printf("#include <sys/param.h>\n");
	printf("#include <sys/signal.h>\n");
	printf("#include <sys/time.h>\n");
	printf("#include <sys/uio.h>\n");
	printf("#include <sys/ioctl.h>\n");
	printf("#include <sys/tty.h>\n");
	printf("#include <sys/systm.h>\n");
	printf("#include <sys/proc.h>\n");
	printf("#include <sys/vnode.h>\n");
	printf("#include <ufs/ufs/quota.h>\n");
	printf("#include <ufs/ufs/inode.h>\n");
	printf("#include \"lffs.h\"\n");
	printf("#include \"lffs_auto.h\"\n\n");
}
/^[ 	]*BEGIN/ {
	if (in_begin) {
		print "Invalid format: missing END statement"
		error++;
	}
	in_begin = 1;
	nvars=0;
	funcs[num_funcs] = $2;
	num_funcs++;
	funcname=$2;
}
/^[ 	]*(ARG|STRING|POINTER)/ {
	# Get relevant descriptions of all parameters
	vars[nvars] = $2;
	types[nvars] = $3;
	modes[nvars] = $1;

	# If the type is multiple words, make sure to get all of them 
	for (i = 4; i < NF; i++)
		types[nvars] = sprintf("%s %s", types[nvars], $i);

	nvars++;
}
/^[ 	]*END/ {
	if (!in_begin) {
		print "Invalid format: missing BEGIN statement"
		error++;
	} else {
		# Function declaration
		printf("%s_args *\n%s_READ(char *buf)\n",
		    funcname, funcname);

		# Function body and local decls
		printf("{\n\t%s_args\t*argp;\n\tint\tn;\n", funcname);
		printf("\tu_long u;\n");

		# MALLOC
		printf("\n\targp = (%s_args *)malloc(sizeof(%s_args));\n", funcname, funcname);
		printf("\tif (argp == NULL)\n\t\treturn(NULL);\n");

		# First get the machine and time fields
		printf("\tbcopy(buf, &argp->machine, sizeof(u_long));\n");
		printf("\tbuf += sizeof(u_long);\n");
		printf("\tbcopy(buf, &argp->time, sizeof(struct timeval));\n");
		printf("\tbuf += sizeof(struct timeval);\n");
		# Copy log values into structure.
		for (i = 0; i < nvars; i ++) {
			if (modes[i] == "STRING") {
				printf("\tbcopy(buf, &n, sizeof(n));\n");
				printf("\tbuf += sizeof(n);\n");
				printf("\targp->%s = buf;\n", vars[i]);
				printf("\tbuf += n + 1;\n");
			} else if (modes[i] == "ARG") {
				printf("\tbcopy(buf, &argp->%s, %s%s));\n",
				    vars[i], "sizeof(argp->", vars[i]);
				printf("\tbuf += sizeof(argp->%s);\n",
				    vars[i]);
			} # *** NOT SURE HOW TO DEAL WITH POINTERS
		}

		# Free and return
		printf("\treturn(argp);\n}\n");
	}
	in_begin = 0;
}
END {
	if (error || in_begin)
		print "Unsuccessful"
	else {
		# Create the switch routine
		printf("void *\nlffs_switch%s\n", "(char *buf, long type)");
		printf("{\n");
		printf("\tswitch(type) {\n");
		for (i = 0; i < num_funcs; i++) {
			printf("\t\tcase REC_%s:\n", funcs[i]);
			printf("\t\t\treturn(%s_READ(buf));\n",
			    funcs[i]);
		}
		printf("\t\tdefault:\n\t\treturn(NULL);\n");
		printf("\t}\n}\n");
	}
}
' < $ifile >> $ofile


