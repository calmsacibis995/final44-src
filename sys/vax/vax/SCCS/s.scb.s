h12305
s 00011/00010/00071
d D 7.4 88/05/14 11:13:45 karels 28 27
c more cleanup on scb/uba vector setup
e
s 00052/00025/00029
d D 7.3 88/05/07 14:20:15 karels 27 26
c vax 8200 support from torek: generalize cpu support, ops, clock ops
e
s 00001/00001/00053
d D 7.2 87/02/21 11:19:11 karels 26 25
c kdb (for sam; untested); misc.
e
s 00001/00001/00053
d D 7.1 86/06/05 00:57:58 mckusick 25 24
c 4.3BSD release version
e
s 00001/00001/00053
d D 6.5 86/04/22 10:48:15 kridle 24 23
c Added MicroVAX II Support (KA630)
e
s 00000/00019/00054
d D 6.4 86/02/18 17:59:57 sam 23 22
c fixed interrupt slots indices now generated by config (ubvec.s)
e
s 00007/00001/00066
d D 6.3 85/06/08 13:57:10 mckusick 22 21
c Add copyright
e
s 00019/00000/00048
d D 6.2 84/08/21 11:11:48 karels 21 20
c add interrupt counts per device, also software interrupts
e
s 00000/00000/00048
d D 6.1 83/08/11 22:26:52 sam 20 19
c 4.2 distribution
e
s 00002/00000/00046
d D 4.16 83/08/11 22:26:41 sam 19 16
c need uba.h for NUBA
e
s 00000/00000/00046
d R 6.1 83/08/01 12:08:37 sam 18 16
c 4.2 distribution
e
s 00000/00000/00046
d R 4.16 83/08/01 12:05:17 sam 17 16
c 4.2 distribution
e
s 00005/00000/00041
d D 4.15 83/08/01 12:03:36 sam 16 14
c add support for second uba on 750; move rpb in front of 
c scb, otherwise it would be at variable location; add nexi numbers 
c for 64K chip controllers and ci
e
s 00000/00000/00041
d R 6.1 83/07/29 07:21:12 sam 15 14
c 4.2 distribution
e
s 00001/00006/00040
d D 4.14 82/03/19 01:50:20 wnj 14 13
c use only one software interrupt for network
e
s 00003/00003/00043
d D 4.13 81/11/30 16:23:33 wnj 13 12
c lint
e
s 00003/00002/00043
d D 4.12 81/11/26 11:58:49 wnj 12 11
c before carry to arpavax
e
s 00001/00001/00044
d D 4.11 81/11/22 23:56:44 wnj 11 10
c s/BBNNET/INET
e
s 00004/00000/00041
d D 4.10 81/10/17 16:16:38 wnj 10 9
c software interrupt for net
e
s 00001/00001/00040
d D 4.9 81/05/13 15:45:42 wnj 9 8
c fix per kls
e
s 00005/00005/00036
d D 4.8 81/04/02 15:17:35 root 8 7
c add nexus zero vector stuff
e
s 00001/00001/00040
d D 4.7 81/03/09 01:48:36 wnj 7 6
c lint and a few minor fixed
e
s 00001/00001/00040
d D 4.6 81/03/03 11:07:52 wnj 6 5
c add cmrd interrupt vector
e
s 00000/00001/00041
d D 4.5 81/02/21 21:27:36 wnj 5 4
c get rid of Scbbase
e
s 00003/00003/00039
d D 4.4 81/02/15 19:38:36 wnj 4 3
c new interrupt scheme
e
s 00031/00150/00011
d D 4.3 81/02/15 12:17:28 wnj 3 2
c cleaned up with macros
e
s 00003/00021/00158
d D 4.2 81/02/08 18:34:28 wnj 2 1
c first working autoconf version
e
s 00179/00000/00000
d D 4.1 80/12/20 01:02:12 wnj 1 0
c date and time created 80/12/20 01:02:12 by wnj
e
u
U
t
T
I 1
D 7
/*	%M%	%I%	%G%	*/
E 7
I 7
D 22
/*	%M%	%I%	%E%	*/
E 22
I 22
/*
D 25
 * Copyright (c) 1982 Regents of the University of California.
E 25
I 25
 * Copyright (c) 1982, 1986 Regents of the University of California.
E 25
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
 *
 *	%W% (Berkeley) %G%
 */
E 22
E 7

I 19
#include "uba.h"

E 19
/*
 * System control block
 */
	.set	INTSTK,1	# handle this interrupt on the interrupt stack
	.set	HALT,3		# halt if this interrupt occurs

D 3
/*	.align	PGSHIFT	*/
D 2
	.globl	Scbbase
Scbbase:
E 2
I 2
	.globl	_Scbbase
_Scbbase:
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xmachcheck + INTSTK	# machine check interrupt
	.long	Xkspnotval + INTSTK	# kernel stack not valid
	.long	Xpowfail + HALT		# power fail
	.long	Xprivinflt		# privileged instruction 
	.long	Xxfcflt			# xfc instruction 
	.long	Xresopflt		# reserved operand 
	.long	Xresadflt		# reserved addressing 
	.long	Xprotflt		# protection and pt length violation
	.long	Xtransflt		# address translation not valid fault 
	.long	Xtracep			# trace pending
	.long	Xbptflt			# bpt instruction
	.long	Xcompatflt		# compatibility mode fault
	.long	Xarithtrap		# arithmetic trap
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xsyscall		# chmk
	.long	Xchme+INTSTK		# chme
	.long	Xchms+INTSTK		# chms
	.long	Xchmu+INTSTK		# chmu
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#if VAX==750
E 2
I 2
#if VAX==750 || VAX==ANY
E 2
	.long	Xwtime + INTSTK		# write timeout
#else
	.long	Xstray + INTSTK		# unused
#endif
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# software level 1
	.long	Xstray + INTSTK		# software level 2 (asts)
	.long	Xresched		# reschedule nudge
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
ubabase:
	.long	Xclockint		# clock
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
#if VAX==750
	.long	Xconsdin + INTSTK	# tu58 receiver
	.long	Xconsdout + INTSTK	# tu58 transmitter
#else
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
#endif
	.long	Xcnrint + INTSTK	# console receiver 
	.long	Xcnxint + INTSTK	# console transmitter
E 3
I 3
_scb:	.globl	_scb
D 5
_Scbbase: .globl	_Scbbase
E 5
E 3

D 3
/*
 * I/O vectors
 */
E 3
I 3
D 9
#define	STRAY	.long	_Xstray+HALT
E 9
I 9
D 27
#define	STRAY	.long	_Xstray+INTSTK
E 9
#define	STRAY8	STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY
D 8
#define	STRAY16	STRAY8;STRAY8
E 8
I 8
#define	STRAY15	STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY;STRAY8
E 27
E 8
#define	KS(a)	.long	_X/**/a
#define	IS(a)	.long	_X/**/a+INTSTK
#define	STOP(a)	.long	_X/**/a+HALT
E 3

D 3
/* IPL 14 */
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#if VAX==780
	.long	Xua0int + INTSTK	# UBA 0 br4
#else
E 2
	.long	Xstray + INTSTK		# unused
D 2
#endif
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
E 3
I 3
D 27
/* 000 */	STRAY;		IS(machcheck);	IS(kspnotval);	STOP(powfail);
E 27
I 27
#define	STRAY(x)	.long	_scbstray+2*(x)+INTSTK
#define	STRAY3(n)	STRAY(n);STRAY(n+4);STRAY(n+8)
#define	STRAY4(n)	STRAY3(n);STRAY(n+12)
#define	STRAY15(n)	STRAY4(n);STRAY4(n+16);STRAY4(n+32);STRAY3(n+48)
#define	STRAY16(n)	STRAY15(n);STRAY(n+60)
#define	NEX0(n)	IS(nex0zvec);STRAY15(n+4)
#define	NEX1(n)	IS(nex1zvec);STRAY15(n+4)

/* 000 */	IS(passiverel);	IS(machcheck);	IS(kspnotval);	STOP(powfail);
E 27
/* 010 */	KS(privinflt);	KS(xfcflt);	KS(resopflt);	KS(resadflt);
/* 020 */	KS(protflt);	KS(transflt);	KS(tracep);	KS(bptflt);
D 27
/* 030 */	KS(compatflt);	KS(arithtrap);	STRAY;		STRAY;
E 27
I 27
/* 030 */	KS(compatflt);	KS(arithtrap);	STRAY(0x38);	STRAY(0x3c);
E 27
/* 040 */	KS(syscall);	KS(chme);	KS(chms);	KS(chmu);
D 6
/* 050 */	STRAY;		STRAY;		STRAY;		STRAY;
E 6
I 6
D 27
/* 050 */	STRAY;		IS(cmrd);	STRAY;		STRAY;
E 6
/* 060 */	IS(wtime);	STRAY;		STRAY;		STRAY;
/* 070 */	STRAY;		STRAY;		STRAY;		STRAY;
D 4
/* 080 */	STRAY;		STRAY;		STRAY;		KS(resched);
E 4
I 4
/* 080 */	STRAY;		STRAY;		KS(astflt);	STRAY;
E 4
/* 090 */	STRAY;		STRAY;		STRAY;		STRAY;
D 4
/* 0a0 */	STRAY;		STRAY;		STRAY;		STRAY;
E 4
I 4
/* 0a0 */	IS(softclock);	STRAY;		STRAY;		STRAY;
I 10
D 11
#ifdef BBNNET
E 11
I 11
D 14
#ifdef INET
E 11
D 12
/* 0b0 */	IS(netintr);	STRAY;		STRAY;		STRAY;
E 12
I 12
D 13
/* 0b0 */	IS(ipintr);
E 13
I 13
/* 0b0 */	IS(ipintr);	IS(rawintr);
E 13
E 12
#else
E 10
E 4
D 12
/* 0b0 */	STRAY;		STRAY;		STRAY;		STRAY;
E 12
I 12
D 13
/* 0b0 */	STRAY;
E 13
I 13
/* 0b0 */	STRAY;		STRAY;
E 13
E 12
I 10
#endif
I 12
D 13
/* 0b4 */			STRAY;		STRAY;		STRAY;
E 13
I 13
/* 0b4 */					STRAY;		STRAY;
E 14
I 14
D 26
/* 0b0 */	IS(netintr);	STRAY;		STRAY;		STRAY;
E 26
I 26
/* 0b0 */	IS(netintr);	STRAY;		STRAY;		IS(kdbintr);
E 26
E 14
E 13
E 12
E 10
D 4
/* 0c0 */	KS(clockint);	STRAY;		STRAY;		STRAY;
E 4
I 4
D 24
/* 0c0 */	IS(hardclock);	STRAY;		STRAY;		STRAY;
E 24
I 24
/* 0c0 */	IS(hardclock);	STRAY;		KS(emulate);	KS(emulateFPD);
E 24
E 4
/* 0d0 */	STRAY;		STRAY;		STRAY;		STRAY;
/* 0e0 */	STRAY;		STRAY;		STRAY;		STRAY;
E 27
I 27
/* 050 */	IS(sbisilo);	IS(cmrd);	IS(sbi0alert);	IS(sbi0fault);
/* 060 */	IS(wtime);	IS(sbi0fail);	STRAY(0x68);	STRAY(0x6c);
/* 070 */	STRAY(0x70);	STRAY(0x74);	STRAY(0x78);	STRAY(0x7c);
/* 080 */	STRAY(0x80);	STRAY(0x84);	KS(astflt);	STRAY(0x8c);
/* 090 */	STRAY(0x90);	STRAY(0x94);	STRAY(0x98);	STRAY(0x9c);
/* 0a0 */	IS(softclock);	STRAY(0xa4);	STRAY(0xa8);	STRAY(0xac);
/* 0b0 */	IS(netintr);	STRAY(0xb4);	STRAY(0xb8);	IS(kdbintr);
/* 0c0 */	IS(hardclock);	STRAY(0xc4);	KS(emulate);	KS(emulateFPD);
/* 0d0 */	STRAY(0xd0);	STRAY(0xd4);	STRAY(0xd8);	STRAY(0xdc);
/* 0e0 */	STRAY(0xe0);	STRAY(0xe4);	STRAY(0xe8);	STRAY(0xec);
E 27
/* 0f0 */	IS(consdin);	IS(consdout);	IS(cnrint);	IS(cnxint);
D 8
/* 100 */	STRAY16;		/* ipl 0x14, nexus 0-15 */
/* 140 */	STRAY16;		/* ipl 0x15, nexus 0-15 */
/* 180 */	STRAY16;		/* ipl 0x16, nexus 0-15 */
/* 1c0 */	STRAY16;		/* ipl 0x17, nexus 0-15 */
E 8
I 8
D 27
/* 100 */	IS(nexzvec); STRAY15;		/* ipl 0x14, nexus 0-15 */
/* 140 */	IS(nexzvec); STRAY15;		/* ipl 0x15, nexus 0-15 */
/* 180 */	IS(nexzvec); STRAY15;		/* ipl 0x16, nexus 0-15 */
/* 1c0 */	IS(nexzvec); STRAY15;		/* ipl 0x17, nexus 0-15 */
E 27
I 27
/* 100 */	NEX0(0x100);		/* ipl 0x14, nexus 0-15 */
/* 140 */	NEX0(0x140);		/* ipl 0x15, nexus 0-15 */
/* 180 */	NEX0(0x180);		/* ipl 0x16, nexus 0-15 */
/* 1c0 */	NEX0(0x1c0);		/* ipl 0x17, nexus 0-15 */
E 27
E 8
E 3

D 3
/* IPL 15 */
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#if VAX==780
	.long	Xua0int + INTSTK	# UBA 0 br5
#else
E 2
	.long	Xstray + INTSTK		# unused
D 2
#endif
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#if VAX==780
	.long	Xmba0int + INTSTK	# mass bus adapter 0
	.long	Xmba1int + INTSTK	# mass bus adapter 1
#else
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#endif
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused

/* IPL 16 */
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
D 2
#if VAX==780
	.long	Xua0int + INTSTK	# UBA 0 br6
#else
E 2
	.long	Xstray + INTSTK		# unused
D 2
#endif
E 2
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused

/* IPL 17 */
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
	.long	Xstray + INTSTK		# unused
E 3
I 3
D 27
	.globl	_UNIvec
_UNIvec:	.space	512		# 750 unibus intr vector
					# 1st UBA jump table on 780's
E 27
I 27
/*
 * 750 hardware reads through UNIvec (scb + 512 bytes) to find Unibus
 * interrupt vectors.  780s use this space as a jump table (lookup
 * code in locore.s makes 780s work like 750s).  Additional pages
D 28
 * of interrupt vectors for additional UBAs follow immediately
E 28
I 28
 * of interrupt vectors for additional UBAs follow immediately.
E 28
 *
D 28
 * 8600s use this area as a second SCB, for which purpose we init it
 * here.  Everything else will simply replace these with Unibus vectors.
E 28
I 28
 * 8600s may use the next page as a second SCB, for which purpose we init
 * it here.  Everything else will simply replace these with Unibus vectors.
E 28
 * An additional page is provided for UBA jump tables if the second
D 28
 * scb might be present.
E 28
I 28
 * scb might be present.  Other CPUs with additional scbs should expand
 * this area as needed.
E 28
 */
D 28
	.globl	_UNIvec,_eUNIvec
E 28
I 28
	.globl	_UNIvec
	.globl	_eUNIvec
E 28
_UNIvec:
I 28
#if VAX8600
E 28
/* 200 */	STRAY16(0x200);		/* unused (?) */
/* 240 */	STRAY16(0x240);		/* sbi1fail etc. set at boot time */
/* 280 */	STRAY16(0x280);		/* unused (?) */
/* 2c0 */	STRAY16(0x2c0);		/* unused (?) */
/* 300 */	NEX1(0x300);		/* ipl 0x14, nexus 0-15, sbia 1 */
/* 340 */	NEX1(0x340);		/* ipl 0x15, nexus 0-15, sbia 1 */
/* 380 */	NEX1(0x380);		/* ipl 0x16, nexus 0-15, sbia 1 */
/* 3c0 */	NEX1(0x3c0);		/* ipl 0x17, nexus 0-15, sbia 1 */

D 28
#if VAX8600
		.space	512		# replacement space for UBA
E 28
#endif
E 27
I 16
D 28
#if NUBA > 1
D 27
	.globl	_UNI1vec
_UNI1vec:	.space	512		# 750 second unibus intr vector
					# 2nd UBA jump table on 780's
E 27
I 27
		.space	512*(NUBA-1)	# 750 second unibus intr vector
					# 2nd+ UBA jump table on 780's
E 28
I 28
#if NUBA > 0
		.space	512*NUBA	# 750 first/second unibus intr vector
					# UBA jump tables on 780's
E 28
E 27
#endif
I 27
_eUNIvec:
E 27
I 21
D 23

/*
 * The following specify offsets into the intrcnt array for SCB interrupt
 * vectors.  Unibus devices will allocate slots after these.
 */
#define	I_CLOCK		(4 * 0)		/* interval timer */
#define	I_CNR		(4 * 1)		/* console receive */
#define	I_CNX		(4 * 2)		/* console transmit */
#define	I_TUR		(4 * 3)		/* console TU58 receive */
#define	I_TUX		(4 * 4)		/* console TU58 transmit */
#define	I_MBA0		(4 * 5)		/* massbus adaptor 0 */
#define	I_MBA1		(4 * 6)		/* massbus adaptor 1 */
#define	I_MBA2		(4 * 7)		/* massbus adaptor 2 */
#define	I_MBA3		(4 * 8)		/* massbus adaptor 3 */
#define	I_UBA		(4 * 9)		/* unibus adaptor base */
#define	I_UBA0		(4 * 9)		/* unibus adaptor 0 */
#define	I_UBA1		(4 * 10)	/* unibus adaptor 1 */
#define	I_UBA2		(4 * 11)	/* unibus adaptor 2 */
#define	I_UBA3		(4 * 12)	/* unibus adaptor 3 */
E 23
E 21
E 16
E 3
D 2

E 2
E 1
