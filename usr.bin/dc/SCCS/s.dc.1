h34323
s 00002/00002/00194
d D 8.1 93/06/06 14:30:15 bostic 9 8
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00060/00060/00136
d D 6.6 91/08/08 18:05:51 cael 8 7
c mdoc version three
e
s 00005/00004/00191
d D 6.5 91/04/17 17:08:52 bostic 7 6
c new copyright; att/bsd/shared
e
s 00001/00002/00194
d D 6.4 90/07/24 22:43:39 cael 6 5
c .Xr botch fix
e
s 00003/00004/00193
d D 6.3 90/06/26 00:59:02 cael 5 4
c converted man page
e
s 00099/00103/00098
d D 6.2 90/06/24 19:00:05 cael 4 3
c converted man page
e
s 00001/00001/00200
d D 6.1 85/04/29 17:43:52 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00001/00001/00200
d D 5.1 85/04/29 17:43:41 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00201/00000/00000
d D 4.1 85/04/29 17:43:31 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 4
.\"	%W% (Berkeley) %G%
E 4
I 4
D 5
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
E 4
.\"
D 2
.TH DC 1 
E 2
I 2
D 3
.TH DC 1  "18 January 1983"
E 3
I 3
D 4
.TH DC 1 "%Q%"
E 3
E 2
.AT 3
.SH NAME
dc \- desk calculator
.SH SYNOPSIS
.B dc
[ file ]
.SH DESCRIPTION
.I Dc
E 4
I 4
.\" %sccs.include.redist.man%
E 5
I 5
D 7
.\" Copyright (c) 1990 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 7
I 7
D 9
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
E 9
I 9
.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 9
E 7
E 5
.\"
D 7
.\"     %W% (Berkeley) %G%
E 7
I 7
.\" %sccs.include.proprietary.roff%
.\"
.\"	%W% (Berkeley) %G%
E 7
.\"
.Dd %Q%
.Dt DC 1
.Os ATT 7th
.Sh NAME
D 8
.Nm dc
E 8
I 8
.Nm \&dc
E 8
.Nd desk calculator
.Sh SYNOPSIS
D 8
.Nm dc
E 8
I 8
.Nm \&dc
E 8
.Op  file
.Sh DESCRIPTION
D 8
.Nm Dc
E 8
I 8
.Nm \&Dc
E 8
E 4
is an arbitrary precision arithmetic package.
Ordinarily it operates on decimal integers,
but one may specify an input base, output base,
and a number of fractional digits to be maintained.
The overall structure of
D 4
.I dc
E 4
I 4
D 8
.Nm dc
E 8
I 8
.Nm \&dc
E 8
E 4
is
a stacking (reverse Polish) calculator.
If an argument is given,
input is taken from that file until its end,
then from the standard input.
The following constructions are recognized:
D 4
.HP 6
number
.br
E 4
I 4
D 8
.Tw Fl
.Tp Va number
E 8
I 8
.Bl -tag -width flag
.It Va number
E 8
E 4
The value of the number is pushed on the stack.
A number is an unbroken string of the digits 0-9.
It may be preceded by an underscore _ to input a
negative number.
Numbers may contain decimal points.
D 4
.HP 6
+  \- /  *  %  ^
.br
E 4
I 4
D 8
.Tp Li \&+  \&\- \&/  \&*  \&%  \&^
E 8
I 8
.It Cm "\&+  \&\- \&/  \&*  \&%  \&^"
E 8
E 4
The
top two values on the stack are added
(+),
subtracted
(\-),
multiplied (*),
divided (/),
remaindered (%),
or exponentiated (^).
The two entries are popped off the stack;
the result is pushed on the stack in their place.
Any fractional part of an exponent is ignored.
D 4
.TP
.BI s x
E 4
I 4
D 8
.Tc Ic s
.Ar x
.Cx
E 8
I 8
.It Ic s Ns Ar x 
E 8
E 4
The
top of the stack is popped and stored into
a register named
D 4
.I x,
E 4
I 4
.Ar x ,
E 4
where
D 4
.I x
E 4
I 4
.Ar x
E 4
may be any character.
If
the
D 4
.B s
E 4
I 4
.Ar s
E 4
is capitalized,
D 4
.I x
E 4
I 4
.Ar x
E 4
is treated as a stack and the value is pushed on it.
D 4
.TP
.BI l x
E 4
I 4
D 8
.Tc Ic l
.Ar x
.Cx
E 8
I 8
.It Ic l Ns Ar x 
E 8
E 4
The
value in register
D 4
.I x
E 4
I 4
.Ar x
E 4
is pushed on the stack.
The register
D 4
.I x
E 4
I 4
.Ar x
E 4
is not altered.
All registers start with zero value.
If the
D 4
.B l
E 4
I 4
.Ar l
E 4
is capitalized,
register
D 4
.I x
E 4
I 4
.Ar x
E 4
is treated as a stack and its top value is popped onto the main stack.
D 4
.TP
.B  d
E 4
I 4
D 8
.Tp Ic d
E 8
I 8
.It Ic d
E 8
E 4
The
top value on the stack is duplicated.
D 4
.TP
.B  p
E 4
I 4
D 8
.Tp Ic p
E 8
I 8
.It Ic p
E 8
E 4
The top value on the stack is printed.
The top value remains unchanged.
D 4
.B P
E 4
I 4
.Ar P
E 4
interprets the top of the stack as an ascii string,
removes it, and prints it.
D 4
.TP
.B  f
E 4
I 4
D 8
.Tp Ic f
E 8
I 8
.It Ic f
E 8
E 4
All values on the stack and in registers are printed.
D 4
.TP
.B  q
E 4
I 4
D 8
.Tp Ic q
E 8
I 8
.It Ic q
E 8
E 4
exits the program.
If executing a string, the recursion level is
popped by two.
If
D 4
.B q
E 4
I 4
.Ar q
E 4
is capitalized,
the top value on the stack is popped and the string execution level is popped
by that value.
D 4
.TP
.B  x
E 4
I 4
D 8
.Tp Ic x
E 8
I 8
.It Ic x
E 8
E 4
treats the top element of the stack as a character string
D 8
and executes it as a string of dc commands.
D 4
.TP
.B  X
E 4
I 4
.Tp Ic X
E 8
I 8
and executes it as a string of
.Nm \&dc
commands.
.It Ic X
E 8
E 4
replaces the number on the top of the stack with its scale factor.
D 4
.TP
.B  "[ ... ]"
E 4
I 4
D 8
.Tp Op \&...
E 8
I 8
.It Cm \&[ Ns ... Ns Cm \&]
E 8
E 4
puts the bracketed ascii string onto the top of the stack.
D 4
.HP 6
.I  "<x  >x  =x"
.br
E 4
I 4
D 8
.Tp Va \&<x  \&>x  \&=x
E 8
I 8
.It Xo
.Cm < Va x
.Cm > Va x
.Cm = Va x
.Xc
E 8
E 4
The
top two elements of the stack are popped and compared.
Register
D 4
.I x
E 4
I 4
.Ar x
E 4
is executed if they obey the stated
relation.
D 4
.TP
.B  v
E 4
I 4
D 8
.Tp Ic v
E 8
I 8
.It Ic v
E 8
E 4
replaces the top element on the stack by its square root.
Any existing fractional part of the argument is taken
into account, but otherwise the scale factor is ignored.
D 4
.TP
.B  !
E 4
I 4
D 8
.Tp Ic \&!
E 4
interprets the rest of the line as a UNIX command.
D 4
.TP
.B  c
E 4
I 4
.Tp Ic c
E 8
I 8
.It Ic \&!
interprets the rest of the line as a
.Ux
command.
.It Ic c
E 8
E 4
All values on the stack are popped.
D 4
.TP
.B  i
E 4
I 4
D 8
.Tp Ic i
E 8
I 8
.It Ic i
E 8
E 4
The top value on the stack is popped and used as the
number radix for further input.
D 4
.B I
E 4
I 4
.Ic I
E 4
pushes the input base on the top of the stack.
D 4
.TP
.B  o
E 4
I 4
D 8
.Tp Ic o
E 8
I 8
.It Ic o
E 8
E 4
The top value on the stack is popped and used as the
number radix for further output.
D 4
.TP
.SM
.B O
E 4
I 4
D 8
.Tp Ic O
E 8
I 8
.It Ic O
E 8
E 4
pushes the output base on the top of the stack.
D 4
.TP
.B  k
E 4
I 4
D 8
.Tp Ic k
E 8
I 8
.It Ic k
E 8
E 4
the top of the stack is popped, and that value is used as
a non-negative scale factor:
the appropriate number of places
are printed on output,
and maintained during multiplication, division, and exponentiation.
The interaction of scale factor,
input base, and output base will be reasonable if all are changed
together.
D 4
.TP
.B  z
E 4
I 4
D 8
.Tp Ic z
E 8
I 8
.It Ic z
E 8
E 4
The stack level is pushed onto the stack.
D 4
.TP
.SM
.B  Z
E 4
I 4
D 8
.Tp Ic Z
E 8
I 8
.It Ic Z
E 8
E 4
replaces the number on the top of the stack with its length.
D 4
.TP
.B  ?
E 4
I 4
D 8
.Tp Ic \&?
E 8
I 8
.It Ic \&?
E 8
E 4
A line of input is taken from the input source (usually the terminal)
and executed.
D 4
.TP
.B "; :"
are used by 
.I bc
E 4
I 4
D 8
.Tp Ic \&; \&:
E 8
I 8
.It Ic \&; \&:
E 8
are used by
D 8
.Ar bc
E 8
I 8
.Xr \&bc
E 8
E 4
for array operations.
D 4
.PP
An example which prints the first ten values of n! is
.nf
.PP
.in +3
[la1+dsa*pla10>y]sy
.br
0sa1
.br
lyx
.fi
.SH "SEE ALSO"
bc(1),
E 4
I 4
D 8
.Tp
E 8
I 8
.El
E 8
.Pp
An example which prints the first ten values of
.Ic n\&! :
.Pp
D 8
.Df I
.Cx Op Li la1+dsa*pla10>y
.Cx sy
.Cx
.De
.Ds I
.Li 0sa1
.De
.Ds I
.Li lyx
.De
E 8
I 8
.Bd -literal -offset indent -compact
[la1+dsa*pla10>y]sy 
0sa1
lyx
.Ed
E 8
.Sh SEE ALSO
D 8
.Xr bc 1 ,
E 8
I 8
.Xr \&bc 1 ,
E 8
E 4
which is a preprocessor for
D 4
.I dc
providing infix notation and a C-like syntax
E 4
I 4
D 8
.Nm dc
providing infix notation and a C- like syntax
E 8
I 8
.Nm \&dc
providing infix notation and a C-like syntax
E 8
E 4
which implements functions and reasonable control
structures for programs.
D 4
.SH DIAGNOSTICS
`x is unimplemented' where x is an octal number.
.br
`stack empty' for not enough elements on the stack to do what was asked.
.br
`Out of space' when the free list is exhausted (too many digits).
.br
`Out of headers' for too many numbers being kept around.
.br
`Out of pushdown' for too many items on the stack.
.br
`Nesting Depth' for too many levels of nested execution.
E 4
I 4
.Sh HISTORY
D 8
.Nm Dc
appeared in Version 6 AT&T Unix.
E 8
I 8
The
.Nm \&dc
command appeared in
.At v6 .
E 8
.Sh DIAGNOSTICS
D 6
.Tp Ar
.\" .Tw x\ is\ unimplemented
E 6
I 6
D 8
.Tw Ar
E 6
.Tp Li x is unimplemented
E 8
I 8
.Bl -tag -width flag
.It Li x is unimplemented
E 8
where x is an octal number.
D 8
.Tp Li stack empty
E 8
I 8
.It Li stack empty
E 8
for not enough elements on the stack to do what was asked.
D 8
.Tp Li Out of space
E 8
I 8
.It Li Out of space
E 8
when the free list is exhausted (too many digits).
D 8
.Tp Li Out of headers
E 8
I 8
.It Li Out of headers
E 8
for too many numbers being kept around.
D 8
.Tp Li Out of pushdown
E 8
I 8
.It Li Out of pushdown
E 8
for too many items on the stack.
D 8
.Tp Li Nesting Depth
E 8
I 8
.It Li Nesting Depth
E 8
for too many levels of nested execution.
D 8
.Tp
E 8
I 8
.El
E 8
E 4
E 1
