h18806
s 00002/00002/00365
d D 8.1 93/06/06 15:04:27 bostic 16 15
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00001/00366
d D 6.12 91/11/20 16:27:11 bostic 15 14
c add affiliation for Oz
e
s 00010/00009/00357
d D 6.11 91/09/03 11:38:07 bostic 14 13
c New version from Oz Yigit; BSD-ized
e
s 00115/00126/00251
d D 6.10 91/08/08 19:09:37 cael 13 12
c mdoc version three
e
s 00004/00006/00373
d D 6.9 91/04/12 16:37:27 bostic 12 11
c new copyright; att/bsd/shared
e
s 00002/00000/00377
d D 6.8 91/03/14 00:13:41 cael 11 9
c add .Vx so tmac.andoc will call tmac.mdoc-old
e
s 00001/00000/00377
d R 6.8 91/03/13 20:31:18 cael 10 9
c add .Vx so tmac.andoc will call tmac.mdoc-old
e
s 00004/00001/00373
d D 6.7 90/11/18 11:39:02 karels 9 8
c fix strings for ` and ' in changequote
e
s 00006/00037/00368
d D 6.6 90/07/24 22:48:06 cael 8 7
c .Xr botch fix
e
s 00002/00001/00403
d D 6.5 90/06/26 01:00:11 cael 7 6
c converted man page
e
s 00258/00198/00146
d D 6.4 90/06/11 05:56:45 cael 6 5
c converted man page
e
s 00007/00021/00337
d D 6.3 89/08/28 15:47:32 bostic 5 4
c Berkleyize
e
s 00313/00109/00045
d D 6.2 89/08/28 15:47:07 bostic 4 3
c original version from Ozan Yigit
e
s 00001/00001/00153
d D 6.1 85/04/29 17:49:47 mckusick 3 2
c 4.3BSD beta release manual page
e
s 00050/00066/00104
d D 5.1 85/04/29 17:49:32 mckusick 2 1
c manual page distributed with 4.2BSD
e
s 00170/00000/00000
d D 4.1 85/04/29 17:49:22 mckusick 1 0
c manual page distributed with 4.1BSD
e
u
U
t
T
I 1
D 4
.\"	%W% (Berkeley) %G%
E 4
I 4
D 6
.\" Copyright (c) 1989 The Regents of the University of California.
E 6
I 6
D 12
.\" Copyright (c) 1989, 1990 The Regents of the University of California.
E 6
D 7
.\" All rights reserved.
E 7
I 7
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 12
I 12
D 16
.\" Copyright (c) 1990 The Regents of the University of California.
.\" All rights reserved.
E 16
I 16
.\" Copyright (c) 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 16
E 12
E 7
E 4
.\"
D 2
.TH M4 1 
E 2
I 2
D 3
.TH M4 1  "18 January 1983"
E 3
I 3
D 4
.TH M4 1 "%Q%"
E 3
E 2
.AT 3
E 4
I 4
D 8
.\" This code is derived from software contributed to Berkeley by
E 8
I 8
.\" The code is derived from software contributed to Berkeley by
E 8
D 15
.\" Ozan Yigit.
E 15
I 15
.\" Ozan Yigit at York University.
E 15
.\"
D 6
.\" Redistribution and use in source and binary forms are permitted
.\" provided that the above copyright notice and this paragraph are
.\" duplicated in all such forms and that any documentation,
.\" advertising materials, and other materials related to such
.\" distribution and use acknowledge that the software was developed
.\" by the University of California, Berkeley.  The name of the
.\" University may not be used to endorse or promote products derived
.\" from this software without specific prior written permission.
.\" THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
.\" IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
.\" WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 6
I 6
D 12
.\" %sccs.include.redist.man%
E 12
I 12
.\" %sccs.include.proprietary.man%
E 12
E 6
.\"
D 6
.\"	%W% (Berkeley) %G%
E 6
I 6
D 12
.\"     %W% (Berkeley) %G%
E 12
I 12
.\"	%W% (Berkeley) %G%
E 12
E 6
.\"
I 11
D 12
.Vx
E 12
D 13
.Vx
E 13
E 11
D 6
.TH M4 1 "August 28, 1989"
E 6
I 6
.Dd %Q%
I 13
.Os ATT 7
E 13
.Dt M4 1
E 6
D 8
.DA 08 Jan 1986
E 8
E 4
D 6
.SH NAME
D 4
m4 \- macro processor
E 4
I 4
D 5
pd m4 \- macro processor
.SH ORIGIN
MetaSystems
E 5
I 5
m4 \- macro processor
E 5
E 4
.SH SYNOPSIS
D 4
.B m4
[ files ]
E 4
I 4
.BI m4 "[ options ]"
E 4
.SH DESCRIPTION
D 4
.I M4
D 2
is a macro processor
intended as a front end for Ratfor, C, and other languages.
E 2
I 2
is a macro processor intended as a front end for Ratfor, C, and other languages.
E 2
Each of the argument files is processed in order;
if there are no arguments, or if an argument is `\-',
the standard input is read.
The processed text is written on the standard output.
E 4
I 4
D 5
.I Pd M4
is a un*x M4 look-alike macro processor
E 5
I 5
.I M4
is a macro processor
E 5
intended as a front end for Ratfor, Pascal, and other languages that do not
E 6
I 6
.Sh NAME
.Nm m4
D 13
.Nd macro language preprocessor for Ratfor and Pascal
E 13
I 13
.Nd macro language preprocessor for
.Xr ratfor 1
and
.Xr pascal 1
E 13
.Sh SYNOPSIS
.Nm m4
.Op options
.Sh DESCRIPTION
.Nm M4
D 14
is a macro language
preprocessor
for Ratfor, Pascal, and similar languages which do not
E 6
have a built-in macro processing capability.
E 14
I 14
is a macro language preprocessor for Ratfor, Pascal, and similar languages
which do not have a built-in macro processing capability.
E 14
D 5
Pd M4 reads standard input, the processed text is written on the standard output.
E 5
I 5
D 6
M4 reads standard input, the processed text is written on the standard output.
E 5
E 4
.PP
E 6
I 6
D 13
M4 reads standard input, and writes the results to the standard output.
E 13
I 13
.Nm M4
reads standard input, and writes the results to the standard output.
E 13
.Pp
E 6
D 2
Macro calls
have the form
E 2
I 2
D 4
Macro calls have the form
E 4
I 4
The options and their effects are as follows:
D 6
.TP
\f3\-D\fP\f2name\^\fP[\f3=\fP\f2val\^\fP]
E 6
I 6
.Pp
I 8
D 13
.Tw _Dname[=Val]
E 8
.Tp Cx Fl D
.Ar name
.Op Ar \&=Val
.Cx
E 13
I 13
.Sm off
.Bl -tag -width _Dname[=Val]
.It Fl D Ar name Op Ar \&=Val
.Sm on
E 13
E 6
Defines
D 6
.I name
E 6
I 6
.Ar name
E 6
to
D 6
.I val
E 6
I 6
.Ar val
E 6
or to null in
D 6
.IR val 's
absence.
.TP
.BI \-U name
E 6
I 6
the absence of
.Ar val .
D 13
.Tp Cx Fl U
.Ar name
.Cx
E 6
undefines
D 6
.IR name .
E 4
E 2
.PP
D 4
	name(arg1,arg2, . . . , argn)
.br
E 4
I 4
Macro calls
have the form:
E 4
.PP
D 4
The `(' must immediately follow the name of the macro.
If a defined macro name is not followed by a `(',
it is deemed to have no arguments.
D 2
Leading unquoted blanks, tabs, and newlines are ignored while collecting arguments.
Potential macro names consist of alphabetic letters,
E 2
I 2
Leading unquoted blanks, tabs, and newlines are ignored while collecting
arguments.  Potential macro names consist of alphabetic letters,
E 2
digits, and underscore `\_', where the first character is not a digit.
E 4
I 4
.RS
\fBname\fI(arg1,arg2, .\|.\|., argn)\fR
.RE
E 4
.PP
E 6
I 6
.Ar name  .
.Tp
E 13
I 13
.It Fl U Ns Ar name
Undefines
.Ar name .
.El
E 13
.Pp
E 6
D 4
Left and right single quotes (\`\|\') are used to quote strings.
E 4
I 4
The
D 6
.B (
must immediately follow the name of the macro.
If the name of a defined macro is not followed by a
.BR ( ,
it is taken to be a call of that macro with no arguments, i.e. name().
Potential macro names consist of alphabetic letters and digits.
.PP
Leading unquoted blanks, tabs and newlines are ignored while collecting 
arguments.
Left and right single quotes are used to quote strings.
E 4
The value of a quoted string is the string stripped of the quotes.
.PP
D 2
When a macro name is recognized,
its arguments are collected by searching for a matching right
parenthesis.
E 2
I 2
D 4
When a macro name is recognized, its arguments are collected by searching
for a matching right parenthesis.
E 4
I 4
When a macro name is recognized,
its arguments are collected by searching for a matching
.BR ) .
If fewer arguments are supplied than are in the macro definition,
the trailing arguments are taken to be null.
E 4
E 2
Macro evaluation proceeds normally during the collection of the arguments,
D 2
and any commas or right parentheses
which happen to turn up within the value of a nested
call are as effective as those in the original input text.
After argument collection,
the value of the macro is pushed back onto the input stream
and rescanned.
E 2
I 2
D 4
and any commas or right parentheses which happen to turn up within the value
of a nested call are as effective as those in the original input text.
After argument collection, the value of the macro is pushed back onto the
input stream and rescanned.
E 4
I 4
and any commas or right parentheses
which happen to turn up within the value of a nested
call are as effective as those in the original input text. (This is typically
referred as
.I inside-out
macro expansion.)
After argument collection,
the value of the macro is pushed back onto the input stream
and rescanned.
E 4
E 2
.PP
D 4
.I M4
E 4
I 4
D 5
.I Pd M4
E 5
I 5
.I M4
E 5
E 4
makes available the following built-in macros.
They may be redefined, but once this is done the original meaning is lost.
Their values are null unless otherwise stated.
D 4
.TP 10
D 2
define
E 2
I 2
.B define
E 2
The second argument is installed as the value of the macro
whose name is the first argument.
D 2
Each occurrence of $\fIn\fR in the replacement text,
where
E 2
I 2
Each occurrence of $\fIn\fR in the replacement text, where
E 4
I 4
.de MC
.TP 14
.B \\$1
usage: \\fI\\$1\\$2\\fR
E 6
I 6
.Nm m4
processor provides a kind of
.Nm C
like syntax and
some of the macro functions will
be familiar:
D 8
.Tw Ds
E 8
I 8
D 13
.Tw \&undiver
E 8
.Tp Ic define
E 13
I 13
.Bl -tag -width \&undiver
.It Ic define
E 13
D 8
usage:
E 8
.Ar define(name [, val])
E 6
D 13
.br
D 6
..
.MC define "(name [, val])"
E 6
the second argument is installed as the value of the macro
whose name is the first argument. If there is no second argument,
E 13
I 13
the second argument is installed
as the value of the macro
whose name is the first argument.
If there is no second argument,
E 13
the value is null.
Each occurrence of
D 6
.BI $ n
E 6
I 6
D 13
.Cx Ic $
.Ar n
.Cx
E 13
I 13
.Ic $ Ns Ar n
E 13
E 6
in the replacement text,
where
E 4
E 2
D 6
.I n
E 6
I 6
.Ar n
E 6
D 2
is a digit,
is replaced by the
E 2
I 2
D 4
is a digit, is replaced by the
E 4
I 4
is a digit,
is replaced by the
E 4
E 2
D 6
.IR n -th
E 6
I 6
D 13
.Cx Ar n
.Cx \'th
.Cx
E 13
I 13
.Ar n Ns 'th
E 13
E 6
D 2
argument.
Argument 0 is the name of the macro;
E 2
I 2
D 4
argument.  Argument 0 is the name of the macro;
E 4
I 4
argument.
Argument 0 is the name of the macro;
E 4
E 2
missing arguments are replaced by the null string.
D 4
.TP
D 2
undefine
E 2
I 2
.B undefine
E 2
removes the definition of the macro named in its argument.
.TP
D 2
ifdef
If the first argument is defined, the value is the second argument, otherwise the third.
If there is no third argument, the value is null.
E 2
I 2
.B ifdef
If the first argument is defined, the value is the second argument,
otherwise the third.  If there is no third argument, the value is null.
E 2
The word
E 4
I 4
D 6
.MC defn "(name [, name ...])
E 6
I 6
D 13
.Tp Ic defn
E 13
I 13
.It Ic defn
E 13
D 8
usage:
E 8
.Ar defn(name [, name ...])
D 13
.br
E 6
returns the quoted definition of its argument(s). Useful in renaming
macros.
D 6
.MC undefine "(name [, name ...])"
E 6
I 6
.Tp Ic undefine
E 13
I 13
returns the quoted definition
of its argument(s).
Useful in renaming macros.
.It Ic undefine
E 13
D 8
usage:
E 8
.Ar undefine(name [, name ...])
D 13
.br
E 6
removes the definition of the macro(s) named. If there is
E 13
I 13
removes the definition of
the macro(s) named.
If there is
E 13
more than one definition for the named macro, (due to previous use of
D 6
.IR pushdef ) 
E 6
I 6
.Ic pushdef )
E 6
all definitions are removed.
D 6
.MC pushdef "(name [, val])"
E 6
I 6
D 13
.Tp Ic  pushdef
E 13
I 13
.It Ic  pushdef
E 13
D 8
usage:
E 8
.Ar pushdef(name [, val])
D 13
.br
E 13
E 6
like
D 6
.IR define ,
E 6
I 6
.Ic define  ,
E 6
but saves any previous definition by stacking the current definition.
D 6
.MC popdef "(name [, name ...])"
E 6
I 6
D 13
.Tp Ic popdef
E 13
I 13
.It Ic popdef
E 13
D 8
usage:
E 8
.Ar popdef(name [, name ...])
D 13
.br
E 13
E 6
removes current definition of its argument(s),
exposing the previous one if any.
D 6
.MC ifdef "(name, if-def [, ifnot-def])"
if the first argument is defined, the value is the second argument, 
E 6
I 6
D 13
.Tp Ic ifdef
E 13
I 13
.It Ic ifdef
E 13
D 8
usage:
E 8
.Ar ifdef(name, if-def [, ifnot-def])
D 13
.br
if the first argument is defined, the value is the second argument,
E 13
I 13
if the first argument is defined,
the value is the second argument,
E 13
E 6
otherwise the third.
If there is no third argument, the value is null.
I 14
A word indicating the current operating system is predefined
(e.g.
.I unix
or
.IR vms ).
E 14
D 5
A word indicating the current operating system is predefined.
(e.g.
E 4
.I unix
D 4
is predefined on UNIX versions of
.IR m4 .
.TP
D 2
changequote
E 2
I 2
.B changequote
E 2
Change quote characters to the first and second arguments.
.I Changequote
D 2
without arguments restores the original values
(i.e., \`\|\').
E 2
I 2
without arguments restores the original values (i.e., \`\|\').
E 2
.TP
D 2
divert
E 2
I 2
.B divert
E 2
.I M4
D 2
maintains 10 output streams,
numbered 0-9.
The final output is the concatenation of the streams
in numerical order;
initially stream 0 is the current stream.
The
E 2
I 2
maintains 10 output streams, numbered 0-9.
The final output is the concatenation of the streams in numerical order;
initially stream 0 is the current stream.  The
E 4
I 4
or
.IR vms )
E 5
D 6
.MC shift "(arg, arg, arg, ...)"
E 6
I 6
D 13
.Tp Ic shift
E 13
I 13
.It Ic shift
E 13
D 8
usage:
E 8
.Ar shift(arg, arg, arg, ...)
D 13
.br
E 13
E 6
returns all but its first argument.
The other arguments are quoted and pushed back with
commas in between.
The quoting nullifies the effect of the extra scan that
will subsequently be performed.
D 6
.MC changequote "(lqchar, rqchar)"
E 6
I 6
D 13
.Tp Ic changequote
E 13
I 13
.It Ic changequote
E 13
D 8
usage:
E 8
.Ar changequote(lqchar, rqchar)
D 13
.br
E 6
change quote symbols to the first and second arguments.
E 13
I 13
change quote symbols to the
first and second arguments.
E 13
With no arguments, the quotes are reset back to the default
D 6
characters. (i.e., \*`\|\*').
.MC changecom "(lcchar, rcchar)"
E 6
I 6
D 9
characters. (i.e., \*`\\*').
E 9
I 9
characters (i.e.,
.Ic \*(ga
and
.Ic \*(aa ).
E 9
D 13
.Tp Ic changecom
E 13
I 13
.It Ic changecom
E 13
D 8
usage:
E 8
.Ar changecom(lcchar, rcchar)
D 13
.br
E 6
change left and right comment markers from the default
E 13
I 13
change left and right
comment markers from the default
E 13
D 6
.B #
and 
.BR newline .
With no arguments, the comment mechanism is reset back to 
E 6
I 6
.Ic #
and
.Ic newline  .
With no arguments, the comment mechanism is reset back to
E 6
the default characters.
With one argument, the left marker becomes the argument and
the right marker becomes newline.
With two arguments, both markers are affected.
D 6
.MC divert "(divnum)"
.I m4
E 6
I 6
D 13
.Tp Ic divert
E 13
I 13
.It Ic divert
E 13
D 8
usage:
E 8
.Ar divert(divnum)
D 13
.br
E 13
.Nm m4
E 6
maintains 10 output streams,
D 6
numbered 0-9.  initially stream 0 is the current stream. 
E 6
I 6
numbered 0-9.  initially stream 0 is the current stream.
E 6
The
E 4
E 2
D 6
.I divert
E 6
I 6
.Ic divert
E 6
D 2
macro changes the current output stream to its (digit-string)
argument.
Output diverted to a stream other than 0 through 9
is discarded.
E 2
I 2
D 4
macro changes the current output stream to its (digit-string) argument.
Output diverted to a stream other than 0 through 9 is discarded.
E 2
.TP
D 2
undivert
E 2
I 2
.B undivert
E 4
I 4
macro changes the current output stream to its (digit-string)
argument.
Output diverted to a stream other than 0 through 9
disappears into bitbucket.
D 6
.MC undivert "([divnum [, divnum ...]])"
E 6
I 6
D 13
.Tp Ic undivert
E 13
I 13
.It Ic undivert
E 13
D 8
usage:
E 8
.Ar undivert([divnum [, divnum ...])
D 13
.br
E 6
E 4
E 2
causes immediate output of text from diversions named as
E 13
I 13
causes immediate output
of text from diversions named as
E 13
D 4
arguments, or all diversions if no argument.
E 4
I 4
argument(s), or all diversions if no argument.
E 4
Text may be undiverted into another diversion.
D 4
Undiverting discards the diverted text.
.TP
D 2
divnum
E 2
I 2
.B divnum
E 4
I 4
Undiverting discards the diverted text. At the end of input processing,
D 6
.I M4
E 6
I 6
.Nm M4
E 6
forces an automatic
D 6
.IR undivert ,
E 6
I 6
.Ic undivert  ,
E 6
unless
D 6
.I m4wrap
E 6
I 6
.Ic m4wrap
E 6
is defined.
D 6
.MC divnum "()"
E 6
I 6
D 13
.Tp Ic divnum
E 13
I 13
.It Ic divnum
E 13
D 8
usage:
E 8
.Ar divnum()
D 13
.br
E 13
E 6
E 4
E 2
returns the value of the current output stream.
D 4
.TP
D 2
dnl
E 2
I 2
.B dnl
E 4
I 4
D 6
.MC dnl "()"
E 6
I 6
D 13
.Tp Ic dnl
E 13
I 13
.It Ic dnl
E 13
D 8
usage:
E 8
.Ar dnl()
D 13
.br
E 13
E 6
E 4
E 2
reads and discards characters up to and including the next newline.
D 4
.TP
D 2
ifelse
E 2
I 2
.B ifelse
E 4
I 4
D 6
.MC ifelse "(arg, arg, if-same [, ifnot-same | arg, arg ...])"
E 6
I 6
D 13
.Tp Ic ifelse
E 13
I 13
.It Ic ifelse
E 13
D 8
usage:
E 8
.Ar ifelse(arg, arg, if-same [, ifnot-same \&| arg,\ arg\ ...])
D 13
.br
E 6
E 4
E 2
has three or more arguments.
E 13
I 13
has
three or more arguments.
E 13
If the first argument is the same string as the second,
then the value is the third argument.
D 4
If not, and if there are more than four arguments, the process is repeated with arguments 4, 5, 6 and 7.
E 4
I 4
D 6
If not, and if there are more than four arguments, the process is 
E 6
I 6
If not, and if there are more than four arguments, the process is
E 6
repeated with arguments 4, 5, 6 and 7.
E 4
Otherwise, the value is either the fourth string, or, if it is not present,
null.
D 4
.TP
D 2
incr
E 2
I 2
.B incr
E 4
I 4
D 6
.MC incr "(num)"
E 6
I 6
D 13
.Tp Ic incr
E 13
I 13
.It Ic incr
E 13
D 8
usage:
E 8
.Ar incr(num)
D 13
.br
E 13
E 6
E 4
E 2
returns the value of its argument incremented by 1.
The value of the argument is calculated
by interpreting an initial digit-string as a decimal number.
D 4
.TP
D 2
eval
E 2
I 2
.B eval
E 2
evaluates its argument as an arithmetic expression, using 32-bit arithmetic.
D 2
Operators include +, \-, \(**, /, %, ^ (exponentiation); relationals; parentheses.
E 2
I 2
Operators include +, \-, \(**, /, %, ^ (exponentiation); relationals;
parentheses.
E 2
.TP
D 2
len
E 2
I 2
.B len
E 4
I 4
D 6
.MC decr "(num)"
E 6
I 6
D 13
.Tp Ic decr
E 13
I 13
.It Ic decr
E 13
D 8
usage:
E 8
.Ar decr(num)
D 13
.br
E 13
E 6
returns the value of its argument decremented by 1.
D 6
.MC eval "(expression)"
E 6
I 6
D 13
.Tp Ic eval
E 13
I 13
.It Ic eval
E 13
D 8
usage:
E 8
.Ar eval(expression)
D 13
.br
E 6
evaluates its argument as a constant expression, using integer arithmetic.
E 13
I 13
evaluates its argument as a constant expression,
using integer arithmetic.
E 13
The evaluation mechanism is very similar to that of
D 6
.I cpp
(#if expression). 
E 6
I 6
.Xr cpp
(#if expression).
E 6
The expression can involve only integer constants and character constants,
possibly connected by the binary operators
D 6
.nf
.ft B

*	/	%	+	-	>>	<<	<	>	
<=	>=	==	!=	&	^	|	&&	||

.ft R
.fi
or the unary operators \fB\- ~ !\fR
or by the ternary operator \fB ? : \fR.
E 6
I 6
D 13
.Ds I
*	/	%	+	-	>>	<<	<	>
<=	>=	==	!=	&	^		&&
.De
E 13
I 13
.Bd -literal -offset indent
*     /     %     +     -     >>    <<    <     >
      <=    >=    ==    !=    &     ^     &&
.Ed
.Pp
E 13
or the unary operators
.Ic  \&~ \&!
or by the ternary operator
.Ic  \&? \&:  .
E 6
Parentheses may be used for grouping. Octal numbers may be specified as
in C.
D 6
.MC len "(string)"
E 6
I 6
D 13
.Tp Ic len
E 13
I 13
.It Ic len
E 13
D 8
usage:
E 8
.Ar len(string)
D 13
.br
E 13
E 6
E 4
E 2
returns the number of characters in its argument.
D 4
.TP
D 2
index
returns the position in its first argument where the second argument begins (zero origin),
or \-1 if the second argument does not occur.
E 2
I 2
.B index
returns the position in its first argument where the second argument
begins (zero origin), or \-1 if the second argument does not occur.
E 2
.TP
D 2
substr
E 2
I 2
.B substr
E 4
I 4
D 6
.MC index "(search-string, string)"
returns the position in its first argument where the second argument 
E 6
I 6
D 13
.Tp Ic index
E 13
I 13
.It Ic index
E 13
D 8
usage:
E 8
.Ar index(search-string, string)
D 13
.br
returns the position in its first argument where the second argument
E 13
I 13
returns the position
in its first argument where the second argument
E 13
E 6
begins (zero origin),
or \-1 if the second argument does not occur.
D 6
.MC substr "(string, index [, length])"
E 6
I 6
D 13
.Tp Ic substr
E 13
I 13
.It Ic substr
E 13
D 8
usage:
E 8
.Ar substr(string, index [, length])
D 13
.br
E 13
E 6
E 4
E 2
returns a substring of its first argument.
D 2
The second argument is a zero origin
number selecting the first character;
E 2
I 2
D 4
The second argument is a zero origin number selecting the first character;
E 4
I 4
The second argument is a zero origin
number selecting the first character (internally treated as an expression);
E 4
E 2
the third argument indicates the length of the substring.
A missing third argument is taken to be large enough to extend to
D 4
the end of the first string.
.TP
D 2
translit
E 2
I 2
.B translit
E 4
I 4
D 6
the end of the first string. 
.MC translit "(source, from [, to])"
E 6
I 6
the end of the first string.
D 13
.Tp Ic translit
E 13
I 13
.It Ic translit
E 13
D 8
usage:
E 8
.Ar translit(source, from [, to])
D 13
.br
E 6
E 4
E 2
transliterates the characters in its first argument
E 13
I 13
transliterates
the characters in its first argument
E 13
from the set given by the second argument to the set given by the third.
D 4
No abbreviations are permitted.
.TP
D 2
include
E 2
I 2
.B include
E 4
I 4
If the third argument is shorter than the second, all extra characters
in the second argument are deleted from the first argument. If the third
argument is missing altogether, all characters in the second argument are
deleted from the first argument.
D 6
.MC include "(filename)"
E 6
I 6
D 13
.Tp Ic include
E 13
I 13
.It Ic include
E 13
D 8
usage:
E 8
.Ar include(filename)
D 13
.br
E 6
E 4
E 2
returns the contents of the file named in the argument.
D 4
.TP
D 2
sinclude
E 2
I 2
.B sinclude
E 4
I 4
D 6
.MC sinclude "(filename)"
E 6
I 6
.Tp Ic sinclude
E 13
I 13
returns
the contents of the file named in the argument.
.It Ic sinclude
E 13
D 8
usage:
E 8
.Ar sinclude(filename)
D 13
.br
E 13
E 6
E 4
E 2
is identical to
D 4
.I include,
E 4
I 4
D 6
.IR include ,
E 6
I 6
.Ic include  ,
E 6
except that it
says nothing if the file is inaccessible.
D 6
.MC paste "(filename)"
E 6
I 6
D 13
.Tp Ic paste
E 13
I 13
.It Ic paste
E 13
D 8
usage:
E 8
.Ar paste(filename)
D 13
.br
E 6
returns the contents of the file named in the argument without any
E 13
I 13
returns
the contents of the file named in the argument without any
E 13
D 6
processing, unlike 
.IR include.
.MC spaste "(filename)"
E 6
I 6
processing, unlike
.Ic include .
D 13
.Tp Ic spaste
E 13
I 13
.It Ic spaste
E 13
D 8
usage:
E 8
.Ar spaste(filename)
D 13
.br
E 13
E 6
is identical to
D 6
.IR paste ,
E 6
I 6
.Ic paste  ,
E 6
E 4
D 2
except that it
says nothing if the file is inaccessible.
E 2
I 2
except that it says nothing if the file is inaccessible.
E 2
D 4
.TP
D 2
syscmd
E 2
I 2
.B syscmd
E 2
executes the UNIX command given in the first argument.
E 4
I 4
D 6
.MC syscmd "(command)"
E 6
I 6
D 13
.Tp Ic syscmd
E 13
I 13
.It Ic syscmd
E 13
D 8
usage:
E 8
.Ar syscmd(command)
D 13
.br
E 13
E 6
executes the
D 6
.SM UNIX
E 6
I 6
D 13
UNIX
E 13
I 13
.Ux
E 13
E 6
command given in the first argument.
E 4
No value is returned.
D 4
.TP
D 2
maketemp
E 2
I 2
.B maketemp
E 2
fills in a string of XXXXX in its argument with the current process id.
.TP
D 2
errprint
prints its argument
on the diagnostic output file.
E 2
I 2
.B errprint
prints its argument on the diagnostic output file.
E 2
.TP
D 2
dumpdef
E 2
I 2
.B dumpdef
E 4
I 4
D 6
.MC sysval "()"
E 6
I 6
D 13
.Tp Ic sysval
E 13
I 13
.It Ic sysval
E 13
D 8
usage:
E 8
.Ar sysval()
D 13
.br
E 13
E 6
is the return code from the last call to
D 6
.IR syscmd .
.MC maketemp "(string)"
E 6
I 6
.Ic syscmd  .
D 13
.Tp Ic maketemp
E 13
I 13
.It Ic maketemp
E 13
D 8
usage:
E 8
.Ar maketemp(string)
D 13
.br
E 13
E 6
fills in a string of
D 6
.SM XXXXXX
E 6
I 6
D 13
XXXXXX
E 13
I 13
.Li XXXXXX
E 13
E 6
in its argument with the current process
D 6
.SM ID\*S.
.MC m4exit "([exitcode])"
E 6
I 6
ID.
D 13
.Tp Ic m4exit
E 13
I 13
.It Ic m4exit
E 13
D 8
usage:
E 8
.Ar m4exit([exitcode])
D 13
.br
E 13
E 6
causes immediate exit from
D 6
.IR m4 .
E 6
I 6
.Nm m4  .
E 6
Argument 1, if given, is the exit code;
the default is 0.
D 6
.MC m4wrap "(m4-macro-or-built-in)"
E 6
I 6
D 13
.Tp Ic m4wrap
E 13
I 13
.It Ic m4wrap
E 13
D 8
usage:
E 8
.Ar m4wrap(m4-macro-or-built-in)
D 13
.br
E 13
E 6
argument 1 will be pushed back at final
D 6
.BR EOF ;
example: m4wrap(`dumptable()').
.MC errprint "(str [, str, str, ...])"
E 6
I 6
.Ic EOF  ;
.Dl example: m4wrap(`dumptable()').
D 8
.Tp Ic errprint "(str
usage:
E 8
I 8
D 13
.Tp Ic errprint
E 13
I 13
.It Ic errprint
E 13
E 8
.Ar errprint(str [, str, str, ...])
D 13
.br
E 6
prints its argument(s) on stderr. If there is more than one argument,
E 13
I 13
prints its
argument(s) on stderr. If there is more than one argument,
E 13
each argument is separated by a space during the output.
D 6
.MC dumpdef "([name, name, ...])"
E 6
I 6
D 13
.Tp Ic dumpdef
E 13
I 13
.It Ic dumpdef
E 13
D 8
usage:
E 8
.Ar dumpdef([name, name, ...])
D 13
.br
E 13
E 6
E 4
E 2
prints current names and definitions,
for the named items, or for all if no arguments are given.
D 6
.dt
D 4
.SH "SEE ALSO"
B. W. Kernighan and D. M. Ritchie,
.I The M4 Macro Processor
E 4
I 4
.SH AUTHOR
E 6
I 6
D 13
.Tp
E 13
I 13
.El
E 13
.Sh AUTHOR
E 6
Ozan S. Yigit (oz)
D 6
.SH BUGS
E 6
I 6
.Sh BUGS
E 6
D 5
Pd M4 is distributed at the source level, and does not require an expensive
license agreement.
.PP
E 5
D 13
A sufficiently complex M4 macro set is about as readable
E 13
I 13
A sufficiently complex
.Nm M4
macro set is about as readable
E 13
as
D 6
.BR APL .
.PP
E 6
I 6
D 13
.Ar APL  .
E 13
I 13
.Tn APL  .
E 13
.Pp
E 6
D 13
All complex uses of M4 require the ability to program in deep recursion.
E 13
I 13
All complex uses of
.Nm M4
require the ability to program in deep recursion.
E 13
Previous lisp experience is recommended.
D 5
.PP
Pd M4 is slower than V7 M4.
E 5
D 6
.SH EXAMPLES
E 6
I 6
.Sh EXAMPLES
E 6
D 5
.PP
E 5
The following macro program illustrates the type of things that
D 6
can be done with M4. 
.PP
.RS
.nf
\fBchangequote\fR(<,>) \fBdefine\fR(HASHVAL,99) \fBdnl\fR
\fBdefine\fR(hash,<\fBexpr\fR(str(\fBsubstr\fR($1,1),0)%HASHVAL)>) \fBdnl\fR
\fBdefine\fR(str,
	<\fBifelse\fR($1,",$2,
		<str(\fBsubstr\fR(<$1>,1),<\fBexpr\fR($2+'\fBsubstr\fR($1,0,1)')>)>)
	>) \fBdnl\fR
\fBdefine\fR(KEYWORD,<$1,hash($1),>) \fBdnl\fR
\fBdefine\fR(TSTART,
E 6
I 6
D 13
can be done with M4.
.Pp
.Ds I
E 13
I 13
can be done with
.Nm M4 .
.Bd -literal -offset indent
E 13
changequote(<,>) define(HASHVAL,99) dnl
define(hash,<expr(str(substr($1,1),0)%HASHVAL)>) dnl
define(str,
	<ifelse($1,",$2,
	\t<str(substr(<$1>,1),<expr($2+'substr($1,0,1)')>)>)
	>) dnl
define(KEYWORD,<$1,hash($1),>) dnl
define(TSTART,
E 6
<struct prehash {
	char *keyword;
	int   hashval;
D 6
} keytab[] = {>) \fBdnl\fR
\fBdefine\fR(TEND,<	"",0
};>) \fBdnl\fR
.fi
.RE
.PP
E 6
I 6
} keytab[] = {>) dnl
define(TEND,<	"",0
};>)
dnl
D 13
.De
E 13
I 13
.Ed
E 13
.Pp
E 6
Thus a keyword table containing the keyword string and its pre-calculated
hash value may be generated thus:
D 6
.PP
.RS
.nf
E 6
I 6
D 13
.Pp
.Ds I
E 13
I 13
.Bd -literal -offset indent
E 13
E 6
TSTART
	KEYWORD("foo")
	KEYWORD("bar")
	KEYWORD("baz")
TEND
D 6
.fi
.RE
.PP
E 6
I 6
D 13
.De
E 13
I 13
.Ed
E 13
.Pp
E 6
which will expand into:
D 6
.RS
.nf
E 6
I 6
D 13
.Pp
.Ds I
E 13
I 13
.Bd -literal -offset indent
E 13
E 6
struct prehash {
	char *keyword;
	int   hashval;
} keytab[] = {
	"foo",27,
	"bar",12,
	"baz",20,
	"",0
};
D 6
.fi
.RE
.PP
E 6
I 6
D 13
.De
E 13
I 13
.Ed
E 13
.Pp
E 6
Presumably, such a table would speed up the installation of the
keywords into a dynamic hash table. (Note that the above macro
D 6
cannot be used with 
.IR M4 , 
since 
.B eval
E 6
I 6
cannot be used with
.Nm m4  ,
since
.Ic eval
E 6
does not handle character constants.)
D 5

E 5
D 6
.SH SEE ALSO
cc(1),
D 5
m4(1),
E 5
cpp(1).
I 5
m4(1),
E 5
.I "The M4 Macro Processor\^"
E 6
I 6
.Sh SEE ALSO
D 14
.Xr cc 1 ,
.Xr cpp 1 .
D 8
.Xr m4 1 ,
E 8
I 8
.Xr m4 1
E 14
I 14
.Xr cpp 1
E 14
D 13
.br
E 8
.Em The M4 Macro Processor
E 6
by B. W. Kernighan and D. M. Ritchie.
E 13
I 13
.Rs
.%T "The M4 Macro Processor"
.%A B. W. Kernighan
.%A D. M. Ritchie.
.Re
E 13
D 6

E 6
I 6
.Sh HISTORY
I 13
An
E 13
.Nm M4
D 13
command appeared in Version 7 AT&T UNIX.  The
.Nm m4
E 13
I 13
command appeared in
.At v7 .
The
.Nm M4
E 13
D 14
command this page describes is derived from code
contributed by Ozan S. Yigit.
E 14
I 14
command this page describes is derived from code contributed by
Ozan S. Yigit.
E 14
E 6
E 4
E 1
