h25721
s 00002/00002/00462
d D 8.1 93/06/06 15:42:22 bostic 7 6
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00120/00211/00344
d D 6.4 91/07/24 16:37:32 cael 6 5
c mdoc version three
e
s 00002/00000/00553
d D 6.3 91/03/14 00:14:40 cael 5 3
c add .Vx so tmac.andoc will call tmac.mdoc-old
e
s 00001/00000/00553
d R 6.3 91/03/13 20:31:49 cael 4 3
c add .Vx so tmac.andoc will call tmac.mdoc-old
e
s 00462/00183/00091
d D 6.2 90/06/11 05:58:33 cael 3 2
c converted man page
e
s 00001/00001/00273
d D 6.1 85/04/29 21:13:25 mckusick 2 1
c 4.3BSD beta release manual page
e
s 00274/00000/00000
d D 5.1 85/04/29 21:13:05 mckusick 1 0
c manual page first distributed with 4.2BSD
e
u
U
t
T
I 1
D 3
.\" Copyright (c) 1983 Regents of the University of California.
.\" All rights reserved.  The Berkeley software License Agreement
.\" specifies the terms and conditions for redistribution.
E 3
I 3
D 7
.\" Copyright (c) 1983, 1990 The Regents of the University of California.
.\" All rights reserved.
E 7
I 7
.\" Copyright (c) 1983, 1990, 1993
.\"	The Regents of the University of California.  All rights reserved.
E 7
E 3
.\"
D 3
.\"	%W% (Berkeley) %G%
E 3
I 3
D 6
.\" %sccs.include.redist.man%
E 6
I 6
.\" %sccs.include.redist.roff%
E 6
E 3
.\"
D 2
.TH PDX 1 "9 February 1983"
E 2
I 2
D 3
.TH PDX 1 "%Q%"
E 2
.UC 5
.SH NAME
pdx \- pascal debugger
.SH SYNOPSIS
pdx [\fB\-r\fP] [\fIobjfile\fP]
.SH DESCRIPTION
\fIPdx\fP is a tool for source level debugging and execution of
E 3
I 3
D 6
.\"     %W% (Berkeley) %G%
E 6
I 6
.\"	%W% (Berkeley) %G%
E 6
.\"
I 5
D 6
.Vx
.Vx
E 6
E 5
.Dd %Q%
.Dt PDX 1
.Os BSD 4.2
.Sh NAME
.Nm pdx
.Nd pascal debugger
.Sh SYNOPSIS
.Nm pdx
.Op Fl r
.Op Ar objfile
.Sh DESCRIPTION
.Nm Pdx
is a tool for source level debugging and execution of
E 3
Pascal programs.
D 3
The \fIobjfile\fP is an object file produced by the Pascal translator
\fIpi\fP(1).  If no \fIobjfile\fP is specified, \fIpdx\fP looks
E 3
I 3
The
.Ar objfile
is an object file produced by the Pascal translator
.Xr pi 1 .
If no
.Ar objfile
is specified,
.Nm pdx
looks
E 3
for a file named ``obj'' in the current directory.
The object file contains a symbol table which includes the name of the
D 3
all the source files translated by \fIpi\fP to create it.
E 3
I 3
all the source files translated by
.Xr pi 1
to create it.
E 3
These files are available for perusal while using the debugger.
D 3
.PP
If the file ``.pdxinit'' exists in the current directory, then the
E 3
I 3
.Pp
If the file
.Dq Pa .pdxinit
exists in the current directory, then the
E 3
debugger commands in it are executed.
D 3
.PP
The \fB\-r\fP option causes the \fIobjfile\fP to be executed immediately;
if it terminates successfully \fIpdx\fP exits.
E 3
I 3
.Pp
D 6
.Tp Fl r
E 6
I 6
.Bl -tag -width flag r
.It Fl r
E 6
The
.Fl r
option causes the
.Ar objfile
to be executed immediately;
if it terminates successfully
.Nm pdx
exits.
E 3
Otherwise it reports the reason for termination
and offers the user the option of entering the debugger
D 3
or simply letting \fIpx\fP continue with a traceback.
If \fB\-r\fP is not specified, \fIpdx\fP just prompts and waits for a command.
.PP
E 3
I 3
or simply letting
.Xr px
continue with a traceback.
If
.Fl r
is not specified,
.Nm pdx
just prompts and waits for a command.
D 6
.Tp
E 6
I 6
.El
E 6
.Pp
E 3
The commands are:
D 3
.TP
\fBrun\fP [\fIargs\fP] [\fB<\fP \fIfilename\fP] [\fB>\fP \fIfilename\fP]
Start executing \fIobjfile\fP, passing \fIargs\fP as command line arguments;
\fB<\fP or \fB>\fP can be used to redirect input or output in the usual manner.
.TP
\fBtrace\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIprocedure/function\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIexpression\fP \fBat\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]
.ns
.TP
\fBtrace\fP \fIvariable\fP [\fBin\fP \fIprocedure/function\fP] [\fBif\fP \fIcondition\fP]
E 3
I 3
D 6
.Dw Fl
.Di L
.Dp Cx Ic run
.Cx \&\ \&
E 6
I 6
.Pp
.Bl -tag -width flag -compact
.It Xo
.Ic run
E 6
.Op Ar args
D 6
.Cx \&\ \&
E 6
.Op Ic \&< Ar filename
D 6
.Cx \&\ \&
E 6
.Op Ic \&> Ar filename
D 6
.Cx
E 6
I 6
.Xc
E 6
Start executing
.Ar objfile  ,
passing
.Ar args
as command line arguments;
.Ic \&<
or
.Ic \&>
can be used to redirect input or output in the usual manner.
.Pp
D 6
.Dp Cx Ic trace
.Pp
.Cx \&\ \&
E 6
I 6
.It Xo
.Ic trace
E 6
.Op Ic in Ar procedure/function
D 6
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
E 6
I 6
.Op Ic if Ar condition 
.Xc
.It Xo
.Ic trace
E 6
.Ar source-line-number
.Op Ic if Ar condition
D 6
.Cx \&\ \&
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
E 6
I 6
.Xc
.It Xo
.Ic trace
E 6
.Ar procedure/function
D 6
.Cx \&\ \&
E 6
.Op Ic in Ar procedure/function
D 6
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
.Ar expression
.Cx \&\ \&
.Ic at
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic trace
.Cx \&\ \&
E 6
I 6
.Op Ic if Ar condition 
.Xc
.It Xo
.Ic trace
.Ar expression Ic at Ar source-line-number
.Op Ic if Ar condition 
.Xc
.It Xo
.Ic trace
E 6
.Ar variable
D 6
.Cx \&\ \&
E 6
.Op Ic in Ar procedure/function
D 6
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
E 6
I 6
.Op Ic if Ar condition 
.Xc
E 6
E 3
Have tracing information printed when the program is executed.
A number is associated with the command that is used
D 3
to turn the tracing off (see the \fBdelete\fP command).
.sp 1
E 3
I 3
to turn the tracing off (see the
.Ic delete
command).
.Pp
E 3
The first argument describes what is to be traced.
D 3
If it is a \fIsource-line-number\fP, then the line is printed
E 3
I 3
If it is a
.Ar source-line-number  ,
then the line is printed
E 3
immediately prior to being executed.
Source line numbers in a file other than the current one
must be preceded by the name of the file and a colon, e.g.
``mumble.p:17''.
D 3
.sp 1
E 3
I 3
.Pp
E 3
If the argument is a procedure or function name then
every time it is called, information is printed telling
what routine called it, from what source line it was called,
and what parameters were passed to it.
In addition, its return is noted, and if it's a function
then the value it is returning is also printed.
D 3
.sp 1
If the argument is an \fIexpression\fP with an \fBat\fP clause
E 3
I 3
.Pp
If the argument is an
.Ar expression
with an
.Ic at
clause
E 3
then the value of the expression is printed whenever the
identified source line is reached.
D 3
.sp 1
E 3
I 3
.Pp
E 3
If the argument is a variable then the name and value of the variable
is printed whenever it changes.
Execution is substantially slower during this form of tracing.
D 3
.sp 1
E 3
I 3
.Pp
E 3
If no argument is specified then all source lines are printed
before they are executed.
Execution is substantially slower during this form of tracing.
D 3
.sp 1
The clause ``\fBin\fP \fIprocedure/function\fP'' restricts tracing information
E 3
I 3
.Pp
The clause
D 6
.Dq Cx Ic in
.Cx \&\ \&
.Ar procedure/function
.Cx
E 6
I 6
.Dq Ic in Ar procedure/function 
E 6
restricts tracing information
E 3
to be printed only while executing inside the given procedure
or function.
D 3
.sp 1
\fICondition\fP is a Pascal boolean expression and is
E 3
I 3
.Pp
.Ar Condition
is a Pascal boolean expression and is
E 3
evaluated prior to printing the tracing information;
if it is false then the information is not printed.
D 3
.sp 1
E 3
I 3
.Pp
E 3
There is no restriction on the amount of information
that can be traced.
D 3
.br
E 3
I 3
.Pp
E 3
.ne 10
D 3
.IP "\fBstop\fP \fBif\fP \fIcondition\fP"
.ns
.IP "\fBstop\fP \fBat\fP \fIsource-line-number\fP [\fBif\fP \fIcondition\fP]"
.ns
.IP "\fBstop\fP \fBin\fP \fIprocedure/function\fP [\fBif\fP \fIcondition\fP]"
.ns
.IP "\fBstop\fP \fIvariable\fP [\fBif\fP \fIcondition\fP]"
E 3
I 3
D 6
.Dp Cx Ic stop
.Cx \&\ \&
.Ic if
.Cx \&\ \&
.Ar condition
.Cx
.Dp Cx Ic stop
.Cx \&\ \&
.Ic at
.Cx \&\ \&
.Ar source-line-number
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic stop
.Cx \&\ \&
.Ic in
.Cx \&\ \&
.Ar procedure /function
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
.Dp Cx Ic stop
.Cx \&\ \&
.Ar variable
.Cx \&\ \&
.Op Ic if Ar condition
.Cx
E 6
I 6
.It Ic stop if Ar condition 
.It Xo
.Ic stop at Ar source-line-number
.Op Ic if Ar condition 
.Xc
.It Xo
.Ic stop in Ar procedure/function
.Op Ic if Ar condition 
.Xc
.It Xo
.Ic stop Ar variable
.Op Ic if Ar condition 
.Xc
E 6
E 3
Stop execution when the given line is reached, procedure or function
called, variable changed, or condition true.
D 3
.IP "\fBdelete\fP \fIcommand-number\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic delete
.Cx \&\ \&
.Ar command-number
.Cx
E 6
I 6
.It Ic delete Ar command-number 
E 6
E 3
The trace or stop corresponding to the given number is removed.
The numbers associated with traces and stops are printed by
D 3
the \fBstatus\fP command.
.IP "\fBstatus\fP [\fB>\fP \fIfilename\fP]"
E 3
I 3
the
.Ic status
command.
.Pp
D 6
.Dp Cx Ic status
.Cx \&\ \&
.Op Ic \&> Ar filename
.Cx
E 6
I 6
.It Ic status Op Ic \&> Ar filename 
E 6
E 3
Print out
D 3
the currently active \fBtrace\fP and \fBstop\fP commands.
.IP \fBcont\fP
E 3
I 3
the currently active
.Ic trace
and
.Ic stop
commands.
.Pp
D 6
.Dp Ic cont
E 6
I 6
.It Ic cont
E 6
E 3
Continue execution from where it stopped.
This can only be
done when the program was stopped by an interrupt
D 3
or through use of the \fBstop\fP command.
.IP \fBstep\fP
E 3
I 3
or through use of the
.Ic stop
command.
.Pp
D 6
.Dp Ic step
E 6
I 6
.It Ic step
E 6
E 3
Execute one source line.
D 3
.IP \fBnext\fP
E 3
I 3
.Pp
D 6
.Dp Ic next
E 6
I 6
.It Ic next
E 6
E 3
Execute up to the next source line.
D 3
The difference between this and \fBstep\fP is that
E 3
I 3
The difference between this and
.Ic step
is that
E 3
if the line contains a call to a procedure or function
D 3
the \fBstep\fP command will stop at the beginning of that
block, while the \fBnext\fP command will not.
.IP "\fBprint\fP \fIexpression\fP [\fB,\fP \fIexpression\fP ...]"
E 3
I 3
the
.Ic step
command will stop at the beginning of that
block, while the
.Ic next
command will not.
.Pp
D 6
.Dp Cx Ic print
.Cx \&\ \&
.Ar expression
.Cx \&\ \&
.Op Ic \&, Ar expression ...
.Cx
E 6
I 6
.It Xo
.Ic print Ar expression
.Op Ic \&, Ar expression ... 
.Xc
E 6
E 3
Print out the values of the Pascal expressions.
Variables declared in an outer block but having
the same identifier as one in the current block may be
D 3
referenced as ``\fIblock-name\fP\ \fB.\fP\ \fIvariable\fP''.
.IP "\fBwhatis\fP \fIidentifier\fP"
E 3
I 3
referenced as
.Dq Ar block-name \&. variable
.Pp
D 6
.Dp Cx Ic whatis
.Cx \&\ \&
.Ar identifier
.Cx
E 6
I 6
.It Ic whatis Ar identifier 
E 6
E 3
Print the declaration of the given identifier.
D 3
.IP "\fBwhich\fP \fIidentifier\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic which
.Cx \&\ \&
.Ar identifier
.Cx
E 6
I 6
.It Ic which Ar identifier 
E 6
E 3
Print the full qualification of the given identifer, i.e.
the outer blocks that the identifier is associated with.
D 3
.IP "\fBassign\fP \fIvariable\fP \fIexpression\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic assign
.Cx \&\ \&
.Ar variable
.Cx \&\ \&
.Ar expression
.Cx
E 6
I 6
.It Ic assign Ar variable Ar expression 
E 6
E 3
Assign the value of the expression to the variable.
D 3
.IP "\fBcall\fP \fIprocedure(parameters)\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic call
.Cx \&\ \&
.Ar procedure (parameters)
.Cx
E 6
I 6
.It Ic call Ar procedure Ns (parameters) 
E 6
E 3
Execute the object code associated with the named procedure or function.
D 3
.IP \fBhelp\fP
Print out a synopsis of \fIpdx\fP commands.
.IP \fBgripe\fP
Invokes a mail program to send a message to the person in charge of \fIpdx\fP.
.IP \fBwhere\fP
E 3
I 3
.Pp
D 6
.Dp Ic help
E 6
I 6
.It Ic help
E 6
Print out a synopsis of
.Nm pdx
commands.
.Pp
D 6
.Dp Ic gripe
E 6
I 6
.It Ic gripe
E 6
Invokes a mail program to send a message to the person in charge of
.Nm pdx  .
.Pp
D 6
.Dp Ic where
E 6
I 6
.It Ic where
E 6
E 3
Print out
a list of the active procedures and functions and the respective source
line where they are called.
D 3
.TP
\fBsource\fP \fIfilename\fP
Read \fIpdx\fP commands from the given \fIfilename\fP.
Especially useful when the \fIfilename\fP has been created by redirecting
a \fBstatus\fP command from an earlier debugging session.
.IP "\fBdump\fP [\fB>\fP \fIfilename\fP]"
E 3
I 3
.Pp
D 6
.Dp Cx Ic source
.Cx \&\ \&
.Ar filename
.Cx
E 6
I 6
.It Ic source Ar filename 
E 6
Read
.Nm pdx
commands from the given
.Ar filename  .
Especially useful when the
.Ar filename
has been created by redirecting
a
.Ic status
command from an earlier debugging session.
.Pp
D 6
.Dp Cx Ic dump
.Cx \&\ \&
.Op Ic \&> Ar filename
.Cx
E 6
I 6
.It Ic dump Op Ic \&> Ar filename 
E 6
E 3
Print the names and values of all active
data.
D 3
.IP "\fBlist\fP [\fIsource-line-number\fP [\fB,\fP \fIsource-line-number\fP]]"
.ns
.IP "\fBlist\fP \fIprocedure/function\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic list
.Cx \&\ \&[
.Ar source-line-number
.Cx \&\ \&
.Op \&, Ar source-line-number
.Cx \&]
.Cx
.Dp Cx Ic list
.Cx \&\ \&
.Ar procedure/function
.Cx
E 6
I 6
.It Xo
.Ic list
.Oo Ar source-line-number
.Op \&, Ar source-line-number Oc
.Xc
.It Ic list Ar procedure/function 
E 6
E 3
List the lines in the current source file from the first line number to
the second inclusive.
As in the editor
``$'' can be used to refer to the last line.
If no lines are specified, the entire file is listed.
If the name of a procedure or function is given
D 3
lines \fIn-k\fP to \fIn+k\fP are listed where \fIn\fP is the first statement
in the procedure or function and \fIk\fP is small.
.IP "\fBfile\fP [\fIfilename\fP]"
Change the current source file name to \fIfilename\fP.
E 3
I 3
lines
.Ar n-k
to
.Ar n+k
are listed where
.Ar n
is the first statement
in the procedure or function and
.Ar k
is small.
.Pp
D 6
.Dp Cx Ic file
.Cx \&\ \&
.Op Ar filename
.Cx
E 6
I 6
.It Ic file Op Ar filename 
E 6
Change the current source file name to
.Ar filename  .
E 3
If none is specified then the current source file name is printed.
D 3
.IP "\fBedit\fP [\fIfilename\fP]"
.ns
.IP "\fBedit\fP \fIprocedure/function-name\fP"
Invoke an editor on \fIfilename\fP or the current source file if none
E 3
I 3
.Pp
D 6
.Dp Cx Ic edit
.Cx \&\ \&
.Op Ar filename
.Cx
.Dp Cx Ic edit
.Cx \&\ \&
.Ar procedure/function-name
.Cx
E 6
I 6
.It Ic edit Op Ar filename 
.It Ic edit Ar procedure Ns / Ns Ar function-name 
E 6
Invoke an editor on
.Ar filename
or the current source file if none
E 3
is specified.
D 3
If a \fIprocedure\fP or \fIfunction\fP name is specified,
E 3
I 3
If a
.Ar procedure
or
.Ar function
name is specified,
E 3
the editor is invoked on the file that contains it.
Which editor is invoked by default depends on the installation.
The default can be overridden by setting the environment variable
D 6
EDITOR to the name of the desired editor.
E 6
I 6
.Ev EDITOR
to the name of the desired editor.
E 6
D 3
.IP \fBpi\fP
E 3
I 3
.Pp
D 6
.Dp Ic pi
E 6
I 6
.It Ic pi
E 6
E 3
Recompile the program and read in the new symbol table information.
D 3
.IP "\fBsh\fP \fIcommand-line\fP"
E 3
I 3
.Pp
D 6
.Dp Cx Ic sh
.Cx \&\ \&
.Ar command-line
.Cx
E 6
I 6
.It Ic sh Ar command-line 
E 6
E 3
Pass the command line to the shell for execution.
The SHELL environment variable determines which shell is used.
D 3
.IP "\fBalias\fP \fInew-command-name\fP \fIold-command-name\fP"
This command makes \fIpdx\fP respond to \fInew-command-name\fP
the way it used to respond to \fIold-command-name\fP.
.IP "\fBquit\fP"
Exit \fIpdx\fP.
.sp 4
.PP
The following commands deal with the program at the \fIpx\fP instruction
E 3
I 3
.Pp
D 6
.Dp Cx Ic alias
.Cx \&\ \&
.Ar new-command-name
.Cx \&\ \&
.Ar old-command-name
.Cx
E 6
I 6
.It Ic alias Ar new-command-name Ar old-command-name 
E 6
This command makes
.Nm pdx
respond to
.Ar new-command-name
the way it used to respond to
.Ar old-command-name  .
.Pp
D 6
.Dp Ic quit
E 6
I 6
.It Ic quit
E 6
Exit
.Nm pdx  .
D 6
.Dp
E 6
I 6
.El
E 6
.Pp
The following commands deal with the program at the
.Ar px
instruction
E 3
level rather than source level.
They are not intended for general use.
D 3
.TP
\fBtracei\fP [\fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBtracei\fP [\fIvariable\fP] [\fBat\fP \fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBstopi\fP [\fIaddress\fP] [\fBif\fP \fIcond\fP]
.ns
.TP
\fBstopi\fP [\fBat\fP] [\fIaddress\fP] [\fBif\fP \fIcond\fP]
Turn on tracing or set a stop using a \fIpx\fP machine
E 3
I 3
D 6
.Dw Fl
.Di L
.Dp Cx Ic tracei
.Cx \&\ \&
E 6
I 6
.Pp
.Bl -tag -width Fl -compact
.It Xo
.Ic tracei
E 6
.Op Ar address
D 6
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
.Dp Cx Ic tracei
.Cx \&\ \&
E 6
I 6
.Op Ic if Ar cond 
.Xc
.It Xo
.Ic tracei
E 6
.Op Ar variable
D 6
.Cx \&\ \&
E 6
.Op Ic at Ar address
D 6
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
.Dp Cx Ic stopi
.Cx \&\ \&
E 6
I 6
.Op Ic if Ar cond 
.Xc
.It Xo
.Ic stopi
E 6
.Op Ar address
D 6
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
.Dp Cx Ic stopi
.Cx \&\ \&
E 6
I 6
.Op Ic if Ar cond 
.Xc
.It Xo
.Ic stopi
E 6
.Op Ic at
D 6
.Cx \&\ \&
E 6
.Op Ar address
D 6
.Cx \&\ \&
.Op Ic if Ar cond
.Cx
E 6
I 6
.Op Ic if Ar cond 
.Xc
E 6
Turn on tracing or set a stop using a
.Ic px
machine
E 3
instruction addresses.
D 3
.TP
\fBxi\fP \fIaddress\fP [\fB,\fP \fIaddress\fP]
Print the instructions starting at the first \fIaddress\fP.
E 3
I 3
.Pp
D 6
.Dp Cx Ic xi
.Cx \&\ \&
.Ar address
.Cx \&\ \&
.Op Ic \&, Ar address
.Cx
E 6
I 6
.It Xo
.Ic xi Ar address
.Op Ic \&, Ar address 
.Xc
E 6
Print the instructions starting at the first
.Ar address  .
E 3
Instructions up to
D 3
the second \fIaddress\fP are printed.
.TP
\fBxd\fP \fIaddress\fP [\fB,\fP \fIaddress\fP]
E 3
I 3
the second
.Ar address
are printed.
.Pp
D 6
.Dp Cx Ic xd
.Cx \&\ \&
.Ar address
.Cx \&\ \&
.Op Ic \&, Ar address
.Cx
E 6
I 6
.It Xo
.Ic xd Ar address
.Op Ic \&, Ar address 
.Xc
E 6
E 3
Print in octal the specified data location(s).
D 3
.SH FILES
.nr In 25
.in +\n(Inn
.ta \n(Inn
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
.ti -\n(Inn
\&obj	\c
E 3
I 3
D 6
.Dp
E 6
I 6
.El
E 6
.Sh ENVIRONMENT
D 6
.Tw Ar
.Tp Ev EDITOR
E 6
I 6
.Bl -tag -width Ar
.It Ev EDITOR
E 6
The
.Ic edit
function uses the
.Ev EDITOR
environment variable to see what editor to use.
D 6
.Tp Ev SHELL
E 6
I 6
.It Ev SHELL
E 6
The function
.Ic sh
checks the
.Ev SHELL
variable to see which shell to
execute.
D 6
.Tp
E 6
I 6
.El
E 6
.Sh FILES
D 6
.Dw .pdxinit
.Di L
.Dp Pa \&obj
E 6
I 6
.Bl -tag -width .pdxinit -compact
.It Pa obj
E 6
E 3
Pascal object file
I 3
D 6
.Dp Pa \&.pdxinit
E 6
I 6
.It Pa .pdxinit
E 6
.Nm Pdx
initialization file
D 6
.Dp
E 6
I 6
.El
E 6
.Sh SEE ALSO
.Xr pi 1 ,
.Xr px 1
E 3
D 6
.br
D 3
.nr wg 0v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
.ti -\n(Inn
\&\&.pdxinit	\c
\fIPdx\fP initialization file
.in -\n(Inn
.br
.nr wg 1v
.ie \n(.h=\n(vk .nr wg -\n(vhu
.el .nr vh 0
.if \n(wg>0 \{\
.sp \n(wgu
.nr vh +\n(wgu \}
.nr vk \n(.h
.SH SEE ALSO
pi(1), px(1)
.br
\fIAn Introduction to Pdx\fP
.SH BUGS
\fIPdx\fP does not understand sets,
E 3
I 3
.Em Ar An Introduction to Pdx
E 6
I 6
.Rs
.%T "An Introduction to Pdx"
.Re
E 6
.Sh HISTORY
.Nm Pdx
D 6
appeared in 4.2 BSD.
E 6
I 6
appeared in
.Bx 4.2 .
E 6
.Sh BUGS
.Nm Pdx
does not understand sets,
E 3
and provides no information about files.
D 3
.sp 1
The \fIwhatis\fP command doesn't quite work for variant records.
.sp 1
E 3
I 3
.Pp
The
.Ic whatis
command doesn't quite work for variant records.
.Pp
E 3
Bad things will happen if a procedure invoked with
D 3
the \fBcall\fP command does a non-local goto.
.sp 1
The commands \fBstep\fP and \fBnext\fP should be able to take a \fIcount\fP
E 3
I 3
the
.Ic call
command does a non-local goto.
.Pp
The commands
.Ic step
and
.Ic next
should be able to take a
.Ar count
E 3
that specifies how many lines to execute.
D 3
.sp 1
There should be commands \fBstepi\fP and \fBnexti\fP that correspond
to \fBstep\fP and \fBnext\fP but work at the instruction level.
.sp 1
E 3
I 3
.Pp
There should be commands
.Ic stepi
and
.Ic nexti
that correspond
to
.Ic step
and
.Ic next
but work at the instruction level.
.Pp
E 3
There should be a way to get an address associated with
a line number, procedure or function, and variable.
D 3
.sp 1
E 3
I 3
.Pp
E 3
Most of the command names are too long.
D 3
.sp 1
E 3
I 3
.Pp
E 3
The alias facility is quite weak.
D 3
.sp 1
A \fIcsh\fP-like history capability would improve the situation.
E 3
I 3
.Pp
A
D 6
.Xr csh 1
\- like history capability would improve the situation.
E 6
I 6
.Xr csh 1 Ns \-like
history capability would improve the situation.
E 6
E 3
E 1
