h54411
s 00002/00002/00144
d D 8.1 93/06/06 22:27:49 bostic 47 46
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00003/00000/00143
d D 3.36 90/06/06 21:43:20 bostic 46 45
c fix contrib notice (Edward Wang)
e
s 00001/00011/00142
d D 3.35 90/06/02 15:19:00 bostic 45 44
c new copyright notice
e
s 00002/00003/00151
d D 3.34 88/08/04 18:09:15 edward 44 43
c use clreos and always try clreol in wwupdate1
e
s 00010/00005/00144
d D 3.33 88/06/29 21:35:32 bostic 43 42
c install approved copyright notice
e
s 00013/00007/00136
d D 3.32 88/02/21 13:36:37 bostic 42 41
c written by Edward Wang; attach Berkeley specific copyright
e
s 00001/00001/00142
d D 3.31 88/01/03 00:56:07 bostic 41 40
c fix ctrl macro for ANSI C
e
s 00001/00001/00142
d D 3.30 87/07/27 17:02:45 bostic 40 39
c for edward; spelling correction
e
s 00006/00000/00137
d D 3.29 85/04/24 16:12:17 edward 39 38
c copyright messages
e
s 00002/00002/00135
d D 3.28 85/03/01 17:32:10 edward 38 37
c changed some prompt messages
e
s 00001/00001/00136
d D 3.27 84/06/02 22:44:25 edward 37 36
c spelling
e
s 00001/00001/00136
d D 3.26 84/05/23 01:56:42 edward 36 35
c new sccs id
e
s 00002/00002/00135
d D 3.25 84/04/08 19:22:49 edward 35 34
c new options to "window": shell, pty, frame
c and stuff to support them
e
s 00004/00004/00133
d D 3.24 84/04/08 12:34:24 edward 34 33
c set ww_mapnl for cmdwin
e
s 00003/00002/00134
d D 3.23 84/04/08 12:08:05 edward 33 32
c control character expansion in wwwrite()
c calling of wwupdate() in wwwrite() dependent of ww_noupdate
c control character handling macros in char.h
e
s 00001/00001/00135
d D 3.22 84/03/23 20:36:48 edward 32 30
c compile with -R
e
s 00001/00001/00135
d R 3.22 84/03/23 20:34:53 edward 31 30
c forgot one
e
s 00006/00006/00130
d D 3.21 84/03/03 22:42:59 edward 30 29
c interrupt driven input
e
s 00005/00005/00131
d D 3.20 84/01/16 15:25:38 edward 29 28
c new io scheme
e
s 00000/00052/00136
d D 3.19 84/01/13 11:53:50 edward 28 27
c {open,close}{i,}win() moved to win.c
e
s 00002/00001/00186
d D 3.18 83/12/17 13:43:27 edward 27 26
c let c_window() take 0 as starting row
e
s 00001/00001/00186
d D 3.17 83/12/01 13:43:32 edward 26 25
c pty hanging bug
e
s 00000/00000/00187
d D 3.16 83/11/30 11:55:20 edward 25 24
c lastselwin, and restructured some code
e
s 00001/00006/00186
d D 3.15 83/11/29 12:53:28 edward 24 23
c vfork
e
s 00019/00014/00173
d D 3.14 83/11/29 11:29:40 edward 23 22
c getpos() cleanup
e
s 00006/00002/00181
d D 3.13 83/11/22 19:52:39 edward 22 21
c openwin has new 'label' argument
e
s 00003/00001/00180
d D 3.12 83/09/15 17:11:08 edward 21 20
c The 'M' command and rearranged debugging commands ('&')
e
s 00003/00002/00178
d D 3.11 83/09/14 14:14:23 edward 20 19
c Off screen windows!!!!!!
e
s 00015/00015/00165
d D 3.10 83/08/31 19:51:07 edward 19 18
c moving windows
e
s 00015/00009/00165
d D 3.9 83/08/26 16:24:40 edward 18 17
c error reporting
e
s 00003/00014/00171
d D 3.8 83/08/26 13:15:53 edward 17 16
c use wwmoveup() to move windows to the front.
e
s 00003/00003/00182
d D 3.7 83/08/25 17:57:00 edward 16 15
c added user setable buffer size.
e
s 00001/00000/00184
d D 3.6 83/08/19 15:04:43 edward 15 14
c fake cursor
e
s 00002/00000/00182
d D 3.5 83/08/18 18:34:02 edward 14 13
c refresh before fork in openwin
e
s 00012/00012/00170
d D 3.4 83/08/18 17:17:50 edward 13 12
c the box
e
s 00001/00001/00181
d D 3.3 83/08/18 15:29:34 edward 12 11
c scrolling has come
e
s 00002/00003/00180
d D 3.2 83/08/12 18:33:17 edward 11 10
c faster and better frames
e
s 00000/00004/00183
d D 3.1 83/08/11 17:21:35 edward 10 8
i 9
c last few day's work
e
s 00047/00051/00140
d D 2.1.1.1 83/08/09 18:34:47 edward 9 8
c mile stone
e
s 00000/00000/00191
d D 2.1 83/07/30 13:25:53 edward 8 7
c prepare for major change
e
s 00002/00002/00189
d D 1.7 83/07/29 17:11:12 edward 7 6
c shell name from the environment
e
s 00021/00010/00170
d D 1.6 83/07/28 18:31:58 edward 6 5
c terse mode and some new commands.
c also, the : business.
e
s 00001/00001/00179
d D 1.5 83/07/28 13:26:32 edward 5 4
c labelwin() changed
e
s 00024/00015/00156
d D 1.4 83/07/22 17:08:46 edward 4 3
c scrolling.
c uses Wscreensize() to get screen size.
c More intelligent framing.
c etc.
e
s 00048/00042/00123
d D 1.3 83/07/20 19:30:58 edward 3 2
c Startup configuration stuff, and misc.
e
s 00010/00013/00155
d D 1.2 83/07/19 20:07:49 edward 2 1
c today's work
e
s 00168/00000/00000
d D 1.1 83/07/18 21:05:12 edward 1 0
c date and time created 83/07/18 21:05:12 by edward
e
u
U
f b 
t
T
I 1
D 42
#ifndef lint
D 36
static	char *sccsid = "%W% %E%";
E 36
I 36
static char sccsid[] = "%W% %G%";
E 36
#endif

E 42
I 39
/*
D 42
 * Copyright (c) 1983 Regents of the University of California,
 * All rights reserved.  Redistribution permitted subject to
 * the terms of the Berkeley Software License Agreement.
E 42
I 42
D 47
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
E 47
I 47
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
E 47
 *
I 46
 * This code is derived from software contributed to Berkeley by
 * Edward Wang at The University of California, Berkeley.
 *
E 46
D 45
 * Redistribution and use in source and binary forms are permitted
D 43
 * provided that this notice is preserved and that due credit is given
 * to the University of California at Berkeley. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
E 43
I 43
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 45
I 45
 * %sccs.include.redist.c%
E 45
E 43
E 42
 */
I 42

#ifndef lint
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* not lint */
E 42

E 39
#include "defs.h"
I 33
#include "char.h"
E 33

D 3
struct ww *getwin();
struct ww *openwin();
char *strtime();
E 3
I 3
D 9
struct ww *doopen();
E 3

dowindow()
E 9
I 9
c_window()
E 9
{
	int col, row, xcol, xrow;
D 3
	register struct ww *w;
E 3
	int id;
D 3
	char ids[10];
E 3

D 3
	for (id = 1; id < 10; id++)
		ids[id] = 0;
	for (w = wwhead; w; w = w->ww_next)
		ids[w->ww_ident] = 1;
	for (id = 1; id < 10 && ids[id]; id++)
		;
	if (id == 10) {
E 3
I 3
D 18
	if ((id = findid()) < 0) {
E 3
D 6
		wwputs("Too many windows.  ", cmdwin);
E 6
I 6
D 9
		if (terse)
			Ding();
		else
			wwputs("Too many windows.  ", cmdwin);
E 9
I 9
		error("Too many windows.");
E 18
I 18
	if ((id = findid()) < 0)
E 18
E 9
E 6
		return;
D 18
	}
E 18
D 6
	wwputs("Upper left corner: ", cmdwin);
E 6
I 6
	if (!terse)
D 9
		wwputs("Upper left corner: ", cmdwin);
E 9
I 9
D 30
		(void) wwputs("Upper left corner: ", cmdwin);
E 30
I 30
D 38
		wwputs("Upper left corner: ", cmdwin);
E 38
I 38
		wwputs("New window (upper left corner): ", cmdwin);
E 38
E 30
E 9
E 6
	col = 0;
	row = 1;
I 13
	wwadd(boxwin, framewin->ww_back);
E 13
	for (;;) {
I 13
D 19
		wwunbox(boxwin);
E 19
		wwbox(boxwin, row - 1, col - 1, 3, 3);
E 13
		wwsetcursor(row, col);
D 2
		while (bpeekc() < 0) {
			wwflush();
E 2
I 2
D 29
		while (bpeekc() < 0)
E 2
			bread();
E 29
I 29
		while (wwpeekc() < 0)
			wwiomux();
E 29
D 2
		}
E 2
D 9
		switch (getpos(&row, &col, 0, 0)) {
E 9
I 9
D 19
		switch (getpos(&row, &col, 1, 0)) {
E 19
I 19
D 23
		wwunbox(boxwin);
E 23
D 27
		switch (getpos(&row, &col, 1, 0, wwnrow - 1, wwncol - 1)) {
E 27
I 27
		switch (getpos(&row, &col, row > 1, 0,
			wwnrow - 1, wwncol - 1)) {
E 27
E 19
E 9
D 23
		case -1:
E 23
I 23
		case 3:
			wwunbox(boxwin);
E 23
I 9
D 13
			/*
E 9
			WBoxActive = 0;
I 9
			*/
E 13
I 13
D 19
			wwunbox(boxwin);
E 19
			wwdelete(boxwin);
E 13
E 9
D 2
			goto out;
E 2
I 2
D 6
			wwputs("\r\nCancelled.  ", cmdwin);
E 6
I 6
D 23
			if (!terse)
D 9
				wwputs("\r\nCancelled.  ", cmdwin);
E 9
I 9
				(void) wwputs("\r\nCancelled.  ", cmdwin);
E 23
E 9
E 6
			return;
E 2
D 23
		case 1:
E 23
I 23
		case 2:
			wwunbox(boxwin);
E 23
			break;
I 23
		case 1:
			wwunbox(boxwin);
E 23
		case 0:
			continue;
		}
		break;
	}
D 2
	wwprintf(cmdwin, "%d %d.  Upper left corner: ", col, row);
E 2
I 2
D 6
	wwputs("\r\nLower right corner: ", cmdwin);
E 6
I 6
	if (!terse)
D 9
		wwputs("\r\nLower right corner: ", cmdwin);
E 6
E 2
	xcol = col + 1;
	xrow = row + 1;
E 9
I 9
D 30
		(void) wwputs("\r\nLower right corner: ", cmdwin);
E 30
I 30
D 34
		wwputs("\r\nLower right corner: ", cmdwin);
E 34
I 34
D 38
		wwputs("\nLower right corner: ", cmdwin);
E 38
I 38
		wwputs("\nNew window (lower right corner): ", cmdwin);
E 38
E 34
E 30
	xcol = col;
	xrow = row;
E 9
	for (;;) {
I 9
D 13
		/*
E 9
		Wbox(col, row, xcol - col + 1, xrow - row + 1);
I 9
		*/
E 13
I 13
D 19
		wwunbox(boxwin);
E 19
		wwbox(boxwin, row - 1, col - 1,
			xrow - row + 3, xcol - col + 3);
E 13
E 9
		wwsetcursor(xrow, xcol);
D 44
		wwflush();
E 44
D 2
		while (bpeekc() < 0) {
			wwflush();
E 2
I 2
D 29
		while (bpeekc() < 0)
E 2
			bread();
E 29
I 29
		while (wwpeekc() < 0)
			wwiomux();
E 29
D 2
		}
E 2
D 9
		switch (getpos(&xrow, &xcol, row + 1, col + 1)) {
E 9
I 9
D 19
		switch (getpos(&xrow, &xcol, row, col)) {
E 19
I 19
D 23
		wwunbox(boxwin);
E 23
		switch (getpos(&xrow, &xcol, row, col, wwnrow - 1, wwncol - 1))
		{
E 19
E 9
D 23
		case -1:
E 23
I 23
		case 3:
			wwunbox(boxwin);
E 23
I 9
D 13
			/*
E 9
			WBoxActive = 0;
I 9
			*/
E 13
I 13
D 19
			wwunbox(boxwin);
E 19
			wwdelete(boxwin);
E 13
E 9
D 2
			goto out;
E 2
I 2
D 6
			wwputs("\r\nCancelled.  ", cmdwin);
E 6
I 6
D 23
			if (!terse)
D 9
				wwputs("\r\nCancelled.  ", cmdwin);
E 9
I 9
				(void) wwputs("\r\nCancelled.  ", cmdwin);
E 23
E 9
E 6
			return;
E 2
D 23
		case 1:
E 23
I 23
		case 2:
			wwunbox(boxwin);
E 23
			break;
I 23
		case 1:
			wwunbox(boxwin);
E 23
		case 0:
			continue;
		}
		break;
	}
I 9
D 13
	/*
E 9
	WBoxActive = 0;
I 9
	*/
E 13
I 13
D 19
	wwunbox(boxwin);
E 19
	wwdelete(boxwin);
E 13
E 9
D 2
	wwprintf(cmdwin, "%d %d.  ", xcol, xrow);
E 2
I 2
D 6
	wwputs("\r\n", cmdwin);
E 6
I 6
	if (!terse)
D 9
		wwputs("\r\n", cmdwin);
E 6
E 2
D 3
	if ((w = wwopen(WW_PTY, id, xrow-row+1, xcol-col+1, row, col)) == 0) {
E 3
I 3
	wwsetcursor(WCurRow(cmdwin->ww_win), WCurCol(cmdwin->ww_win));
	if (doopen(id, xrow-row+1, xcol-col+1, row, col) == 0)
E 3
D 2
		wwprintf(cmdwin, "Can't open window.  ");
E 2
I 2
D 6
		wwputs("Can't open window.  ", cmdwin);
E 6
I 6
		if (terse)
			Ding();
		else
			wwputs("Can't open window.  ", cmdwin);
E 9
I 9
D 30
		(void) wwputs("\r\n", cmdwin);
E 30
I 30
D 34
		wwputs("\r\n", cmdwin);
E 34
I 34
		wwputc('\n', cmdwin);
E 34
E 30
	wwcurtowin(cmdwin);
D 16
	if (openwin(id, xrow-row+1, xcol-col+1, row, col) == 0)
E 16
I 16
D 18
	if (openwin(id, row, col, xrow-row+1, xcol-col+1, nbufline) == 0)
E 16
		error("Can't open window.");
E 18
I 18
D 22
	(void) openwin(id, row, col, xrow-row+1, xcol-col+1, nbufline);
E 22
I 22
D 44
	(void) openwin(id, row, col, xrow-row+1, xcol-col+1, nbufline,
D 35
		(char *) 0);
E 35
I 35
		(char *) 0, 1, 1, shellfile, shell);
E 44
I 44
	(void) openwin(id, row, col, xrow-row+1, xcol-col+1, default_nline,
		(char *) 0, 1, 1, default_shellfile, default_shell);
E 44
E 35
E 22
E 18
E 9
E 6
E 2
D 3
		return;
E 3
I 3
}

D 28
findid()
{
D 9
	register id;
	char ids[10];
	register struct ww *w;
E 9
I 9
	register i;
E 9
D 6
#define NWINDOW 9
E 6

D 9
	for (id = 1; id <= NWINDOW; id++)
		ids[id] = 0;
	for (w = wwhead; w; w = w->ww_next) {
		if (w->ww_ident < 1 || w->ww_ident > NWINDOW)
			continue;
		ids[w->ww_ident]++;
E 3
	}
D 3
	wwframe(w);
	labelwin(w, 0);
	/*
	reframe();
	*/
	wwsetcursor(WCurRow(w->ww_win), WCurCol(w->ww_win));
	wwflush();
	switch (wwfork(w)) {
	case -1:
		wwprintf(cmdwin, "Can't fork.  ");
		wwclose(w);
		return;
	case 0:
		execl("/bin/csh", "csh", 0);
		perror("exec(csh)");
		exit(1);
	}
	if (selwin == 0)
		setselwin(w);
	else
		wwsetcurrent(cmdwin);
E 3
I 3
	for (id = 1; id <= NWINDOW && ids[id]; id++)
E 9
I 9
	for (i = 0; i < NWINDOW && window[i] != 0; i++)
E 9
		;
D 9
	return id < 10 ? id : -1;
E 9
I 9
D 18
	return i < NWINDOW ? i : -1;
E 18
I 18
	if (i >= NWINDOW) {
		error("Too many windows.");
		return -1;
	}
	return i;
E 18
E 9
E 3
D 2
out:
	wwputs("\r\n", cmdwin);
E 2
}

E 28
D 19
getpos(row, col, minrow, mincol)
register int *row, *col, minrow, mincol;
E 19
I 19
getpos(row, col, minrow, mincol, maxrow, maxcol)
register int *row, *col;
int minrow, mincol;
int maxrow, maxcol;
E 19
{
D 32
	static int scount = 0;
E 32
I 32
	static int scount;
E 32
	int count;
	char c;
I 23
	int oldrow = *row, oldcol = *col;
E 23

D 29
	while ((c = bgetc()) >= 0) {
E 29
I 29
	while ((c = wwgetc()) >= 0) {
E 29
		switch (c) {
		case '0': case '1': case '2': case '3': case '4':
		case '5': case '6': case '7': case '8': case '9':
			scount = scount * 10 + c - '0';
			continue;
		}
		count = scount ? scount : 1;
		scount = 0;
		switch (c) {
		case 'h':
			if ((*col -= count) < mincol)
				*col = mincol;
			break;
		case 'H':
			*col = mincol;
			break;
		case 'l':
D 4
			if ((*col += count) >= WCols)
				*col = WCols - 1;
E 4
I 4
D 19
			if ((*col += count) >= wwncol)
				*col = wwncol - 1;
E 19
I 19
			if ((*col += count) > maxcol)
				*col = maxcol;
E 19
E 4
			break;
		case 'L':
D 4
			*col = WCols - 1;
E 4
I 4
D 19
			*col = wwncol - 1;
E 19
I 19
			*col = maxcol;
E 19
E 4
			break;
		case 'j':
D 4
			if ((*row += count) >= WRows)
				*row = WRows - 1;
E 4
I 4
D 19
			if ((*row += count) >= wwnrow)
				*row = wwnrow - 1;
E 19
I 19
			if ((*row += count) > maxrow)
				*row = maxrow;
E 19
E 4
			break;
		case 'J':
D 4
			*row = WRows - 1;
E 4
I 4
D 19
			*row = wwnrow - 1;
E 19
I 19
			*row = maxrow;
E 19
E 4
			break;
		case 'k':
			if ((*row -= count) < minrow)
				*row = minrow;
			break;
		case 'K':
			*row = minrow;
			break;
D 33
		case CTRL([):
E 33
I 33
D 41
		case ctrl([):
E 41
I 41
		case ctrl('['):
E 41
E 33
D 23
			return -1;
E 23
I 23
			if (!terse)
D 30
				(void) wwputs("\r\nCancelled.  ", cmdwin);
E 30
I 30
D 34
				wwputs("\r\nCancelled.  ", cmdwin);
E 34
I 34
D 37
				wwputs("\nCancelled.  ", cmdwin);
E 37
I 37
D 40
				wwputs("\nCanceled.  ", cmdwin);
E 40
I 40
				wwputs("\nCancelled.  ", cmdwin);
E 40
E 37
E 34
E 30
			return 3;
E 23
		case '\r':
D 23
			return 1;
E 23
I 23
			return 2;
E 23
		default:
I 2
D 6
			wwputs("\r\nType [hjklHJKL] to move, return to enter position, escape to cancel.", cmdwin);
E 6
I 6
			if (!terse)
D 9
				wwputs("\r\nType [hjklHJKL] to move, return to enter position, escape to cancel.", cmdwin);
E 6
E 2
			Ding();
E 9
I 9
D 30
				(void) wwputs("\r\nType [hjklHJKL] to move, return to enter position, escape to cancel.", cmdwin);
			wwbell();
E 30
I 30
D 34
				wwputs("\r\nType [hjklHJKL] to move, return to enter position, escape to cancel.", cmdwin);
E 34
I 34
				wwputs("\nType [hjklHJKL] to move, return to enter position, escape to cancel.", cmdwin);
E 34
D 33
			wwputc(CTRL(g), cmdwin);
E 33
I 33
D 35
			wwputc(ctrl(g), cmdwin);
E 35
I 35
			wwbell();
E 35
E 33
E 30
E 9
		}
	}
D 23
	return 0;
E 23
I 23
	return oldrow != *row || oldcol != *col;
E 23
D 28
}

D 3
/*
reframe()
E 3
I 3
struct ww *
D 9
doopen(id, nrow, ncol, row, col)
E 9
I 9
D 16
openwin(id, nrow, ncol, row, col)
E 16
I 16
D 22
openwin(id, row, col, nrow, ncol, nline)
E 22
I 22
openwin(id, row, col, nrow, ncol, nline, label)
E 22
E 16
E 9
int id, nrow, ncol, row, col;
I 22
char *label;
E 22
E 3
{
	register struct ww *w;

I 9
D 18
	if (row <= 0)
		return 0;
E 18
E 9
D 3
	for (w = wwhead; w; w = w->ww_next) {
		wwunframe(w);
		wwframe(w);
		labelwin(w, selwin == w ? WINVERSE : 0);
E 3
I 3
	if (id < 0 && (id = findid()) < 0)
		return 0;
D 9
	if ((w = wwopen(WW_PTY, id, nrow, ncol, row, col)) == 0)
E 9
I 9
D 12
	if ((w = wwopen(WWO_PTY, nrow, ncol, row, col, 0)) == 0)
E 12
I 12
D 16
	if ((w = wwopen(WWO_PTY, nrow, ncol, row, col, 48)) == 0)
E 16
I 16
D 18
	if ((w = wwopen(WWO_PTY, nrow, ncol, row, col, nline)) == 0)
E 18
I 18
D 20
	if (row <= 0) {
		error("Bad row number.");
E 20
I 20
	if (row + nrow <= 0 || row > wwnrow - 1
	    || col + ncol <= 0 || col > wwncol - 1) {
D 21
		error("Illegal window size or position.");
E 21
I 21
		error("Illegal window position.");
E 21
E 20
E 18
E 16
E 12
E 9
		return 0;
I 18
	}
	if ((w = wwopen(WWO_PTY, nrow, ncol, row, col, nline)) == 0) {
		error("%s.", wwerror());
		return 0;
	}
E 18
D 4
	wwframe(w);
	labelwin(w, 0);
	/*
E 4
D 9
	reframe();
D 4
	*/
E 4
I 4
	if (selwin == 0)
		setselwin(w);
	else
		wwsetcurwin(cmdwin);
E 9
I 9
	w->ww_id = id;
	window[id] = w;
	w->ww_hasframe = 1;
I 21
	w->ww_altpos.r = 1;
	w->ww_altpos.c = 0;
I 22
	if (label != 0 && setlabel(w, label) < 0)
		error("No memory for label.");
E 22
E 21
I 15
	wwcursor(w, 1);
E 15
D 17
	wwadd(w, (selwin ? selwin : wwhead.ww_back));
	setselwin(w);
E 17
I 17
	wwadd(w, framewin);
	selwin = w;
D 23
	reframe();			/* setselwin() won't do it */
E 23
I 23
	reframe();
E 23
E 17
I 14
	wwupdate();
	wwflush();
E 14
D 10
	/*
	wwupdate();
E 9
E 4
	wwflush();
I 9
	*/
E 10
E 9
D 24
	switch (wwfork(w)) {
	case -1:
E 24
I 24
	if (wwspawn(w, shell, shellname, (char *)0) < 0) {
E 24
D 4
		wwclose(w);
E 4
I 4
D 6
		doclose(CLOSE_ONE, w);
E 6
I 6
D 9
		doclose(w);
E 9
I 9
		c_close(w);
I 18
D 26
		error("%s.", wwerror());
E 26
I 26
		error("%s: %s.", shell, wwerror());
E 26
E 18
E 9
E 6
E 4
		return 0;
D 24
	case 0:
D 7
		execl("/bin/csh", "csh", 0);
		perror("exec(csh)");
E 7
I 7
		execl(shell, shellname, 0);
		perror(shell);
E 7
		exit(1);
E 24
E 3
	}
I 3
D 4
	if (selwin == 0)
		setselwin(w);
	else
		wwsetcurwin(cmdwin);
E 4
	return w;
E 28
I 4
D 17
}

reframe()
{
	register struct ww *w;

D 9
	for (w = wwhead; w; w = w->ww_next) {
		if (w == cmdwin)
			continue;
		wwunframe(w);
		wwframe(w);
D 5
		labelwin(w, w == selwin ? WINVERSE : 0);
E 5
I 5
		labelwin(w);
E 5
	}
E 9
I 9
	wwunframe(framewin);
	for (w = wwhead.ww_back; w != &wwhead; w = w->ww_back)
D 11
		if (w->ww_hasframe)
E 11
I 11
		if (w->ww_hasframe) {
E 11
			wwframe(w, framewin);
D 11
	for (w = wwhead.ww_back; w != &wwhead; w = w->ww_back)
		if (w->ww_hasframe)
E 11
			labelwin(w);
I 11
		}
E 17
E 11
E 9
E 4
E 3
}
D 3
*/
E 3
E 1
