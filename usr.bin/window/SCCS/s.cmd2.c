h65513
s 00002/00002/00126
d D 8.1 93/06/06 22:27:53 bostic 54 53
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00002/00000/00126
d D 3.41 93/02/01 11:27:13 edward 53 52
c documentation for yank and put (y and p commands)
e
s 00003/00000/00123
d D 3.40 90/06/06 21:43:22 bostic 52 51
c fix contrib notice (Edward Wang)
e
s 00001/00011/00122
d D 3.39 90/06/02 15:19:06 bostic 51 50
c new copyright notice
e
s 00001/00001/00132
d D 3.38 88/08/05 14:13:46 edward 50 49
c alphabetical order in help messages
e
s 00004/00002/00129
d D 3.37 88/08/04 18:09:12 edward 49 48
c use clreos and always try clreol in wwupdate1
e
s 00010/00005/00121
d D 3.36 88/06/29 21:35:34 bostic 48 47
c install approved copyright notice
e
s 00013/00007/00113
d D 3.35 88/02/21 13:36:39 bostic 47 46
c written by Edward Wang; attach Berkeley specific copyright
e
s 00002/00001/00118
d D 3.34 87/05/18 12:20:27 edward 46 45
c added keepopen and smooth flags, added + and - window selections
e
s 00006/00000/00113
d D 3.33 85/04/24 16:12:56 edward 45 44
c copyright messages
e
s 00048/00040/00065
d D 3.32 85/04/22 01:36:35 edward 44 43
c help updated
e
s 00023/00020/00082
d D 3.31 85/03/01 17:47:59 edward 43 42
c new stuff for the help command
e
s 00001/00001/00101
d D 3.30 84/05/23 01:56:56 edward 42 41
c new sccs id
e
s 00003/00002/00099
d D 3.29 84/04/08 19:22:57 edward 41 40
c new options to "window": shell, pty, frame
c and stuff to support them
e
s 00001/00001/00100
d D 3.28 84/04/08 12:34:28 edward 40 39
c set ww_mapnl for cmdwin
e
s 00002/00002/00099
d D 3.27 84/04/08 12:08:19 edward 39 38
c control character expansion in wwwrite()
c calling of wwupdate() in wwwrite() dependent of ww_noupdate
c control character handling macros in char.h
e
s 00012/00042/00089
d D 3.26 84/04/07 00:02:11 edward 38 37
c l_variable and l_list added
e
s 00000/00101/00131
d D 3.25 84/04/05 17:32:19 edward 37 36
c "s," "t," and "T" moved to long commands (iostat, time).
c "S" removed.
e
s 00004/00004/00228
d D 3.24 84/04/05 00:31:42 edward 36 35
c -c flag, incmd, setcmd(), setterse() added
e
s 00036/00030/00196
d D 3.23 84/03/03 22:43:58 edward 35 34
c interrupt driven input
e
s 00015/00009/00211
d D 3.22 84/01/16 15:25:49 edward 34 33
c new io scheme
e
s 00001/00061/00219
d D 3.21 84/01/13 11:54:05 edward 33 32
c {open,close}{i,}win() moved to win.c
e
s 00037/00027/00243
d D 3.20 84/01/13 11:08:48 edward 32 31
c more() and waitnl() reworked.
e
s 00001/00004/00269
d D 3.19 84/01/12 12:04:21 edward 31 30
c arguments to more() changed
e
s 00001/00000/00272
d D 3.18 84/01/12 11:56:39 edward 30 29
c help entry for unset
e
s 00012/00000/00260
d D 3.17 84/01/11 17:08:32 edward 29 28
c more() added
e
s 00082/00048/00178
d D 3.16 83/12/06 12:53:07 edward 28 27
c c_help() update, and waitnl() cleanup
e
s 00001/00001/00225
d D 3.15 83/12/02 23:38:32 edward 27 26
c front() must reframe() when called from setselwin()
e
s 00007/00005/00219
d D 3.14 83/12/02 22:45:03 edward 26 25
c WWU_MAJOR, clreol in wwupdate(), and more optimizations.
e
s 00002/00000/00222
d D 3.13 83/11/02 11:07:14 edward 25 24
c flags for different machines.
e
s 00000/00001/00222
d D 3.12 83/09/14 14:54:56 edward 24 23
c lint
e
s 00011/00007/00212
d D 3.11 83/09/01 18:34:46 edward 23 22
c Got rid of 'curwin'.
c and now knows about dead processes.
e
s 00004/00006/00215
d D 3.10 83/08/26 16:25:37 edward 22 21
c error reporting
e
s 00001/00005/00220
d D 3.9 83/08/26 13:15:58 edward 21 20
c use wwmoveup() to move windows to the front.
e
s 00011/00010/00214
d D 3.8 83/08/25 17:58:09 edward 20 19
c help updated for 'buffer' and new argument to 'window'
e
s 00014/00011/00210
d D 3.7 83/08/22 13:07:36 edward 19 18
c updated c_help()
e
s 00002/00002/00219
d D 3.6 83/08/16 15:24:07 edward 18 17
c window sizes tweeked
e
s 00001/00001/00220
d D 3.5 83/08/16 12:52:34 edward 17 16
c spelling
e
s 00036/00038/00185
d D 3.4 83/08/16 12:31:55 edward 16 15
c changed \r\n to \n and some new stats
e
s 00004/00003/00219
d D 3.3 83/08/16 11:43:11 edward 15 14
c ntouched and nmiss added to c_stat
e
s 00001/00001/00221
d D 3.2 83/08/12 18:30:20 edward 14 13
c c_list() bug (MAX instead of MIN)
e
s 00000/00000/00222
d D 3.1 83/08/11 17:21:49 edward 13 11
i 12
c last few day's work
e
s 00111/00105/00111
d D 2.1.1.1 83/08/09 18:35:04 edward 12 11
c mile stone
e
s 00000/00000/00216
d D 2.1 83/07/30 13:25:56 edward 11 10
c prepare for major change
e
s 00002/00001/00214
d D 1.10 83/07/29 17:47:53 edward 10 9
c update dohelp
e
s 00001/00001/00214
d D 1.9 83/07/28 18:48:24 edward 9 8
c %% needed
e
s 00067/00020/00148
d D 1.8 83/07/28 18:32:06 edward 8 7
c terse mode and some new commands.
c also, the : business.
e
s 00004/00005/00164
d D 1.7 83/07/28 15:59:10 edward 7 6
c update dohelp(), and center the label in openwin().
e
s 00004/00002/00165
d D 1.6 83/07/27 14:33:28 edward 6 5
c io statistics
e
s 00022/00017/00145
d D 1.5 83/07/26 14:11:49 edward 5 4
c dohelp() updated and doquit() prompts with [yn]?
e
s 00015/00002/00147
d D 1.4 83/07/22 17:09:19 edward 4 3
c scrolling.
c uses Wscreensize() to get screen size.
c More intelligent framing.
c etc.
e
s 00039/00023/00110
d D 1.3 83/07/20 19:31:09 edward 3 2
c Startup configuration stuff, and misc.
e
s 00014/00007/00119
d D 1.2 83/07/19 20:07:55 edward 2 1
c today's work
e
s 00126/00000/00000
d D 1.1 83/07/18 21:05:13 edward 1 0
c date and time created 83/07/18 21:05:13 by edward
e
u
U
f b 
t
T
I 1
D 47
#ifndef lint
D 42
static	char *sccsid = "%W% %E%";
E 42
I 42
static char sccsid[] = "%W% %G%";
E 42
#endif

E 47
I 45
/*
D 47
 * Copyright (c) 1983 Regents of the University of California,
 * All rights reserved.  Redistribution permitted subject to
 * the terms of the Berkeley Software License Agreement.
E 47
I 47
D 54
 * Copyright (c) 1983 Regents of the University of California.
 * All rights reserved.
E 54
I 54
 * Copyright (c) 1983, 1993
 *	The Regents of the University of California.  All rights reserved.
E 54
 *
I 52
 * This code is derived from software contributed to Berkeley by
 * Edward Wang at The University of California, Berkeley.
 *
E 52
D 51
 * Redistribution and use in source and binary forms are permitted
D 48
 * provided that this notice is preserved and that due credit is given
 * to the University of California at Berkeley. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
E 48
I 48
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 51
I 51
 * %sccs.include.redist.c%
E 51
E 48
E 47
 */
I 47

#ifndef lint
static char sccsid[] = "%W% (Berkeley) %G%";
#endif /* not lint */
E 47

E 45
#include "defs.h"

I 28
char *help_shortcmd[] = {
D 43
	"{1-9}   Select window {1-9} and return to conversation mode.",
	"%{1-9}  Select window {1-9} but stay in command mode.",
E 43
I 43
D 44
	"#       Select window # and return to conversation mode.",
	"%#      Select window # but stay in command mode.",
E 43
D 38
	"escape  Return to conversation mode",
	"        and don't change the current window.",
	"^^      Return to conversation mode",
	"        and change to previously selected window.",
E 38
I 38
	"escape  Return to conversation mode without changing window.",
	"^^      Return to conversation mode and change to previous window.",
E 38
D 43
	"c{1-9}  Close window {1-9}.",
E 43
I 43
	"c#      Close window #.",
E 43
D 38
	"C       Close all windows.",
	"S       Show all windows in sequence.",
	"L       List all windows with their labels.",
E 38
	"w       Open a new window.",
D 43
	"m{1-9}  Move window {1-9}.",
	"M{1-9}  Move window {1-9} to previous position.",
D 38
	"v       List all variables.",
E 38
	"{^Y^E}  Scroll {up, down} one line",
	"{^U^D}  Scroll {up, down} half a window.",
	"{^B^F}  Scroll {up, down} a full window.",
	"{hjkl}  Move cursor {left, down, up, right}.",
E 43
I 43
	"m#      Move window #.",
	"M#      Move window # to its previous position.",
	"s#      Change the size of window #.",
	"S#      Change window # to its previous size.",
	"^Y,^E   Scroll up, down one line.",
	"^U,^D   Scroll up, down half a window.",
	"^B,^F   Scroll up, down a full window.",
	"h,j,k,l Move cursor left, down, up, right.",
	"^S,^Q   Stop, start output in current window.",
E 43
	"^L      Redraw screen.",
	"^Z      Suspend.",
	"q       Quit.",
I 43
	":       Enter a long command.",
E 44
I 44
	"#       Select window # and return to conversation mode",
	"%#      Select window # but stay in command mode",
	"escape  Return to conversation mode without changing window",
	"^^      Return to conversation mode and change to previous window",
	"c#      Close window #",
	"w       Open a new window",
	"m#      Move window #",
	"M#      Move window # to its previous position",
	"s#      Change the size of window #",
	"S#      Change window # to its previous size",
	"^Y      Scroll up one line",
	"^E      Scroll down one line",
	"^U      Scroll up half a window",
	"^D      Scroll down half a window",
	"^B      Scroll up a full window",
	"^F      Scroll down a full window",
	"h       Move cursor left",
	"j       Move cursor down",
	"k       Move cursor up",
	"l       Move cursor right",
I 53
	"y       Yank",
	"p       Put",
E 53
	"^S      Stop output in current window",
	"^Q      Restart output in current window",
	"^L      Redraw screen",
	"^Z      Suspend",
	"q       Quit",
	":       Enter a long command",
E 44
E 43
	0
};
char *help_longcmd[] = {
D 43
	":%{1-9}               Select window {1-9}.",
D 38
	":buffer lines         Set the default window buffer size.",
	":close {1-9}          Close window.",
E 38
I 38
	":close {1-9} . . .    Close windows.",
E 43
I 43
D 44
	":%#                   Select window #.",
	":close # . . .        Close windows.",
E 43
	":close all            Close all windows.",
E 38
	":cursor modes         Set the cursor modes.",
I 43
	":echo # string . . .  Print ``string . . .'' in window #.",
E 43
	":escape C             Set escape character to C.",
I 38
D 43
	":foreground {1-9} [off]",
	"                      Make {1-9} a foreground window.",
E 38
	":label {1-9} string   Label window {1-9}.",
I 38
	":list                 List all windows.",
E 43
I 43
	":foreground # [off]   Make # a foreground window.",
	":label # string       Set label of window # to ``string''.",
	":list                 Give a list of all windows.",
E 43
	":nline lines          Set the default number of lines",
	"                      in window text buffers.",
E 38
D 41
	":source filename      Execute commands in ``filename''.",
E 41
I 41
D 43
	":shell string         Set default shell program to ``string.''",
E 43
I 43
	":shell string . . .   Set default shell program to ``string . . .''",
E 43
	":source filename      Execute commands in ``filename.''",
E 41
	":terse [off]          Turn on (or off) terse mode.",
I 30
	":unset variable       Deallocate ``variable''.",
I 38
	":variable             List all variables.",
E 44
I 44
	":alias name string ...  Make `name' an alias for `string ...'",
	":alias                  Show all aliases",
	":close # ...            Close windows",
	":close all              Close all windows",
	":cursor modes           Set the cursor modes",
	":echo # string ...      Print `string ...' in window #",
	":escape c               Set escape character to `c'",
	":foreground # flag      Make # a foreground window, if `flag' is true",
	":label # string         Set label of window # to `string'",
	":list                   List all open windows",
D 49
	":nline lines            Set default window buffer size to `lines'",
E 49
I 49
	":default_nline lines    Set default window buffer size to `lines'",
D 50
	":default_smooth flag    Set default smooth scroll flag",
E 50
	":default_shell string ...",
	"                        Set default shell to `string ...'",
I 50
	":default_smooth flag    Set default smooth scroll flag",
E 50
E 49
	":select #               Select window #",
D 49
	":shell string ...       Set default shell program to `string ...'",
E 49
I 46
	":smooth # flag          Set window # to smooth scroll mode",
E 46
	":source filename        Execute commands in `filename'",
	":terse flag             Set terse mode",
	":unalias name           Undefine `name' as an alias",
	":unset variable         Deallocate `variable'",
	":variable               List all variables",
E 44
E 38
E 30
D 41
	":window row col nrow ncol [nline label]",
E 41
I 41
D 46
	":window row col nrow ncol [nline label pty frame shell]",
E 46
I 46
	":window [row col nrow ncol nline label pty frame mapnl keepopen smooth shell]",
E 46
E 41
D 44
	"                      Open a window at ``row'', ``col''",
	"                      of size ``nrow'', ``ncol'',",
	"                      with ``nline'', and ``label''.",
D 38
	":write {1-9} string   Write ``string'' to window {1-9}.",
E 38
I 38
D 43
	":write {1-9} string . . .",
	"                      Write strings to window {1-9}.",
E 43
I 43
	":write # string . . . Write ``string . . .'' to window #.",
E 44
I 44
	"                        Open a window at `row', `col' of size `nrow', `ncol',",
	"                        with `nline' lines in the buffer, and `label'",
	":write # string ...     Write `string ...' to window # as input",
E 44
E 43
E 38
	0
};

E 28
D 12
struct ww *getwin();
struct ww *openwin();
char *strtime();
E 12
I 12
D 22
struct ww *openiwin();
E 12

E 22
D 12
dohelp()
E 12
I 12
c_help()
E 12
{
	register struct ww *w;

D 2
	if ((w = openwin(20, "Help")) == 0)
E 2
I 2
D 3
	if ((w = openwin(22, "Help")) == 0)
E 3
I 3
D 7
	if ((w = openwin(22, "Help")) == 0) {
E 7
I 7
D 8
	if ((w = openwin(wwncol - 1, "Help")) == 0) {
E 7
		wwputs("Can't open help window.  ", cmdwin);
E 8
I 8
D 12
	if ((w = openwin(wwnrow - 1, "Help")) == 0) {
		if (terse)
			Ding();
		else
			wwputs("Can't open help window.  ", cmdwin);
E 12
I 12
D 18
	if ((w = openiwin(wwnrow - 2, "Help")) == 0) {
E 18
I 18
	if ((w = openiwin(wwnrow - 3, "Help")) == 0) {
E 18
D 22
		error("Can't open help window.");
E 22
I 22
		error("Can't open help window: %s.", wwerror());
E 22
E 12
E 8
E 3
E 2
		return;
I 3
	}
E 3
D 8
	wwprintf(w, "The escape character is ^P, which gets you into command mode.\r\n");
	wwprintf(w, "The commands are:\r\n");
D 2
	wwprintf(w, "%%[1-9]  select window [1-9]\r\n");
E 2
D 3
	wwprintf(w, "[1-9]   select window [1-9] and exit command mode\r\n");
I 2
	wwprintf(w, "%%[1-9]  select window [1-9]\r\n");
E 2
	wwprintf(w, "c[1-9]  close window [1-9]\r\n");
	wwprintf(w, "C       close all empty windows\r\n");
I 2
	wwprintf(w, "Z       close all windows\r\n");
	wwprintf(w, "Q       show all windows in sequence\r\n");
E 2
	wwprintf(w, "R       force refresh after every newline in current window\r\n");
	wwprintf(w, "r       don't refresh every line\r\n");
	wwprintf(w, "w       open a new window\r\n");
	wwprintf(w, "s       print IO statistics\r\n");
	wwprintf(w, "t       print resource usage of this program\r\n");
	wwprintf(w, "T       print resource usage of children\r\n");
	wwprintf(w, "escape  exit command mode\r\n");
	wwprintf(w, "^L      redraw screen\r\n");
	wwprintf(w, "^Z      suspend\r\n");
	wwprintf(w, ".       quit\r\n");
E 3
I 3
D 5
	wwprintf(w, "[1-9]   Select window [1-9] and exit command mode\r\n");
	wwprintf(w, "%%[1-9]  Select window [1-9]\r\n");
	wwprintf(w, "c[1-9]  Close window [1-9]\r\n");
	wwprintf(w, "C       Close all empty windows\r\n");
	wwprintf(w, "Z       Close all windows\r\n");
	wwprintf(w, "Q       Show all windows in sequence\r\n");
	wwprintf(w, "R       Force refresh after every newline in current window\r\n");
	wwprintf(w, "r       Don't refresh every line\r\n");
	wwprintf(w, "w       Open a new window\r\n");
	wwprintf(w, "s       Print IO statistics\r\n");
	wwprintf(w, "t       Print resource usage of this program\r\n");
	wwprintf(w, "T       Print resource usage of children\r\n");
	wwprintf(w, "escape  Exit command mode\r\n");
	wwprintf(w, "^L      Redraw screen\r\n");
	wwprintf(w, "^Z      Suspend\r\n");
	wwprintf(w, ".       Quit\r\n");
E 5
I 5
	wwprintf(w, "[1-9]   Select window [1-9] and exit command mode.\r\n");
	wwprintf(w, "%%[1-9]  Select window [1-9].\r\n");
	wwprintf(w, "c[1-9]  Close window [1-9].\r\n");
E 8
I 8
D 12
	wwprintf(w, "The escape character is %s, which gets you into command mode.\r\n\n",
E 12
I 12
D 16
	(void) wwprintf(w, "The escape character is %s, which gets you into command mode.\r\n\n",
E 16
I 16
D 35
	(void) wwprintf(w, "The escape character is %s, which gets you into command mode.\n\n",
E 35
I 35
D 39
	wwprintf(w, "The escape character is %s, which gets you into command mode.\n\n",
E 35
E 16
E 12
		unctrl(escapec));
E 39
I 39
D 43
	wwprintf(w, "The escape character is %c, which gets you into command mode.\n\n",
		escapec);
E 43
I 43
	wwprintf(w, "The escape character is %c.\n", escapec);
D 44
	wwprintf(w, "(Below, # is one of the digits from 1 to 9.)\n\n");
E 44
I 44
	wwprintf(w, "(# represents one of the digits from 1 to 9.)\n\n");
E 44
E 43
E 39
D 12
	wwprintf(w, "Short commands:\r\n\n");
	wwprintf(w, "{1-9}   Select window {1-9} and return to conversation mode.\r\n");
	wwprintf(w, "%%{1-9}  Select window {1-9}.\r\n");
	wwprintf(w, "c{1-9}  Close window {1-9}.\r\n");
E 8
D 7
	wwprintf(w, "C       Close all empty windows.\r\n");
	wwprintf(w, "Z       Close all windows.\r\n");
	wwprintf(w, "Q       Show all windows in sequence.\r\n");
E 7
I 7
	wwprintf(w, "C       Close all windows.\r\n");
	wwprintf(w, "S       Show all windows in sequence.\r\n");
E 7
D 8
	wwprintf(w, "R       Force refresh after every newline (current window only).\r\n");
	wwprintf(w, "r       Don't refresh every line.\r\n");
E 8
I 8
	wwprintf(w, "L       List all windows with their labels.\r\n");
E 8
	wwprintf(w, "w       Open a new window.\r\n");
D 8
	wwprintf(w, "^U      Scroll up.\r\n");
	wwprintf(w, "^D      Scroll down.\r\n");
E 8
I 8
	wwprintf(w, "[^U^D]  Scroll [up, down] half a window.\r\n");
	wwprintf(w, "[^B^F]  Scroll [up, down] a full window.\r\n");
E 8
	wwprintf(w, "[hjkl]  Move cursor [left, down, up, right].\r\n");
D 8
	/*
	wwprintf(w, "s       Print IO statistics.\r\n");
	wwprintf(w, "t       Print resource usage of this program.\r\n");
	wwprintf(w, "T       Print resource usage of children.\r\n");
	*/
E 8
	wwprintf(w, "escape  Exit command mode.\r\n");
	wwprintf(w, "^L      Redraw screen.\r\n");
	wwprintf(w, "^Z      Suspend.\r\n");
	wwprintf(w, ".       Quit.\r\n");
E 12
I 12
D 16
	(void) wwprintf(w, "Short commands:\r\n\n");
	(void) wwprintf(w, "{1-9}   Select window {1-9} and return to conversation mode.\r\n");
	(void) wwprintf(w, "%%{1-9}  Select window {1-9}.\r\n");
	(void) wwprintf(w, "c{1-9}  Close window {1-9}.\r\n");
	(void) wwprintf(w, "C       Close all windows.\r\n");
	(void) wwprintf(w, "S       Show all windows in sequence.\r\n");
	(void) wwprintf(w, "L       List all windows with their labels.\r\n");
	(void) wwprintf(w, "w       Open a new window.\r\n");
	(void) wwprintf(w, "[^U^D]  Scroll [up, down] half a window.\r\n");
	(void) wwprintf(w, "[^B^F]  Scroll [up, down] a full window.\r\n");
	(void) wwprintf(w, "[hjkl]  Move cursor [left, down, up, right].\r\n");
	(void) wwprintf(w, "escape  Exit command mode.\r\n");
	(void) wwprintf(w, "^L      Redraw screen.\r\n");
	(void) wwprintf(w, "^Z      Suspend.\r\n");
	(void) wwprintf(w, ".       Quit.\r\n");
E 16
I 16
D 28
	(void) wwprintf(w, "Short commands:\n\n");
	(void) wwprintf(w, "{1-9}   Select window {1-9} and return to conversation mode.\n");
D 19
	(void) wwprintf(w, "%%{1-9}  Select window {1-9}.\n");
E 19
I 19
	(void) wwprintf(w, "%%{1-9}  Select window {1-9} but stay in command mode.\n");
	(void) wwprintf(w, "escape  Return to conversation mode and don't change the current window.\n");
E 19
	(void) wwprintf(w, "c{1-9}  Close window {1-9}.\n");
	(void) wwprintf(w, "C       Close all windows.\n");
	(void) wwprintf(w, "S       Show all windows in sequence.\n");
	(void) wwprintf(w, "L       List all windows with their labels.\n");
	(void) wwprintf(w, "w       Open a new window.\n");
D 19
	(void) wwprintf(w, "[^U^D]  Scroll [up, down] half a window.\n");
	(void) wwprintf(w, "[^B^F]  Scroll [up, down] a full window.\n");
	(void) wwprintf(w, "[hjkl]  Move cursor [left, down, up, right].\n");
	(void) wwprintf(w, "escape  Exit command mode.\n");
E 19
I 19
	(void) wwprintf(w, "{^Y^E}  Scroll {up, down} one line\n");
	(void) wwprintf(w, "{^U^D}  Scroll {up, down} half a window.\n");
	(void) wwprintf(w, "{^B^F}  Scroll {up, down} a full window.\n");
	(void) wwprintf(w, "{hjkl}  Move cursor {left, down, up, right}.\n");
E 19
	(void) wwprintf(w, "^L      Redraw screen.\n");
	(void) wwprintf(w, "^Z      Suspend.\n");
D 19
	(void) wwprintf(w, ".       Quit.\n");
E 19
I 19
	(void) wwprintf(w, "q       Quit.\n");
E 19
E 16
E 12
E 5
E 3
I 2
	waitnl(w);
I 8
D 12
	wwprintf(w, "Long commands:\r\n\n");
	wwprintf(w, ":terse [off]            Turn on (or off) terse mode.\r\n");
	wwprintf(w, ":refresh {1-9} [off]    Turn on (or off) refresh after every newline\r\n");
	wwprintf(w, "                        for window {1-9}.\r\n");
	wwprintf(w, ":label {1-9} string     Label window {1-9}.\r\n");
D 10
	wwprintf(w, ":escape c               Set escape character to c.\r\n");
E 10
I 10
	wwprintf(w, ":escape C               Set escape character to C.\r\n");
E 10
D 9
	wwprintf(w, ":%{1-9}                 Select window {1-9}.\r\n");
E 9
I 9
	wwprintf(w, ":%%{1-9}                 Select window {1-9}.\r\n");
E 9
	wwprintf(w, ":window r c nr nc       Open a window at row r column c\r\n");
	wwprintf(w, "                        with nr rows and nc colomns\r\n");
I 10
	wwprintf(w, ":source filename        Execute the commands in `filename'.\r\n");
E 12
I 12
D 16
	(void) wwprintf(w, "Long commands:\r\n\n");
	(void) wwprintf(w, ":terse [off]            Turn on (or off) terse mode.\r\n");
	(void) wwprintf(w, ":refresh {1-9} [off]    Turn on (or off) refresh after every newline\r\n");
	(void) wwprintf(w, "                        for window {1-9}.\r\n");
	(void) wwprintf(w, ":label {1-9} string     Label window {1-9}.\r\n");
	(void) wwprintf(w, ":escape C               Set escape character to C.\r\n");
	(void) wwprintf(w, ":%%{1-9}                 Select window {1-9}.\r\n");
	(void) wwprintf(w, ":window r c nr nc       Open a window at row r column c\r\n");
	(void) wwprintf(w, "                        with nr rows and nc colomns\r\n");
	(void) wwprintf(w, ":source filename        Execute the commands in `filename'.\r\n");
E 16
I 16
	(void) wwprintf(w, "Long commands:\n\n");
D 20
	(void) wwprintf(w, ":terse [off]            Turn on (or off) terse mode.\n");
D 19
	(void) wwprintf(w, ":refresh {1-9} [off]    Turn on (or off) refresh after every newline\n");
	(void) wwprintf(w, "                        for window {1-9}.\n");
E 19
	(void) wwprintf(w, ":label {1-9} string     Label window {1-9}.\n");
I 19
	(void) wwprintf(w, ":write {1-9} string     Write ``strings'' to window {1-9}.\n");
E 19
	(void) wwprintf(w, ":escape C               Set escape character to C.\n");
	(void) wwprintf(w, ":%%{1-9}                 Select window {1-9}.\n");
	(void) wwprintf(w, ":window r c nr nc       Open a window at row r column c\n");
D 19
	(void) wwprintf(w, "                        with nr rows and nc colomns\n");
	(void) wwprintf(w, ":source filename        Execute the commands in `filename'.\n");
E 19
I 19
	(void) wwprintf(w, "                        with nr rows and nc colomns.\n");
	(void) wwprintf(w, ":close {1-9}            Close window.\n");
	(void) wwprintf(w, ":source filename        Execute commands in ``filename''.\n");
E 20
I 20
	(void) wwprintf(w, ":terse [off]              Turn on (or off) terse mode.\n");
	(void) wwprintf(w, ":label {1-9} string       Label window {1-9}.\n");
	(void) wwprintf(w, ":write {1-9} string       Write ``strings'' to window {1-9}.\n");
	(void) wwprintf(w, ":escape C                 Set escape character to C.\n");
	(void) wwprintf(w, ":%%{1-9}                   Select window {1-9}.\n");
	(void) wwprintf(w, ":window r c nr nc [nl]    Open a window at row r column c\n");
	(void) wwprintf(w, "                          with nr rows, nc colomns,\n");
	(void) wwprintf(w, "                          and nl lines in the buffer.\n");
	(void) wwprintf(w, ":buffer lines             Set the default window buffer size.\n");
	(void) wwprintf(w, ":close {1-9}              Close window.\n");
	(void) wwprintf(w, ":source filename          Execute commands in ``filename''.\n");
E 20
E 19
E 16
E 12
E 10
	waitnl(w);
E 28
I 28
D 32
	help_print(w, "Short commands", help_shortcmd);
	help_print(w, "Long commands", help_longcmd);
E 32
I 32
	if (help_print(w, "Short commands", help_shortcmd) >= 0)
		(void) help_print(w, "Long commands", help_longcmd);
E 32
E 28
E 8
E 2
D 12
	closewin(w);
E 12
I 12
	closeiwin(w);
E 12
}

I 28
help_print(w, name, list)
register struct ww *w;
char *name;
D 32
char **list;
E 32
I 32
register char **list;
E 32
{
D 32
	register char **p;
	char firsttime = 1;

	for (p = list; *p;) {
		(void) wwprintf(w, "%s:%s\n\n",
			name, firsttime ? "" : " (continued)");
		firsttime = 0;
		while (*p && w->ww_cur.r < w->ww_w.b - 2) {
			(void) wwputs(*p++, w);
E 32
I 32
D 35
	(void) wwprintf(w, "%s:\n\n", name);
E 35
I 35
	wwprintf(w, "%s:\n\n", name);
E 35
	while (*list)
		switch (more(w, 0)) {
		case 0:
D 35
			(void) wwputs(*list++, w);
E 32
			(void) wwputc('\n', w);
E 35
I 35
			wwputs(*list++, w);
			wwputc('\n', w);
E 35
I 32
			break;
		case 1:
D 33
			(void) wwprintf(w, "%s: (continue)\n\n", name);
E 33
I 33
D 35
			(void) wwprintf(w, "%s: (continued)\n\n", name);
E 35
I 35
			wwprintf(w, "%s: (continued)\n\n", name);
E 35
E 33
			break;
		case 2:
			return -1;
E 32
		}
D 32
		waitnl(w);
		(void) wwputs("\033E", w);	/* clear and home cursor */
	}
E 32
I 32
	return more(w, 1) == 2 ? -1 : 0;
E 32
D 38
}

E 28
I 25
D 37
#ifndef O_4_1A
E 25
D 12
dotime(flag)
E 12
I 12
char *strtime();

c_time(flag)
E 12
{
	register struct ww *w;
	struct rusage rusage;
	struct timeval timeval;
I 12
D 35
	struct timezone timezone;
E 35
E 12

D 2
	if ((w = openwin(9, "Time")) == 0)
E 2
I 2
D 3
	if ((w = openwin(8, "Time")) == 0)
E 3
I 3
D 4
	if ((w = openwin(8, "Time")) == 0) {
E 4
I 4
D 12
	if ((w = openwin(8, "Timing and Resource Usage")) == 0) {
E 4
D 8
		wwputs("Can't open time window.  ", cmdwin);
E 8
I 8
		if (terse)
			Ding();
		else
			wwputs("Can't open time window.  ", cmdwin);
E 12
I 12
	if ((w = openiwin(6, "Timing and Resource Usage")) == 0) {
D 22
		error("Can't open time window.");
E 22
I 22
		error("Can't open time window: %s.", wwerror());
E 22
E 12
E 8
E 3
E 2
		return;
I 3
	}
E 3

D 12
	gettimeofday(&timeval, &timezone);
E 12
I 12
D 35
	(void) gettimeofday(&timeval, &timezone);
E 35
I 35
	(void) gettimeofday(&timeval, (struct timezone *)0);
E 35
E 12
	timeval.tv_sec -= starttime.tv_sec;
	if ((timeval.tv_usec -= starttime.tv_usec) < 0) {
		timeval.tv_sec--;
		timeval.tv_usec += 1000000;
	}
D 12
	getrusage(flag, &rusage);
E 12
I 12
	(void) getrusage(flag, &rusage);
E 12

D 12
	wwprintf(w, "time\t\tutime\t\tstime\t\tmaxrss\tixrss\tidrss\tisrss\r\n");
	wwprintf(w, "%-16s", strtime(&timeval));
	wwprintf(w, "%-16s", strtime(&rusage.ru_utime));
	wwprintf(w, "%-16s", strtime(&rusage.ru_stime));
	wwprintf(w, "%D\t%D\t%D\t%D\r\n",
E 12
I 12
D 16
	(void) wwprintf(w, "time\t\tutime\t\tstime\t\tmaxrss\tixrss\tidrss\tisrss\r\n");
E 16
I 16
D 35
	(void) wwprintf(w, "time\t\tutime\t\tstime\t\tmaxrss\tixrss\tidrss\tisrss\n");
E 16
	(void) wwprintf(w, "%-16s", strtime(&timeval));
	(void) wwprintf(w, "%-16s", strtime(&rusage.ru_utime));
	(void) wwprintf(w, "%-16s", strtime(&rusage.ru_stime));
D 16
	(void) wwprintf(w, "%D\t%D\t%D\t%D\r\n",
E 16
I 16
	(void) wwprintf(w, "%D\t%D\t%D\t%D\n",
E 35
I 35
	wwprintf(w, "time\t\tutime\t\tstime\t\tmaxrss\tixrss\tidrss\tisrss\n");
	wwprintf(w, "%-16s", strtime(&timeval));
	wwprintf(w, "%-16s", strtime(&rusage.ru_utime));
	wwprintf(w, "%-16s", strtime(&rusage.ru_stime));
	wwprintf(w, "%D\t%D\t%D\t%D\n",
E 35
E 16
E 12
		rusage.ru_maxrss, rusage.ru_ixrss,
		rusage.ru_idrss, rusage.ru_isrss);
D 12
	wwprintf(w, "minflt\tmajflt\tnswap\tinblk\toublk\tmsgsnd\tmsgrcv\tnsigs\tnvcsw\tnivcsw\r\n");
	wwprintf(w, "%D\%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\r\n",
E 12
I 12
D 16
	(void) wwprintf(w, "minflt\tmajflt\tnswap\tinblk\toublk\tmsgsnd\tmsgrcv\tnsigs\tnvcsw\tnivcsw\r\n");
	(void) wwprintf(w, "%D\%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\r\n",
E 16
I 16
D 35
	(void) wwprintf(w, "minflt\tmajflt\tnswap\tinblk\toublk\tmsgsnd\tmsgrcv\tnsigs\tnvcsw\tnivcsw\n");
	(void) wwprintf(w, "%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\n",
E 35
I 35
	wwprintf(w, "minflt\tmajflt\tnswap\tinblk\toublk\tmsgsnd\tmsgrcv\tnsigs\tnvcsw\tnivcsw\n");
	wwprintf(w, "%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\t%D\n",
E 35
E 16
E 12
		rusage.ru_minflt, rusage.ru_majflt, rusage.ru_nswap,
		rusage.ru_inblock, rusage.ru_oublock,
		rusage.ru_msgsnd, rusage.ru_msgrcv, rusage.ru_nsignals,
		rusage.ru_nvcsw, rusage.ru_nivcsw);

I 2
	waitnl(w);
E 2
D 12
	closewin(w);
E 12
I 12
	closeiwin(w);
E 12
}

char *
strtime(t)
register struct timeval *t;
{
	char fill = 0;
	static char buf[20];
	register char *p = buf;

	if (t->tv_sec > 60*60) {
D 12
		sprintf(p, "%D:", t->tv_sec / (60*60));
E 12
I 12
		(void) sprintf(p, "%D:", t->tv_sec / (60*60));
E 12
		while (*p++)
			;
		p--;
		t->tv_sec %= 60*60;
		fill++;
	}
	if (t->tv_sec > 60) {
D 12
		sprintf(p, fill ? "%02D:" : "%D:", t->tv_sec / 60);
E 12
I 12
		(void) sprintf(p, fill ? "%02D:" : "%D:", t->tv_sec / 60);
E 12
		while (*p++)
			;
		p--;
		t->tv_sec %= 60;
		fill++;
	}
D 12
	sprintf(p, fill ? "%02D.%02d" : "%D.%02D",
E 12
I 12
	(void) sprintf(p, fill ? "%02D.%02d" : "%D.%02D",
E 12
		t->tv_sec, t->tv_usec / 10000);
	return buf;
}
I 25
#endif
E 25

I 4
D 12
dostat()
E 12
I 12
c_stat()
E 12
{
	register struct ww *w;

D 6
	if ((w = openwin(22, "IO Statics")) == 0) {
E 6
I 6
D 12
	if ((w = openwin(6, "IO Statics")) == 0) {
E 6
D 8
		wwputs("Can't open statistics window.  ", cmdwin);
E 8
I 8
		if (terse)
			Ding();
		else
			wwputs("Can't open statistics window.  ", cmdwin);
E 12
I 12
D 18
	if ((w = openiwin(6, "IO Statics")) == 0) {
E 18
I 18
D 26
	if ((w = openiwin(4, "IO Statics")) == 0) {
E 26
I 26
D 34
	if ((w = openiwin(6, "IO Statics")) == 0) {
E 34
I 34
D 35
	if ((w = openiwin(8, "IO Statistics")) == 0) {
E 35
I 35
	if ((w = openiwin(14, "IO Statistics")) == 0) {
E 35
E 34
E 26
E 18
D 22
		error("Can't open statistics window.");
E 22
I 22
		error("Can't open statistics window: %s.", wwerror());
E 22
E 12
E 8
		return;
	}
D 6
	wwprintf(w, "nread: %d\r\n", nread);
E 6
I 6
D 12
	wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\r\n");
	wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\r\n",
E 12
I 12
D 15
	(void) wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\r\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\r\n",
E 12
		nread, nreadz, nreade, nreadc, wwnwrite, wwnwritec);
E 15
I 15
D 16
	(void) wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\tntouched\tnmiss\r\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\r\n",
E 16
I 16
D 17
	(void) wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\tnupdt\tntouch\tnmiss\n");
E 17
I 17
D 26
	(void) wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\tnupdate\tntouchd\tnmiss\n");
E 17
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
E 16
		nread, nreadz, nreade, nreadc, wwnwrite, wwnwritec,
D 16
		wwntouched, wwnmiss);
E 16
I 16
		wwnupdate, wwntouched, wwnmiss);
E 26
I 26
D 34
	(void) wwprintf(w, "nread\tnreadz\tnreade\tnreadc\tnwrite\tnwritec\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\n",
		nread, nreadz, nreade, nreadc, wwnwrite, wwnwritec);
	(void) wwprintf(w, "nupdate\tnupdlin\tnupdmis\tnmajlin\tnmajmis\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\n",
E 34
I 34
D 35
	(void) wwprintf(w, "nwrite\tnwritec\tnupdate\tnupdlin\tnupdmis\tnmajlin\tnmajmis\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
		wwnwrite, wwnwritec,
E 35
I 35
	wwprintf(w, "ttflush\twrite\terror\tzero\tchar\n");
	wwprintf(w, "%d\t%d\t%d\t%d\t%d\n",
		wwnflush, wwnwr, wwnwre, wwnwrz, wwnwrc);
	wwprintf(w, "wwwrite\tattmpt\tchar\n");
	wwprintf(w, "%d\t%d\t%d\n",
		wwnwwr, wwnwwra, wwnwwrc);
	wwprintf(w, "wwupdat\tline\tmiss\tmajor\tmiss\n");
	wwprintf(w, "%d\t%d\t%d\t%d\t%d\n",
E 35
E 34
		wwnupdate, wwnupdline, wwnupdmiss, wwnmajline, wwnmajmiss);
I 34
D 35
	(void) wwprintf(w, "nsel\tnselz\tnsele\tnread\tnreadz\tnreade\tnreadc\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
		wwnselect, wwnselectz, wwnselecte,
		wwnread, wwnreadz, wwnreade, wwnreadc);
	(void) wwprintf(w, "nwread\tnwreadz\tnwreade\tnwreadd\tnwreadc\tnwreadp\n");
	(void) wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\n",
		wwnwread, wwnwreadz, wwnwreade,
		wwnwreadd, wwnwreadc, wwnwreadp);
E 35
I 35
	wwprintf(w, "select\terror\tzero\n");
	wwprintf(w, "%d\t%d\t%d\n",
		wwnselect, wwnselecte, wwnselectz);
	wwprintf(w, "read\terror\tzero\tchar\n");
	wwprintf(w, "%d\t%d\t%d\t%d\n",
		wwnread, wwnreade, wwnreadz, wwnreadc);
	wwprintf(w, "ptyread\terror\tzero\tcontrol\tdata\tchar\n");
	wwprintf(w, "%d\t%d\t%d\t%d\t%d\t%d\n",
		wwnwread, wwnwreade, wwnwreadz,
		wwnwreadp, wwnwreadd, wwnwreadc);
E 35
E 34
E 26
E 16
E 15
E 6
	waitnl(w);
D 12
	closewin(w);
E 12
I 12
	closeiwin(w);
E 12
}

E 37
I 8
D 12
dolist()
E 12
I 12
c_list()
E 12
{
D 12
	register struct ww *w, *w1;
	int id;
	char doneit = 0;
E 12
I 12
D 23
	register struct ww *w;
E 23
I 23
	register struct ww *w, *wp;
E 23
	register i;
	int n;
I 23
D 24
	char *msg;
E 24
E 23
E 12

D 12
	if ((w = openwin(14, "Active Windows")) == 0) {
		if (terse)
			Ding();
		else
			wwputs("Can't open listing window.  ", cmdwin);
E 12
I 12
	for (n = 0, i = 0; i < NWINDOW; i++)
		if (window[i] != 0)
			n++;
D 14
	if ((w = openiwin(MIN(n, 1) + 2, "Active Windows")) == 0) {
E 14
I 14
D 23
	if ((w = openiwin(MAX(n, 1) + 2, "Active Windows")) == 0) {
E 23
I 23
D 28
	if ((w = openiwin(MAX(n, 1) + 2, "Windows")) == 0) {
E 28
I 28
	if (n == 0) {
		error("No windows.");
		return;
	}
	if ((w = openiwin(n + 2, "Windows")) == 0) {
E 28
E 23
E 14
D 22
		error("Can't open listing window.");
E 22
I 22
		error("Can't open listing window: %s.", wwerror());
E 22
E 12
		return;
	}
D 12
	for (id = 1; id <= NWINDOW; id++) {
		if ((w1 = wwfind(id)) == 0)
			continue;
		doneit = 1;
		wwprintf(w, "%d   %s\r\n", id, w1->ww_label);
E 12
I 12
D 28
	if (n == 0) {
D 16
		(void) wwputs("No windows.\r\n", w);
E 16
I 16
		(void) wwputs("No windows.\n", w);
E 16
	} else {
		for (i = 0; i < NWINDOW; i++) {
D 23
			if (window[i] == 0)
E 23
I 23
			if ((wp = window[i]) == 0)
E 23
				continue;
D 16
			(void) wwprintf(w, "%c   %s\r\n", i + '1',
E 16
I 16
D 19
			(void) wwprintf(w, "%c   %s\n", i + '1',
E 19
I 19
D 23
			(void) wwprintf(w, "%c %c   %s\n",
				window[i] == selwin ? '*' : ' ',
E 23
I 23
			(void) wwprintf(w, "%c %c %-13s %-.*s\n",
				wp == selwin ? '*' : ' ',
E 23
				i + '1',
E 19
E 16
D 23
				window[i]->ww_label ? window[i]->ww_label
					: "(No label)");
E 23
I 23
				wp->ww_state == WWS_HASPROC
					? "" : "(No process)",
				wwncol - 20,
				wp->ww_label
					? wp->ww_label : "(No label)");
E 23
		}
E 28
I 28
	for (i = 0; i < NWINDOW; i++) {
		if ((wp = window[i]) == 0)
			continue;
D 35
		(void) wwprintf(w, "%c %c %-13s %-.*s\n",
E 35
I 35
		wwprintf(w, "%c %c %-13s %-.*s\n",
E 35
			wp == selwin ? '*' : ' ',
			i + '1',
D 32
			wp->ww_state == WWS_HASPROC
				? "" : "(No process)",
E 32
I 32
			wp->ww_state == WWS_HASPROC ? "" : "(No process)",
E 32
			wwncol - 20,
D 32
			wp->ww_label
				? wp->ww_label : "(No label)");
E 32
I 32
			wp->ww_label ? wp->ww_label : "(No label)");
E 32
E 28
E 12
	}
D 12
	if (!doneit)
		wwprintf(w, "No windows.\r\n");
E 12
	waitnl(w);
D 12
	closewin(w);
E 12
I 12
	closeiwin(w);
E 38
E 12
}

E 8
E 4
I 3
D 12
doquit()
E 12
I 12
c_quit()
E 12
{
I 8
D 36
	if (terse)
D 12
		Wunhide(cmdwin->ww_win);
E 8
D 5
	wwputs("Really quit? ", cmdwin);
E 5
I 5
	wwputs("Really quit [yn]? ", cmdwin);
E 5
	wwsetcursor(WCurRow(cmdwin->ww_win), WCurCol(cmdwin->ww_win));
E 12
I 12
		wwadd(cmdwin, &wwhead);
E 36
I 36
	char oldterse = terse;

	setterse(0);
E 36
D 35
	(void) wwputs("Really quit [yn]? ", cmdwin);
E 35
I 35
	wwputs("Really quit [yn]? ", cmdwin);
E 35
	wwcurtowin(cmdwin);
E 12
D 34
	while (bpeekc() < 0)
		bread();
	if (bgetc() == 'y') {
E 34
I 34
	while (wwpeekc() < 0)
		wwiomux();
	if (wwgetc() == 'y') {
E 34
D 12
		wwputs("Yes", cmdwin);
E 12
I 12
D 35
		(void) wwputs("Yes", cmdwin);
E 35
I 35
		wwputs("Yes", cmdwin);
E 35
E 12
		quit++;
	} else
D 12
		wwputs("\r\n", cmdwin);
I 8
	if (terse)
		Whide(cmdwin->ww_win);
E 12
I 12
D 35
		(void) wwputs("\r\n", cmdwin);
E 35
I 35
D 40
		wwputs("\r\n", cmdwin);
E 40
I 40
		wwputc('\n', cmdwin);
E 40
E 35
D 36
	if (terse && !quit)
		wwdelete(cmdwin);
E 36
I 36
	setterse(!quit && oldterse);
E 36
E 12
E 8
D 33
}

I 12
/*
 * Open an information window.
 */
E 12
E 3
struct ww *
D 12
openwin(nrow, label)
E 12
I 12
openiwin(nrow, label)
E 12
char *label;
{
	register struct ww *w;
I 8
D 12
	int startcol;
E 12
E 8

D 3
	if ((w = wwopen(WW_NONE, 0, nrow, WCols, 1, 0)) == 0) {
		wwputs("\r\nCan't open help window.  ", cmdwin);
E 3
I 3
D 4
	if ((w = wwopen(WW_NONE, 0, nrow, WCols, 1, 0)) == 0)
E 4
I 4
D 8
	if ((w = wwopen(WW_NONE, 0, nrow, wwncol, 1, 0)) == 0)
E 8
I 8
D 12
	if ((w = wwopen(WW_NONE, 0, nrow, wwncol, 0, 0)) == 0)
E 12
I 12
	if ((w = wwopen(0, nrow, wwncol, 2, 0, 0)) == 0)
E 12
E 8
E 4
E 3
		return 0;
D 3
	}
E 3
D 12
	wwframe(w);
D 7
	wwlabel(w, label, WINVERSE);
E 7
I 7
D 8
	wwlabel(w, (wwncol - strlen(label)) / 2 + 1, label, WINVERSE);
E 8
I 8
	if ((startcol = (wwncol - strlen(label)) / 2) <= 0)
		startcol = 1;
	wwlabel(w, startcol, label, WINVERSE);
E 8
E 7
D 3
	wwsetcurrent(w);
E 3
I 3
	wwsetcurwin(w);
E 12
I 12
D 16
	/*
E 16
	w->ww_mapnl = 1;
D 16
	*/
E 16
	w->ww_hasframe = 1;
	w->ww_id = -1;
	w->ww_center = 1;
	(void) setlabel(w, label);
	wwadd(w, framewin);
	reframe();
E 12
E 3
	return w;
}

D 2
closewin(w)
E 2
I 2
waitnl(w)
I 32
struct ww *w;
{
	(void) waitnl1(w, "[Type any key to continue]");
}

waitnl1(w, prompt)
E 32
E 2
register struct ww *w;
I 32
char *prompt;
E 32
{
I 3
D 12
	wwsetcurwin(w);
E 3
	wwprintf(w, "\r\nType return to continue: ");
	wwsetcursor(WCurRow(w->ww_win), WCurCol(w->ww_win));
E 12
I 12
D 21
	if (w->ww_back != framewin) {
D 20
		(void) wwputs("reframed", w);
E 20
		wwdelete(w);
		wwadd(w, framewin);
		reframe();
	}
E 21
I 21
D 27
	front(w);
E 27
I 27
	front(w, 0);
E 27
E 21
D 16
	(void) wwputs("\r\nType return to continue: ", w);
E 16
I 16
D 28
	(void) wwputs("\nType return to continue: ", w);
E 28
I 28
D 32
	(void) wwprintf(w, "\033Y%c%c[Type any key to continue] ",
		w->ww_w.nr - 1 + ' ', ' ');	/* print on last line */
E 32
I 32
	(void) wwprintf(w, "\033Y%c%c\033p%s\033q ",
		w->ww_w.nr - 1 + ' ', ' ', prompt);	/* print on last line */
E 32
E 28
E 16
	wwcurtowin(w);
E 12
D 2
	while (bgetc() < 0) {
		wwflush();
E 2
I 2
D 32
	while (bgetc() < 0)
E 32
I 32
	while (bpeekc() < 0)
E 32
E 2
		bread();
I 32
	return bgetc();
E 32
I 8
D 12
	wwputs("\033E", w);			/* clear and home cursor */
E 12
I 12
D 28
	(void) wwputs("\033E", w);		/* clear and home cursor */
E 28
E 12
E 8
D 2
	}
E 2
I 2
}

I 29
D 31
/*VARARGS2*/
more(w, fmt, a, b, c, d, e)
E 31
I 31
D 32
more(w)
E 32
I 32
more(w, flag)
E 32
E 31
register struct ww *w;
I 32
char flag;
E 32
D 31
char *fmt;
E 31
{
D 32
	if (w->ww_cur.r > w->ww_w.b - 3) {
		waitnl(w);
		(void) wwputs("\033E", w);
	}
E 32
I 32
	int c;

	if (!flag && w->ww_cur.r < w->ww_w.b - 2)
		return 0;
	c = waitnl1(w, "[Type escape to abort, any other key to continue]");
	(void) wwputs("\033E", w);
	return c == CTRL([) ? 2 : 1;
E 32
D 31
	(void) wwprintf(w, fmt, a, b, c, d, e);
E 31
}

E 29
D 12
closewin(w)
register struct ww *w;
E 12
I 12
closeiwin(w)
struct ww *w;
E 12
{
E 2
D 12
	wwclose(w);
D 3
	wwsetcurrent(cmdwin);
E 3
I 3
	wwsetcurwin(cmdwin);
E 12
I 12
	closewin(w);
	reframe();
E 33
E 12
E 3
}
E 1
