h44216
s 00002/00001/01057
d D 8.2 94/01/21 14:24:33 hibler 41 40
c make sure interleave > 0 for cd device
e
s 00002/00002/01056
d D 8.1 93/06/06 13:52:54 bostic 40 39
c 4.4BSD snapshot (revision 8.1); add 1993 to copyright
e
s 00001/00000/01057
d D 5.30 93/05/10 21:25:34 ralph 39 38
c added "sys/time.h" to pmax ioconf.c
e
s 00053/00000/01004
d D 5.29 93/05/09 21:23:10 hibler 38 37
c support for sequential swap devices and concatonated disks
e
s 00031/00001/00973
d D 5.28 93/04/17 18:57:15 torek 37 36
c pseudo_ioconf() generates pdevinit[] table so that kernel does
c not need lots of #ifdefs for pseudo device initialization
e
s 00003/00003/00971
d D 5.27 93/01/21 17:10:32 mckusick 36 35
c add sys/ to NEWS ioconf includes
e
s 00001/00001/00973
d D 5.26 92/11/06 09:00:08 bostic 35 34
c Cael Staelin made it compile
e
s 00154/00000/00820
d D 5.25 92/07/31 09:02:39 mckusick 34 33
c update from utashiro for NEWS3400 port
e
s 00005/00002/00815
d D 5.24 92/06/19 17:49:21 mckusick 33 32
c support for luna68k
e
s 00001/00001/00816
d D 5.23 92/06/04 17:27:34 hibler 32 31
c correct device.h path for hp300
e
s 00007/00005/00810
d D 5.22 92/02/29 15:33:40 ralph 31 30
c added support for DS5000
e
s 00091/00013/00724
d D 5.21 91/09/07 14:14:48 ralph 30 29
c forgot to include changes for pmax
e
s 00000/00000/00737
d D 5.20 91/09/07 13:21:19 ralph 29 28
c added mips and pmax support
e
s 00001/00002/00736
d D 5.19 91/09/03 20:03:34 william 28 27
c remove K&R concatenation "comment"
e
s 00000/00001/00738
d D 5.18 91/05/10 10:45:21 karels 27 26
c pte has moved, isn't needed
e
s 00137/00000/00602
d D 5.17 91/01/15 13:41:31 william 26 25
c 386BSD additions to config
e
s 00016/00016/00586
d D 5.16 91/01/09 15:01:10 bostic 25 24
c kernel reorg (probably not right...)
e
s 00000/00002/00602
d D 5.15 90/12/03 17:27:35 mckusick 24 23
c delete sys/vm.h include file
e
s 00001/00011/00603
d D 5.14 90/06/01 18:39:30 bostic 23 22
c new copyright notice
e
s 00142/00000/00472
d D 5.13 90/05/16 10:37:17 mckusick 22 21
c "add support for hp300 from Utah"
e
s 00007/00007/00465
d D 5.12 89/04/25 17:29:30 mckusick 21 20
c ../h => ../sys
e
s 00002/00002/00470
d D 5.11 89/04/25 15:01:41 mckusick 20 19
c ../machine => machine
e
s 00010/00005/00462
d D 5.10 88/06/18 13:43:09 bostic 19 18
c install approved copyright notice
e
s 00001/00001/00466
d D 5.9 88/05/21 16:40:52 karels 18 17
c pretend bi's connect to nexi; delete unnecessary keywords
e
s 00009/00003/00458
d D 5.8 88/04/29 13:43:31 bostic 17 16
c add Berkeley specific header; original conception by Michael Toy
e
s 00001/00001/00460
d D 5.7 88/04/26 13:34:40 bostic 16 15
c format/argument count mismatch
e
s 00004/00002/00457
d D 5.6 87/10/22 11:09:19 bostic 15 14
c ANSI C; sprintf now returns an int.
e
s 00001/00001/00458
d D 5.5 87/04/06 10:04:11 bostic 14 13
c fprintf format/argument mismatch
e
s 00007/00005/00452
d D 5.4 86/12/09 10:57:23 sam 13 12
c must output external declaration for devices w/o interrupts
e
s 00005/00005/00452
d D 5.3 86/12/07 12:05:15 sam 12 11
c some VERSAbus devices don't generate interrupts
e
s 00074/00047/00383
d D 5.2 86/10/13 15:35:35 sam 11 10
c replace ancient sun support with tahoe support
e
s 00007/00001/00423
d D 5.1 85/05/08 11:57:47 dist 10 9
c Add copyright
e
s 00003/00001/00421
d D 2.9 83/08/11 22:54:19 sam 9 8
c standardize sccs keyword lines
e
s 00004/00004/00418
d D 2.8 83/06/11 01:10:04 sam 8 7
c qu returns static
e
s 00008/00007/00414
d D 2.7 83/03/28 23:10:12 sam 7 6
c someone broke qu a ways back by removing the ns function on 
c the return value; this requires each invocation to be done in separate printfs
e
s 00002/00002/00419
d D 2.6 83/01/02 15:24:20 sam 6 5
c pte.h moved; sunmb->sundev
e
s 00035/00038/00386
d D 2.5 82/10/25 00:59:13 root 5 4
c lint and cleanup
e
s 00005/00002/00419
d D 2.4 82/10/24 22:25:26 root 4 3
c more #if stuff
e
s 00003/00007/00418
d D 2.3 82/10/24 22:21:59 root 3 2
c trivial cleanups
e
s 00391/00226/00034
d D 2.2 82/10/24 22:19:49 root 2 1
c from santa clara (but duplicated code!)
e
s 00260/00000/00000
d D 2.1 82/10/24 20:37:35 root 1 0
c date and time created 82/10/24 20:37:35 by root
e
u
U
t
T
I 10
/*
D 40
 * Copyright (c) 1980 Regents of the University of California.
D 17
 * All rights reserved.  The Berkeley software License Agreement
 * specifies the terms and conditions for redistribution.
E 17
I 17
 * All rights reserved.
E 40
I 40
 * Copyright (c) 1980, 1993
 *	The Regents of the University of California.  All rights reserved.
E 40
 *
D 23
 * Redistribution and use in source and binary forms are permitted
D 19
 * provided that this notice is preserved and that due credit is given
 * to the University of California at Berkeley. The name of the University
 * may not be used to endorse or promote products derived from this
 * software without specific prior written permission. This software
 * is provided ``as is'' without express or implied warranty.
E 19
I 19
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
E 23
I 23
 * %sccs.include.redist.c%
E 23
E 19
E 17
 */

E 10
I 2
D 9
/*	%M%	%I%	%E%	*/
E 9
I 9
#ifndef lint
static char sccsid[] = "%W% (Berkeley) %G%";
D 10
#endif
E 10
I 10
D 17
#endif not lint
E 17
I 17
#endif /* not lint */
E 17
E 10
E 9

E 2
I 1
#include <stdio.h>
#include "y.tab.h"
#include "config.h"

/*
D 2
 * %M%	%I%	%E%
 * ioconf:
 *	Build the ioconf.c file
E 2
I 2
 * build the ioconf.c file
E 2
 */
D 2
char *qu();
E 2
I 2
char	*qu();
I 4
char	*intv();
I 30
char	*wnum();
I 37
void	pseudo_ioconf();
E 37
E 30
E 4
E 2

I 4
#if MACHINE_VAX
E 4
D 2
ioconf()
E 2
I 2
vax_ioconf()
E 2
{
D 2
    register struct device *dp, *mp, *np;
    register int uba_n, slave;
    char *intv();
    FILE *fp;
E 2
I 2
	register struct device *dp, *mp, *np;
	register int uba_n, slave;
D 4
	char *intv();
E 4
	FILE *fp;
E 2

D 2
    fp = fopen(path("ioconf.c"), "w");
    if (fp == NULL) {
	perror(path("ioconf.c"));
	exit(1);
    }
    fprintf(fp, "#include \"../h/param.h\"\n");
    fprintf(fp, "#include \"../h/pte.h\"\n");
    fprintf(fp, "#include \"../h/buf.h\"\n");
    fprintf(fp, "#include \"../h/map.h\"\n");
    fprintf(fp, "#include \"../h/mbavar.h\"\n");
    fprintf(fp, "#include \"../h/vm.h\"\n");
    fprintf(fp, "#include \"../h/ubavar.h\"\n\n");
    fprintf(fp, "#define C (caddr_t)\n\n");
    /*
     * First print the mba initialization structures
     */
    if (seen_mba)
    {
	for (dp = dtab; dp != NULL; dp = dp->d_next)
	{
	    mp = dp->d_conn;
	    if (mp == NULL || mp == TO_NEXUS || !eq(mp->d_name, "mba"))
		continue;
	    fprintf(fp, "extern struct mba_driver %sdriver;\n", dp->d_name);
E 2
I 2
	fp = fopen(path("ioconf.c"), "w");
D 5
	if (fp == NULL) {
E 5
I 5
	if (fp == 0) {
E 5
		perror(path("ioconf.c"));
		exit(1);
E 2
	}
I 6
D 20
	fprintf(fp, "#include \"../machine/pte.h\"\n");
E 20
I 20
D 25
	fprintf(fp, "#include \"machine/pte.h\"\n");
E 20
E 6
D 2
	fprintf(fp, "\nstruct mba_device mbdinit[] = {\n");
	fprintf(fp, "\t/* Device,  Unit, Mba, Drive, Dk */\n");
	for (dp = dtab; dp != NULL; dp = dp->d_next)
	{
	    mp = dp->d_conn;
	    if (dp->d_unit == QUES || mp == NULL || mp == TO_NEXUS || !eq(mp->d_name, "mba"))
		continue;
	    if (dp->d_addr) {
		printf("can't specify csr address on mba for %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_vec != NULL) {
		printf("can't specify vector for %s%d on mba\n",
			dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_drive == UNKNOWN) {
		printf("drive not specified for %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_slave != UNKNOWN) {
		printf("can't specify slave number for %s%d\n", 
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    fprintf(fp, "\t{ &%sdriver, %d,   %s,  %s,    %d },\n",
		dp->d_name, dp->d_unit, qu(mp->d_unit),
		qu(dp->d_drive), dp->d_dk);
E 2
I 2
D 21
	fprintf(fp, "#include \"../h/param.h\"\n");
D 6
	fprintf(fp, "#include \"../h/pte.h\"\n");
E 6
	fprintf(fp, "#include \"../h/buf.h\"\n");
	fprintf(fp, "#include \"../h/map.h\"\n");
	fprintf(fp, "#include \"../h/vm.h\"\n");
E 21
I 21
	fprintf(fp, "#include \"../sys/param.h\"\n");
	fprintf(fp, "#include \"../sys/buf.h\"\n");
	fprintf(fp, "#include \"../sys/map.h\"\n");
E 25
I 25
	fprintf(fp, "#include \"vax/include/pte.h\"\n");
	fprintf(fp, "#include \"sys/param.h\"\n");
	fprintf(fp, "#include \"sys/buf.h\"\n");
	fprintf(fp, "#include \"sys/map.h\"\n");
E 25
D 24
	fprintf(fp, "#include \"../sys/vm.h\"\n");
E 24
E 21
	fprintf(fp, "\n");
D 25
	fprintf(fp, "#include \"../vaxmba/mbavar.h\"\n");
	fprintf(fp, "#include \"../vaxuba/ubavar.h\"\n\n");
E 25
I 25
	fprintf(fp, "#include \"vax/mba/mbavar.h\"\n");
	fprintf(fp, "#include \"vax/uba/ubavar.h\"\n\n");
E 25
	fprintf(fp, "\n");
	fprintf(fp, "#define C (caddr_t)\n\n");
	/*
	 * First print the mba initialization structures
	 */
	if (seen_mba) {
D 5
		for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
		for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
			mp = dp->d_conn;
D 5
			if (mp == NULL || mp == TO_NEXUS ||
E 5
I 5
			if (mp == 0 || mp == TO_NEXUS ||
E 5
			    !eq(mp->d_name, "mba"))
				continue;
			fprintf(fp, "extern struct mba_driver %sdriver;\n",
			    dp->d_name);
		}
		fprintf(fp, "\nstruct mba_device mbdinit[] = {\n");
		fprintf(fp, "\t/* Device,  Unit, Mba, Drive, Dk */\n");
D 5
		for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
		for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
			mp = dp->d_conn;
D 5
			if (dp->d_unit == QUES || mp == NULL ||
E 5
I 5
			if (dp->d_unit == QUES || mp == 0 ||
E 5
			    mp == TO_NEXUS || !eq(mp->d_name, "mba"))
				continue;
			if (dp->d_addr) {
				printf("can't specify csr address on mba for %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
D 5
			if (dp->d_vec != NULL) {
E 5
I 5
			if (dp->d_vec != 0) {
E 5
				printf("can't specify vector for %s%d on mba\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_drive == UNKNOWN) {
				printf("drive not specified for %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_slave != UNKNOWN) {
				printf("can't specify slave number for %s%d\n", 
				    dp->d_name, dp->d_unit);
				continue;
			}
D 7
			fprintf(fp,
				"\t{ &%sdriver, %d,   %s,  %s,    %d },\n",
				dp->d_name, dp->d_unit, qu(mp->d_unit),
E 7
I 7
			fprintf(fp, "\t{ &%sdriver, %d,   %s,",
				dp->d_name, dp->d_unit, qu(mp->d_unit));
			fprintf(fp, "  %s,  %d },\n",
E 7
				qu(dp->d_drive), dp->d_dk);
		}
		fprintf(fp, "\t0\n};\n\n");
		/*
		 * Print the mbsinit structure
		 * Driver Controller Unit Slave
		 */
		fprintf(fp, "struct mba_slave mbsinit [] = {\n");
		fprintf(fp, "\t/* Driver,  Ctlr, Unit, Slave */\n");
D 5
		for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
		for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
			/*
			 * All slaves are connected to something which
			 * is connected to the massbus.
			 */
D 5
			if ((mp = dp->d_conn) == NULL || mp == TO_NEXUS)
E 5
I 5
			if ((mp = dp->d_conn) == 0 || mp == TO_NEXUS)
E 5
				continue;
			np = mp->d_conn;
D 5
			if (np == NULL || np == TO_NEXUS ||
E 5
I 5
			if (np == 0 || np == TO_NEXUS ||
E 5
			    !eq(np->d_name, "mba"))
				continue;
D 8
			fprintf(fp,
			    "\t{ &%sdriver, %s,  %2d,    %s },\n",
			    mp->d_name, qu(mp->d_unit), dp->d_unit,
			    qu(dp->d_slave));
E 8
I 8
			fprintf(fp, "\t{ &%sdriver, %s",
			    mp->d_name, qu(mp->d_unit));
			fprintf(fp, ",  %2d,    %s },\n",
			    dp->d_unit, qu(dp->d_slave));
E 8
		}
		fprintf(fp, "\t0\n};\n\n");
E 2
	}
D 2
	fprintf(fp, "\t0\n};\n\n");
E 2
	/*
D 2
	 * Print the mbsinit structure
	 * Driver Controller Unit Slave
E 2
I 2
	 * Now generate interrupt vectors for the unibus
E 2
	 */
D 2
	fprintf(fp, "struct mba_slave mbsinit [] = {\n");
	fprintf(fp, "\t/* Driver,  Ctlr, Unit, Slave */\n");
	for (dp = dtab; dp != NULL; dp = dp->d_next)
	{
	    /*
	     * All slaves are connected to something which is connected to
	     * the massbus.
	     */
	    if ((mp = dp->d_conn) == NULL || mp == TO_NEXUS)
		continue;
	    np = mp->d_conn;
	    if (np == NULL || np == TO_NEXUS || !eq(np->d_name, "mba"))
		continue;
	    fprintf(fp, "\t{ &%sdriver, %s,  %2d,    %s },\n",
		mp->d_name, qu(mp->d_unit), dp->d_unit, qu(dp->d_slave));
E 2
I 2
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
		if (dp->d_vec != NULL) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		if (dp->d_vec != 0) {
E 5
			struct idlst *ip;
			mp = dp->d_conn;
D 5
			if (mp == NULL || mp == TO_NEXUS ||
E 5
I 5
			if (mp == 0 || mp == TO_NEXUS ||
E 5
D 18
			    !eq(mp->d_name, "uba"))
E 18
I 18
			    (!eq(mp->d_name, "uba") && !eq(mp->d_name, "bi")))
E 18
				continue;
			fprintf(fp,
			    "extern struct uba_driver %sdriver;\n",
			    dp->d_name);
			fprintf(fp, "extern ");
			ip = dp->d_vec;
			for (;;) {
				fprintf(fp, "X%s%d()", ip->id, dp->d_unit);
				ip = ip->id_next;
				if (ip == 0)
					break;
				fprintf(fp, ", ");
			}
			fprintf(fp, ";\n");
			fprintf(fp, "int\t (*%sint%d[])() = { ", dp->d_name,
D 14
			    dp->d_unit, dp->d_unit);
E 14
I 14
			    dp->d_unit);
E 14
			ip = dp->d_vec;
			for (;;) {
				fprintf(fp, "X%s%d", ip->id, dp->d_unit);
				ip = ip->id_next;
				if (ip == 0)
					break;
				fprintf(fp, ", ");
			}
			fprintf(fp, ", 0 } ;\n");
		}
E 2
	}
D 2
	fprintf(fp, "\t0\n};\n\n");
    }
    /*
     * Now generate interrupt vectors for the unibus
     */
    for (dp = dtab; dp != NULL; dp = dp->d_next) {
	if (dp->d_vec != NULL) {
	    struct idlst *ip;
	    mp = dp->d_conn;
	    if (mp == NULL || mp == TO_NEXUS || !eq(mp->d_name, "uba"))
		continue;
	    fprintf(fp, "extern struct uba_driver %sdriver;\n", dp->d_name);
	    fprintf(fp, "extern ");
	    ip = dp->d_vec;
	    for (;;) {
		fprintf(fp, "X%s%d()", ip->id, dp->d_unit);
		ip = ip->id_next;
		if (ip == 0)
		    break;
		fprintf(fp, ", ");
	    }
	    fprintf(fp, ";\n");
	    fprintf(fp, "int\t (*%sint%d[])() = { ", dp->d_name,
		    dp->d_unit, dp->d_unit);
	    ip = dp->d_vec;
	    for (;;) {
		fprintf(fp, "X%s%d", ip->id, dp->d_unit);
		ip = ip->id_next;
		if (ip == 0)
		    break;
		fprintf(fp, ", ");
	    }
	    fprintf(fp, ", 0 } ;\n");
E 2
I 2
D 3
	/*
	 * Now spew forth the uba_minfo structure
	 */
E 3
	fprintf(fp, "\nstruct uba_ctlr ubminit[] = {\n");
	fprintf(fp, "/*\t driver,\tctlr,\tubanum,\talive,\tintr,\taddr */\n");
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
		mp = dp->d_conn;
D 5
		if (dp->d_type != CONTROLLER || mp == TO_NEXUS || mp == NULL ||
E 5
I 5
		if (dp->d_type != CONTROLLER || mp == TO_NEXUS || mp == 0 ||
E 5
		    !eq(mp->d_name, "uba"))
			continue;
		if (dp->d_vec == 0) {
			printf("must specify vector for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_addr == 0) {
			printf("must specify csr address for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
			printf("drives need their own entries; dont ");
			printf("specify drive or slave for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_flags) {
			printf("controllers (e.g. %s%d) ",
			    dp->d_name, dp->d_unit);
			printf("don't have flags, only devices do\n");
			continue;
		}
		fprintf(fp,
		    "\t{ &%sdriver,\t%d,\t%s,\t0,\t%sint%d, C 0%o },\n",
		    dp->d_name, dp->d_unit, qu(mp->d_unit),
		    dp->d_name, dp->d_unit, dp->d_addr);
E 2
	}
D 2
    }
    /*
     * Now spew forth the uba_minfo structure
     */
    fprintf(fp, "\nstruct uba_ctlr ubminit[] = {\n");
    fprintf(fp, "/*\t driver,\tctlr,\tubanum,\talive,\tintr,\taddr */\n");
    for (dp = dtab; dp != NULL; dp = dp->d_next) {
	mp = dp->d_conn;
	if (dp->d_type != CONTROLLER || mp == TO_NEXUS || mp == NULL || !eq(mp->d_name, "uba"))
	    continue;
	if (dp->d_vec == 0) {
	    printf("must specify vector for %s%d\n", dp->d_name, dp->d_unit);
	    continue;
E 2
I 2
	fprintf(fp, "\t0\n};\n");
D 3
	/*
	 * Now we go for the uba_device stuff
	 */
E 3
I 3
/* unibus devices */
E 3
	fprintf(fp, "\nstruct uba_device ubdinit[] = {\n");
D 3
	fprintf(fp, "\t/* driver,  unit, ctlr,  ubanum, slave,   intr,    addr,    dk, flags*/\n");
E 3
I 3
	fprintf(fp,
"\t/* driver,  unit, ctlr,  ubanum, slave,   intr,    addr,    dk, flags*/\n");
E 3
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
		mp = dp->d_conn;
D 5
		if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == NULL ||
E 5
I 5
		if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == 0 ||
E 5
		    mp == TO_NEXUS || mp->d_type == MASTER ||
		    eq(mp->d_name, "mba"))
			continue;
		np = mp->d_conn;
D 5
		if (np != NULL && np != TO_NEXUS && eq(np->d_name, "mba"))
E 5
I 5
		if (np != 0 && np != TO_NEXUS && eq(np->d_name, "mba"))
E 5
			continue;
D 5
		np = NULL;
E 5
I 5
		np = 0;
E 5
		if (eq(mp->d_name, "uba")) {
			if (dp->d_vec == 0) {
				printf("must specify vector for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_addr == 0) {
				printf("must specify csr for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
				printf("drives/slaves can be specified ");
				printf("only for controllers, ");
				printf("not for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			uba_n = mp->d_unit;
			slave = QUES;
		} else {
D 5
			if ((np = mp->d_conn) == NULL) {
E 5
I 5
			if ((np = mp->d_conn) == 0) {
E 5
				printf("%s%d isn't connected to anything ",
				    mp->d_name, mp->d_unit);
				printf(", so %s%d is unattached\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			uba_n = np->d_unit;
			if (dp->d_drive == UNKNOWN) {
				printf("must specify ``drive number'' ");
				printf("for %s%d\n", dp->d_name, dp->d_unit);
				continue;
			}
			/* NOTE THAT ON THE UNIBUS ``drive'' IS STORED IN */
			/* ``SLAVE'' AND WE DON'T WANT A SLAVE SPECIFIED */
			if (dp->d_slave != UNKNOWN) {
				printf("slave numbers should be given only ");
				printf("for massbus tapes, not for %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_vec != 0) {
				printf("interrupt vectors should not be ");
				printf("given for drive %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_addr != 0) {
				printf("csr addresses should be given only ");
				printf("on controllers, not on %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			slave = dp->d_drive;
		}
D 7
		fprintf(fp,
"\t{ &%sdriver,  %2d,   %s,  %s,    %2d,   %s, C 0%-6o,  %d,  0x%x },\n",
E 7
I 7
		fprintf(fp, "\t{ &%sdriver,  %2d,   %s,",
E 7
		    eq(mp->d_name, "uba") ? dp->d_name : mp->d_name, dp->d_unit,
D 7
		    eq(mp->d_name, "uba") ? " -1" : qu(mp->d_unit), qu(uba_n),
		    slave, intv(dp), dp->d_addr, dp->d_dk, dp->d_flags);
E 7
I 7
		    eq(mp->d_name, "uba") ? " -1" : qu(mp->d_unit));
		fprintf(fp, "  %s,    %2d,   %s, C 0%-6o,  %d,  0x%x },\n",
		    qu(uba_n), slave, intv(dp), dp->d_addr, dp->d_dk,
		    dp->d_flags);
E 7
E 2
	}
D 2
	if (dp->d_addr == 0) {
	    printf("must specify csr address for %s%d\n",
		dp->d_name, dp->d_unit);
	    continue;
E 2
I 2
	fprintf(fp, "\t0\n};\n");
I 37
	pseudo_ioconf(fp);
E 37
D 5
	fclose(fp);
E 5
I 5
	(void) fclose(fp);
E 5
}
I 4
#endif
E 4

I 4
D 11
#if MACHINE_SUN
E 4
sun_ioconf()
E 11
I 11
#if MACHINE_TAHOE
tahoe_ioconf()
E 11
{
D 5
	register struct device *dp, *mp, *np;
	register int uba_n, slave;
E 5
I 5
D 11
	register struct device *dp, *mp;
	register int slave;
E 11
I 11
	register struct device *dp, *mp, *np;
	register int vba_n, slave;
E 11
E 5
D 4
	char *intv();
E 4
	FILE *fp;

	fp = fopen(path("ioconf.c"), "w");
D 5
	if (fp == NULL) {
E 5
I 5
	if (fp == 0) {
E 5
		perror(path("ioconf.c"));
		exit(1);
E 2
	}
D 2
	if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
	    printf("drives need their own entries; dont specify drive or slave for %s%d\n",
		dp->d_name, dp->d_unit);
	    continue;
E 2
I 2
D 21
	fprintf(fp, "#include \"../h/param.h\"\n");
E 21
I 21
D 25
	fprintf(fp, "#include \"../sys/param.h\"\n");
E 21
I 11
D 20
	fprintf(fp, "#include \"../machine/pte.h\"\n");
E 20
I 20
	fprintf(fp, "#include \"machine/pte.h\"\n");
E 20
E 11
D 21
	fprintf(fp, "#include \"../h/buf.h\"\n");
	fprintf(fp, "#include \"../h/map.h\"\n");
E 21
I 21
	fprintf(fp, "#include \"../sys/buf.h\"\n");
	fprintf(fp, "#include \"../sys/map.h\"\n");
E 25
I 25
	fprintf(fp, "#include \"sys/param.h\"\n");
	fprintf(fp, "#include \"tahoe/include/pte.h\"\n");
	fprintf(fp, "#include \"sys/buf.h\"\n");
	fprintf(fp, "#include \"sys/map.h\"\n");
E 25
E 21
D 11
	fprintf(fp, "#include \"../h/vm.h\"\n");
E 11
	fprintf(fp, "\n");
D 6
	fprintf(fp, "#include \"../sunmb/mbvar.h\"\n");
E 6
I 6
D 11
	fprintf(fp, "#include \"../sundev/mbvar.h\"\n");
E 11
I 11
D 25
	fprintf(fp, "#include \"../tahoevba/vbavar.h\"\n");
E 25
I 25
	fprintf(fp, "#include \"tahoe/vba/vbavar.h\"\n");
E 25
E 11
E 6
	fprintf(fp, "\n");
	fprintf(fp, "#define C (caddr_t)\n\n");
D 11
	fprintf(fp, "\n");
E 11
	/*
D 11
	 * Now generate interrupt vectors for the Multibus
E 11
I 11
	 * Now generate interrupt vectors for the versabus
E 11
	 */
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
		if (dp->d_pri != NULL) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
I 13
		mp = dp->d_conn;
		if (mp == 0 || mp == TO_NEXUS || !eq(mp->d_name, "vba"))
			continue;
E 13
D 11
		if (dp->d_pri != 0) {
E 11
I 11
		if (dp->d_vec != 0) {
			struct idlst *ip;
E 11
E 5
D 13
			mp = dp->d_conn;
D 5
			if (mp == NULL || mp == TO_NEXUS ||
E 5
I 5
			if (mp == 0 || mp == TO_NEXUS ||
E 5
D 11
			    !eq(mp->d_name, "mb"))
E 11
I 11
			    !eq(mp->d_name, "vba"))
E 11
				continue;
E 13
D 11
			fprintf(fp, "extern struct mb_driver %sdriver;\n",
E 11
I 11
			fprintf(fp,
			    "extern struct vba_driver %sdriver;\n",
E 11
			    dp->d_name);
I 11
			fprintf(fp, "extern ");
			ip = dp->d_vec;
			for (;;) {
				fprintf(fp, "X%s%d()", ip->id, dp->d_unit);
				ip = ip->id_next;
				if (ip == 0)
					break;
				fprintf(fp, ", ");
			}
			fprintf(fp, ";\n");
			fprintf(fp, "int\t (*%sint%d[])() = { ", dp->d_name,
D 16
			    dp->d_unit, dp->d_unit);
E 16
I 16
			    dp->d_unit);
E 16
			ip = dp->d_vec;
			for (;;) {
				fprintf(fp, "X%s%d", ip->id, dp->d_unit);
				ip = ip->id_next;
				if (ip == 0)
					break;
				fprintf(fp, ", ");
			}
			fprintf(fp, ", 0 } ;\n");
E 11
D 13
		}
E 13
I 13
		} else if (dp->d_type == DRIVER)  /* devices w/o interrupts */
			fprintf(fp,
			    "extern struct vba_driver %sdriver;\n",
			    dp->d_name);
E 13
E 2
	}
D 2
	if (dp->d_flags) {
	    printf("controllers (e.g. %s%d) don't have flags, only devices do\n",
		dp->d_name, dp->d_unit);
	    continue;
E 2
I 2
D 11
	/*
	 * Now spew forth the mb_cinfo structure
	 */
	fprintf(fp, "\nstruct mb_ctlr mbcinit[] = {\n");
	fprintf(fp, "/*\t driver,\tctlr,\talive,\taddr,\tintpri */\n");
E 11
I 11
	fprintf(fp, "\nstruct vba_ctlr vbminit[] = {\n");
	fprintf(fp, "/*\t driver,\tctlr,\tvbanum,\talive,\tintr,\taddr */\n");
E 11
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
		mp = dp->d_conn;
D 5
		if (dp->d_type != CONTROLLER || mp == TO_NEXUS || mp == NULL ||
E 5
I 5
		if (dp->d_type != CONTROLLER || mp == TO_NEXUS || mp == 0 ||
E 5
D 11
		    !eq(mp->d_name, "mb"))
E 11
I 11
		    !eq(mp->d_name, "vba"))
E 11
			continue;
D 11
		if (dp->d_pri == 0) {
			printf("must specify priority for %s%d\n",
E 11
I 11
		if (dp->d_vec == 0) {
			printf("must specify vector for %s%d\n",
E 11
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_addr == 0) {
			printf("must specify csr address for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
D 11
			printf("drives need their own entries; ");
			printf("dont specify drive or slave for %s%d\n",
E 11
I 11
			printf("drives need their own entries; dont ");
			printf("specify drive or slave for %s%d\n",
E 11
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_flags) {
D 11
			printf("controllers (e.g. %s%d) don't have flags, ");
			printf("only devices do\n",
E 11
I 11
			printf("controllers (e.g. %s%d) ",
E 11
			    dp->d_name, dp->d_unit);
I 11
			printf("don't have flags, only devices do\n");
E 11
			continue;
		}
D 11
		fprintf(fp, "\t{ &%sdriver,\t%d,\t0,\tC 0x%x,\t%d },\n",
		    dp->d_name, dp->d_unit, dp->d_addr, dp->d_pri);
E 11
I 11
		fprintf(fp,
		    "\t{ &%sdriver,\t%d,\t%s,\t0,\t%sint%d, C 0x%x },\n",
		    dp->d_name, dp->d_unit, qu(mp->d_unit),
		    dp->d_name, dp->d_unit, dp->d_addr);
E 11
E 2
	}
D 2
	fprintf(fp, "\t{ &%sdriver,\t%d,\t%s,\t0,\t%sint%d, C 0%o },\n",
	    dp->d_name, dp->d_unit, qu(mp->d_unit),
	    dp->d_name, dp->d_unit, dp->d_addr);
    }
    fprintf(fp, "\t0\n};\n");
    /*
     * Now we go for the uba_device stuff
     */
    fprintf(fp, "\nstruct uba_device ubdinit[] = {\n");
    fprintf(fp, "\t/* driver,  unit, ctlr,  ubanum, slave,   intr,    addr,    dk, flags*/\n");
    for (dp = dtab; dp != NULL; dp = dp->d_next) {
	mp = dp->d_conn;
	if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == NULL ||
		mp == TO_NEXUS || mp->d_type == MASTER || eq(mp->d_name, "mba"))
	    continue;
        np = mp->d_conn;
        if (np != NULL && np != TO_NEXUS && eq(np->d_name, "mba"))
	    continue;
	np = NULL;
	if (eq(mp->d_name, "uba")) {
	    if (dp->d_vec == 0) {
		printf("must specify vector for device %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_addr == 0) {
		printf("must specify csr address for device %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
		printf("drives/slaves can be specified only for controllers, not for device %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    uba_n = mp->d_unit;
	    slave = QUES;
	} else {
	    if ((np = mp->d_conn) == NULL) {
		printf("%s%d isn't connected to anything, so %s%d is unattached\n",
		    mp->d_name, mp->d_unit, dp->d_name, dp->d_unit);
		continue;
	    }
	    uba_n = np->d_unit;
	    if (dp->d_drive == UNKNOWN) {
		printf("must specify ``drive number'' for %s%d\n",
		   dp->d_name, dp->d_unit);
		continue;
	    }
	    /* NOTE THAT ON THE UNIBUS ``drive'' IS STORED IN */
	    /* ``SLAVE'' AND WE DON'T WANT A SLAVE SPECIFIED */
	    if (dp->d_slave != UNKNOWN) {
		printf("slave numbers should be given only for massbus tapes, not for %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_vec != 0) {
		printf("interrupt vectors should not be given for drive %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    if (dp->d_addr != 0) {
		printf("csr addresses should be given only on controllers, not on %s%d\n",
		    dp->d_name, dp->d_unit);
		continue;
	    }
	    slave = dp->d_drive;
E 2
I 2
	fprintf(fp, "\t0\n};\n");
D 11
	/*
	 * Now we go for the mb_device stuff
	 */
	fprintf(fp, "\nstruct mb_device mbdinit[] = {\n");
E 11
I 11
/* versabus devices */
	fprintf(fp, "\nstruct vba_device vbdinit[] = {\n");
E 11
	fprintf(fp,
D 11
"\t/* driver,  unit, ctlr,  slave,   addr,    pri,    dk, flags*/\n");
E 11
I 11
"\t/* driver,  unit, ctlr,  vbanum, slave,   intr,    addr,    dk, flags*/\n");
E 11
D 5
	for (dp = dtab; dp != NULL; dp = dp->d_next) {
E 5
I 5
	for (dp = dtab; dp != 0; dp = dp->d_next) {
E 5
		mp = dp->d_conn;
D 5
		if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == NULL ||
E 5
I 5
		if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == 0 ||
E 5
		    mp == TO_NEXUS || mp->d_type == MASTER ||
		    eq(mp->d_name, "mba"))
			continue;
D 5
		np = NULL;
E 5
D 11
		if (eq(mp->d_name, "mb")) {
			if (dp->d_pri == 0) {
E 11
I 11
		np = mp->d_conn;
		if (np != 0 && np != TO_NEXUS && eq(np->d_name, "mba"))
			continue;
		np = 0;
		if (eq(mp->d_name, "vba")) {
D 12
			if (dp->d_vec == 0) {
E 11
				printf("must specify vector for device %s%d\n",
E 12
I 12
			if (dp->d_vec == 0)
				printf(
		"Warning, no interrupt vector specified for device %s%d\n",
E 12
				    dp->d_name, dp->d_unit);
D 12
				continue;
			}
E 12
			if (dp->d_addr == 0) {
				printf("must specify csr for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
D 11
				printf("drives/slaves can be specified only ");
				printf("for controllers, not for device %s%d\n",
E 11
I 11
				printf("drives/slaves can be specified ");
				printf("only for controllers, ");
				printf("not for device %s%d\n",
E 11
				    dp->d_name, dp->d_unit);
				continue;
			}
I 11
			vba_n = mp->d_unit;
E 11
			slave = QUES;
		} else {
D 5
			if ((np = mp->d_conn) == NULL) {
E 5
I 5
D 11
			if (mp->d_conn == 0) {
E 5
				printf("%s%d isn't connected to anything, ",
E 11
I 11
			if ((np = mp->d_conn) == 0) {
				printf("%s%d isn't connected to anything ",
E 11
				    mp->d_name, mp->d_unit);
D 11
				printf("so %s%d is unattached\n",
E 11
I 11
				printf(", so %s%d is unattached\n",
E 11
				    dp->d_name, dp->d_unit);
				continue;
			}
I 11
			vba_n = np->d_unit;
E 11
			if (dp->d_drive == UNKNOWN) {
D 11
				printf("must specify ``drive number'' for %s%d\n",
				   dp->d_name, dp->d_unit);
E 11
I 11
				printf("must specify ``drive number'' ");
				printf("for %s%d\n", dp->d_name, dp->d_unit);
E 11
				continue;
			}
			/* NOTE THAT ON THE UNIBUS ``drive'' IS STORED IN */
			/* ``SLAVE'' AND WE DON'T WANT A SLAVE SPECIFIED */
			if (dp->d_slave != UNKNOWN) {
				printf("slave numbers should be given only ");
				printf("for massbus tapes, not for %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
D 11
			if (dp->d_pri != 0) {
				printf("interrupt priority should not be ");
E 11
I 11
			if (dp->d_vec != 0) {
				printf("interrupt vectors should not be ");
E 11
				printf("given for drive %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_addr != 0) {
D 11
				printf("csr addresses should be given only");
E 11
I 11
				printf("csr addresses should be given only ");
E 11
				printf("on controllers, not on %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			slave = dp->d_drive;
		}
D 11
		fprintf(fp,
"\t{ &%sdriver,  %2d,   %s,    %2d,   C 0x%x, %d,  %d,  0x%x },\n",
		    eq(mp->d_name, "mb") ? dp->d_name : mp->d_name, dp->d_unit,
		    eq(mp->d_name, "mb") ? " -1" : qu(mp->d_unit),
		    slave, dp->d_addr, dp->d_pri, dp->d_dk, dp->d_flags);
E 11
I 11
		fprintf(fp, "\t{ &%sdriver,  %2d,   %s,",
		    eq(mp->d_name, "vba") ? dp->d_name : mp->d_name, dp->d_unit,
		    eq(mp->d_name, "vba") ? " -1" : qu(mp->d_unit));
		fprintf(fp, "  %s,    %2d,   %s, C 0x%-6x,  %d,  0x%x },\n",
		    qu(vba_n), slave, intv(dp), dp->d_addr, dp->d_dk,
		    dp->d_flags);
E 11
E 2
	}
D 2
	fprintf(fp, "\t{ &%sdriver,  %2d,   %s,  %s,    %2d,   %s, C 0%-6o,  %d,  0x%x },\n",
	    eq(mp->d_name, "uba") ? dp->d_name : mp->d_name, dp->d_unit,
	    eq(mp->d_name, "uba") ? " -1" : qu(mp->d_unit), qu(uba_n),
	    slave, intv(dp), dp->d_addr, dp->d_dk, dp->d_flags);
    }
    fprintf(fp, "\t0\n};\n");
    fclose(fp);
E 2
I 2
	fprintf(fp, "\t0\n};\n");
I 37
	pseudo_ioconf(fp);
E 37
D 5
	fclose(fp);
E 5
I 5
	(void) fclose(fp);
E 5
E 2
}
I 4
#endif
E 4

I 22
D 33
#if MACHINE_HP300
E 33
I 33
#if MACHINE_HP300 || MACHINE_LUNA68K
E 33
hp300_ioconf()
{
D 30
	register struct device *dp, *mp, *np;
E 30
I 30
	register struct device *dp, *mp;
E 30
	register int hpib, slave;
	FILE *fp;
D 30
	extern char *wnum();
E 30

	fp = fopen(path("ioconf.c"), "w");
	if (fp == 0) {
		perror(path("ioconf.c"));
		exit(1);
	}
D 25
	fprintf(fp, "#include \"machine/pte.h\"\n");
	fprintf(fp, "#include \"../sys/param.h\"\n");
	fprintf(fp, "#include \"../sys/buf.h\"\n");
	fprintf(fp, "#include \"../sys/map.h\"\n");
E 25
I 25
D 27
	fprintf(fp, "#include \"hp300/include/pte.h\"\n");
E 27
	fprintf(fp, "#include \"sys/param.h\"\n");
	fprintf(fp, "#include \"sys/buf.h\"\n");
	fprintf(fp, "#include \"sys/map.h\"\n");
E 25
D 24
	fprintf(fp, "#include \"../sys/vm.h\"\n");
E 24
	fprintf(fp, "\n");
D 25
	fprintf(fp, "#include \"../hpdev/device.h\"\n\n");
E 25
I 25
D 32
	fprintf(fp, "#include \"hp300/dev/device.h\"\n\n");
E 32
I 32
D 33
	fprintf(fp, "#include \"hp/dev/device.h\"\n\n");
E 33
I 33
	if (machine == MACHINE_HP300)
		fprintf(fp, "#include \"hp/dev/device.h\"\n\n");
	else
		fprintf(fp, "#include \"luna68k/dev/device.h\"\n\n");
E 33
E 32
E 25
	fprintf(fp, "\n");
	fprintf(fp, "#define C (caddr_t)\n");
	fprintf(fp, "#define D (struct driver *)\n\n");
	/*
	 * First print the hpib controller initialization structures
	 */
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		mp = dp->d_conn;
		if (dp->d_unit == QUES || mp == 0)
			continue;
		fprintf(fp, "extern struct driver %sdriver;\n", dp->d_name);
	}
	fprintf(fp, "\nstruct hp_ctlr hp_cinit[] = {\n");
	fprintf(fp, "/*\tdriver,\t\tunit,\talive,\taddr,\tflags */\n");
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		mp = dp->d_conn;
		if (dp->d_unit == QUES ||
			dp->d_type != MASTER && dp->d_type != CONTROLLER)
			continue;
		if (mp != TO_NEXUS) {
			printf("%s%s must be attached to an sc (nexus)\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
			printf("can't specify drive/slave for %s%s\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		fprintf(fp,
			"\t{ &%sdriver,\t%d,\t0,\tC 0x%x,\t0x%x },\n",
			dp->d_name, dp->d_unit, dp->d_addr, dp->d_flags);
	}
	fprintf(fp, "\t0\n};\n");
/* devices */
	fprintf(fp, "\nstruct hp_device hp_dinit[] = {\n");
	fprintf(fp,
	   "/*driver,\tcdriver,\tunit,\tctlr,\tslave,\taddr,\tdk,\tflags*/\n");
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		mp = dp->d_conn;
		if (mp == 0 || dp->d_type != DEVICE || hpbadslave(mp, dp))
			continue;
		if (mp == TO_NEXUS) {
			if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
				printf("can't specify drive/slave for %s%s\n",
					dp->d_name, wnum(dp->d_unit));
				continue;
			}
			slave = QUES;
			hpib = QUES;
		} else {
			if (dp->d_addr != 0) {
				printf("can't specify sc for device %s%s\n",
					dp->d_name, wnum(dp->d_unit));
				continue;
			}
			if (mp->d_type == CONTROLLER) {
				if (dp->d_drive == UNKNOWN) {
					printf("must specify drive for %s%s\n",
						dp->d_name, wnum(dp->d_unit));
					continue;
				}
				slave = dp->d_drive;
			} else {
				if (dp->d_slave == UNKNOWN) {
					printf("must specify slave for %s%s\n",
						dp->d_name, wnum(dp->d_unit));
					continue;
				}
				slave = dp->d_slave;
			}
			hpib = mp->d_unit;
		}
		fprintf(fp, "{ &%sdriver,\t", dp->d_name);
		if (mp == TO_NEXUS)
			fprintf(fp, "D 0x0,\t");
		else
			fprintf(fp, "&%sdriver,", mp->d_name);
		fprintf(fp, "\t%d,\t%d,\t%d,\tC 0x%x,\t%d,\t0x%x },\n",
			dp->d_unit, hpib, slave,
			dp->d_addr, dp->d_dk, dp->d_flags);
	}
	fprintf(fp, "0\n};\n");
I 37
	pseudo_ioconf(fp);
E 37
	(void) fclose(fp);
}

#define ishpibdev(n) (eq(n,"rd") || eq(n,"ct") || eq(n,"mt") || eq(n,"ppi"))
D 35
#define isscsidev(n) (eq(n,"sd") || eq(n,"st"))
E 35
I 35
#define isscsidev(n) (eq(n,"sd") || eq(n,"st") || eq(n,"ac"))
E 35

hpbadslave(mp, dp)
	register struct device *dp, *mp;
{
D 30
	extern char *wnum();
E 30

	if (mp == TO_NEXUS && ishpibdev(dp->d_name) ||
	    mp != TO_NEXUS && eq(mp->d_name, "hpib") &&
	    !ishpibdev(dp->d_name)) {
		printf("%s%s must be attached to an hpib\n",
		       dp->d_name, wnum(dp->d_unit));
		return (1);
	}
	if (mp == TO_NEXUS && isscsidev(dp->d_name) ||
	    mp != TO_NEXUS && eq(mp->d_name, "scsi") &&
	    !isscsidev(dp->d_name)) {
		printf("%s%s must be attached to a scsi\n",
		       dp->d_name, wnum(dp->d_unit));
		return (1);
	}
	return (0);
}
D 30

char *
wnum(num)
{

	if (num == QUES || num == UNKNOWN)
		return ("?");
	(void) sprintf(errbuf, "%d", num);
	return (errbuf);
}
E 30
#endif

I 26
#if MACHINE_I386
char *sirq();

i386_ioconf()
{
	register struct device *dp, *mp, *np;
	register int uba_n, slave;
	FILE *fp;

	fp = fopen(path("ioconf.c"), "w");
	if (fp == 0) {
		perror(path("ioconf.c"));
		exit(1);
	}
	fprintf(fp, "/*\n");
	fprintf(fp, " * ioconf.c \n");
	fprintf(fp, " * Generated by config program\n");
	fprintf(fp, " */\n\n");
	fprintf(fp, "#include \"machine/pte.h\"\n");
	fprintf(fp, "#include \"sys/param.h\"\n");
	fprintf(fp, "#include \"sys/buf.h\"\n");
	fprintf(fp, "#include \"sys/map.h\"\n");
D 28
	fprintf(fp, "#include \"sys/vm.h\"\n");
E 28
	fprintf(fp, "\n");
D 28
	fprintf(fp, "#define V(s)	V/**/s\n");
E 28
I 28
	fprintf(fp, "#define V(s)	__CONCAT(V,s)\n");
E 28
	fprintf(fp, "#define C (caddr_t)\n\n");
	/*
	 * First print the isa initialization structures
	 */
	if (seen_isa) {

		fprintf(fp, "/*\n");
		fprintf(fp, " * ISA devices\n");
		fprintf(fp, " */\n\n");
		fprintf(fp, "#include \"i386/isa/isa_device.h\"\n");
		fprintf(fp, "#include \"i386/isa/isa.h\"\n");
		fprintf(fp, "#include \"i386/isa/icu.h\"\n\n");

		for (dp = dtab; dp != 0; dp = dp->d_next) {
			mp = dp->d_conn;
			if (mp == 0 || mp == TO_NEXUS ||
			    !eq(mp->d_name, "isa"))
				continue;
			fprintf(fp,
"extern struct isa_driver %sdriver; extern V(%s%d)();\n",
			    dp->d_name, dp->d_name, dp->d_unit);
		}
		fprintf(fp, "\nstruct isa_device isa_devtab_bio[] = {\n");
		fprintf(fp, "\
/* driver 	iobase	irq   drq     maddr    msiz    intr   unit */\n");
		for (dp = dtab; dp != 0; dp = dp->d_next) {
			mp = dp->d_conn;
			if (dp->d_unit == QUES || mp == 0 ||
			    mp == TO_NEXUS || !eq(mp->d_name, "isa"))
				continue;
			if (!eq(dp->d_mask, "bio")) continue;
			if (dp->d_port)
		 fprintf(fp, "{ &%sdriver,  %8.8s,", dp->d_name, dp->d_port);
			else
	 fprintf(fp, "{ &%sdriver,     0x%03x,", dp->d_name, dp->d_portn);
		fprintf(fp, " %5.5s, %2d,  C 0x%05X, %5d, V(%s%d),  %2d },\n",
			 	sirq(dp->d_irq), dp->d_drq, dp->d_maddr,
			 dp->d_msize, dp->d_name, dp->d_unit, dp->d_unit);
		}
		fprintf(fp, "0\n};\n");

		fprintf(fp, "struct isa_device isa_devtab_tty[] = {\n");
		fprintf(fp, "\
/* driver 	iobase	irq   drq     maddr    msiz    intr   unit */\n");
		for (dp = dtab; dp != 0; dp = dp->d_next) {
			mp = dp->d_conn;
			if (dp->d_unit == QUES || mp == 0 ||
			    mp == TO_NEXUS || !eq(mp->d_name, "isa"))
				continue;
			if (!eq(dp->d_mask, "tty")) continue;
			if (dp->d_port)
		 fprintf(fp, "{ &%sdriver,  %8.8s,", dp->d_name, dp->d_port);
			else
	 fprintf(fp, "{ &%sdriver,     0x%03x,", dp->d_name, dp->d_portn);
		fprintf(fp, " %5.5s, %2d,  C 0x%05X, %5d, V(%s%d),  %2d },\n",
			 	sirq(dp->d_irq), dp->d_drq, dp->d_maddr,
			 dp->d_msize, dp->d_name, dp->d_unit, dp->d_unit);
		}
		fprintf(fp, "0\n};\n\n");

		fprintf(fp, "struct isa_device isa_devtab_net[] = {\n");
		fprintf(fp, "\
/* driver 	iobase	irq   drq     maddr    msiz    intr   unit */\n");
		for (dp = dtab; dp != 0; dp = dp->d_next) {
			mp = dp->d_conn;
			if (dp->d_unit == QUES || mp == 0 ||
			    mp == TO_NEXUS || !eq(mp->d_name, "isa"))
				continue;
			if (!eq(dp->d_mask, "net")) continue;
			if (dp->d_port)
		 fprintf(fp, "{ &%sdriver,  %8.8s,", dp->d_name, dp->d_port);
			else
	 fprintf(fp, "{ &%sdriver,     0x%03x,", dp->d_name, dp->d_portn);
		fprintf(fp, " %5.5s, %2d,  C 0x%05X, %5d, V(%s%d),  %2d },\n",
			 	sirq(dp->d_irq), dp->d_drq, dp->d_maddr,
			 dp->d_msize, dp->d_name, dp->d_unit, dp->d_unit);
		}
		fprintf(fp, "0\n};\n\n");

		fprintf(fp, "struct isa_device isa_devtab_null[] = {\n");
		fprintf(fp, "\
/* driver 	iobase	irq   drq     maddr    msiz    intr   unit */\n");
		for (dp = dtab; dp != 0; dp = dp->d_next) {
			mp = dp->d_conn;
			if (dp->d_unit == QUES || mp == 0 ||
			    mp == TO_NEXUS || !eq(mp->d_name, "isa"))
				continue;
			if (!eq(dp->d_mask, "null")) continue;
			if (dp->d_port)
		 fprintf(fp, "{ &%sdriver,  %8.8s,", dp->d_name, dp->d_port);
			else
	 fprintf(fp, "{ &%sdriver,     0x%03x,", dp->d_name, dp->d_portn);
		fprintf(fp, " %5.5s, %2d,  C 0x%05X, %5d, V(%s%d),  %2d },\n",
			 	sirq(dp->d_irq), dp->d_drq, dp->d_maddr,
			 dp->d_msize, dp->d_name, dp->d_unit, dp->d_unit);
		}
		fprintf(fp, "0\n};\n\n");
	}
I 37
	pseudo_ioconf(fp);
E 37
	(void) fclose(fp);
}

char *
sirq(num)
{

	if (num == -1)
		return ("0");
	sprintf(errbuf, "IRQ%d", num);
	return (errbuf);
}
#endif

I 30
#if MACHINE_PMAX
pmax_ioconf()
{
	register struct device *dp, *mp;
	FILE *fp;

	fp = fopen(path("ioconf.c"), "w");
	if (fp == 0) {
		perror(path("ioconf.c"));
		exit(1);
	}
D 37
	fprintf(fp, "#include \"types.h\"\n");
E 37
I 37
	fprintf(fp, "#include \"sys/types.h\"\n");
I 39
	fprintf(fp, "#include \"sys/time.h\"\n");
E 39
E 37
	fprintf(fp, "#include \"pmax/dev/device.h\"\n\n");
	fprintf(fp, "#define C (char *)\n\n");

	/* print controller initialization structures */
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		if (dp->d_type == PSEUDO_DEVICE)
			continue;
		fprintf(fp, "extern struct driver %sdriver;\n", dp->d_name);
	}
	fprintf(fp, "\nstruct pmax_ctlr pmax_cinit[] = {\n");
D 31
	fprintf(fp, "/*\tdriver,\t\tunit,\taddr,\t\tflags */\n");
E 31
I 31
	fprintf(fp, "/*\tdriver,\t\tunit,\taddr,\t\tpri,\tflags */\n");
E 31
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		if (dp->d_type != CONTROLLER && dp->d_type != MASTER)
			continue;
		if (dp->d_conn != TO_NEXUS) {
			printf("%s%s must be attached to a nexus (internal bus)\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
			printf("can't specify drive/slave for %s%s\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		if (dp->d_unit == UNKNOWN || dp->d_unit == QUES)
			dp->d_unit = 0;
		fprintf(fp,
D 31
			"\t{ &%sdriver,\t%d,\tC 0x%x,\t0x%x },\n",
			dp->d_name, dp->d_unit, dp->d_addr, dp->d_flags);
E 31
I 31
			"\t{ &%sdriver,\t%d,\tC 0x%x,\t%d,\t0x%x },\n",
			dp->d_name, dp->d_unit, dp->d_addr, dp->d_pri,
			dp->d_flags);
E 31
	}
	fprintf(fp, "\t0\n};\n");

	/* print devices connected to other controllers */
	fprintf(fp, "\nstruct scsi_device scsi_dinit[] = {\n");
	fprintf(fp,
	   "/*driver,\tcdriver,\tunit,\tctlr,\tdrive,\tslave,\tdk,\tflags*/\n");
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		if (dp->d_type == CONTROLLER || dp->d_type == MASTER ||
		    dp->d_type == PSEUDO_DEVICE)
			continue;
		mp = dp->d_conn;
D 31
		if (mp == 0 || !eq(mp->d_name, "sii")) {
			printf("%s%s: devices must be attached to a SCSI (sii) controller\n",
E 31
I 31
		if (mp == 0 ||
		    !eq(mp->d_name, "asc") && !eq(mp->d_name, "sii")) {
			printf("%s%s: devices must be attached to a SCSI (asc or sii) controller\n",
E 31
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		if ((unsigned)dp->d_drive > 6) {
			printf("%s%s: SCSI drive must be in the range 0..6\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		/* may want to allow QUES later */
		if ((unsigned)dp->d_slave > 7) {
			printf("%s%s: SCSI slave (LUN) must be in the range 0..7\n",
				dp->d_name, wnum(dp->d_unit));
			continue;
		}
		fprintf(fp, "{ &%sdriver,\t&%sdriver,", dp->d_name, mp->d_name);
		fprintf(fp, "\t%d,\t%d,\t%d,\t%d,\t%d,\t0x%x },\n",
			dp->d_unit, mp->d_unit, dp->d_drive, dp->d_slave,
			dp->d_dk, dp->d_flags);
	}
	fprintf(fp, "0\n};\n");
I 37
	pseudo_ioconf(fp);
E 37
	(void) fclose(fp);
}
#endif

I 34
#if MACHINE_NEWS3400
int have_iop = 0;
int have_hb = 0;
int have_vme = 0;

news_ioconf()
{
	register struct device *dp, *mp;
	register int slave;
	FILE *fp;

	fp = fopen(path("ioconf.c"), "w");
	if (fp == 0) {
		perror(path("ioconf.c"));
		exit(1);
	}
D 36
	fprintf(fp, "#include \"param.h\"\n");
	fprintf(fp, "#include \"buf.h\"\n");
	fprintf(fp, "#include \"map.h\"\n");
E 36
I 36
	fprintf(fp, "#include \"sys/param.h\"\n");
	fprintf(fp, "#include \"sys/buf.h\"\n");
	fprintf(fp, "#include \"sys/map.h\"\n");
E 36
	fprintf(fp, "#include \"vm/vm.h\"\n");
	fprintf(fp, "#include \"iop.h\"\n");
	fprintf(fp, "#include \"hb.h\"\n");
	fprintf(fp, "\n");
	fprintf(fp, "#if NIOP > 0\n");
	fprintf(fp, "#include \"news3400/iop/iopvar.h\"\n");
	fprintf(fp, "#endif\n");
	fprintf(fp, "#if NHB > 0\n");
	fprintf(fp, "#include \"news3400/hbdev/hbvar.h\"\n");
	fprintf(fp, "#endif\n");
	fprintf(fp, "\n");
	fprintf(fp, "#define C (caddr_t)\n\n");
	fprintf(fp, "\n");

/* BEGIN HB */
	fprintf(fp, "#if NHB > 0\n");
	/*
	 * Now generate interrupt vectors for the HYPER-BUS
	 */
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		if (dp->d_pri >= 0) {
			mp = dp->d_conn;
			if (mp == 0 || mp == TO_NEXUS ||
			    !eq(mp->d_name, "hb"))
				continue;
			fprintf(fp, "extern struct hb_driver %sdriver;\n",
			    dp->d_name);
			have_hb++;
		}
	}
	/*
	 * Now spew forth the hb_cinfo structure
	 */
	fprintf(fp, "\nstruct hb_ctlr hminit[] = {\n");
	fprintf(fp, "/*\t driver,\tctlr,\talive,\taddr,\tintpri */\n");
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		mp = dp->d_conn;
		if ((dp->d_type != MASTER && dp->d_type != CONTROLLER)
		    || mp == TO_NEXUS || mp == 0 ||
		    !eq(mp->d_name, "hb"))
			continue;
		if (dp->d_pri < 0) {
			printf("must specify priority for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
			printf("drives need their own entries; ");
			printf("dont specify drive or slave for %s%d\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		if (dp->d_flags) {
			printf("controllers (e.g. %s%d) don't have flags, ");
			printf("only devices do\n",
			    dp->d_name, dp->d_unit);
			continue;
		}
		fprintf(fp, "\t{ &%sdriver,\t%d,\t0,\tC 0x%x,\t%d },\n",
		    dp->d_name, dp->d_unit, dp->d_addr, dp->d_pri);
	}
	fprintf(fp, "\t0\n};\n");
	/*
	 * Now we go for the hb_device stuff
	 */
	fprintf(fp, "\nstruct hb_device hdinit[] = {\n");
	fprintf(fp,
"\t/* driver,  unit, ctlr,  slave,   addr,    pri,    dk, flags*/\n");
	for (dp = dtab; dp != 0; dp = dp->d_next) {
		mp = dp->d_conn;
		if (dp->d_unit == QUES || dp->d_type != DEVICE || mp == 0 ||
		    mp == TO_NEXUS || /* mp->d_type == MASTER || */
		    eq(mp->d_name, "iop") || eq(mp->d_name, "vme"))
			continue;
		if (eq(mp->d_name, "hb")) {
			if (dp->d_pri < 0) {
				printf("must specify vector for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_drive != UNKNOWN || dp->d_slave != UNKNOWN) {
				printf("drives/slaves can be specified only ");
				printf("for controllers, not for device %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			slave = QUES;
		} else {
			if (mp->d_conn == 0) {
				printf("%s%d isn't connected to anything, ",
				    mp->d_name, mp->d_unit);
				printf("so %s%d is unattached\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_drive == UNKNOWN) {
				printf("must specify ``drive number'' for %s%d\n",
				   dp->d_name, dp->d_unit);
				continue;
			}
			/* NOTE THAT ON THE IOP ``drive'' IS STORED IN */
			/* ``SLAVE'' AND WE DON'T WANT A SLAVE SPECIFIED */
			if (dp->d_slave != UNKNOWN) {
				printf("slave numbers should be given only ");
				printf("for massbus tapes, not for %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_pri >= 0) {
				printf("interrupt priority should not be ");
				printf("given for drive %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			if (dp->d_addr != 0) {
				printf("csr addresses should be given only");
				printf("on controllers, not on %s%d\n",
				    dp->d_name, dp->d_unit);
				continue;
			}
			slave = dp->d_drive;
		}
		fprintf(fp,
"\t{ &%sdriver,  %2d,   %s,    %2d,   C 0x%x, %d,  %d,  0x%x },\n",
		    eq(mp->d_name, "hb") ? dp->d_name : mp->d_name, dp->d_unit,
		    eq(mp->d_name, "hb") ? " -1" : qu(mp->d_unit),
		    slave, dp->d_addr, dp->d_pri, dp->d_dk, dp->d_flags);
	}
	fprintf(fp, "\t0\n};\n\n");
	fprintf(fp, "#endif\n\n");
/* END HB */
I 37
	pseudo_ioconf(fp);
E 37
	(void) fclose(fp);
}
#endif

E 34
E 30
E 26
E 22
D 2
/*
 * intv
 *	Return vector name
 */

E 2
D 12
char *intv(dev)
E 12
I 12
char *
intv(dev)
E 12
D 2
register struct device *dev;
E 2
I 2
	register struct device *dev;
E 2
{
	static char buf[20];

D 2
	if (dev->d_vec == NULL)
	    return "     0";
E 2
I 2
	if (dev->d_vec == 0)
		return ("     0");
E 2
D 5
	else
D 2
	    return sprintf(buf, "%sint%d", dev->d_name, dev->d_unit);
E 2
I 2
		return (sprintf(buf, "%sint%d", dev->d_name, dev->d_unit));
E 5
I 5
D 15
	return (sprintf(buf, "%sint%d", dev->d_name, dev->d_unit));
E 15
I 15
	(void) sprintf(buf, "%sint%d", dev->d_name, dev->d_unit);
	return (buf);
E 15
E 5
E 2
}

char *
qu(num)
{
I 2

E 2
	if (num == QUES)
D 2
		return "'?'";
	if(num == UNKNOWN)
		return " -1";
	return ns(sprintf(errbuf, "%3d", num));
E 2
I 2
		return ("'?'");
D 5
	else if (num == UNKNOWN)
E 5
I 5
	if (num == UNKNOWN)
E 5
		return (" -1");
D 5
	else
		return (ns(sprintf(errbuf, "%3d", num)));
E 5
I 5
D 15
	return (sprintf(errbuf, "%3d", num));
E 15
I 15
	(void) sprintf(errbuf, "%3d", num);
I 30
	return (errbuf);
}

char *
wnum(num)
{

	if (num == QUES || num == UNKNOWN)
		return ("?");
	(void) sprintf(errbuf, "%d", num);
E 30
	return (errbuf);
I 37
}

void
pseudo_ioconf(fp)
	register FILE *fp;
{
	register struct device *dp;

	(void)fprintf(fp, "\n#include <sys/device.h>\n\n");
	for (dp = dtab; dp != NULL; dp = dp->d_next)
		if (dp->d_type == PSEUDO_DEVICE)
			(void)fprintf(fp, "extern void %sattach __P((int));\n",
			    dp->d_name);
I 38
	/*
	 * XXX concatonated disks are pseudo-devices but appear as DEVICEs
	 * since they don't adhere to normal pseudo-device conventions
	 * (i.e. one entry with total count in d_slave).
	 */
	if (seen_cd)
		(void)fprintf(fp, "extern void cdattach __P((int));\n");
E 38
	/* XXX temporary for HP300, others */
	(void)fprintf(fp, "\n#include <sys/systm.h> /* XXX */\n");
	(void)fprintf(fp, "#define etherattach (void (*)__P((int)))nullop\n");
	(void)fprintf(fp, "#define iteattach (void (*) __P((int)))nullop\n");
	(void)fprintf(fp, "\nstruct pdevinit pdevinit[] = {\n");
	for (dp = dtab; dp != NULL; dp = dp->d_next)
		if (dp->d_type == PSEUDO_DEVICE)
			(void)fprintf(fp, "\t{ %sattach, %d },\n", dp->d_name,
			    dp->d_slave > 0 ? dp->d_slave : 1);
I 38
	/*
	 * XXX count up cds and put out an entry
	 */
	if (seen_cd) {
		struct file_list *fl;
		int cdmax = -1;

		for (fl = comp_list; fl != NULL; fl = fl->f_next)
			if (fl->f_type == COMPDEVICE && fl->f_compinfo > cdmax)
				cdmax = fl->f_compinfo;
		(void)fprintf(fp, "\t{ cdattach, %d },\n", cdmax+1);
	}
E 38
	(void)fprintf(fp, "\t{ 0, 0 }\n};\n");
I 38
	if (seen_cd)
		comp_config(fp);
}

comp_config(fp)
	FILE *fp;
{
	register struct file_list *fl;
	register struct device *dp;

	fprintf(fp, "\n#include \"dev/cdvar.h\"\n");
	fprintf(fp, "\nstruct cddevice cddevice[] = {\n");
	fprintf(fp, "/*\tunit\tileave\tflags\tdk\tdevs\t\t\t\t*/\n");

	fl = comp_list;
	while (fl) {
		if (fl->f_type != COMPDEVICE) {
			fl = fl->f_next;
			continue;
		}
		for (dp = dtab; dp != 0; dp = dp->d_next)
			if (dp->d_type == DEVICE &&
			    eq(dp->d_name, fl->f_fn) &&
			    dp->d_unit == fl->f_compinfo)
				break;
		if (dp == 0)
			continue;
		fprintf(fp, "\t%d,\t%d,\t%d,\t%d,\t{",
D 41
			dp->d_unit, dp->d_pri, dp->d_flags, 1);
E 41
I 41
			dp->d_unit, dp->d_pri < 0 ? 0 : dp->d_pri,
			dp->d_flags, 1);
E 41
		for (fl = fl->f_next; fl->f_type == COMPSPEC; fl = fl->f_next)
			fprintf(fp, " 0x%x,", fl->f_compdev);
		fprintf(fp, " NODEV },\n");
	}
	fprintf(fp, "\t-1,\t0,\t0,\t0,\t{ 0 },\n};\n");
E 38
E 37
E 15
E 5
E 2
}
E 1
